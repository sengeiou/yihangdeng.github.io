<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="yhd">
    
    <title>
        
            数据结构 第四章 栈 |
        
        MyBlog
    </title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="shortcut icon" href="/images/logo.svg">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"yoursite.com","root":"/","language":"en","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.jpg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.1"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.1.1"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                MyBlog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">数据结构 第四章 栈</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">yhd</span>
                        
                            <span class="author-label">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2020-09-19 20:01:32
    </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/">技术积累</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <ul>
<li><strong>读物</strong>：<a class="link"   target="_blank" rel="noopener" href="https://book.douban.com/subject/6424904/" >《大话数据结构》<i class="fas fa-external-link-alt"></i></a></li>
<li><strong>印次</strong>：2020年5月第25次印刷(2020.5重印)</li>
</ul>
<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ol>
<li><strong>栈的定义</strong></li>
<li><strong>栈的抽线数据类型</strong></li>
<li><strong>栈的顺序存储结构</strong></li>
<li><strong>栈的链式存储结构</strong></li>
<li><strong>小结</strong></li>
<li><strong>栈的应用</strong></li>
</ol>
<h1 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h1><p><strong>栈的定义如下：</strong></p>
<ol>
<li>栈(stack)如同<strong>弹夹</strong>一样，<strong>先进后出，后进先出</strong>(Last In First Out，<strong>LIFO</strong>)的特性。</li>
<li>栈而且是限定<strong>仅在表尾(栈顶)</strong>进行插入和删除的<strong>线性表</strong>。</li>
</ol>
<p>相关术语如下：</p>
<ul>
<li><strong>栈顶(top)</strong>：允许插入和删除的一端</li>
<li><strong>栈底(bottom)</strong>：相对于栈顶的另一端</li>
<li><strong>空栈</strong>：不含任何数据元素的栈</li>
<li><strong>进栈/压栈/入栈(push)</strong>：栈的元素插入操作</li>
<li><strong>出栈/弹栈(pop)</strong>：栈的元素删除操作</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89.png"
                      alt="栈的定义"
                ></p>
<p><del>进栈出栈变化形式</del></p>
<h1 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 栈(<span class="built_in">stack</span>)</span><br><span class="line">Data</span><br><span class="line">    同线性表。元素具有相同的类型，相邻元素具有前驱和后继的关系。</span><br><span class="line">Operation</span><br><span class="line">    InitStack(*S)：初始化操作，建立一个空栈S</span><br><span class="line">    DestroyStack(*S)：若栈存在，则销毁它</span><br><span class="line">    ClearStack(*S)：将栈清空</span><br><span class="line">    StackEmpty(S)：若栈为空，返回<span class="literal">true</span>，否则返回<span class="literal">false</span></span><br><span class="line">    GetTop(*S,e)：若栈存在且非空，用e返回S的栈顶元素</span><br><span class="line">    Push(*S,e)：若栈S存在，插入新元素e到栈S中，并成为栈顶元素</span><br><span class="line">    Pop(*S,*e)：删除栈S中的顶栈元素，并用e返回其值</span><br><span class="line">    StackLength(S)：返回栈S的元素个数</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>



<h1 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h1><h2 id="顺序栈的结构定义"><a href="#顺序栈的结构定义" class="headerlink" title="顺序栈的结构定义"></a>顺序栈的结构定义</h2><ul>
<li>栈的顺序存储结构也称为 “<strong>顺序栈</strong>”</li>
<li>通常用数组<strong>下标为0</strong>的一端作为<strong>栈底</strong>，因为变化最小</li>
<li>定义一个<strong>top</strong>变量存储<strong>栈顶元素所在的位置</strong>，top &lt; StackSize，<ul>
<li>栈存在一个元素时(<strong>对应数组下标为0</strong>)，<strong>top = 0</strong></li>
<li>当<strong>top = -1</strong> 表示为<strong>空栈</strong></li>
</ul>
</li>
</ul>
<p>顺序栈的结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SElemType;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    SElemType data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> top;	<span class="comment">//记录栈顶下标</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>

<h2 id="进栈-amp-出栈操作"><a href="#进栈-amp-出栈操作" class="headerlink" title="进栈&amp;出栈操作"></a>进栈&amp;出栈操作</h2><h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><p><strong>思路</strong>：</p>
<ul>
<li>若栈已满，退出</li>
<li>修改栈顶top值，+1，并且作为下标存入数据e</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack *S,SElemType e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S-&gt;top == MAXSIZE <span class="number">-1</span>) <span class="comment">/* 栈满 */</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">        </span><br><span class="line">    	S-&gt;top++;				<span class="comment">/* 栈顶指针增加一 */</span></span><br><span class="line">        S-&gt;data[S-&gt;top]=e;  <span class="comment">/* 将新插入元素赋值给栈顶空间 */</span></span><br><span class="line">    	<span class="comment">//这两句可写成：S-&gt;data[++S-&gt;top] = *e;</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p><strong>思路</strong>：</p>
<ul>
<li>若栈为空，则无元素出栈</li>
<li>以当前top为数组下标取出值并赋值给e</li>
<li>top值自减1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack *S,SElemType *e)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">        *e=S-&gt;data[S-&gt;top];	<span class="comment">/* 将要删除的栈顶元素赋值给e */</span></span><br><span class="line">        S-&gt;top--;				<span class="comment">/* 栈顶指针减一 */</span></span><br><span class="line">    	<span class="comment">//这两句同样可写成：*e = S-&gt;data[S-&gt;top--];</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li>通常一个程序中要<strong>用到多个栈</strong>，为了不发生上溢错误，就必须给每个栈分配一个<strong>足够大的存储空间</strong>。但实际中，<strong>很难准确地估计</strong>，若每个栈都分配过大的存储空间，势必造成系统<strong>空间紧张</strong>；若让<strong>多个栈共用</strong>一个足够大的连续存储空间，则可利用栈的动态特性使他们的存储空间互补。(<strong>关键字：’’多个栈’’</strong>)</li>
<li>事实上，使用这种数据结构，通常是<strong>两个栈</strong>的空间需求有<strong>相反关系</strong>，即<strong>一个栈增长时，另一个栈在缩短</strong>的情况。这样使用这种结构的<strong>意义更大</strong>。(如买卖股票，买入必定存在卖出等应用场景)</li>
</ul>
<h3 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h3><ul>
<li>前提是，两个<strong>栈的数据类型</strong>必须<strong>相同</strong></li>
<li>让其中一个栈的<strong>栈底</strong>为<strong>数组下标0（-1）</strong>，另一个<strong>栈底</strong>为<strong>n-1（n）</strong> (n表示数组的长度)</li>
<li>关键思路：<strong>两个栈是在数组的两端，向中间靠拢</strong>，</li>
</ul>
<h3 id="两盏共享空间结构"><a href="#两盏共享空间结构" class="headerlink" title="两盏共享空间结构"></a>两盏共享空间结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*两盏共享空间结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	SElemType data[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> top1;	<span class="comment">/*栈1 栈顶指针 */</span></span><br><span class="line">	<span class="keyword">int</span> top2;	<span class="comment">/*栈2 栈顶指针 */</span></span><br><span class="line">&#125;SqDoubleStack;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="栈内元素存储状态"><a href="#栈内元素存储状态" class="headerlink" title="栈内元素存储状态"></a>栈内元素存储状态</h3><ol>
<li><strong>空栈</strong>：top<strong>1</strong> = <strong>-1</strong>，top<strong>2</strong> = <strong>MAXSIZE</strong></li>
<li><strong>栈满</strong>：<ol>
<li><strong>往右靠拢</strong>：top<strong>1</strong> = <strong>n - 1</strong>，top<strong>2</strong> = <strong>n -1</strong></li>
<li><strong>往左靠拢</strong>：top<strong>2</strong> = <strong>0</strong>，top<strong>1</strong> = <strong>0</strong></li>
<li><strong>向中间靠拢</strong>：top<strong>1</strong>+ <strong>1</strong>= top<strong>2</strong></li>
</ol>
</li>
</ol>
<p>通常使用<strong><code>top1 + 1 = top2</code></strong>为<strong>栈满的判别条件</strong>。</p>
<h3 id="共享空间下的进栈-amp-出栈操作"><a href="#共享空间下的进栈-amp-出栈操作" class="headerlink" title="共享空间下的进栈&amp;出栈操作"></a>共享空间下的进栈&amp;出栈操作</h3><p>对于两栈共享空间的push与pop方法，除了顺序栈进出栈原有的两个参数外，<strong>还需要栈号参数stackNumber</strong>，用于判断操作的栈对象。</p>
<h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p><strong>思路</strong>：</p>
<ul>
<li>判断栈的是否已经存满</li>
<li>分别执行类同顺序栈的进栈代码(<strong>注意：处于尾部栈的下标操作是相反的</strong>)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqDoubleStack *S,SElemType e,<span class="keyword">int</span> stackNumber)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top1+<span class="number">1</span>==S-&gt;top2)	<span class="comment">/* 栈已满，不能再push新元素了 */</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;	</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (stackNumber==<span class="number">1</span>)			<span class="comment">/* 栈1有元素进栈 */</span></span><br><span class="line">        S-&gt;data[++S-&gt;top1]=e; <span class="comment">/* 若是栈1则先top1+1后给数组元素赋值。 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (stackNumber==<span class="number">2</span>)	<span class="comment">/* 栈2有元素进栈 */</span></span><br><span class="line">        S-&gt;data[--S-&gt;top2]=e; <span class="comment">/* 若是栈2则先top2-1后给数组元素赋值。 */</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pop-1"><a href="#pop-1" class="headerlink" title="pop"></a>pop</h4><p><strong>思路</strong>：</p>
<ul>
<li>首先通过stackNumber分别分支处理</li>
<li>判断被选中栈的是否为空</li>
<li>别执行类同顺序栈的出栈代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqDoubleStack *S,SElemType *e,<span class="keyword">int</span> stackNumber)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (stackNumber==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S-&gt;top1==<span class="number">-1</span>) </span><br><span class="line">            <span class="keyword">return</span> ERROR; <span class="comment">/* 说明栈1已经是空栈，溢出 */</span></span><br><span class="line">        *e=S-&gt;data[S-&gt;top1--]; <span class="comment">/* 将栈1的栈顶元素出栈 */</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (stackNumber==<span class="number">2</span>)&#123; </span><br><span class="line">        <span class="keyword">if</span> (S-&gt;top2==MAXSIZE) </span><br><span class="line">            <span class="keyword">return</span> ERROR; <span class="comment">/* 说明栈2已经是空栈，溢出 */</span></span><br><span class="line">        *e=S-&gt;data[S-&gt;top2++]; <span class="comment">/* 将栈2的栈顶元素出栈 */</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>可知顺序栈的<strong>push和pop</strong>操作时间复杂度均为<strong>O(1)</strong></p>
<h1 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h1><p>栈的链式存储结构，简称“<strong>链栈</strong>”</p>
<ul>
<li>链栈没有头结点，或者说是把<strong>头结点与栈顶指针</strong>融为一体</li>
<li>对于链栈来说，基本<strong>不存在栈满</strong>的情况(除非内存耗尽/死机)</li>
<li>栈顶指针(<strong>top</strong>) = <strong>NULL</strong>时，表示<strong>空栈</strong></li>
</ul>
<p>栈的链式存储结构定义如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89.jpg"
                      alt="栈的链式存储结构"
                ></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类似单链表的结构定义：LinkStackPtr(Ptr，Pointer Recod 表指针含义)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>&#123;</span></span><br><span class="line"></span><br><span class="line">	SElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;StackNode,*LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再创建一个top结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span> &#123;</span></span><br><span class="line">	LinkStackPtr top;<span class="comment">//每一个结点是否被定义为头结点</span></span><br><span class="line">	<span class="keyword">int</span> count;<span class="comment">//链的长度</span></span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure>

<h2 id="链栈的进栈操作"><a href="#链栈的进栈操作" class="headerlink" title="链栈的进栈操作"></a>链栈的进栈操作</h2><p><strong>思路</strong>：</p>
<ul>
<li>链式结构一般不用考虑插入是否已满</li>
<li>创建新结点</li>
<li>通过“<strong>头插法</strong>”(让首结点成为新结点的next，然后新结点成为首结点)即新元素只与头结点(栈顶/top)交换</li>
<li>修改count数值</li>
<li>返回OK</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack *S,SElemType e)</span></span>&#123;</span><br><span class="line">    LinkStackPtr s=(LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode)); </span><br><span class="line">    s-&gt;data=e; </span><br><span class="line">    s-&gt;next=S-&gt;top;	<span class="comment">/* 把当前的栈顶元素赋值给新结点的直接后继*/</span></span><br><span class="line">    S-&gt;top=s;         <span class="comment">/* 将新的结点s赋值给栈顶指针，见图中② */</span></span><br><span class="line">    S-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="链栈的出栈操作"><a href="#链栈的出栈操作" class="headerlink" title="链栈的出栈操作"></a>链栈的出栈操作</h2><p><strong>思路</strong>：</p>
<ul>
<li>若栈为空，则无元素可出栈</li>
<li>创建暂存结点变量</li>
<li>改变top指向，释放暂存结点</li>
<li>返回OK</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若栈S为空栈，则返回TRUE，否则返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(LinkStack S)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (S.count==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack *S,SElemType *e)</span></span>&#123; </span><br><span class="line">    LinkStackPtr p;</span><br><span class="line">    <span class="keyword">if</span>(StackEmpty(*S))</span><br><span class="line">    	<span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">	LinkStackPtr p = S-&gt;top;	<span class="comment">//将栈顶结点赋值给p</span></span><br><span class="line">	*e = p-&gt;data;	<span class="comment">//返回即将出栈元素值</span></span><br><span class="line">	S-&gt;top = p-&gt;next;<span class="comment">//修改top结点指向</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(p);	<span class="comment">//释放结点</span></span><br><span class="line">	S-&gt;count--;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>顺序栈和链栈的时间复杂度<strong>都是O(1)</strong></li>
<li>顺序栈在元素定位上相比链栈更<strong>节省内存开销</strong>，<strong>但需事先确定一个固定长度</strong></li>
<li>链栈则<strong>无长度限制</strong></li>
</ul>
<hr>
<ul>
<li>因此，如果栈的使用过程中<strong>元素不可预料，有时很小，有时很大</strong>，那么最好使用<strong>栈链</strong></li>
<li>反之，如果它的<strong>变化在可控范围内</strong>，使用<strong>顺序栈</strong>会更好一些</li>
</ul>
<h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>栈的引入主要是<strong>将问题划分了不同的关注层次，使得思考范围进一步缩小，更加聚焦于我们解决问题的核心。从而简化了程序设计的问题</strong>，反之，使用传统“万金油”数组下标操作，则会使我们分散精力去处理一些琐碎的细节问题，反而掩盖了问题的本质。</p>
<h2 id="栈的应用——递归"><a href="#栈的应用——递归" class="headerlink" title="栈的应用——递归"></a>栈的应用——递归</h2><h3 id="递归的概念"><a href="#递归的概念" class="headerlink" title="递归的概念"></a>递归的概念</h3><p>递归函数：<strong>直接调用自己或通过一系列调用语句间接地调用自己的函数</strong></p>
<h3 id="斐波那契数列的实现"><a href="#斐波那契数列的实现" class="headerlink" title="斐波那契数列的实现"></a>斐波那契数列的实现</h3><p>斐波那契数列(<strong>Fibonacci</strong>)：如 “<strong>1，1，2，3，5，8，13…</strong>” 这种<strong>前面相邻两项之和，构成了后一项</strong>的序列。</p>
<h4 id="常规迭代方法"><a href="#常规迭代方法" class="headerlink" title="常规迭代方法"></a>常规迭代方法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*常规的迭代办法实现前40位Fibonacci数列 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fibonacci_Common</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> f[<span class="number">40</span>];</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, f[<span class="number">0</span>]);<span class="comment">//输出首个Fibonacci数字</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, f[<span class="number">1</span>]);<span class="comment">//输出第二个Fibonacci数字</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">		f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, f[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归方式实现"><a href="#递归方式实现" class="headerlink" title="递归方式实现"></a>递归方式实现</h4><ol>
<li>从实际存在<strong>递归/重复</strong>规律的实际问题出发<ul>
<li>递归的核心在于：每一次的结果都是需要通过<strong>函数调用</strong>的方式<strong>回退到规律的起点</strong></li>
<li>通过<strong>函数return</strong>的自然机制<strong>递归</strong>出每一次的结果</li>
</ul>
</li>
<li>将实际问题的递归规律<strong>通过数学函数表示</strong>出来(完成递归函数的百分之80)</li>
<li>将数学函数<strong>通过代码</strong>的形式表达出来</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E9%80%92%E5%BD%92%E7%9A%84%E5%88%86%E6%9E%90.png"
                      alt="递归"
                ></p>
<p>通过递归的方式实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*斐波那契的递归函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fbi</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( i &lt; <span class="number">2</span> )</span><br><span class="line">		<span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">return</span> Fbi(i - <span class="number">1</span>) + Fbi(i - <span class="number">2</span>);  <span class="comment">/* 这里Fbi就是函数自己，等于在调用自己 */</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">40</span>;i++)  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, Fbi(i));  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>递归和迭代的区别</strong></p>
<ol>
<li>递归：递归使用<strong>选择结构</strong><ul>
<li><strong>优点</strong>：递归能使<strong>程序结构更清晰，更简洁、容易理解，减少读代码时间</strong></li>
<li><strong>缺点</strong>：大量的递归调用回建立函数的副本，<strong>耗费大量的时间和内存</strong></li>
</ul>
</li>
<li>迭代：迭代使用<strong>循环结构</strong><ul>
<li><strong>优点</strong>：迭代<strong>无需反复调用函数和占用额外内存</strong></li>
<li><strong>缺点</strong>：代码复杂，程序结构不利于代码的阅读</li>
</ul>
</li>
</ol>
<h3 id="栈在递归里的应用"><a href="#栈在递归里的应用" class="headerlink" title="栈在递归里的应用"></a>栈在递归里的应用</h3><p>递归函数的执行特点是：</p>
<ul>
<li>“<strong>先回退(前行)，后递归(退回)</strong>”即退回和前行两个阶段。而且这两个执行阶段互为<strong>逆序</strong></li>
<li>在<strong>递归(退回)</strong>的过程中，需要不断执行且<strong>恢复前行过程中存储起来的某些数据</strong></li>
</ul>
<p>对于这种<strong>先不断前行执行，后又以其逆序的方式恢复这些数据</strong>的数据结构，<strong>符合栈这样的特点</strong>。因此底层的<strong>编译器</strong>常使用<strong>栈实现函数的递归操作</strong>。</p>
<blockquote>
<p>简单的说，就是在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。</p>
<p>当然，对于现在的高级语言，这样的递归问题是不需要用户来管理这个栈的，一切都由系统代劳了。</p>
</blockquote>
<h2 id="栈的应用——四则运算表达式求值"><a href="#栈的应用——四则运算表达式求值" class="headerlink" title="栈的应用——四则运算表达式求值"></a>栈的应用——四则运算表达式求值</h2><h3 id="后缀表达式-逆波兰-法定义"><a href="#后缀表达式-逆波兰-法定义" class="headerlink" title="后缀表达式(逆波兰)法定义"></a>后缀表达式(逆波兰)法定义</h3><ul>
<li><p><strong>中缀表达式</strong>：形如 <strong>“ 9 + (3 - 1) X 3 + 10 ÷ 2 ”</strong> 标准的四则运算表达式，<strong>所有运算符号</strong>都在两数字<strong>中间</strong>。</p>
<blockquote>
<p>对于计算机来说，中缀表达式这种具有括号，乘除加减的复杂四则运算，计算机是不能马上识别出真确的运算顺序，而对于计算机如何实现数学表达式的求职。提出了一种新的表达法——<strong>后缀表达法</strong>。  </p>
</blockquote>
</li>
<li><p><strong>后缀表达法(逆波兰)(Reverse Polish Notation，RPN)</strong>：是一种<strong>不需要括号</strong>,<strong>所有符号</strong>都是在要运算数字的<strong>后面</strong>出现。    </p>
<p>如： <strong>“ 9 + (3 - 1) X 3 + 10 ÷ 2 ”</strong>的后缀表达式为， <strong>“ 9 3 1 - 3 *  + 10 2 / + ”</strong></p>
</li>
</ul>
<h3 id="栈的应用——中缀表达式转后缀表达式"><a href="#栈的应用——中缀表达式转后缀表达式" class="headerlink" title="栈的应用——中缀表达式转后缀表达式"></a>栈的应用——中缀表达式转后缀表达式</h3><p><strong>核心</strong>：栈是用来进出运算的<strong>符号</strong></p>
<ul>
<li><strong>数字直接输出</strong></li>
<li><strong>入栈</strong>：<ul>
<li><strong>未匹配的左括号</strong>，<strong>优先级高</strong>于栈顶符号</li>
<li>低优先级出栈机制结束后再进栈</li>
</ul>
</li>
<li><strong>出栈</strong>：<ul>
<li><strong>右括号</strong>，出栈到与之匹配的左括号为止</li>
<li><strong>低优先级</strong>符号出栈直至有比原顶栈符号优先级更低的为止，最后再将其低优先级符号入栈</li>
<li>中缀表达式<strong>处理完毕</strong>，则输出栈内剩下的所有符号</li>
</ul>
</li>
<li><strong>注意：” ( ) “括号参与出入栈，但不表示在表达式中</strong></li>
</ul>
<blockquote>
<p>具体推导的图示过程，可查看本读物 p108~p110</p>
</blockquote>
<h3 id="栈的应用——后缀表达式的计算"><a href="#栈的应用——后缀表达式的计算" class="headerlink" title="栈的应用——后缀表达式的计算"></a>栈的应用——后缀表达式的计算</h3><p><strong>核心</strong>：栈是用来进出运算的<strong>数字</strong></p>
<p>后缀表达式在计算机中的具体运算规则如下：</p>
<ol>
<li>从<strong>左到右</strong>遍历表达式的每个<strong>数字和符号</strong></li>
<li>遇到<strong>数字就进栈</strong></li>
<li>遇到<strong>符号</strong>就把处于<strong>栈顶的两个数字出栈</strong>，进行运算。把<strong>运算结构进栈</strong></li>
<li>直至处理完毕得到最终结果为止</li>
</ol>
<blockquote>
<p>具体推导的图示过程，可查看本读物 p106~p108</p>
</blockquote>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2020/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E9%98%9F%E5%88%97/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">数据结构 第四章 队列</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2020/09/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8&amp;%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">数据结构 第三章 循环链表&amp;双向链表</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">yhd</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.1</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-number">1.</span> <span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">2.</span> <span class="nav-text">栈的定义</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">栈的抽象数据类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">栈的顺序存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="nav-number">4.1.</span> <span class="nav-text">顺序栈的结构定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E6%A0%88-amp-%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="nav-number">4.2.</span> <span class="nav-text">进栈&amp;出栈操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Push"><span class="nav-number">4.2.1.</span> <span class="nav-text">Push</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pop"><span class="nav-number">4.2.2.</span> <span class="nav-text">pop</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4"><span class="nav-number">4.3.</span> <span class="nav-text">两栈共享空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">4.3.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="nav-number">4.3.2.</span> <span class="nav-text">设计方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%9B%8F%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84"><span class="nav-number">4.3.3.</span> <span class="nav-text">两盏共享空间结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%86%85%E5%85%83%E7%B4%A0%E5%AD%98%E5%82%A8%E7%8A%B6%E6%80%81"><span class="nav-number">4.3.4.</span> <span class="nav-text">栈内元素存储状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4%E4%B8%8B%E7%9A%84%E8%BF%9B%E6%A0%88-amp-%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="nav-number">4.3.5.</span> <span class="nav-text">共享空间下的进栈&amp;出栈操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#push"><span class="nav-number">4.3.5.1.</span> <span class="nav-text">push</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pop-1"><span class="nav-number">4.3.5.2.</span> <span class="nav-text">pop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">4.3.5.3.</span> <span class="nav-text">时间复杂度分析</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">5.</span> <span class="nav-text">栈的链式存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E6%A0%88%E7%9A%84%E8%BF%9B%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="nav-number">5.1.</span> <span class="nav-text">链栈的进栈操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E6%A0%88%E7%9A%84%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="nav-number">5.2.</span> <span class="nav-text">链栈的出栈操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">7.</span> <span class="nav-text">栈的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80-1"><span class="nav-number">7.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E9%80%92%E5%BD%92"><span class="nav-number">7.2.</span> <span class="nav-text">栈的应用——递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">7.2.1.</span> <span class="nav-text">递归的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.2.2.</span> <span class="nav-text">斐波那契数列的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%84%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95"><span class="nav-number">7.2.2.1.</span> <span class="nav-text">常规迭代方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.2.2.2.</span> <span class="nav-text">递归方式实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%9C%A8%E9%80%92%E5%BD%92%E9%87%8C%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">7.2.3.</span> <span class="nav-text">栈在递归里的应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-number">7.3.</span> <span class="nav-text">栈的应用——四则运算表达式求值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E9%80%86%E6%B3%A2%E5%85%B0-%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="nav-number">7.3.1.</span> <span class="nav-text">后缀表达式(逆波兰)法定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">7.3.2.</span> <span class="nav-text">栈的应用——中缀表达式转后缀表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-number">7.3.3.</span> <span class="nav-text">栈的应用——后缀表达式的计算</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/dark-light-toggle.js"></script>


    <script src="/js/local-search.js"></script>



    <script src="/js/code-copy.js"></script>



    <script src="/js/lazyload.js"></script>


<div class="post-scripts">
    
        <script src="/js/left-side-toggle.js"></script><script src="/js/libs/anime.min.js"></script><script src="/js/toc.js"></script>
    
</div>



</body>
</html>
