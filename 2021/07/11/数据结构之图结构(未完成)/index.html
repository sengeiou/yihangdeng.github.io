<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="yhd">
    
    <title>
        
            数据结构之图结构(未完成) |
        
        DyhBlog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/MyLogo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"yoursite.com","root":"/","language":"en","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.jpg","favicon":"/images/MyLogo.svg","article_img_align":"left","left_side_width":"230px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.jpeg"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.1"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.1.1"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                DyhBlog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">数据结构之图结构(未完成)</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">yhd</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-07-11 11:14:52
    </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>6k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>23 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p><strong>引言</strong>：本文主要介绍了数据结构中的图结构，涵盖图的逻辑结构概念，基本术语、图的基本性质。以及图的遍历，深度优先与广度优先遍历。图的存储结构，邻接矩阵和邻接表，及其实现与深度广度优先遍历的实现。最小生成树算法，Prim，Kruskal以及最短路径算法Dijkstra算法、Floyed算法，AOV和AOE。</p>
<blockquote>
<p><strong>参考资料</strong>：</p>
<ul>
<li>《数据结构——从概念到C++实现》（第3版）- 王红梅 - 清华大学出版社</li>
<li>《数据结构——从概念到Java实现》（第2版）- 王红梅 - 清华大学出版社</li>
<li>《大话数据结构》（第1版）- 程杰 - 清华大学出版社</li>
</ul>
</blockquote>
<ul>
<li><strong>图结构知识图谱之思维导图</strong></li>
</ul>
<h1 id="概念与术语">概念与术语</h1>
<h2 id="图的定义">图的定义</h2>
<ul>
<li><strong>图</strong>（graph），即<strong>有穷非空顶点</strong>的集合 + <strong>顶点间的边</strong>的集合</li>
<li><strong>顶点</strong>（vertex）：图中数据元素</li>
<li><strong>边</strong>（edge）：图中任意两顶点构成的边</li>
</ul>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G = (V,E)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></span></p>
<h2 id="基本术语">基本术语</h2>
<p>图涉及众多基本术语，涉及大部分离散数学的内容</p>
<h3 id="边">边</h3>
<ul>
<li><strong>无向边</strong>：边无方向，记作：(v<sub>0</sub>，v<sub>1</sub>)
<ul>
<li><strong>无向图</strong>（undirected graph）：<u>均由无向边组成</u>的图</li>
<li><strong>完全无向图</strong>（undirected completed graph）：<u>任意两点间</u>都含无向边</li>
</ul>
</li>
<li><strong>有向边/弧</strong>：边有方向，记作：&lt;v<sub>0</sub>，v<sub>1</sub>&gt;，v<sub>0</sub> —&gt; v<sub>1</sub>，v<sub>0</sub> 弧尾，v<sub>1</sub>弧<strong>头</strong>(箭<strong>头</strong>)
<ul>
<li><strong>有向图</strong>（directed graph）：<u>均由有向边组成</u>的图</li>
<li><strong>完全无向图</strong>（directed completed  graph）：任意两点均含**<u>两条</u><strong>，方向</strong><u>相反</u>**的弧</li>
</ul>
</li>
</ul>
<blockquote>
<p>若图G = (V，E)中同时包含无向边和有向边，则称为混合图</p>
</blockquote>
<ul>
<li><strong>权</strong>（weight）：对<strong>边</strong>赋予有意义的<strong>数量值</strong>，如边的长度、等级等描述
<ul>
<li><strong>网图</strong>（network graph）：边带权构成的图称为网图</li>
</ul>
</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210707094205.png" alt=""></p>
<h3 id="依附与邻接">依附与邻接</h3>
<p>“依附”描述<strong>边</strong>，“邻接”描述<strong>点</strong></p>
<ul>
<li>
<p><strong>依附</strong>（adhere）：一条边连接两个点，则该边依附这两个点</p>
</li>
<li>
<p><strong>邻接点</strong>（adjacent）：一条边相连的两个点<strong>互为邻接点</strong></p>
<ul>
<li><strong>无向图</strong>的邻接点：<u>互为邻接点</u></li>
<li><strong>有向图</strong>的邻接点：称弧尾邻接<strong>到</strong>弧头，弧头<strong>是</strong>弧尾的邻接点</li>
</ul>
<blockquote>
<p>例如：&lt;v<sub>0</sub>，v<sub>1</sub>&gt;，v<sub>0</sub> —&gt; v<sub>1</sub>，v<sub>0</sub> 邻接到 v<sub>1</sub>， v<sub>1</sub>是v<sub>0</sub>的邻接点</p>
</blockquote>
</li>
</ul>
<h3 id="度">度</h3>
<ul>
<li><strong>度</strong>（degree / D）：<strong>某个顶点</strong>所<strong>依附的边的条数</strong>
<ul>
<li><strong>无向图</strong>的度：即某个点所依附的边的条数</li>
<li><strong>有向图</strong>的度：
<ul>
<li><strong>出度</strong>（out-degree / OD）：O→</li>
<li><strong>入度</strong>（in-degree / ID）：O ←</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="稠密与稀疏图">稠密与稀疏图</h3>
<ul>
<li><strong>边数很少</strong>的图称为<strong>稀疏图</strong>（spares graph），反之称为<strong>稠密图</strong>（dense graph）</li>
<li>稀疏和稠密本身就是模糊的相对的概念。但显然边数为0最稀疏，完全图最稠密</li>
</ul>
<h3 id="路径相关">路径相关</h3>
<ul>
<li>
<p><strong>路径</strong>（path）：</p>
<ul>
<li><strong>无向图</strong>路径：两个点之间通过若干条边连接的路线</li>
<li><strong>有向图</strong>路径：两个点之间<strong>按出度方向</strong>相连接的路线</li>
<li><strong>简单路径</strong>（simple path）：在路径中，除第一个结点和最后一个结点外，其他顶点只经过一次</li>
</ul>
<blockquote>
<p>通常情况下，一般所说的回路，即指简单回路</p>
</blockquote>
</li>
<li>
<p><strong>路径长度</strong>（path length）：</p>
<ul>
<li><strong>非网图</strong>：路径所经过的<strong>边数</strong></li>
<li><strong>网图</strong>：路径所经过边的<strong>权值之和</strong></li>
</ul>
</li>
<li>
<p><strong>回路</strong>（circuit）：<strong>出发顶点 == 终点顶点</strong>的路径</p>
<ul>
<li><strong>简单回路</strong>（simple circuit）：在回路中，所有顶点只经过一次</li>
</ul>
<blockquote>
<p>通常情况下，一般所说的回路，即指简单回路</p>
</blockquote>
</li>
</ul>
<h3 id="子图">子图</h3>
<ul>
<li>某图G = (V , E)中顶点V和边E<strong>分别的子集 v’ ,e’</strong>，所构成的图<strong>称为G的子图</strong></li>
<li><strong>正例</strong></li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210707094953.png" alt=""></p>
<ul>
<li><strong>反例</strong>：都出现了图中V或E集合中没有的子集</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210707095644.png" alt=""></p>
<h3 id="连通图相关">连通图相关</h3>
<h4 id="连通图">连通图</h4>
<p>若顶点v<sub>i</sub> 和 v<sub>j</sub>之间<strong>存在路径</strong>，则称v<sub>i</sub> 和 v<sub>j </sub><strong>是连通的</strong></p>
<ul>
<li>
<p><strong>连通图</strong>（connected graph）（无向图）：<strong><u>任意两个</u><strong>顶点</strong>之间</strong>(两个方向<u>合成一个方向</u>)<strong>都存在路径</strong></p>
<ul>
<li><strong>连通分量</strong>：<u>非连通图中</u>的<strong>极大连通子图</strong>，存在多个</li>
<li>“<strong>极大</strong>”含义：
<ul>
<li>子图在满足连通条件下，包含所有连通的顶点及其关联的所有边</li>
<li>注意，“极大”不是边数最多的连通子图，不只有一个。而是说连通子图中尽可能去连通可连通的顶点</li>
</ul>
</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210707101056.png" alt=""></p>
</li>
</ul>
<h4 id="强连通图">强连通图</h4>
<ul>
<li>
<p><strong>强连通图</strong>（strongly connected graph）：<u><strong>任意两个</strong></u>顶点<strong>之间</strong>(<u>两个方向，<strong>来回</strong></u>)<strong>都存在路径</strong></p>
<ul>
<li><strong>强连通分量</strong>：<u>非强连通图中</u>的<strong>极大强连通子图</strong>，存在多个</li>
<li>“极大”同连通分量的含义</li>
</ul>
<hr>
<ul>
<li>（b）非强连通是由于 不存在v<sub>0</sub> 到 v<sub>1</sub>的路径</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210707101134.png" alt=""></p>
</li>
<li>
<p><strong>辨别强连通图</strong>：每个顶点<strong>都有出度和入度</strong>为<strong>强连通图</strong></p>
</li>
</ul>
<h2 id="ADT接口声明">ADT接口声明</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GraphInterface</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> startIndex)</span></span>;	<span class="comment">//图的深度优先遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> startIndex)</span></span>;	<span class="comment">//图的广度优先遍历</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="图的基本性质">图的基本性质</h1>
<h2 id="边与度">边与度</h2>
<ul>
<li><strong>无向图</strong>：<strong>e = 2d</strong>，即边的总数，是度的总数的两倍
<ul>
<li>解析：“<strong>一边两度</strong>”</li>
</ul>
</li>
<li><strong>有向图</strong>：<strong>ID = OD = e</strong>，入度总数等于出度总数等于边总数
<ul>
<li>解析：一条弧上所依附两个顶点必定有一个出度，另一个入度，</li>
</ul>
</li>
</ul>
<h2 id="完全图">完全图</h2>
<h3 id="公式">公式</h3>
<ul>
<li>n个顶点的<strong>有向</strong>完全图含有 <strong>n x</strong> (<strong>n - 1</strong>) 条弧</li>
<li>n个顶点的无向完全图含有 <strong>n x</strong> (<strong>n - 1</strong>)  <strong>/ 2</strong> 条边</li>
</ul>
<h3 id="原理">原理</h3>
<ul>
<li>
<p>通过数学归纳法，统计可以得出有向完全图n个顶点含有n x (n - 1)条弧</p>
</li>
<li>
<p>而无向完全图的边没有方向，相当于将有向完全图任意两个顶点依附的<strong>两条弧合并成了一条无向边</strong></p>
</li>
<li>
<p>因此无向完全图应是<strong>在有向完全图数量基础上除一半</strong>，即 n x (n - 1) <strong>/ 2</strong></p>
<hr>
</li>
<li>
<p>下图为分析<strong>有向完全图</strong>n个顶点所含有边的增量过程</p>
</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210707091901.png" alt=""></p>
<h1 id="图的遍历">图的遍历</h1>
<h2 id="思想引导">思想引导</h2>
<ul>
<li><strong>图的遍历</strong>（traverse）和其他数据结构遍历要求类似，即<strong>所有顶点有且只有被访问一次</strong></li>
<li>但由于上图结构本身的复杂性，图的遍历需要解决许多困难</li>
</ul>
<table>
<thead>
<tr>
<th>遍历需解决的关键问题Q</th>
<th>解决方案A</th>
</tr>
</thead>
<tbody>
<tr>
<td>没有确定的开始结点，如何选取遍历起始点？</td>
<td>方案1：<strong>任意顶点出发</strong><br>方案2：依赖对应的存储结构<strong>进行编号，从小到大遍历</strong></td>
</tr>
<tr>
<td>非连通图如何遍历所有结点？</td>
<td>多次从各个结点遍历，取结果的不重复并集<br>现只讨论一个顶点开始遍历图</td>
</tr>
<tr>
<td>图存在回路，如何避免不重复访问？</td>
<td>设置一个<strong>访问标志数组</strong>，被访问过的顶点置为1</td>
</tr>
<tr>
<td>一个顶点会和多个顶点相邻接，<br>如何选取下一个顶点访问的顶点？</td>
<td>属于<strong>遍历次序</strong>问题，有<strong>深度优先</strong>遍历<strong>和广度优先</strong>遍历</td>
</tr>
</tbody>
</table>
<p><strong>注</strong>：由于图的结构复杂，即使确定的遍历次序，<strong>遍历序列也不是唯一的</strong></p>
<h2 id="深度优先遍历">深度优先遍历</h2>
<ul>
<li><strong>深度优先遍历</strong>（depth-first traverse / DFS）类似树的<u>前序遍历</u>，属于“<strong>一条路走到死才递归返回</strong>”</li>
<li>深度优先遍历与树的前序遍历一样，属于<strong>递归思想实现</strong>的一种遍历</li>
</ul>
<h3 id="基本思想">基本思想</h3>
<ol>
<li>
<p>初始化，取任意顶点v开始遍历</p>
</li>
<li>
<p>直至所有访问标志数组均被置数访问过</p>
<p>2.1. 从v的<strong>未被访问</strong>的邻接点中选取一个顶点w访问</p>
<p>2.2. 从w出发再进行深度优先遍历，即重复步骤2</p>
</li>
</ol>
<p><img lazyload="" src="/images/loading.svg" data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210707111656.png" alt=""></p>
<h2 id="广度优先遍历">广度优先遍历</h2>
<ul>
<li><strong>广度优先遍历</strong>（breadth-first traverse / BFS），<strong>类似树的层序遍历</strong>，属于<strong>非递归方式遍历</strong></li>
<li>规定从某个顶点开始，<strong>由近到远</strong>（路径），依次访问图的所有结点</li>
</ul>
<h3 id="基本思想-2">基本思想</h3>
<ol>
<li>
<p>选取一个<strong>起始顶点入队</strong></p>
</li>
<li>
<p><strong>出队</strong>一个元素，并把<strong>该元素</strong>所有**<u>未遍历</u><strong>的</strong>出度**的元素入队</p>
</li>
<li>
<p>若队列<strong>不为空</strong>，继续执行步骤 2</p>
</li>
</ol>
<p><img lazyload="" src="/images/loading.svg" data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210707111313.png" alt=""></p>
<h1 id="图的存储结构">图的存储结构</h1>
<h2 id="前言">前言</h2>
<ul>
<li>图是一种复杂的数据结构，任意两个顶点之间都可能存在边，所以无法通过顶点的存储位置反映顶点之间的邻接关系，因此<strong>图没有顺序存储结构</strong></li>
<li>从图的定义可知，一个图包括两部分：<strong>顶点的信息</strong>以及<strong>顶点之间边的信息</strong>。无论采用什么方法存储图，都要完整、准确地表示这两方面的信息</li>
<li>一般来说，图的存储结构应<strong>需根据具体问题的要求来设计</strong></li>
<li>下面介绍<u>两种常用的存储结构</u>——<strong>邻接矩阵</strong>和<strong>邻接表</strong></li>
</ul>
<h2 id="邻接矩阵">邻接矩阵</h2>
<h3 id="定义">定义</h3>
<h4 id="邻接矩阵定义">邻接矩阵定义</h4>
<ul>
<li><strong>邻接矩阵</strong>（adjacency matrix）是使用<u>两个数组</u>实现的图的存储结构，因此也成为<strong>数组表示法</strong></li>
<li>矩阵，必定至少是个二维表。
<ul>
<li>一维数组 <strong>vertex[ ? ] = { v0 v1 v2 v3 v4}</strong>：存储顶<strong>点信息</strong></li>
<li>二维数组 <strong>edge[ i ] [ j ] = ?</strong>：存储两点之间的<strong>边的信息</strong>，<strong>i — j 或 i —&gt; j</strong></li>
</ul>
</li>
<li>因此对于<strong>无向图</strong>的邻接矩阵一定是<strong>对称矩阵</strong></li>
</ul>
<h4 id="代码实现">代码实现</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MGraph</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">GraphInterface</span>&lt;<span class="title">T</span>&gt;</span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> vertices_num;   <span class="comment">//图的顶点数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edge_num;       <span class="comment">//图的边数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T[] vertices;       <span class="comment">//一维数组存储图的顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] adjMatrix;  <span class="comment">//二维数组实现邻接矩阵</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visited;          <span class="comment">//访问标志数组</span></span><br><span class="line">    <span class="comment">//实现接口方法...</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="非网图邻接矩阵">非网图邻接矩阵</h3>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>d</mi><mi>g</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>存在无向边</mtext><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mtext>或有向边</mtext><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>不存在边或等于自身点</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr></mtable><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">edge[i][j]=\begin{Bmatrix}
1 &amp; 存在无向边(v_{i},v_{j})或有向边&lt;v_{i},v_{j}&gt; &amp; \\ 
0 &amp; 不存在边或等于自身点  &amp; 
\end{Bmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">无</span><span class="mord cjk_fallback">向</span><span class="mord cjk_fallback">边</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">向</span><span class="mord cjk_fallback">边</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">边</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">自</span><span class="mord cjk_fallback">身</span><span class="mord cjk_fallback">点</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.4499999999999997em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-2.2499999999999996em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">}</span></span></span></span></span></span></span></p>
<h3 id="网图邻接矩阵">网图邻接矩阵</h3>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>d</mi><mi>g</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>W</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>表示边的权值</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>即存在无向边</mtext><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mtext>或有向边</mtext><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>自身点</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi mathvariant="normal">∞</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>不存在边</mtext></mstyle></mtd></mtr></mtable><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">edge[i][j]=\begin{Bmatrix}
W_{ij} &amp;表示边的权值  &amp;即存在无向边(v_{i},v_{j})或有向边&lt;v_{i},v_{j}&gt; \\ 
0 &amp; 自身点  &amp; \\
∞ &amp; 不存在边
\end{Bmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.49999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.00501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">边</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">权</span><span class="mord cjk_fallback">值</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">自</span><span class="mord cjk_fallback">身</span><span class="mord cjk_fallback">点</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">边</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">即</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">无</span><span class="mord cjk_fallback">向</span><span class="mord cjk_fallback">边</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">向</span><span class="mord cjk_fallback">边</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000053em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.49999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎭</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎬</span></span></span><span style="top:-4.00501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><strong>注</strong>：∞表示计算机允许的、大于所有边上权值的树</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p>
<h3 id="邻接矩阵实现">邻接矩阵实现</h3>
<h4 id="邻接矩阵结构">邻接矩阵结构</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MGraph</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">GraphInterface</span>&lt;<span class="title">T</span>&gt;</span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> vertices_num;   <span class="comment">//图的顶点数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edge_num;       <span class="comment">//图的边数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T[] vertices;       <span class="comment">//一维数组存储图的顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] adjMatrix;  <span class="comment">//二维数组实现邻接矩阵</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visited;          <span class="comment">//访问标志数组</span></span><br><span class="line">    <span class="comment">//实现接口方法...</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="测试无向图">测试无向图</h4>
<ul>
<li><strong>用于一下代码测试的无向图</strong></li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210707161140.png" alt=""></p>
<h4 id="无向图初始化">无向图初始化</h4>
<ul>
<li><strong>伪代码</strong>：建议掌握书写伪代码的能力</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">算法：MGraph（init vertices，edge_num）</span><br><span class="line">输入：顶点的数据信息init vertices，边的个数edge_num</span><br><span class="line">输出：图的邻接矩阵</span><br><span class="line">	1.存储图的顶点个数和边的个数；</span><br><span class="line">	2.将顶点数据信息存储在一维数组 vertices中；</span><br><span class="line">	3.初始化邻接矩阵adjMatrix；</span><br><span class="line">	4.依次输入每条存在的边并存储在邻接矩阵adjMatrix中：</span><br><span class="line">		4.1输入边依附的两个顶点的编号i和j；</span><br><span class="line">		4.2将adjMatrix[i][j]和adjMatrix[j][i]的值置为1；（无向图）</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>示例代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 无向图构造函数</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> init_vertices 图的顶点信息数据</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> edge_num  无向图的边的数量</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MGraph</span><span class="params">(T[] init_vertices,<span class="keyword">int</span> edge_num)</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(init_vertices.length == <span class="number">0</span>){</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"无顶点，无向图构造失败"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一系列初始操作</span></span><br><span class="line">    <span class="keyword">this</span>.vertices_num = init_vertices.length;</span><br><span class="line">    <span class="keyword">this</span>.edge_num = edge_num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.vertices = (T[]) <span class="keyword">new</span> Object[vertices_num];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; init_vertices.length; i++) {</span><br><span class="line">        vertices[i] = init_vertices[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.adjMatrix = <span class="keyword">new</span> <span class="keyword">int</span>[vertices_num][vertices_num];</span><br><span class="line">    Scanner reader = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= edge_num; i++) {</span><br><span class="line">        System.out.print(<span class="string">"请输入存在的第 "</span>+ i + <span class="string">"条边的第1个顶点信息"</span>);</span><br><span class="line">        <span class="keyword">int</span> vertex1 = reader.nextInt();</span><br><span class="line">        System.out.print(<span class="string">"请输入存在的第 "</span>+ i + <span class="string">"条边的第2个顶点信息"</span>);</span><br><span class="line">        <span class="keyword">int</span> vertex2 = reader.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//无向边初始化</span></span><br><span class="line">        adjMatrix[vertex1][vertex2] = <span class="number">1</span>;</span><br><span class="line">        adjMatrix[vertex2][vertex1] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    reader.close();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>测试代码</strong>：以测试无向图为例进行测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    String[] vertices = <span class="keyword">new</span> String[]{<span class="string">"0A"</span>,<span class="string">"1B"</span>,<span class="string">"2C"</span>,<span class="string">"3D"</span>};</span><br><span class="line">    MGraph&lt;String&gt; graph = <span class="keyword">new</span> MGraph&lt;&gt;(vertices,<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//键盘输入存在的4条边，无向图是对称矩阵，任意一条边都选取一个方向的顶点对输入即可</span></span><br><span class="line">    <span class="comment">//即只需要选取上三角或下三角的邻接矩阵值输入即可</span></span><br><span class="line">    <span class="comment">//键盘输入内容：0,1、0,3、3,1、1,2</span></span><br><span class="line"></span><br><span class="line">    graph.DFS(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="深度优先遍历-DFT">深度优先遍历(DFT)</h4>
<ul>
<li><strong>伪代码</strong>：建议掌握书写伪代码的能力</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">算法：DFT输入：顶点的编号v</span><br><span class="line">输出：无</span><br><span class="line">	1.访问顶点v；修改标志 visited[v]=true；</span><br><span class="line">	2.w = 顶点v的第一个邻接点；</span><br><span class="line">	3.while（w存在）</span><br><span class="line">		3.1 if（w未被访问）从顶点w出发递归执行该算法；</span><br><span class="line">		3.2 w = 顶点v的下一个邻接点；</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>示例代码</strong>：原接口实现方法用于接收用户定义的起始顶点调用，另创建递归实现的方法体</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 无向图深度优先遍历</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> startIndex 用户决定起始遍历的顶点索引</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(startIndex &lt; <span class="number">0</span> || startIndex &gt;= vertices_num){</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"起始遍历顶点不存在"</span>);</span><br><span class="line">    }</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="keyword">this</span>.vertices_num];</span><br><span class="line">    iteratorDFT(startIndex);</span><br><span class="line">    System.out.println();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 无向图深度优先遍历递归实现</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> startIndex 顶点索引</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iteratorDFT</span><span class="params">(<span class="keyword">int</span> startIndex)</span></span>{</span><br><span class="line">    System.out.print(vertices[startIndex] + <span class="string">" "</span>);</span><br><span class="line">    visited[startIndex] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找该顶点下一个未被访问过的邻接顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertices_num; i++) {</span><br><span class="line">        <span class="keyword">if</span>(adjMatrix[startIndex][i] == <span class="number">1</span> &amp;&amp; !visited[i]){</span><br><span class="line">            iteratorDFT(i);<span class="comment">//递归存在的且未被访问的邻接结点</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>测试代码</strong>：以测试无向图为例进行测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    String[] vertices = <span class="keyword">new</span> String[]{<span class="string">"0A"</span>,<span class="string">"1B"</span>,<span class="string">"2C"</span>,<span class="string">"3D"</span>};</span><br><span class="line">    MGraph&lt;String&gt; graph = <span class="keyword">new</span> MGraph&lt;&gt;(vertices,<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//键盘输入内容：0,1、0,3、3,1、1,2</span></span><br><span class="line">    </span><br><span class="line">    graph.DFS(<span class="number">0</span>);<span class="comment">//0A 1B 2C 3D </span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="广度优先遍历-BFT">广度优先遍历(BFT)</h4>
<ul>
<li><strong>伪代码</strong>：建议掌握书写伪代码的能力</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">算法：BFTraverse</span><br><span class="line">输入：顶点的编号v</span><br><span class="line">输出：无</span><br><span class="line">	1.队列Q初始化；</span><br><span class="line">	2.访问顶点v；修改标志visited[v]=1；顶点v入队列Q；</span><br><span class="line">	3.while（队列Q非空）</span><br><span class="line">		3.1 v=队列Q的队头元素出队；</span><br><span class="line">		3.2 w=顶点v的第一个邻接点；</span><br><span class="line">		3.3 while（w存在）</span><br><span class="line">			3.3.1如果w未被访问，则访问顶点w；修改标志 visited[w]=1；顶点w人队列Q；</span><br><span class="line">			3.3.2w=顶点v的下一个邻接点；</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>个人实现</strong>：有别于伪代码方式，伪代码是3.3.1步骤访问输出数据，本人是以队头出队时访问并输出数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 无向图广度优先遍历</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> startIndex 用户决定起始遍历的顶点索引</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(startIndex &lt; <span class="number">0</span> || startIndex &gt;= vertices_num){</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"起始遍历顶点不存在"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//初始化访问标识数组</span></span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="keyword">this</span>.vertices_num];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化队列，并将开始遍历顶点入队</span></span><br><span class="line">    QueueInterface&lt;Integer&gt; queue = <span class="keyword">new</span> CircularQueue&lt;&gt;(vertices_num);</span><br><span class="line">    queue.enQueue(startIndex);</span><br><span class="line">    visited[startIndex] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直到队列为空</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line">        Integer vertex = queue.deQueue();</span><br><span class="line">        System.out.print(vertices[vertex] + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//寻找出队顶点的所有邻接结点并入队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertices_num; i++) {</span><br><span class="line">            <span class="comment">//邻接点存在且未被访问过</span></span><br><span class="line">            <span class="keyword">if</span>(adjMatrix[vertex][i] == <span class="number">1</span> &amp;&amp; !visited[i]){</span><br><span class="line">                queue.enQueue(i);</span><br><span class="line">                <span class="comment">//入队时就要将要访问的结点所在访问标识数组置为true，否则会反复入队</span></span><br><span class="line">                visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    System.out.println();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>测试代码</strong>：以测试无向图为例进行测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    String[] vertices = <span class="keyword">new</span> String[]{<span class="string">"0A"</span>,<span class="string">"1B"</span>,<span class="string">"2C"</span>,<span class="string">"3D"</span>};</span><br><span class="line">    MGraph&lt;String&gt; graph = <span class="keyword">new</span> MGraph&lt;&gt;(vertices,<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//键盘输入下三角部分：0,1、0,3、3,1、1,2</span></span><br><span class="line"></span><br><span class="line">    graph.BFS(<span class="number">0</span>);<span class="comment">//0A 1B 3D 2C </span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="邻接表">邻接表</h2>
<h3 id="邻接表定义">邻接表定义</h3>
<h4 id="定义-2">定义</h4>
<ul>
<li><strong>邻接表</strong>（adjacency list）是一种类似<u>树的孩子表示法</u>。</li>
<li>将v的<u>所有邻接点</u>（出度）<strong>链成一个单链表</strong>，称为顶点v的<strong>边表</strong>（有向图称<strong>出边表</strong>）
<ul>
<li><strong>边表结点</strong>：EdgeNode
<ul>
<li><strong>int adjvex</strong>：邻接点域（引用数据下标）</li>
<li><strong>EdgeNode next</strong>：下一个边表结点指针域</li>
</ul>
</li>
<li><strong>顶点表结点</strong>：VertexNode
<ul>
<li><strong>T vertex</strong>：顶点数据域</li>
<li><strong>EdgeNode first</strong>：第一个边表结点的指针域（引用域）</li>
</ul>
</li>
</ul>
</li>
<li>存储<strong>边表的头指针</strong>和<strong>顶点数据</strong><u>构成一个元素</u>，为了节省开销使用<strong>数组存储</strong>，边表引用，称为<strong>顶点表</strong></li>
<li>对于<strong>网图</strong>，则在<strong>边表</strong>中增加一个<strong>权值域</strong></li>
</ul>
<h4 id="实现">实现</h4>
<ul>
<li><strong>边表结点</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeNode</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> adjvex;     <span class="comment">//邻接点域（引用数据下标）</span></span><br><span class="line">    <span class="keyword">private</span> EdgeNode next;  <span class="comment">//邻接点域（引用数据下标）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeNode</span><span class="params">(<span class="keyword">int</span> adjvex)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.adjvex = adjvex;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//省略getter和setter方法...</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>顶点表结点</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VertexNode</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">private</span> T data;             <span class="comment">//顶点数据域</span></span><br><span class="line">    <span class="keyword">private</span> EdgeNode first;     <span class="comment">//第一个边表结点的指针域（引用域）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VertexNode</span><span class="params">()</span></span>{</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VertexNode</span><span class="params">(T data)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//省略getter和setter方法...</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="非网图邻接表">非网图邻接表</h3>
<p><img lazyload="" src="/images/loading.svg" data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210710092259.png" alt=""></p>
<h3 id="网图邻接表">网图邻接表</h3>
<ul>
<li>边表增加一个权值域info</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210710092320.png" alt=""></p>
<h3 id="邻接表实现">邻接表实现</h3>
<h4 id="邻接表结构">邻接表结构</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有向非网图</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ALGrapht</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">GraphInterface</span>&lt;<span class="title">T</span>&gt;</span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> VertexNode&lt;T&gt;[] vertices;   <span class="comment">//顶点表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> vertices_num;           <span class="comment">//顶点数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edge_num;               <span class="comment">//边数量</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visited;                  <span class="comment">//访问标志数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实现GraphInterface接口的方法...</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="测试有向非网图">测试有向非网图</h4>
<p><img lazyload="" src="/images/loading.svg" data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%9C%89%E5%90%91%E9%9D%9E%E7%BD%91%E5%9B%BE%E6%B5%8B%E8%AF%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p>
<h4 id="有向非网图初始化">有向非网图初始化</h4>
<ul>
<li>初始化代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 初始化有向图非网图邻接表</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> init_vertices</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> edge_num</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ALGrapht</span><span class="params">(T[] init_vertices,<span class="keyword">int</span> edge_num)</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(init_vertices.length == <span class="number">0</span>){</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"顶点为空"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.vertices_num = init_vertices.length;</span><br><span class="line">    <span class="keyword">this</span>.edge_num = edge_num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.vertices = <span class="keyword">new</span> VertexNode[<span class="keyword">this</span>.vertices_num];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertices_num; i++) {</span><br><span class="line">        vertices[i] = <span class="keyword">new</span> VertexNode&lt;&gt;(init_vertices[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= edge_num; i++) {</span><br><span class="line">        System.out.print(<span class="string">"请输入存在的第 "</span>+ i + <span class="string">"条边的第1个顶点信息："</span>);</span><br><span class="line">        <span class="keyword">int</span> vertex1 = scanner.nextInt();</span><br><span class="line">        System.out.print(<span class="string">"请输入存在的第 "</span>+ i + <span class="string">"条边的第2个顶点信息："</span>);</span><br><span class="line">        <span class="keyword">int</span> vertex2 = scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        EdgeNode edgeNode = <span class="keyword">new</span> EdgeNode(vertex2);</span><br><span class="line"></span><br><span class="line">        VertexNode&lt;T&gt; vertex = vertices[vertex1];</span><br><span class="line">        EdgeNode firstEdgeNode = vertex.getFirst();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//头插法</span></span><br><span class="line">        edgeNode.setNext(firstEdgeNode);</span><br><span class="line">        vertex.setFirst(edgeNode);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//尾插法</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if(firstEdgeNode == null){</span></span><br><span class="line"><span class="comment">            vertex.setFirst(edgeNode);</span></span><br><span class="line"><span class="comment">        }else {</span></span><br><span class="line"><span class="comment">			EdgeNode p = firstEdgeNode;</span></span><br><span class="line"><span class="comment">            while (p.getNext() != null){</span></span><br><span class="line"><span class="comment">            	p = p.getNext();</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">            p.setNext(edgeNode);</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    }</span><br><span class="line">    scanner.close();</span><br><span class="line">    System.out.println(<span class="string">"初始化邻接表成功..."</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul>
<li>测试代码，根据测试有向非网图</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    String[] init = <span class="keyword">new</span> String[]{<span class="string">"V0"</span>,<span class="string">"V1"</span>,<span class="string">"V2"</span>,<span class="string">"V3"</span>};</span><br><span class="line">    ALGrapht&lt;String&gt; alGrapht = <span class="keyword">new</span> ALGrapht&lt;&gt;(init,<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//有向非网图，键盘输入有向边，0,1、0,2、2,3、3,0</span></span><br><span class="line">    System.out.println(alGrapht);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="深度优先遍历-DFT-2">深度优先遍历(DFT)</h4>
<ul>
<li>伪代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">算法：ALGrapht（init vertices，n，e）</span><br><span class="line">输入：顶点的数据信息init_vertices，顶点个数n，边的个数e输出：图的邻接表</span><br><span class="line">    1.存储图的顶点个数和边的个数；</span><br><span class="line">    2.将顶点信息存储在顶点表中，将该顶点边表的头引用初始化为NULL；</span><br><span class="line">    3.依次输入边的信息并存储在边表中：</span><br><span class="line">    	3.1 输入边所依附的两个顶点的编号i和j；</span><br><span class="line">    	3.2 生成边表结点edgeNode，其邻接点的编号为j；</span><br><span class="line">    	3.3 将结点edgeNode插入第i个边表的表头；</span><br></pre></td></tr></table></figure>
<ul>
<li>示例代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 邻接表深度优先遍历</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> startIndex 用户决定起始遍历的顶点索引</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="keyword">this</span>.vertices_num];</span><br><span class="line">    iteratorDFT(startIndex);</span><br><span class="line">    System.out.println();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 邻接表深度优先遍历递归实现</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> startIndex 顶点索引</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">iteratorDFT</span><span class="params">(<span class="keyword">int</span> startIndex)</span></span>{</span><br><span class="line">    System.out.print(vertices[startIndex].getData() + <span class="string">" "</span>);</span><br><span class="line">    visited[startIndex] = <span class="keyword">true</span>;</span><br><span class="line">    EdgeNode p = vertices[startIndex].getFirst();</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">if</span>(visited[p.getAdjvex()] == <span class="keyword">false</span>){</span><br><span class="line">            iteratorDFT(p.getAdjvex());</span><br><span class="line">        }</span><br><span class="line">        p = p.getNext();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="广度优先遍历-BFT-2">广度优先遍历(BFT)</h4>
<ul>
<li><strong>伪代码</strong>：建议掌握书写伪代码的能力</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">算法：BFTraverse</span><br><span class="line">输入：顶点的编号v</span><br><span class="line">输出：无</span><br><span class="line">	1.队列Q初始化；</span><br><span class="line">	2.访问顶点v；修改标志visited[v]=1；顶点v入队列Q；</span><br><span class="line">	3.while（队列Q非空）</span><br><span class="line">		3.1 v=队列Q的队头元素出队；</span><br><span class="line">		3.2 w=顶点v的第一个邻接点；</span><br><span class="line">		3.3 while（w存在）</span><br><span class="line">			3.3.1如果w未被访问，则访问顶点w；修改标志 visited[w]=1；顶点w人队列Q；</span><br><span class="line">			3.3.2w=顶点v的下一个邻接点；</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>个人实现</strong>：有别于伪代码方式，伪代码是3.3.1步骤访问输出数据，本人是以队头出队时访问并输出数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 邻接表广度优先遍历</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> startIndex 用户决定起始遍历的顶点索引</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(startIndex &lt; <span class="number">0</span> || startIndex &gt;= vertices_num){</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"起始遍历顶点不存在"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertices_num];</span><br><span class="line">    <span class="comment">//初始化，将开始索引入队</span></span><br><span class="line">    CircularQueue&lt;Integer&gt; queue = <span class="keyword">new</span> CircularQueue&lt;&gt;(vertices_num);</span><br><span class="line">    queue.enQueue(startIndex);</span><br><span class="line">    visited[startIndex] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line">        Integer key = queue.deQueue();</span><br><span class="line">        VertexNode&lt;T&gt; vertexNode = vertices[key];</span><br><span class="line">        System.out.print(vertexNode.getData() + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        EdgeNode p = vertexNode.getFirst();</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">int</span> index = p.getAdjvex();</span><br><span class="line">            <span class="keyword">if</span>(!visited[index]){</span><br><span class="line">                queue.enQueue(index);</span><br><span class="line">                visited[index] = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            p = p.getNext();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    System.out.println();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="性能比较">性能比较</h2>
<h3 id="时间复杂度">时间复杂度</h3>
<h4 id="出度-邻接点">出度/邻接点</h4>
<ul>
<li><strong>查找顶点 i 的所有<u>出度 / 邻接点</u></strong>（设图G含有n个顶点，e条边）</li>
</ul>
<table>
<thead>
<tr>
<th>存储结构</th>
<th>原理</th>
<th>时间复杂度</th>
<th>对比</th>
</tr>
</thead>
<tbody>
<tr>
<td>邻接矩阵</td>
<td>遍历第 i <strong>行/列</strong> 数组的所有非零个数</td>
<td>O(n)</td>
<td>劣</td>
</tr>
<tr>
<td>邻接表</td>
<td>遍历第 i 个元素的边表</td>
<td>O(e/n)</td>
<td><strong>优</strong></td>
</tr>
</tbody>
</table>
<p><strong>解析</strong>：由于即使是最稠密的完全有向图，e = n(n - 1)，即e/n = n(n - 1)/n  = n - 1，O(n - 1) &lt; O(n)</p>
<blockquote>
<p>无向图无出入度之分，因此无向图可以选邻接表更高效率的出度方式实现无向图的某顶点求度的需求</p>
</blockquote>
<h4 id="入度">入度</h4>
<ul>
<li>查找顶点 i 的所有入度（设图G含有n个顶点，e条边）</li>
</ul>
<table>
<thead>
<tr>
<th>存储结构</th>
<th>原理</th>
<th>时间复杂度</th>
<th>对比</th>
</tr>
</thead>
<tbody>
<tr>
<td>邻接矩阵</td>
<td>遍历第 i <strong>列/行</strong> 数组的所有非零个数（同出度，仅翻转行列）</td>
<td>O(n)</td>
<td><strong>优</strong></td>
</tr>
<tr>
<td>邻接表</td>
<td>遍历<strong>整个边表</strong>寻找含 i 的顶点</td>
<td>O(e)</td>
<td>劣</td>
</tr>
</tbody>
</table>
<h4 id="读取边-权值">读取边/权值</h4>
<ul>
<li>读取边（ i ，j） <strong>是否存在</strong>或<strong>权值</strong>（设图G含有n个顶点，e条边）</li>
</ul>
<table>
<thead>
<tr>
<th>存储结构</th>
<th>原理</th>
<th>时间复杂度</th>
<th>对比</th>
</tr>
</thead>
<tbody>
<tr>
<td>邻接矩阵</td>
<td>二维邻接矩阵表[ i ] [ j ]，直接取得结果</td>
<td>O(1)</td>
<td><strong>优</strong></td>
</tr>
<tr>
<td>邻接表</td>
<td>遍历 i 顶点的边表，寻找 j 顶点</td>
<td>O(e/n)</td>
<td>劣</td>
</tr>
</tbody>
</table>
<h4 id="遍历">遍历</h4>
<ul>
<li>含<strong>有向图</strong>深度优先与广度优先遍历</li>
</ul>
<table>
<thead>
<tr>
<th>存储结构</th>
<th>原理</th>
<th>时间复杂度</th>
<th>对比</th>
</tr>
</thead>
<tbody>
<tr>
<td>邻接矩阵</td>
<td>遍历每个未访问结点O(n)，的所有未访问邻接点O(n)</td>
<td>O(n<sup>2</sup>)</td>
<td>劣</td>
</tr>
<tr>
<td>邻接表</td>
<td>遍历每个未访问结点O(n)，的所有未访问的邻接点O(e)</td>
<td>O(n + e)</td>
<td><strong>优</strong></td>
</tr>
</tbody>
</table>
<h3 id="空间复杂度">空间复杂度</h3>
<ul>
<li>设图G含有n个顶点，e条边</li>
</ul>
<table>
<thead>
<tr>
<th>存储结构</th>
<th>原理</th>
<th>理论复杂度</th>
<th>稀疏图</th>
<th>稠密图</th>
</tr>
</thead>
<tbody>
<tr>
<td>邻接矩阵</td>
<td>存储<u>所有可能的边</u>状态</td>
<td>O(n<sup>2</sup>)</td>
<td>劣</td>
<td><strong>优</strong></td>
</tr>
<tr>
<td>邻接表</td>
<td>只存储<u>实际出现,存在的边</u></td>
<td>O(n + e)</td>
<td><strong>优</strong></td>
<td>劣(指针域开销占比逐渐变大)</td>
</tr>
</tbody>
</table>
<h3 id="小结">小结</h3>
<ul>
<li>邻接矩阵优势：适合<strong>稠密图存储</strong>、读取<strong>边的信息</strong>(存在/权值)、<strong>求入度</strong></li>
<li>邻接表优势(边表/出边表)：    适合<strong>稀疏图存储</strong>、读取<strong>邻接点/出度</strong>、</li>
</ul>
<h1 id="最小生成树算法">最小生成树算法</h1>
<h2 id="基础概念">基础概念</h2>
<h3 id="生成树">生成树</h3>
<h4 id="定义-3">定义</h4>
<ul>
<li>连通图的生成树（spanning tree）是包含<u>图中全部顶点</u>的<strong>极小连通子图</strong>（边数最少）</li>
<li>生成树是描述<strong>全部顶点能相通</strong>所需要的最少边数的图结构（类树结构）</li>
</ul>
<blockquote>
<ul>
<li>极小连通子图：一个连通图中连通子图</li>
<li>极大连通子图：一个是非连通图中的连通子图</li>
</ul>
</blockquote>
<h4 id="性质">性质</h4>
<ul>
<li>由于生成树是极小的连通子图，接边数最少的连通（子）图，因此<u>任意两个顶点</u>间<strong>只存在一条路径</strong></li>
<li>即图中任意两个顶点间<strong>不存在回路</strong></li>
<li>在生成树中<strong>添加</strong>任意一条属于原图的<strong>边必定产生回路</strong></li>
<li><strong>减少</strong>任意一条边则<strong>必定成为非连通图</strong></li>
<li>因此具有 <strong>n 个顶点</strong>的<u>生成树</u>有且<strong>仅有 n - 1 条边</strong></li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210711092358.png" alt=""></p>
<h3 id="最小生成树">最小生成树</h3>
<ul>
<li><strong>生成树的代价</strong>：无向连通网<u>生成树上</u><strong>各边权值之和</strong></li>
<li><strong>最小生成树</strong>（minimal spanning tree）：其中<strong>代价最小</strong>的<u>生成树</u>称为最小生成树</li>
</ul>
<h2 id="Prim算法">Prim算法</h2>
<h3 id="理论实现">理论实现</h3>
<h3 id="代码实现-2">代码实现</h3>
<h4 id="数据结构">数据结构</h4>
<h4 id="实现代码">实现代码</h4>
<h2 id="Kruskal算法">Kruskal算法</h2>
<h1 id="最短路径算法">最短路径算法</h1>
<h1 id="有向无环图及其应用">有向无环图及其应用</h1>
<h2 id="AOV网与拓扑排序">AOV网与拓扑排序</h2>
<h2 id="AOE网与关键路径">AOE网与关键路径</h2>
<h1 id="扩展与应用">扩展与应用</h1>
<h2 id="扩展">扩展</h2>
<h3 id="图的其他存储方法">图的其他存储方法</h3>
<h4 id="十字链表">十字链表</h4>
<h4 id="邻接多重表">邻接多重表</h4>
<h3 id="图的连通性">图的连通性</h3>
<h4 id="无向图的连通分量和生成树">无向图的连通分量和生成树</h4>
<h4 id="有向图的强连通分量">有向图的强连通分量</h4>
<h2 id="应用">应用</h2>
<h3 id="七巧板涂色问题">七巧板涂色问题</h3>
<h3 id="医院选址问题">医院选址问题</h3>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：数据结构之图结构(未完成)</li>
        <li>Post author：yhd</li>
        <li>Create time：2021-07-11 11:14:52</li>
        <li>
            Post link：https://keep.xpoet.cn/2021/07/11/数据结构之图结构(未完成)/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/07/18/H5%20video%E6%A0%87%E7%AD%BE%E5%8F%8AJava%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E6%B5%81%E6%92%AD%E6%94%BE/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">H5 video标签及Java实现视频流播放</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/07/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91%E7%BB%93%E6%9E%84/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">数据结构之树结构</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">yhd</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.1</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%9C%AF%E8%AF%AD"><span class="nav-number">1.</span> <span class="nav-text">概念与术语</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">图的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-number">1.2.</span> <span class="nav-text">基本术语</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9"><span class="nav-number">1.2.1.</span> <span class="nav-text">边</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E9%99%84%E4%B8%8E%E9%82%BB%E6%8E%A5"><span class="nav-number">1.2.2.</span> <span class="nav-text">依附与邻接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%A6"><span class="nav-number">1.2.3.</span> <span class="nav-text">度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%A0%E5%AF%86%E4%B8%8E%E7%A8%80%E7%96%8F%E5%9B%BE"><span class="nav-number">1.2.4.</span> <span class="nav-text">稠密与稀疏图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E7%9B%B8%E5%85%B3"><span class="nav-number">1.2.5.</span> <span class="nav-text">路径相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E5%9B%BE"><span class="nav-number">1.2.6.</span> <span class="nav-text">子图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9B%B8%E5%85%B3"><span class="nav-number">1.2.7.</span> <span class="nav-text">连通图相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E9%80%9A%E5%9B%BE"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">连通图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%9B%BE"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">强连通图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ADT%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E"><span class="nav-number">1.3.</span> <span class="nav-text">ADT接口声明</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8"><span class="nav-number">2.</span> <span class="nav-text">图的基本性质</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%B9%E4%B8%8E%E5%BA%A6"><span class="nav-number">2.1.</span> <span class="nav-text">边与度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E5%9B%BE"><span class="nav-number">2.2.</span> <span class="nav-text">完全图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E5%BC%8F"><span class="nav-number">2.2.1.</span> <span class="nav-text">公式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.2.</span> <span class="nav-text">原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">3.</span> <span class="nav-text">图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E6%83%B3%E5%BC%95%E5%AF%BC"><span class="nav-number">3.1.</span> <span class="nav-text">思想引导</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-number">3.2.</span> <span class="nav-text">深度优先遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="nav-number">3.2.1.</span> <span class="nav-text">基本思想</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-number">3.3.</span> <span class="nav-text">广度优先遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-2"><span class="nav-number">3.3.1.</span> <span class="nav-text">基本思想</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">图的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">4.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="nav-number">4.2.</span> <span class="nav-text">邻接矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">4.2.1.</span> <span class="nav-text">定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AE%9A%E4%B9%89"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">邻接矩阵定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E7%BD%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="nav-number">4.2.2.</span> <span class="nav-text">非网图邻接矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="nav-number">4.2.3.</span> <span class="nav-text">网图邻接矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.2.4.</span> <span class="nav-text">邻接矩阵实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%BB%93%E6%9E%84"><span class="nav-number">4.2.4.1.</span> <span class="nav-text">邻接矩阵结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%97%A0%E5%90%91%E5%9B%BE"><span class="nav-number">4.2.4.2.</span> <span class="nav-text">测试无向图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.2.4.3.</span> <span class="nav-text">无向图初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-DFT"><span class="nav-number">4.2.4.4.</span> <span class="nav-text">深度优先遍历(DFT)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-BFT"><span class="nav-number">4.2.4.5.</span> <span class="nav-text">广度优先遍历(BFT)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="nav-number">4.3.</span> <span class="nav-text">邻接表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AE%9A%E4%B9%89"><span class="nav-number">4.3.1.</span> <span class="nav-text">邻接表定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.3.1.2.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E7%BD%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="nav-number">4.3.2.</span> <span class="nav-text">非网图邻接表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="nav-number">4.3.3.</span> <span class="nav-text">网图邻接表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.3.4.</span> <span class="nav-text">邻接表实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="nav-number">4.3.4.1.</span> <span class="nav-text">邻接表结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%9C%89%E5%90%91%E9%9D%9E%E7%BD%91%E5%9B%BE"><span class="nav-number">4.3.4.2.</span> <span class="nav-text">测试有向非网图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E9%9D%9E%E7%BD%91%E5%9B%BE%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.3.4.3.</span> <span class="nav-text">有向非网图初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-DFT-2"><span class="nav-number">4.3.4.4.</span> <span class="nav-text">深度优先遍历(DFT)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-BFT-2"><span class="nav-number">4.3.4.5.</span> <span class="nav-text">广度优先遍历(BFT)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="nav-number">4.4.</span> <span class="nav-text">性能比较</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">4.4.1.</span> <span class="nav-text">时间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BA%E5%BA%A6-%E9%82%BB%E6%8E%A5%E7%82%B9"><span class="nav-number">4.4.1.1.</span> <span class="nav-text">出度&#x2F;邻接点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A5%E5%BA%A6"><span class="nav-number">4.4.1.2.</span> <span class="nav-text">入度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E8%BE%B9-%E6%9D%83%E5%80%BC"><span class="nav-number">4.4.1.3.</span> <span class="nav-text">读取边&#x2F;权值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86"><span class="nav-number">4.4.1.4.</span> <span class="nav-text">遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">4.4.2.</span> <span class="nav-text">空间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">4.4.3.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">最小生成树算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">5.1.</span> <span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">5.1.1.</span> <span class="nav-text">生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%B4%A8"><span class="nav-number">5.1.1.2.</span> <span class="nav-text">性质</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">5.1.2.</span> <span class="nav-text">最小生成树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">Prim算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.2.1.</span> <span class="nav-text">理论实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">5.2.2.</span> <span class="nav-text">代码实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">实现代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kruskal%E7%AE%97%E6%B3%95"><span class="nav-number">5.3.</span> <span class="nav-text">Kruskal算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">最短路径算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8"><span class="nav-number">7.</span> <span class="nav-text">有向无环图及其应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AOV%E7%BD%91%E4%B8%8E%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">7.1.</span> <span class="nav-text">AOV网与拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOE%E7%BD%91%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-number">7.2.</span> <span class="nav-text">AOE网与关键路径</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="nav-number">8.</span> <span class="nav-text">扩展与应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95"><span class="nav-number">8.1.</span> <span class="nav-text">扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%85%B6%E4%BB%96%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95"><span class="nav-number">8.1.1.</span> <span class="nav-text">图的其他存储方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="nav-number">8.1.1.1.</span> <span class="nav-text">十字链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="nav-number">8.1.1.2.</span> <span class="nav-text">邻接多重表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="nav-number">8.1.2.</span> <span class="nav-text">图的连通性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E5%92%8C%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">8.1.2.1.</span> <span class="nav-text">无向图的连通分量和生成树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="nav-number">8.1.2.2.</span> <span class="nav-text">有向图的强连通分量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-number">8.2.</span> <span class="nav-text">应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83%E5%B7%A7%E6%9D%BF%E6%B6%82%E8%89%B2%E9%97%AE%E9%A2%98"><span class="nav-number">8.2.1.</span> <span class="nav-text">七巧板涂色问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BB%E9%99%A2%E9%80%89%E5%9D%80%E9%97%AE%E9%A2%98"><span class="nav-number">8.2.2.</span> <span class="nav-text">医院选址问题</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>



<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
