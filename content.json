{"meta":{"title":"yhdblog","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"Repositories","date":"2020-08-25T13:03:56.000Z","updated":"2020-08-25T13:08:55.059Z","comments":true,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-08-25T12:50:00.000Z","updated":"2020-08-25T13:04:12.688Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构 第三章 单链表","slug":"数据结构 第三章 单链表","date":"2020-09-05T14:38:32.000Z","updated":"2020-09-06T13:24:17.023Z","comments":true,"path":"2020/09/05/数据结构 第三章 单链表/","link":"","permalink":"http://yoursite.com/2020/09/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%8D%95%E9%93%BE%E8%A1%A8/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲 线性表链式存储结构定义 单链表的创建 线性表链式存储结构定义基本概念为保持线性结构“前驱后继，一对一”逻辑结构前提下，同时避免顺序存储结构中对相邻关系的依赖性。链式结构，除了要存数据元素信息外，还要存储它的后继元素的存储地址。 数据域：存储数据元素信息的域 指针域：存储直接后继位置的域，其中存储的信息称做指针或链 结点(Node)：数据域和指针域组成数据元素ai的存储映像 链表：由n个结点链成的一个链表 单链表：链表中的每个结点只包含一个指针域 单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起，如图所示： 线性表链式存储结构代码描述 相关规定，线性链表的最后一个结点为“空”(用NULL或“^”符号表示) 头结点：在单链表的第一个结点前附设的一个结点，指针域指向第一个结点，若指针域为“空”，表示线性表为空 头结点主要作用是为便于对链表进行统一操作，头结点的数据域可不存储信息，或者存储线性表长度等附加信息。 单链表的定义123456//线性表的单链表存储结构typedef struct Node &#123; ElemType data; struct Node *next;&#125;Node;typedef struct Node *LinkList;//定义LinkList，指针变量的typedef typedef struct Node &#123;...&#125;Node;中的Node同名对象(实例)Node的作用：常用于为sizeof()函数传参。 typedef struct Node *LinkList; 语法理解：如typedef int Status; ‘Status‘等价于int，在这里可以看作类似变量的声明，即 声明一个int类型变量Status int Status，而int *Status表示定义一个int型的指针变量。同样类比在typedef中，“*”表示typedef的对象是Node 结构体的指针变量，即LinkList 等价于 struct Node *linkList; (不过写法上确实有点新颖，有点融合着写) 单链表的创建单链表的初始化(空表的建立)InitList123456789/* 初始化顺序线性表 */Status InitList(LinkList *L) &#123; *L=(LinkList)malloc(sizeof(Node)); /* 产生头结点(向内存申请一个结点的空间),并使L指向此头结点 */ if(!(*L)) /* 存储分配失败 */ return ERROR; (*L)-&gt;next=NULL; /* 指针域为空 */ return OK;&#125; malloc函数：void *malloc(long NumBytes)向内存申请NumBytes个字节的空间，并返回了指向这块内存的指针。若分配失败，则返回一个空指针(NULL）,如系统空间不足等失败情况。使用malloc函数需注意如下几点： 申请了内存空间后，必须检查是否分配成功。 当不需要再使用申请的内存时，记得释放；并把这块内存的指针指向NULL，防止程序后面不小心使用了它。 malloc与free这两个函数应该是配对使用。如果申请后不释放就是内存泄露；如果无故释放那就是什么也没有做。释放只能一次，如果释放两次及两次以上会出现错误（释放空指针例外，释放空指针其实也等于啥也没做，所以释放空指针释放多少次都没有问题）。 虽然malloc()函数的类型是(void *)，任何类型的指针都可以转换成(void *),但是最好还是在前面进行强制类型转换，因为这样可以躲过一些编译器的检查。 参考链接：malloc()和free()的基本概念以及基本用法 LinkList *L形参的理解： Status InitList(LinkList *L)注意，此时传入形参L已是二级指针(指针的指针)。 一级指针与二级指针的区别与使用： 形参传递永远是值传递(临时变量)，想要通过调用函数去改变传入实参的内容，则需要至少传入欲修改参数类型基础上的一级指针，并且通过“*” 调用实体内容进行修改。而并不能仅修改传入新参的内容，因为新参内容本身怎么修改都不会影响传入的实参。(值传递原则) 当传值时，只可以引用值而不可以改变值， 当你传指针时，只可以改变指针所指的内容，不可以改变指针本身 但传指针的指针时，即可以改变指针所指的内容，又可以改变指针本身 LinkList *L二级指针的用处：回归目的本身，很明确。即想要LinkList L;这个指针变量L最终指向通过malloc函数申请空间后返回的地址值(即地址的赋值)。理应L=malloc(sizeof(Node));即可，从一条语句操作上是完全正确的，类型也是一致的。但问题在于如今想要通过调用函数且把L作为实参传入修改其地址值。这样的前提下，若只传入想要修改内容类型的本身(这里就是指针变量/一级指针)，安装值传递原则是达不到效果的，代码如下所示： 12345678910111213Status InitList(LinkList L) &#123; //形参修改成一级指针 L = (LinkList)malloc(sizeof(Node)); if (!(L)) return ERROR; L-&gt;next = NULL; &#125;void main() &#123; LinkList L = NULL; InitList(L); if (L == NULL) printf(&quot;L=NULL&quot;);//最终L还是NULL被打印出来，没有被改变 getchar();&#125; “想要通过调用函数去改变传入实参的内容，则需要至少传入欲修改参数类型基础上的一级指针”，即先要修改指针值本身，则至少需要传入该参数类型上的一级指针，即指针的指针，这就是Status InitList(LinkList L) &#123;...&#125; 二级指针形参的意义。 参考链接： (C++)函数参数传递中的一级指针和二级指针 引用传递和值传递以及链表中的LinkList L、LinkList *L、LinkList &amp;L 单链表的整表创建单链表的整表创建又分为“头插法”，“尾插法”两种。 CreateListHead“头插法”即生成新结点永远只和头结点“交易”，“后来却先到”，把NULL不断后移 123456789101112131415/* 随机产生n个元素的值，建立带表头结点的单链线性表L（头插法） */void CreateListHead(LinkList *L, int n) &#123; LinkList p; int i; srand(time(0)); /* 初始化(修改)随机数种子 */ *L = (LinkList)malloc(sizeof(Node)); (*L)-&gt;next = NULL; /* 先建立一个带头结点的单链表 */ for (i=0; i&lt;n; i++) &#123; p = (LinkList)malloc(sizeof(Node)); /* 生成新结点 */ p-&gt;data = rand()%100+1; /* 随机生成100以内的数字填充数据域 */ p-&gt;next = (*L)-&gt;next; (*L)-&gt;next = p; /* 插入到表头 */ &#125;&#125; srand函数与rand函数使用(stdio.h) void srand(unsigned int seed)：设置随机数种子 srand函数用来设置rand函数产生随机数时的随机数种子，参数seed必须是整数，通常可以用time(0)的返回值作为seed。如果每次seed都设置相同的值，rand()产生 一系列 随机数值每次都一样。当计算机正常开机后，随机种子的值是定了的，除非你破坏了系统，或者通过srand函数修改。 int rand(void)：生成随机数 在0到RAND_MAX之间的整数值生成一个随机数，rand的内部是用线性同余法做的，不是真的随机数，只不过因为其周期特别长，所以在一定范围内可以看成是随机的。(RAND_MAX的范围最少在32767之间（int），即双字节（16位）。若unsigned int双字节是65535) 参考链接：C语言的srand与rand函数浅谈 time函数的使用 函数原型：time_t time(time_t *seconds) time函数用于返回格林尼治时间(1970年1月1日00:00:00到当前时刻的时长)，单位是秒。存在与&lt;time.h&gt;库，一般使用方式t1=time(NULL) 或 t1=time(0)来获取当前格林尼治时间。 CreateListTail“尾插法”，符合日常排队思维，后到的排在后。即新结点放在头结点的指针域，接下来所有新结点都在当前的尾结点后插入。 123456789101112131415/* 随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */void CreateListTail(LinkList *L, int n) &#123; LinkList p,r; int i; srand(time(0)); /* 初始化随机数种子 */ *L = (LinkList)malloc(sizeof(Node)); /* L为整个线性表 */ r=*L; /* r为指向尾部的结点 */ for (i=0; i&lt;n; i++) &#123; p = (Node *)malloc(sizeof(Node)); /* 生成新结点 */ p-&gt;data = rand()%100+1; /* 随机生成100以内的数字 */ r-&gt;next=p; /* 将表尾终端结点的指针指向新结点 */ r = p; /* 将当前的新结点定义为表尾终端结点 */ &#125; r-&gt;next = NULL; /* 表示当前链表结束 */&#125; 除了首次循环r是头结点，其余r成为了永远的尾结点。 r = p;功能是，注意这里没有真正修改了地址值，而是局部变量顺应循环设计的循环变换，变换内容是将最新插入的结点成为下次循环的尾结点。 单链表的整表删除单链表的读取思路： 单链表的插入和删除","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 第三章 线性表及其顺序存储结构","slug":"数据结构 第三章 线性表及其顺序存储结构","date":"2020-09-03T04:40:32.000Z","updated":"2020-09-06T09:49:13.837Z","comments":true,"path":"2020/09/03/数据结构 第三章 线性表及其顺序存储结构/","link":"","permalink":"http://yoursite.com/2020/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%8F%8A%E5%85%B6%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲 线性表的定义 线性表的抽象数据类型 线性表的顺序存储结构 地址计算方法 顺序存储结构的存入与取出 顺序存储结构的插入与删除 线性表顺序存储结构的优缺点 线性表的定义线性表（List）：零个(空表)或多个数据元素的有限序列。即线性表的长度n≧0。关键点如下： 序列：表示元素之间是有严格的顺序。元素之间的关系是一对一的关系。 若线性表记为(a1，…ai-1，ai，ai+1，…，an)，称ai-1是ai的直接前驱元素，ai+1则是ai的直接后继元素 第一个元素无前驱，最后一个元素无后继，其他元素有且只有一个前驱和后继 有限 元素类型相同 线性表的抽象数据类型线性表的抽象数据类型定义如下： 1234567891011121314ADT 线性表（List）Data &#123;a1,a2,…,an&#125;Operation InitList(*L): 初始化操作，建立一个空的线性表L。 ListEmpty(L): 判断线性表是否为空表，若线性表为空，返回true，否则返回false。 ClearList(*L): 将线性表清空。 GetElem(L,i,*e): 将线性表L中的第i个位置元素值返回给e。 LocateElem(L,e): 在线性表L中查找与给定值e相等的元素，如果查找成功， 返回该元素在表中序号表示成功；否则，返回0表示失败。 ListInsert(*L,i,e): 在线性表L中第i个位置插入新元素e。 ListDelete(*L,i,*e): 删除线性表L中第i个位置元素，并用e返回其值。 ListLength(L): 返回线性表L的元素个数。endADT ps：上述为最基本操作，其他更复杂的操作完全可以通过这些基本操作组合实现。 线性表的顺序存储结构线性表的顺序存储定义线性表的顺序存储结构：指的是用一段地址连续的存储单元依次存储线性表的数据元素。 最常见的就是用一维数组来实现顺序存储结构 线性表的顺序存储结构代码如下： 123456#define MAXSIZE 20 //存储空间处时分配量typedef int ElemType //数据类型根据实际情况而定，这里假设为inttypedef strcuct&#123; ElemType data [MAXSIZE]; int length; //线性表当前长度&#125;SqList; 据上述可知，描述顺序存储结构需要三个属性： 存储空间的起始位置：其实就是数组data(首地址) 线性表的最大存储容量：数组长度MaxSize 线性表的当前长度：length 顺序线性表的初始化12345/* 初始化顺序线性表 */Status InitList(SqList *L) &#123; L-&gt;length=0; return OK;&#125; 地址计算方法数组长度与线性表长度的区别 数组长度：是指存放线性表存储空间的长度，一般是固定值。int data[3]={1,2,3}长度为3。 线性表长度：线性表中存在数据元素个数，是经常变化的。 数组下标从“0”开始，线性表是从“1”数起的。 地址计算方法数据元素的序号和存放它的数组下标之间对应关系如下图所示： 对于第i个数据元素ai的存储位置可由a1推算出： LOC(ai) = LOC(a1)+(i-1)*c LOC表示获得存储位置的函数，c表示数据元素的类型的存储单元 顺序存储结构的存入与取出GetElem思路： 线性表必须存在数据; i 的数值在数组下标范围内; 返回数组的第 i-1 下标的值即可; 123456789101112131415#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;//基本说明：Status是函数的类型，其值是函数结果状态代码，如OK等//初始条件(输入条件)：线性表L已存在，位置参数i范围应处于： 1 ≤ i ≤ ListLength(L)//操作结果：用e返回L中的第i个元素Status GetElem(SqList L,int i,ElemType *e) &#123; if (L.length == 0 || i &lt; 1 || i &gt; L.length) return ERROR; *e = L.data[i - 1]; return OK;&#125; 任意位置的存取时间复杂度都为O(1)**，即存取性能为O(1)，称为“随机存取结构**”。 “存取”，不等于“插删” 顺序线性表的存取仅需要知道存入的位置逻辑即可，因此查询位置的复杂度决定了存取的复杂度 顺序存储结构的插入与删除存在线性表定义如下： 1234567#define MAXSIZE 20typedef int ElemType;typedef struct &#123; ElemType data[MAXSIZE]; int length;&#125;SqList; ListInsert思路： 如果线性表的长度等于数组长度，则抛出异常或者动态增加容量; 如果插入位置不合理，抛出异常; 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置; 将要插入元素填入位置 i 中; 1234567891011121314151617181920212223/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， *//* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */Status ListInsert(SqList *L,int i,ElemType e)&#123; int k; if (L-&gt;length==MAXSIZE) /* 顺序线性表已经满 */ return ERROR; if (i&lt;1 || i&gt;L-&gt;length+1)/* 当i比第一位置小或者比最后一位置后一位置还要大时 */ return ERROR; if (i&lt;=L-&gt;length)&#123; /* 若插入数据位置不在表尾 */ for(k=L-&gt;length-1;k&gt;=i-1;k--) /* 将要插入位置之后的数据元素向后移动一位 */ L-&gt;data[k+1]=L-&gt;data[k]; &#125; /*索引改良 for (k = L-&gt;length; k &gt;= i; k--) &#123; L-&gt;data[k] = L-&gt;data[k - 1]; &#125; */ L-&gt;data[i-1]=e; /* 将新元素插入 */ L-&gt;length++; return OK;&#125; ListDelete思路： 线性表必须存在数据; 如果删除位置不合理，抛出异常; 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置; 表的长度减少1; 12345678910111213141516171819/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) *//* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */Status ListDelete(SqList *L,int i,ElemType *e) &#123; if (L-&gt;length==0) /* 线性表为空 */ return ERROR; if (i&lt;1 || i&gt;L-&gt;length) /* 删除位置不正确 */ return ERROR; *e=L-&gt;data[i-1]; int k; if (i&lt;L-&gt;length)&#123; /* 如果删除不是最后位置 */ for(k=i;k&lt;L-&gt;length;k++)/* 将删除位置后继元素前移 */ L-&gt;data[k-1]=L-&gt;data[k]; &#125; L-&gt;length--; return OK;&#125; 线性表顺序存储结构的优缺点时间复杂度分析存入与取出查询任意位置可由公式直接查出，从而决定存取的时间复杂度**均为O(1)**。 插入与删除 最优情况复杂度：插入与删除位置为最后一个元素，复杂度为O(1) 最坏情况复杂度：插入与删除位置为第一个位置，复杂度为O(n) 平均情况复杂度：位置靠前，移动元素多。位置靠后，移动元素少。平均为(n-1)/2，复杂度即为O(n) 优缺点总结优点： 无须为表示表中元素之间的逻辑关系而增加额外的存储空间(即可由公式直接关联) 可以快速地存取表中任意位置的元素 缺点： 插入和删除操作需要移动大量的元素 当线性表长度变化较大时，难以确定存储空间的容量。即难以确定MAXSIZE属性的大小 造成存储空间的“碎片” 小结 顺序存储结构的线性表，适合于元素个数不太需要变化，更多用于存取数据的应用。 插入和删除效率低的原因在于，相邻两元素之间的存储位置也依赖于邻居关系本身。","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 第二章 算法基础","slug":"数据结构 第二章 算法基础","date":"2020-09-01T03:40:32.000Z","updated":"2020-09-05T04:00:31.834Z","comments":true,"path":"2020/09/01/数据结构 第二章 算法基础/","link":"","permalink":"http://yoursite.com/2020/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲 算法的定义 算法的特性 算法设计的要求 算法效率的度量方法 函数的渐进增长 算法时间复杂度 算法空间复杂度 最坏情况与平均情况 算法的定义算法：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 算法的特性算法具有的五个基本特性：输入、输出、有穷性、确定性、可行性。 输入与输出 算法具有零个或多个输入。 算法至少有一个或多个输出。 有穷性 算法在执行有限步骤之后，自动结束而不会出现无限循环。 每一个步骤在可接受的时间内完成。即实际意义。 确定性确定性：算法的每一步骤都具有确定的含义，不会出现二义性，类似函数。 可行性 算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。 可行性意味着算法可转换为程序上机运行。 算法设计的要求算法设计的要求包含：正确性、可读性、健壮性、时间效率高和存储量低。 正确性正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。大体分为以下四个层次： 没有语法错误 对于合法的输入数据能够产生满足要求的输出结果 对于非法的输入数据能够得出满足规格说明的结果 对于精心选择的，甚至刁难的测试数据都有满足要求的输出结构。 一般情况下，我们把层次3作为一个算法是否正确的标准 可读性可读性：算法设计的另一个目的是为了便于阅读、理解和交流。 健壮性健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名奇妙的结果。 时间效率高和存储量低设计算法应该尽量满足时间效率高和存储量(占用内存与外部硬盘存储空间)低的需求。 算法效率的度量方法ps：这里指的效率大都是指算法的执行时间。 事后统计方法事后统计方法：这种方法主要是通过事先设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。 但这种方法显然存在很大的缺陷： 必须依据算法事先编制对应的测试程序，费时费力，工作量可能翻倍。 计时器的计时效果比较依赖计算机硬件和软件等环境因素。 算法的测试数据设计困难。 事前分析估算方法事前分析估算方法：在计算机程序编程前，依据统计方法对算法提前进行估算。 事前分析一个程序在计算机运行所消耗的时间取决于下列因素： 算法采用的策略、方法。 编译产生的代码质量。 问题的输入规模。 机器执行指令的速度。 结论： 一个程序的运行时间，依赖于算法的好坏和问题的**输入规模(输入变量的值)**。 测定运行时间最可靠的方法就是依据输入规模计算语句的执行次数。 执行次数，也成为基本操作数量，记作 f(n)，n表示输入规模。 函数的渐进增长ps：判断两个算法效率的高低，会存在因不同量级的输入规模而得出相反的结果。 因此给出定义，输入规模n在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，我们称函数是渐进增长快的。 函数渐进增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐进快于g(n)。 结论：判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而**更应该关注主项(最高阶项)**的阶数。 算法时间复杂度时间复杂度的定义算法时间复杂度，记作T(n)=O(f(n))，通过大写O( )**来体现时间复杂度的记法，也称之为大O记法**。 在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)= O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。 推导大O阶方法 写出每一条语句的执行次数。 把所有语句的执行次数相加并且进行基本的数学化简。 用常数1取代运行时间中的所有加法常数。 只保留最高阶项。 若最高阶项存在且不是1，则去除与这个项相乘的常数。 123456789int i,j; //执行1次for(i = 0; i &lt; n; i++)&#123; //执行n次 for(j = i; j &lt; n; j++)&#123; /*时间复杂度O(1)的程序步骤序列*/ //执行n-2次...n-1,n,执行1次 //执行n-2次...n-1,n,执行1次 &#125; &#125;printf(&quot;end&quot;); //执行1次 总执行次数为：1+n+(n-1)+(n-2)+…+1 + 1= n(n+1)/2 +2 = n2/2+n/2 + 2 去除常数： n2/2+n/2 保留最高阶项： n2/2 最高阶项存在且不等于1，去除相乘常数：n2，即最终时间复杂度为 O(n2) 可看作等差数列求和：na1 + n(n-1)/2 * d 首项a1=1，公差d=1，项数n=n 常见时间复杂度 阶 非正式术语 常见结构 例 O(1) 常数阶 顺序结构、无循环分支结构 12 O(n) 线性阶 无内嵌循环结构 2n+3 O(n2) 平方阶 二层内嵌循环结构 3n2+2n+1 O(log n) 对数阶 非1线性增长的循环索引 log2n+20 O(n log n) nlog n阶 2n+3nlog2n O(n3) 立方阶 三层内嵌循环 n3+2 2n 指数阶 2n 常用时间复杂度所耗费得时间从小到大依次是： O(1) &lt; O(log⁡n) &lt; O(n) &lt; O(nlog⁡n) &lt; O(n2) &lt; O(n3) &lt; O(an) &lt; O(n!) &lt; O(nn) 对数阶补充说明 123456int count =1;while(count &lt; n)&#123; count = count * 2; /*时间复杂度O(1)的程序步骤序列*/&#125; 每次count乘2之后，就距离n更接近一分，而需要乘多少次？接需要执行多少次，才能跳出循环？ 把需要乘的次数设为x，则2x=n，得到执行次数x=log2n 算法的空间复杂度空间复杂度：算法的空间复杂度即算法所需的存储空间，记作：S(n)=O(f(n)，此时n为问题的规模，f(n)为语句关于n所占存储空间函数。 当不用限定词地使用“复杂度”，则通常指时间复杂度。 时间复杂度和空间复杂度一般情况下可以相互转换。 最坏情况与平均情况最坏情况：即一个算法存在的最低执行效率情况。 在应用中，最坏情况是一种重要的需求，通常，除非特别指定，提及的运行时间都是指最坏情况的运行时间 平均运行时间是所有情况中最有意义的，它属于期望的运行时间。","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 第一章 绪论","slug":"数据结构 第一章 绪论","date":"2020-08-29T14:03:32.000Z","updated":"2020-09-01T09:33:31.519Z","comments":true,"path":"2020/08/29/数据结构 第一章 绪论/","link":"","permalink":"http://yoursite.com/2020/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 知识大纲 数据结构的起源 基本概念和术语 逻辑结构与物理结构 抽象数据类型 数据结构的起源早期认知人们都把计算机理解为数值计算工具。解决问题方式如下： 分析问题 抽像其数据模型 设计数据模型对应算法 编写程序 实际环境现实中，更多是解决非数值型问题，因此需要更加有效的科学手段。**(比如表、树图等数据结构)。 基本概念和术语数据数据的基本概念数据：是描述客观事物的符号，是计算机中可操作的对象，是能被计算机识别，并能够输入给计算机处理的符号集合。 比如编程所用到的数据类型，还包括字符、声音、图像、视频等这里所描述的数据，其实就是符号 数据的基本特性 可输入到计算机中 能被计算机程序处理 数据元素数据元素：组成数据的，有一定意义的基本单位，在及算你中通常作为整体处理。也被称为记录。 数据项数据项：一个数据元素可以由若干个数据项组成。 比如人这样的数据元素，可以有眼、耳、口、鼻，姓名、年龄、性别这些数据项 数据项是数据的最小单位 在研究数据结构问题时，数据元素才是建立数据模型的着眼点 数据对象数据对象：是性质相同的数据元素的集合，是数据的子集。 小结 数据：就是符号，数值型和非数值型集合 数据元素：组成数据有意义的基本单位，即java中的“类” 数据项：组成数据元素的基本单位，即类里面的“属性” 数据对象：是数据的子集。即类里面的“对象/实例” 数据结构数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。结构即关系！ 一个“好”的程序，必须分析待处理对象的特性及其**各处理对象之间存在的关系**这就是研究数据结构的意义所在。 “分析待处理对象的特性”，即以前接触高级语言的“面向对象编程” 博主如今缺乏的，即是学习“各处理对象之间存在的关系” 逻辑结构与物理结构逻辑结构逻辑结构：是指数据对象中数据元素之间的相互关系，也是今后讨论的重点。主要类型包含如下 集合结果 线性结构 树形结构 图像结构 集合结构集合结构：集合结构中的数据元素除了同一个集合外，它们之间没有其他关系。 它们相互平等，唯一且共同的属性就是“同属一个集合”，类似数学的集合，形如“鱼塘” 线性结构线性结构：线性结构中的数据元素之间是一对一的关系，类似“火车，项链”。 树形结构树形结构：树形结构中的数据元素之间存在一种一对多的的层次关系。形如“大树”分支。 图形结构图像结构：图形结构的数据元素是多对多的关系，类似“人际关系”，交错复杂。 小结用示意图表示数据的逻辑结构时，要注意两点 将每一个数据元素看做一个结点，用圆圈表示 元素之间的逻辑关系用结点之间的连线表示，如果这个关系是有方向的，必须标明箭头 物理结构/存储结构物理结构：是指数据的逻辑结构在计算机中的存储形式。 即数据元素如何存储到计算机的存储器中，这里的存储器主要针对内存而言 数据的存储结构应正确反映数据元素之间的逻辑关系，这才是重点 存储结构形式有两种：顺序存储和链式存储 顺序存储结构顺序存储结构：是把数据元素存放在地址连续的存储单元里。此时，其数据间的逻辑关系和物理关系是一致的。 形如理想状态下的排队，又如编程中的数组存储/开辟空间机制 链式存储结构链式存储结构：是把数据元素存放在任意的存储单元里，而这组存储单元可以是连续的，也可以是不连续的。 形如去银行、医院等地方，设置了“叫号排序”的机制。实际，把变量的地址存储在一个指针变量中，通过指针变量找到对应的数据 小结 逻辑结构是面向问题的，而物理结构就是面向计算机的 顺序存储：连续开辟-按序对应 链式存储：任意开辟-叫号对应 抽象数据类型数据类型数据类型：是指一组性质相同的值的集合,及定义在此集合上的一些操作的总称。 在计算机中，内存也不是无限大的，计算机的研究者们就考虑，要对数据类型进行分类，分出多种数据类型来适合各种不同的计算条件差异，同时节省内存 C语言中数据类型可以分为两类 原子类型：不可以再分解的基本类型，例如整型、浮点型、字符型等。 结构类型：由若干种数据类型组合而成，是可再分解。如整型数组由若干整型数据组成的 抽象数据类型抽象抽象：抽象是指抽取出事物具有的普遍性的本质。即抽出问题的特征而忽略非本质的细节。 抽象数据类型抽象数据类型(Abstract Data Type，ADT)：是指一个数学模型及定义在该模型上的一组操作。 抽象数据类型不仅仅指那些已经定义并实现的数据类型(int、char等)，还可以是计算机编程者在设计软件程序时自己定义的数据类型，即如同高级语言的即“类”一样。而“及定义在该模型上的一组操作”即如同定义类，及其基本“方法” 比如，无论在PC、平版电脑、只能手机上都拥有“整数”这个类型，那么可以说“整型”其实就是一个抽象的数据类型，而且“抽象”的意义在于数据类型的数学抽象特征。 抽象数据类型体现了程序设计中，问题分解、抽线、信息隐藏的特性。 抽象数据类型的标准格式ADT 抽象数据类型名 Data 数据元素之间逻辑关系的定义 Operation 操作1 初始条件 操作结构描述 操作2 ... endADT 总结 现实问题中更需要解决的是非数值运算问题。 数据 数据即符号 数据元素即“类” 数据对象即可“实例” 数据项即“属性” 结构即关系 数据结构定义：是相互之间存在一种或多种特定关系的数据元素的集合 逻辑结构与物理结构，即面向问题，与面向存储。 四大逻辑结构(“四形”) 集合结构 线性结构 树形结构 图形结构 两大物理结构 顺序存储(数组) 链式存储(指针) 抽象数据类型 数据类型 原子类型(不可分割/int，char) 结构类型(组合而成) 抽象数据类型 已定义数据类型抽象，即int，char 自定义数据类型抽象，即struct，类 抽象数据类型规范:ADT、Data、Operation、endADT 作者建议研读方法 复习c语言的基础知识。 第一遍阅读，建议从头至尾进行通读。 阅读时，摘抄/笔记是非常好的习惯。“最淡的墨水也胜于最强的记忆” 阅读每一章时，特别是阅读****算法的推导过程，一定要在电脑中运行代码和进行调试，设置断点和逐行执行，参照书的讲解，观察变量的变化情况来理解算法的编写原理。 阅读完每一章时，一定要在理解基础上记忆一些关键东西，最佳效果就是不看书也可以一点不错的默写相关的算法。 阅读完每一章时，一定要适当练习。 在之后的学习或工作中，尽量把学到的数据结构和算法运用到现实开发中。 《大话数据树结构》初读后有感教材和自学读物，所面向的读者是完全不同的教材特性 好的教材应试是提纲挈领、重点突出。 一定要留出思考空间，否则就没必要再听老师上课了。教材很多内容的讲解都是由老师在课堂上完成的。 教材中必定有练习、课后习题、思考题等，而这些大多可以通过老师来解答。 比如我们中学时的语文、数学课本，很薄的一本书通常要用一个学期、甚至一年的时间来学，这就是因为它们是教材而不是自学读物。如果小说,可能一两天就读完了。 读物——隔空交流的介质作者角度 作者认为，读者拿到的虽然只是一本没有表情、不会说话的书，但其实也是在隔空与另一个朋友交流。 人与人的交流不可能只是就事论事，一定会有情感的沟通，这种情感如果能产生共鸣、达成互信，就会让沟通的事情本身更容易理解和接受。 博主理解 读物本是以内容第一为原则。但其作者的表诉方式，引用，感受等情感会附带许多作者本人的价值观。即情感交流，也是阅读的影响之一。 对于技术类读物，除技术内外，最明显的就是学习读者的编书方式，从编书结构从而建立更全面，深刻，有效的知识的架构。 如本书最明显的其中一个特征就是会对每一个小知识群进行小结提炼。这也会影响到我摘抄笔记的录入结构。","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"基于Hexo框架的博客搭建及其GitHub部署","slug":"基于Hexo框架的博客搭建及其GitHub部署","date":"2020-08-28T01:09:02.000Z","updated":"2020-09-02T09:50:08.071Z","comments":true,"path":"2020/08/28/基于Hexo框架的博客搭建及其GitHub部署/","link":"","permalink":"http://yoursite.com/2020/08/28/%E5%9F%BA%E4%BA%8EHexo%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%85%B6GitHub%E9%83%A8%E7%BD%B2/","excerpt":"","text":"Hexo简介 Hexo 是一个快速、简洁且高效的静态博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo受众面较广，对应的问题、扩展等内容在网上均有成熟解决方案，推荐安装使用。 安装安装前提安装Hexo之前需要先安装Node.js与Git。 ps：本文所有安装过程基于Windows环境下操作 Git安装 官网下载地址：https://git-scm.com/downloads 默认自动弹出适配版本，若没有则在“Git for Windows Setup”选择对应电脑位数下载 安装过程一直next直到完成即刻。 设置Git用户名 ps:Windows终端(cmd)内操作,不设置用户名和密码在安装hexo的过程中会报错 设置用户名git config --global user.name &quot;username&quot; 设置邮箱git config --global user.email useremail@qq.com 修改后可以检查一下，查看用户名和密码 git config user.name git config user.email 查看其他配置信息 git config --list Node.js安装 官方下载地址：https://nodejs.org/en/ 一般选择左边的 XX.XX.X LTS (长期支持版) 安装过程简单，直接操作即可。 安装完成后存在两个组件，一个是Node.js本身，另一个是npm(包管理器) hexo下载与安装 以管理员身份进入Windows终端。 检查node.js的安装结果node –vnpm –v 通过npm或cnpm安装hexo npm是外国的镜像源速度很慢，用淘宝的cnpm比较快 npm install -g cnpm --registry=http://registry.npm.taobao.org 通过cnpm下载安装hexocnmp install -g hexo cli 安装完成后通过命令可查看版本表示安装成功hexo –v hexo博客初始化 以下操作均在”总文件”路径下完成，且实例说明以名为”myblog”的文件夹表示hexo总文件夹。 若接下来的操作出现什么错误，直接把这个总文件夹删除重新来过即可 在想要安装博客的路径下创建一个总文件夹，如“myblog” 通过终端进入到这个总文件夹路径下 初始化博客 hexo init 常用组成文件功能介绍 ├_config.yml├&lt;source&gt;&emsp;&emsp;├&lt;_posts&gt;├&lt;themes&gt; _config.yml：配置文件，用于配置博客的重要属性 &lt;source&gt;：用于存放各种类型的md文件 &lt;_posts&gt; ：hexo new命令生成的md文件存位置 &lt;themes&gt;：存放不同的主题 启动博客，通过浏览器尝试访问 hexo s 终端会提示本地端口访问，一般为：localhost:4000 基本操作 ps：所有hexo命令操作都需要在安装hexo的总文件夹路径下操作 创建一篇文章， 新建的文章即md文件存放在/source/_posts hexo new &quot;My New Post&quot; 停止运行hexoctrl + c 清理之前生成的内容 hexo clean 校验并生成新的内容 hexo g GitHub部署仓库设置 登录github，创建仓库：repository name设置为：username.github.io 您github账号中的username,如博主账号username为yihangdeng则repository name 设置为：yihangdeng.github.io 其他保持默认即可，点击“Create repository”完成仓库创建 生成的链接结构为： https://github.com/username/username.github.io.git如：https://github.com/yihangdeng/yihangdeng.github.io.git Git远程部署插件安装cnpm install --save hexo-deployer-git 配置_config.yml设置总文件夹下的配置文件_config.yml，在配置信息的最底部修改并添加内容如下 123456# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deploymentdeploy: type: ‘git’ repo: (仓库创建后生成的链接) branch: master 123456# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deploymentdeploy: type: git repo: https:&#x2F;&#x2F;github.com&#x2F;yihangdeng&#x2F;yihangdeng.github.io.git branch: master 内容推送 通过命令远程部署到GitHub仓库hexo d 在远程部署的过程中有时要求输入GitHub的用户名和密码，如：Username for &quot;https://github.com\\&quot; 输入用户名Password for &quot;https://username@github.com\\&quot; 输入密码(密码默认不显示，直接输入后回车即可)若出错请检查是否有配置git的用户名和邮箱 刷新GitHub仓库可查看生成内容已部署到GitHub中 通过浏览器访问你的博客 url：username.github.io 如：yiahngdeng.github.io 若访问不了，请先尝试访问博主的博客(yiahngdeng.github.io)进而确认是部署出错还是访问GitHub的网络出现问题，具体参加博文《GitHub访问及其下载问题解决方案》。 常见错误 建议每次修改内容后都执行“hexo g”命令校验生成一下，报错的内容会显示在终端上。 标明错误行数：一般是配置文件中的“键值对”敲错，记住是英文冒号加空格，“: ” Git错误提示之：fatal: Not a git repository (or any of the parent directories): .git 提示说没有.git这样一个目录，在命令行 输入 git init 然后回车就好了 参考链接 codesheep：https://www.bilibili.com/video/BV1Yb411a7ty","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-08-25T09:05:12.504Z","updated":"2020-08-25T09:05:12.504Z","comments":true,"path":"2020/08/25/hello-world/","link":"","permalink":"http://yoursite.com/2020/08/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]}