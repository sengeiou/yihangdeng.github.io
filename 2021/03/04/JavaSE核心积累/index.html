<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Keep Team">
    
    <title>
        
            JavaSE核心积累 |
        
        Keep Theme
    </title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="shortcut icon" href="/images/logo.svg">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"yoursite.com","root":"/","language":"en","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.1"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.1.1"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                Keep Theme
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">JavaSE核心积累</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Keep Team</span>
                        
                            <span class="author-label">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-03-04 11:40:32
    </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/">技术积累</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/JavaSE/">JavaSE</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p><strong>JavaSE核心积累</strong></p>
<hr>
<p>[TOC]</p>
<hr>
<h1 id="常用DOS命令"><a href="#常用DOS命令" class="headerlink" title="常用DOS命令"></a>常用DOS命令</h1><ul>
<li><strong>快速进入特定路径下的命令窗体</strong>：在拟进入文件路径的地址栏中直接输入cmd</li>
<li><strong>复制与黏贴</strong><ul>
<li>win7：任意位置<strong>右键“标记”</strong>，<strong>选中</strong>要复制的内容，再<strong>点击右键</strong>，剪贴板里面了</li>
<li>win10：<strong>左键</strong>直接选中，然后<strong>右键单击一下</strong>就到剪贴板里面了</li>
</ul>
</li>
<li><strong>D:</strong> 切换盘符直接输入“<strong>盘符</strong>”</li>
<li><strong>md</strong>：mkdir make director创建目录</li>
<li><strong>cd</strong>：change directory切换目录<ul>
<li><strong>cd</strong>：相对路径或绝对路径</li>
<li>**cd ..**：回到上级路径</li>
<li><strong>cd \</strong> ：直接回到根路径</li>
<li><strong>.</strong> ：一个点，代表当前路径。（常用与配置环境变量）</li>
</ul>
</li>
<li><strong>cls：</strong>清屏</li>
<li><strong>dir</strong> directory：查看当前路径文件目录：</li>
<li><strong>exit</strong>：退出DOS命令窗口</li>
<li><strong>rd</strong>：只能删除空文件夹：</li>
<li><strong>de</strong>：删除文件目录内所有内容</li>
<li><strong>echo</strong> content(内容)&gt;1.doc：输入流</li>
</ul>
<h1 id="语言概述"><a href="#语言概述" class="headerlink" title="语言概述"></a>语言概述</h1><h2 id="语言历史"><a href="#语言历史" class="headerlink" title="语言历史"></a>语言历史</h2><p>​    创始人：java之父<strong>James Gosling</strong></p>
<ul>
<li><p><strong>SUN</strong>(Stanford University Network，斯坦福大学网络公司 )<strong>1995</strong>推出</p>
</li>
<li><p><strong>1991</strong>年 Green项目，开发语言<strong>最初版本</strong>命名为<strong>Oak (橡树)</strong></p>
<p>…</p>
</li>
<li><p><strong>2004年，发布里程碑式版本：JDK 1.5，</strong>为突出此版本的重要性，**<em>更名为JDK 5.0**</em></p>
</li>
<li><p>2005年，改名J2SE -&gt; <strong>JavaSE(桌面级)**，J2EE -&gt; **JavaEE(企业WEB)**，J2ME -&gt; **JavaME</strong></p>
</li>
<li><p>2009年，<strong>Oracle公司收购</strong>SUN，交易价格74亿美元</p>
<p>…                              </p>
</li>
<li><p><strong>2014</strong>年，**<em>发布JDK 8.0**</em>，<strong>是继JDK 5.0以来</strong>变化最大的版本**</p>
<p>…</p>
</li>
<li><p>2018年3月，发布JDK <strong>10.0</strong>，版本号也称为<strong>18.3</strong>(<strong>改为时间命名</strong>)号称<strong>每月一更</strong></p>
</li>
<li><p>2018年9月，发布JDK 11.0，版本号也称为18.9</p>
</li>
</ul>
<h2 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h2><ol>
<li><strong>面向对象</strong>：类、对象、<strong>封装、继承、多态</strong></li>
<li><strong>健壮性</strong>：<strong>垃圾回收机制</strong>(<strong>GC</strong>机制)，<em>但仍存在内存泄漏与溢出</em>。c通过malloc与free手动管理)</li>
<li><strong>跨平台性</strong>：<strong>java虚拟</strong>(<strong>JVM</strong>)，write once,run anywhere 一次编译，到处运行</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7.png"
                     
                ></p>
<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><ul>
<li><p><strong>JDK</strong> ：<strong>Java开发工具包</strong> (Java Development Kit), 用与<strong>开发及运行</strong></p>
<ul>
<li><strong>JDK = JRE+开发工具集</strong></li>
</ul>
</li>
<li><p><strong>Java开发工具</strong>：<strong>javac.exe</strong> (编译工具) ，<strong>jar</strong>.<strong>exe</strong>(打包工具)等</p>
</li>
<li><p><strong>JRE</strong>：<strong>Java运行环境</strong>(Java Runtime Environment)，仅用于<strong>运行</strong>java项目</p>
<ul>
<li><strong>JRE = JVM+Java SE标准类库</strong></li>
</ul>
</li>
<li><p><strong>JVM：Java虚拟机</strong>(JVM Java Virtual Machine)和Java程序所需的<strong>核心类库</strong>等</p>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE回炉-JDK-JRE-JVM.png"
                      style="zoom: 80%;" /
                >

<h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><ol>
<li><p><strong>下载安装JDK</strong>:，官网，一键式傻瓜安装。可自定义安装路径，但注意安装软件的路径中不能包含中文、空格。(建议安装文件夹保留JDK版本号)</p>
</li>
<li><p><strong>配置环境变量path</strong>：</p>
<ol>
<li>进入<strong>系统变量设置</strong>：(win10)计算机，右键属性，高级系统变量，环境变量</li>
<li>把安装<strong>JDK</strong>的<strong>bin目录路径</strong>添加到环境变量<strong>path</strong>中(若不存在path则新建)<ul>
<li><strong>方式1</strong>：直接把JDK下的bin目录路径添加到path变量中</li>
<li><strong>方式2</strong>(<strong>推荐</strong>)：<ol>
<li>在<strong>系统变量</strong>中<strong>新建</strong>名为<strong>JAVA_HOME</strong>，值为<strong>JDK目录</strong>路径的环境变量</li>
<li>在path中<strong>通过引用</strong>的方式添加，即在path中添加 <strong>%JAVA_HOME%\bin;</strong> </li>
</ol>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>Tips：推荐使用方式2，后续tomcat运行环境需识别JAVA_HOME</p>
</blockquote>
</li>
<li><p><strong>验证</strong>：<strong>重新</strong>进入cmd输入<strong>javac</strong>程序如下内容显示或输入<strong>java –version</strong> 若出现安装JDK的版本号信息则安装成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-JDK%E5%AE%89%E8%A3%852.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-JDK%E5%AE%89%E8%A3%851.png"
                     
                ></p>
</li>
<li><p><strong>常见问题：(待收集)</strong></p>
<p>尝试把java的环境变量的位置以至最前面(防止部分功能失效)</p>
</li>
</ol>
<h2 id="JDK内容概要"><a href="#JDK内容概要" class="headerlink" title="JDK内容概要"></a>JDK内容概要</h2><p>默认安装路径：C:\Program Files\Java\jdk1.8.0_144</p>
<ul>
<li><strong>bin</strong>  – 开发工具（常用，javac.c 编译，java.exe 解析运行，javadoc.exe，生成文档）</li>
<li><strong>db</strong>  – java 实现的数据库</li>
<li><strong>include</strong> – 含c语言编写的头文件</li>
<li><strong>jre</strong> – java运行时环境</li>
<li><strong>lib</strong> – 存放jar包</li>
<li><strong>src.zip</strong> – 存放java开源代码，一些常用的类库(IDE中查看源码可引用它)</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-java8-JDK%E5%9B%BE.png"
                     
                ></p>
<ul>
<li><strong>JDK主要的包</strong>(packed)介绍<ul>
<li><strong>java.lang</strong>(language)：包含一些Java语言的<strong>核心类</strong>，如String、Math、Integer、 System和 Thread，提供常用功能</li>
<li><strong>java.net</strong>：包含执行与<strong>网络相关</strong>的操作的类和接口</li>
<li><strong>java.io</strong>：包含能提供多种<strong>输入/输出</strong>功能的类</li>
<li>j<strong>ava.util</strong>：包含一些实用<strong>工具类</strong>，如定义<strong>系统特性</strong>、接口的<strong>集合</strong>框架类、使用与<strong>日期日历</strong>相关的函数</li>
<li><strong>java.text</strong>：包含了一些java<strong>格式化</strong>相关的类</li>
<li><strong>java.sql</strong>：包含了java进行<strong>JDBC数据库编程</strong>的相关类/接口</li>
<li>j<strong>ava.awt</strong>：包含了构成<strong>抽象窗口</strong>工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 B/S C/S</li>
</ul>
</li>
</ul>
<h2 id="环境变量详解"><a href="#环境变量详解" class="headerlink" title="环境变量详解"></a>环境变量详解</h2><ol>
<li><p><strong>path环境变量</strong>：<strong>windows</strong>系统在cmd内执行命令时要<strong>搜寻的路径</strong>。配置path环境变量可实现在<strong>任何目录下</strong>都可以执行配置在path内容里的程序的效果。</p>
<ul>
<li><strong>环境变量类型</strong>：<strong>用户变量</strong>针对当前用户有效。<strong>系统变量</strong>，针对所有用户有效</li>
<li><strong>cmd命令的搜索逻辑</strong>：从当前目录—&gt;path路径(<strong>从前往后</strong>)</li>
<li><strong>环境变量值格式</strong>：由<strong>绝对路径</strong>组成。多个值用<strong>分号“;”</strong> (win7)隔开或(win10) 通过” 新建”的方式直接添加。</li>
<li><strong>%**JAVA_HOME</strong>%<strong>\bin;中</strong>“%%”<strong>表示</strong>获取<strong>这个</strong>环境变量的值**</li>
</ul>
</li>
<li><p>一台电脑允许同时安装多个版本JDK，实际使用哪个，却决与环境变量的指定</p>
</li>
<li><p>官方JDK安装过程会弹出两个安装框，一个是JDK安装，一个是独立的JRE安装，其实理论上安装JDK已经包含JRE，这个多出来的独立安装的JRE为了方便eclipse识别而安装，建议安装。</p>
</li>
</ol>
<h1 id="Java程序运行逻辑"><a href="#Java程序运行逻辑" class="headerlink" title=".Java程序运行逻辑"></a>.Java程序运行逻辑</h1><h2 id="java程序执行逻辑"><a href="#java程序执行逻辑" class="headerlink" title="java程序执行逻辑"></a>java程序执行逻辑</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-java%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.png"
                     
                ></p>
<h2 id="编译及运行命令的使用"><a href="#编译及运行命令的使用" class="headerlink" title="编译及运行命令的使用"></a>编译及运行命令的使用</h2><ul>
<li><p><strong>编译.java文件</strong>：<code>javac XXX.java</code>    (需含.java后缀)</p>
<blockquote>
<p>同目录下会编译出.class字节码文件，该<strong>字节码文件名</strong>由代码中<strong>class类名</strong>决定的</p>
</blockquote>
</li>
<li><p><strong>运行.class文件</strong>：<code>java .class文件名</code> (无需.class后缀)</p>
</li>
</ul>
<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><ol>
<li><p>新建一个<strong>HelloWorld.java</strong>结尾的文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloChina</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello,world!&quot;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译及运行</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-%E7%BC%96%E8%AF%91%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95.png"
                     
                ></p>
<ol start="3">
<li><strong>补充说明</strong><ol>
<li>javac命令<strong>因在</strong>Windows<strong>平台下执行，因此</strong>不区分<strong>大小写</strong></li>
<li>java命令<strong>是涉及java中的的执行，java是</strong>严格区分<strong>大小写的</strong></li>
<li>任何书写语法都没错，但还是报出“<strong>错误：找不到或无法加载主类</strong>”，有可能电脑配置了classpath的环境变量，classpath的配置表示使所有**.class文件**的执行都往该路径去寻找，导致在classpath路径下找不到对于执行的.class文件，因此提示错误。只需要删除classpath环境变量即可</li>
<li>在一个java源文件中可以声明多个类，但<strong>只有一个</strong>类能<strong>声明public</strong>，而且声明public的类的<strong>类名</strong>必须与源文件<strong>文件名相同</strong></li>
<li>存在多个class的源文件编译会生成对应的多个字节码文件，<strong>java.exe只需执行</strong>含<strong>main方法</strong>的类即可</li>
</ol>
</li>
</ol>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>​    java包含三种注释：单行注释、多行注释、<strong>文档注释</strong>(java特有)</p>
<ul>
<li><p><strong>文档注释</strong>：通过指定的注释格式，使注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。可以进入生成的文件夹，打开index.html即可。</p>
<ol>
<li><p><strong>注释格式</strong>：javadoc 工具默认只处理以 <strong>public 或 protected</strong> 修饰的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	<span class="doctag">@author</span> 指定java程序的作者</span></span><br><span class="line"><span class="comment">	<span class="doctag">@version</span> 指定源文件的版本</span></span><br><span class="line"><span class="comment">	文本内容，在类头部形成对class的文档注释</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXX</span></span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		在方法头部形成对方法的一个文档注释</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		method();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>javadoc命令使用</strong>：<code>javadoc –d filename –author –version javaFile.java</code></p>
<p>bug：</p>
<p>错误提示：javadoc 编码GBK的不可映射字符</p>
<p>原因：由于jdk是国际版的, 在编译时, 如果没有使用-encoding参数指定java源程序的编码格式, javac.exe则会获取操作系统默认的编码格式.</p>
<p>解决方案：</p>
<p>方案1：追加指定编码命令：<code>javadoc -d filename -author -version -encoding utf-8 HelloWorld.java</code></p>
<p>​    </p>
</li>
</ol>
</li>
</ul>
<h2 id="关键字、保留字、标识符"><a href="#关键字、保留字、标识符" class="headerlink" title="关键字、保留字、标识符"></a>关键字、保留字、标识符</h2><ul>
<li><p><strong>关键字</strong>：被Java语言赋予了特殊含义，用做<strong>专门用途</strong>的字符串。如**int、for、class…**（小写单词）</p>
</li>
<li><p><strong>保留字</strong>：现Java版本<strong>尚未使用</strong>，但以后版本<strong>可能会作为关键字</strong>使用。如：<strong>goto 、const</strong></p>
</li>
<li><p><strong>标识符(Unicode编码)**：凡是自己可以起名字的地方都叫标识符 (为了提高阅读性，要尽量意义，“</strong>见名知意**”)</p>
<p><strong>规则</strong>：</p>
<ul>
<li>由26个<strong>英文</strong>字母大小写，<strong>0-9</strong>，**_或$**组成</li>
<li><strong>数字不可以开头</strong>，不可以使用关键字和保留字，但能包含关键字和保留字</li>
<li>Java中<strong>严格区分大小写</strong>，长度无限制。</li>
<li>标识符不能包含空格。</li>
</ul>
<p><strong>规范</strong>：</p>
<ul>
<li><strong>包名</strong>：多单词组成，所有字母<strong>小写</strong>，xxxyyyzzz</li>
<li><strong>类名、接口名</strong>：多单词组成时，所有单词的<strong>首字母大写</strong>，XxxYyyZzz(大驼峰)</li>
<li><strong>变量名、方法名</strong>：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写，xxxYyyZzz(小驼峰)</li>
<li><strong>常量名</strong>：所有<strong>字母都大写</strong>。多单词时每个单词用<strong>下划线连接</strong>，XXX_YYY_zzz</li>
</ul>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li><strong>数据类型</strong></li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE回炉-数据类型.png"
                      style="zoom:80%;" /
                >

<table>
<thead>
<tr>
<th>数据类型</th>
<th>内存空间</th>
<th>默认值</th>
<th>表示范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1 byte (2<sup>0</sup>)</td>
<td>0</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>short /char</td>
<td>2 byte (2<sup>1</sup>)</td>
<td>0</td>
<td>-2<sup>15</sup>~2<sup>15</sup>-1 / 无符号整型</td>
</tr>
<tr>
<td>int</td>
<td>4 byte (2<sup>2</sup>)</td>
<td>0</td>
<td>-2<sup>31</sup>~2<sup>31</sup>-1(约21亿)</td>
</tr>
<tr>
<td>long</td>
<td>8 byte (2<sup>3</sup>)</td>
<td>0L 或 0l</td>
<td>-2<sup>63</sup>~2<sup>63</sup>-1</td>
</tr>
<tr>
<td>float</td>
<td>4 byte</td>
<td>0.0F 或 0.0f</td>
<td></td>
</tr>
<tr>
<td>double</td>
<td>8 byte</td>
<td>0.0</td>
<td></td>
</tr>
</tbody></table>
<ol start="2">
<li><p><strong>补充说明</strong></p>
<ul>
<li>Java的<strong>整型常量</strong>默认为 <strong>int 型</strong>，因此<strong>声明long</strong>型常量须后加 <strong>‘l’或‘L’</strong></li>
<li>Java 的<strong>浮点型常量</strong>默认为<strong>double型</strong>，因此<strong>声明float</strong>型常量，须后加<strong>‘f’或‘F’</strong></li>
</ul>
<blockquote>
<p>无论是赋值语句的数字还是字面常量的数字，只要是整型数字 java就认为是int，只要浮点数字就认为double</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译成功，但bigValue并非long型，而是int型</span></span><br><span class="line"><span class="keyword">long</span> bigValue = <span class="number">100</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译失败 ，系统不会把 9999999999999 当成long类型处理</span></span><br><span class="line"><span class="comment">所以超出 int 的表数范围，从而引起错误</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">long</span> bigValue1 = <span class="number">9999999999999</span>;</span><br><span class="line"><span class="comment">//下面代码是正确的，在巨大的整数值后使用 L 后缀 ，强制使用long 类型</span></span><br><span class="line"><span class="keyword">long</span> bigVa1ue2 = <span class="number">9223372036854775807L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译失败，12.3默认是double型，大类型转小类型必须加强制转换符，或改为12.3f</span></span><br><span class="line"><span class="keyword">float</span> f1 = <span class="number">12.3</span>;</span><br></pre></td></tr></table></figure>

<hr>
</li>
</ol>
<ul>
<li><p><strong>整数值</strong>的<strong>4种</strong>表示方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义两个 8 位的二进制整数</span></span><br><span class="line"><span class="comment">// 注意，计算机底层都是以补码的方式存储数据的</span></span><br><span class="line"><span class="keyword">int</span> binVal1 = <span class="number">0b11010100</span>; </span><br><span class="line"><span class="keyword">byte</span> bnVal2= <span class="number">0B01101001</span>;</span><br><span class="line"><span class="comment">//以 0 开头的整数值是八进制的整数</span></span><br><span class="line"><span class="keyword">int</span> octa1Va1ue = <span class="number">013</span> ; </span><br><span class="line"><span class="comment">//0~9组成的十进制整数</span></span><br><span class="line"><span class="keyword">int</span> decValue = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//以 0x 或0X 开头的整数值是十六进制的整数</span></span><br><span class="line"><span class="keyword">int</span> hexVa1uel = <span class="number">0x13</span> ; </span><br><span class="line"><span class="keyword">int</span> hexVa1ue2 = <span class="number">0XaF</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>编程中进制间的转换，调用 Integer 的toHexString()，toOctalString()等方法</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>字符型</strong>的<strong>3种</strong>表示方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接指定单个字符作为字符值</span></span><br><span class="line"><span class="keyword">char</span> aChar = <span class="string">&#x27;a&#x27;</span>; </span><br><span class="line"><span class="comment">//使用转义字符来作为字符值</span></span><br><span class="line"><span class="keyword">char</span> enterChar = <span class="string">&#x27;\r&#x27;</span>; </span><br><span class="line"><span class="comment">//使用 Unicode 编码值来指定字符值</span></span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;\u9999&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>常用acsii编码字符</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>ASCII码</th>
</tr>
</thead>
<tbody><tr>
<td>a ~ z</td>
<td>97 ~ 122</td>
</tr>
<tr>
<td>A ~ Z</td>
<td>65 ~ 90</td>
</tr>
<tr>
<td>0 ~ 9</td>
<td>48 ~ 57</td>
</tr>
</tbody></table>
<ul>
<li>常见编码积累<ol>
<li>Windows CMD 默认编码是：ANSI编码，即GBK编码</li>
<li>UTF-8 是 Unicode 编码的一种形式，是国际最通用的编码</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>浮点型</strong>的<strong>2种</strong>表示方式</p>
<ul>
<li>十进制数形式:如5.12 、512.0 、.512 。浮点数必须包含一个小数点</li>
<li>科学计数法形式:例如 5.12e2 (即 5.12x10<sup>2</sup>)，5.12E2 也是5.12x10<sup>2</sup></li>
</ul>
</li>
<li><p>float:单精度，尾数可以精确到<strong>7位有效数字</strong>。很多情况下，精度很难满足需求</p>
<ul>
<li>虽说float只占4个字节，但因为尾数表示方式，表示数值的范围比long还大</li>
</ul>
</li>
<li><p>double:双精度，精度是float的两倍。通常采用此类型。</p>
<ul>
<li>小结：整型通常使用int类型，浮点型通常使用double</li>
</ul>
</li>
</ul>
<ol start="3">
<li><p><strong>类型间运算及其转换(不含boolean)</strong></p>
<ol>
<li><p><strong>自动类型转换</strong>：当不同数据类型之间运算时，结果自动<strong>提升为容量大的数据类型</strong>。</p>
<p>注意，当<strong>byte、char、short</strong>三种类型之间<strong>任何两种</strong>，<strong>包括自身两种</strong>变量做运算时，结果都转换为<strong>int型</strong></p>
<p>byte + byte = int….、byte + short = int 、char + byte = int 、char + short = int </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png"
                     
                ></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相关练习与测试</span></span><br><span class="line">System.out.println(<span class="string">&quot;*	*&quot;</span>); 			<span class="comment">//*	   *</span></span><br><span class="line">System.out.print1n(<span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&#x27;*&#x27;</span>);	 <span class="comment">//93</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&quot;\t&quot;</span> + <span class="string">&#x27;*&#x27;</span>); 	 <span class="comment">//*	*</span></span><br><span class="line">System.out.printin(<span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&quot;*&quot;</span>); 	 <span class="comment">//51*</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + (<span class="string">&#x27;\t&#x27;</span> + <span class="string">&quot;*&quot;</span>));  <span class="comment">//*	*</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p><strong>强制类型转换</strong>：自动类型转换的逆运算，加强制转换符 ()，注意精度损失，或溢出</p>
</li>
<li><p><strong>String与其他类型的运算</strong>：String可以和8种基本数据类型变量做+运算，且运算只能是<strong>连接运算</strong>，运算的结果<strong>仍然是String类</strong>型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number = <span class="number">100</span>;</span><br><span class="line">String numberStr = <span class="string">&quot;学号&quot;</span>;</span><br><span class="line">System.out.println(numberStr + number);<span class="comment">//输出 &quot;学号100&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>无论是自动转换还是<strong>强制转换</strong>，只能<strong>适用数值间</strong>的转换<strong>，即强制类型转换符()也</strong>只适用数值的数据类型</p>
</blockquote>
</li>
</ol>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ol>
<li><p><strong>算术运算符</strong></p>
<ol>
<li><p><strong>前至++与后至++</strong></p>
<ul>
<li><p>前置++：++i，先自增，后使用</p>
</li>
<li><p>后置++：i++，先使用，后自增</p>
</li>
<li><p>++与–的特点：<strong>不改变原数据类型</strong>的情况下进行++与–，<strong>效率高</strong></p>
</li>
<li><p>无论前置还是后置++还是–，<strong>均改变变量</strong>，i++ == i = i +1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">10</span>;</span><br><span class="line">s1 = s1 + <span class="number">1</span>;<span class="comment">//编译失败，int不能直接转换为short</span></span><br><span class="line">s1 = (<span class="keyword">short</span>)s1 + <span class="number">1</span> <span class="comment">//正确写法，效率低，截断方式</span></span><br><span class="line">s1++; <span class="comment">//编译运行均通过，正确写法，效率高</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>/除运算</strong>：</p>
<ul>
<li><p>无论在什么地方，<strong>两个int型相除</strong>，结果一定为<strong>整型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> result = <span class="number">12</span> / <span class="number">5</span>; <span class="comment">// result = 2.0;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>%模运算</strong>/取余：</p>
<ul>
<li><strong>模运算 = 前除后，求余数</strong></li>
<li>java规定，结果的符号与<strong>被模数</strong>(前面的数)的符号相同</li>
</ul>
</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>模运算式</th>
<th>结果</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>0 % 1</td>
<td>0</td>
<td><strong>0除以任何数=0</strong>，<strong>不会存在余数</strong></td>
</tr>
<tr>
<td>1 % 0</td>
<td>error</td>
<td>0<strong>不能作除数</strong>，作分母，溢出</td>
</tr>
<tr>
<td>2 % 1</td>
<td>0</td>
<td>整除余0</td>
</tr>
<tr>
<td>7 % 5</td>
<td>2</td>
<td>够除 1余2</td>
</tr>
<tr>
<td>2 % 3</td>
<td>3</td>
<td>不够除：0余2</td>
</tr>
<tr>
<td>12 % -5</td>
<td>2</td>
<td>符号由被<strong>模数决定</strong></td>
</tr>
<tr>
<td>-12 % -5</td>
<td>-2</td>
<td>同上</td>
</tr>
</tbody></table>
<ol start="2">
<li><p><strong>赋值运算符</strong></p>
<ul>
<li><p>复合/扩展运算符：</p>
<ul>
<li><p>基本原理：<code>num1 +=2; 等价 num1 = num1 + 2;</code></p>
</li>
<li><p>特点，同++一样，复合赋值运算符同样可以在<strong>不改变原数据类型</strong>情况下运算，更加高效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>; s1 += <span class="number">2</span>;<span class="comment">//编译运行均通过</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>; i *= <span class="number">0.1</span>; <span class="comment">//编译运行均通过 输出0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>综合练习</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">n += (n++) + (++n); <span class="comment">//n = n + (n++) + (++n); n = 10 + 10 + 12</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>逻辑运算符</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>布尔</th>
<th>数值(按位与)</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>if( true &amp; num++ )，全部执行</td>
<td>二进制按位与</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>短路与：if ( true &amp;&amp; num++ )，可得出结果就停止执行，即num++不执行</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>注意：**&amp;，|，^<strong>这三个运算符</strong>同为逻辑运算符与位运算符<strong>，具体表示哪种，</strong>取决于参与运算对象**是数值还是布尔值</li>
</ul>
</li>
<li><p><strong>位运算符</strong></p>
<table>
<thead>
<tr>
<th>位运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
</tr>
<tr>
<td>~</td>
<td>按位取反</td>
</tr>
<tr>
<td>&lt;&lt;n</td>
<td>左移n位右<strong>补零</strong></td>
</tr>
<tr>
<td>&gt;&gt;n</td>
<td>按位右移n位，<strong>补最高位</strong>(正数0，负数1)</td>
</tr>
<tr>
<td>&gt;&gt;&gt;</td>
<td>无符号右移，空缺位<strong>均补零</strong></td>
</tr>
</tbody></table>
<p>tips：注意，真正对计算机<strong>数值数据移位</strong>也是移动该数值的<strong>补码</strong>，如 -5 &lt;&lt; 2结果如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-%E8%B4%9F%E6%95%B0%E7%A7%BB%E4%BD%8D.png"
                     
                ></p>
<ul>
<li><p>位运算符常见应用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-j%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8.png"
                     
                ></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、你能否写出最高效的2 * 8的实现方式？ </span></span><br><span class="line"><span class="number">2</span> &lt;&lt; <span class="number">3</span>  或  <span class="number">8</span> &lt;&lt; <span class="number">1</span></span><br><span class="line"><span class="comment">//2、交换两个数值变量的几种方式</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1 + <span class="string">&quot;,num2 = &quot;</span> + num2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式一：定义临时变量的方式</span></span><br><span class="line"><span class="comment">//推荐的方式</span></span><br><span class="line"><span class="comment">//int temp = num1;</span></span><br><span class="line"><span class="comment">//num1 = num2;</span></span><br><span class="line"><span class="comment">//num2 = temp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：好处：不用定义临时变量  </span></span><br><span class="line"><span class="comment">//弊端：① 相加操作可能超出存储范围 ② 有局限性：只能适用于数值类型</span></span><br><span class="line"><span class="comment">//num1 = num1 + num2;</span></span><br><span class="line"><span class="comment">//num2 = num1 - num2;</span></span><br><span class="line"><span class="comment">//num1 = num1 - num2;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*方式三：使用位运算符</span></span><br><span class="line"><span class="comment">	num1=(numl ^ num2)^num2;</span></span><br><span class="line"><span class="comment">	num2=(num2 ^ num1)^num1;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//有局限性：只能适用于数值类型</span></span><br><span class="line">num1 = num1 ^ num2;</span><br><span class="line">num2 = num1 ^ num2;</span><br><span class="line">num1 = num1 ^ num2;<span class="comment">//此时num2 == num1</span></span><br><span class="line">System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1 + <span class="string">&quot;,num2 = &quot;</span> + num2);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>三元/目表达式</strong></p>
<ul>
<li>格式：表达式1 ? 表达式2 : 表达式3</li>
</ul>
<p>​       含义：若表达式1为真，整个条件表达式返回表达式2的结果反之表达式3的结果</p>
<ul>
<li><p>三元运算符可以嵌套使用</p>
</li>
<li><p>若程序使用三元运算符，又可以使用if-else结构，优先选择三元运算符。原因：简洁、执行效率高。</p>
</li>
<li><p>表达式1和表达式2不要求完全一致，但必须可兼容为其中一种类型</p>
</li>
<li><p>对于数值基本数据类型，使用三元运算符还会想使用比较运算符那样进行自动类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">true</span> ? <span class="number">3</span> : <span class="number">4.0</span>);<span class="comment">//输出3.0，自动转换为double型</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<ol start="5">
<li><p><strong>比较运算符</strong></p>
<ul>
<li>‘==，&gt;，&lt;，&gt;=，&lt;= ‘：粗略来说，比较运算符只能用于<strong>数值类型</strong>(类型不一定完全相同，底层是数值即可)</li>
<li>特别说明，’==’ 也可以在<strong>引用类型中使用</strong>，但也聚焦在<strong>数值上</strong>(地址值)</li>
</ul>
</li>
</ol>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ol>
<li><p><strong>顺序结构</strong></p>
</li>
<li><p><strong>分支结构</strong></p>
<ul>
<li><p><strong>if-else结构</strong></p>
<ul>
<li>if：符合则执行</li>
</ul>
</li>
<li><p>if - else：2选1</p>
</li>
<li><p>if - else if - else ：n选1</p>
<hr>
<ul>
<li><p>若if-else结构中只有<strong>一条执行语句</strong>，则可以省略{}</p>
</li>
<li><p>同时，省略{}的if语句的else总是与<strong>最近</strong>的未匹配的if匹配</p>
</li>
</ul>
</li>
<li><p><strong>switch结构</strong></p>
<ul>
<li><strong>执行逻辑</strong>：根据switch表达式的值，依次匹配各个case中的常量。一旦匹配成功，则执行case结构中语句。若此时没有遇到break语句，则<strong>不判断地</strong>直接继续向下执行其他case结构中的执行语句，直到遇到break关键字或末尾结束为止。(为更好理解，表达式与case 后语句划上等号进行的判断)</li>
<li>表达式支持<strong>6种</strong>数据类型：<strong>byte 、short、char、int、枚举类型</strong>(JDK5.0新增)、<strong>String</strong>类型(JDK7.0新增)</li>
<li>把<strong>default</strong>语句理解成为一个<strong>无条件case</strong>语句则一切明了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例1：常见方式</span></span><br><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 常量表达式<span class="number">1</span> : 语句<span class="number">1</span>;<span class="comment">//break;</span></span><br><span class="line">	…</span><br><span class="line">	<span class="keyword">case</span> 常量表达式n : 语句n;<span class="comment">//break;</span></span><br><span class="line">	<span class="keyword">default</span> : 语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出1，2，3，4</span></span><br><span class="line"><span class="keyword">int</span> i =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(i)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:System.out.println(<span class="string">&quot;2&quot;</span>);		</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:System.out.println(<span class="string">&quot;3&quot;</span>);		</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例2：多个case共用一条语句</span></span><br><span class="line"><span class="comment">//应理解为，每个case的执行语句都为空，且没有break，因此连续执行</span></span><br><span class="line"><span class="comment">//不应该理解为内嵌case语句</span></span><br><span class="line"><span class="comment">//值为‘A\B\C’都执行语句1</span></span><br><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> ‘A’ :</span><br><span class="line">	<span class="keyword">case</span> ‘B’ :</span><br><span class="line">	<span class="keyword">case</span> ‘C’ : 语句<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">	…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编写经验</strong></p>
<ul>
<li><p>若多个条件表达式之间是</p>
<ul>
<li><p>“<strong>互斥</strong>“关系(或没有交集的关系),哪个判断和执行语句声明在上面还是下面，无所谓</p>
</li>
<li><p>交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面</p>
</li>
<li><p><strong>有包含</strong>的关系，通常情况下，需要将<strong>范围小</strong>的声明<strong>在范围大的上面</strong>。<strong>否则，范围小的就没机会执行了</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例1：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graduate</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		InstanceTest test = <span class="keyword">new</span> InstanceTest();</span><br><span class="line">		test.method(<span class="keyword">new</span> Student());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Person e)</span></span>&#123;</span><br><span class="line">		<span class="comment">//错误写法,每次执行第一个if</span></span><br><span class="line">        <span class="comment">//if(e instanceof Person)&#123;</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;a graduated student&quot;);</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;a student&quot;);</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;a person&quot;);</span></span><br><span class="line"><span class="comment">//		&#125;else if(e instanceof Student)&#123;</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;a student&quot;);</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;a person&quot;);</span></span><br><span class="line"><span class="comment">//		&#125;else if(e instanceof Graduate)&#123;</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;a person&quot;);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">       </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//方式一，包含关系应将范围小的在范围大前判断</span></span><br><span class="line">		<span class="keyword">if</span>(e <span class="keyword">instanceof</span> Graduate)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;a graduated student&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a student&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a person&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a student&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;a person&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a person&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//方式二</span></span><br><span class="line">		<span class="keyword">if</span>(e <span class="keyword">instanceof</span> Graduate)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a graduated student&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(e <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a student&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(e <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a person&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p><strong>循环结构</strong></p>
<ul>
<li><p>循环相关关键字使用：</p>
<ul>
<li><p><strong>break</strong>：结束<strong>当前</strong>循环体的循环</p>
</li>
<li><p><strong>continue</strong>：结束<strong>当次</strong>循环体当的循环</p>
<hr>
</li>
<li><p>break与continue<strong>语句后</strong>均<strong>不能声明执行语句</strong></p>
</li>
<li><p>break与continue只作用在离关键字<strong>最近的循环体</strong></p>
<hr>
</li>
<li><p><strong>带标签break与continue</strong>语句使用：可指定作用在哪一层循环结构</p>
<ol>
<li>在拟作用循环体前<strong>声明标签</strong>：<strong>label :  for</strong>()</li>
<li>在break或continue语句后追加标签民：<strong>break label;</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">label:<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">10</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">//break;//默认跳出包裹此关键字最近的一层循环。</span></span><br><span class="line">			<span class="comment">//continue;</span></span><br><span class="line">			<span class="keyword">break</span> label;<span class="comment">//结束指定标识的一层循环结构</span></span><br><span class="line">             <span class="comment">//continue labe1；//结束指定标识的一层循环结构当次循环  </span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(j);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>for循环</strong></p>
<ul>
<li><p>for内的变量只在for中有效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首次执行：1-&gt;2-&gt;3-&gt;4</span></span><br><span class="line"><span class="comment">//循环执行：2-&gt;3-&gt;4，2-&gt;3-&gt;4...</span></span><br><span class="line"><span class="comment">//可输入多个语句用逗号“，”</span></span><br><span class="line"><span class="keyword">for</span>( <span class="number">1</span>,?,? ; <span class="number">2</span> ; <span class="number">4</span>)&#123;</span><br><span class="line">	<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>while循环</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首次执行：1-&gt;2-&gt;3</span></span><br><span class="line"><span class="comment">//循环执行：2-&gt;3,2-&gt;3...</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">2</span>)&#123;</span><br><span class="line">	<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>do-while循环</strong></p>
<ul>
<li><p>do-while循环至少会执行一次循环体！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首次执行：1 - 3 - 4 </span></span><br><span class="line"><span class="comment">//循环执行：2 - 3 - 4 </span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	<span class="number">3</span>;</span><br><span class="line">	<span class="number">4</span>;</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>





</li>
</ul>
</li>
</ul>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><ul>
<li><p><strong>基本概念</strong></p>
<ul>
<li>数组的类型可以是<strong>基本数据类型</strong>，也可<strong>引用数据类型</strong></li>
<li>数组是<strong>引用数据类型</strong>，必须含<strong>new</strong>，含方法，含属性(常用length)</li>
</ul>
</li>
<li><p>数组长度一旦确定，就不可修改</p>
</li>
<li><p><strong>声明与初始化</strong>：静态初始化，动态初始化</p>
<ul>
<li><p><strong>静态初始化</strong>：<strong>指定</strong>数组元素的<strong>初始值</strong>，由<strong>系统决定</strong>数组<strong>长度</strong> </p>
</li>
<li><p><strong>动态初始化</strong>：<strong>指定数组长度</strong>(可以是<strong>变量</strong>)，由<strong>系统</strong>为数组元素<strong>分配初始值</strong></p>
<blockquote>
<pre><code>整型：0
浮点型：0.0
char型：0或&#39;\u0000&#39;，而非&#39;0&#39;
boolean型：false
用数据类型：null</code></pre>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [] ids;<span class="comment">//声明</span></span><br><span class="line">ids = <span class="keyword">new</span> ids[]&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>&#125;;<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;<span class="comment">//简化语法格式</span></span><br><span class="line"></span><br><span class="line">String[] names = <span class="keyword">new</span> String[<span class="number">4</span>];<span class="comment">//动态初始化，数组长度可以是变量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数组的内存解析</strong></p>
<p>待补充，暂时不需要</p>
</li>
</ul>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><ol>
<li><p><strong>基础认知</strong></p>
<ul>
<li>从数组底层的运行机制上来看(线性内存，多维映射)，没有多维数组</li>
</ul>
</li>
</ol>
<ul>
<li>把多维数组看成多个一维数组的内嵌，如二维数组是一个一维数组，每个数组元素也是一个数组</li>
</ul>
<ol start="2">
<li><p><strong>二维数组的使用</strong></p>
<ul>
<li><p><strong>初始化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;<span class="comment">//静态初始化</span></span><br><span class="line">String[][] arr2 = <span class="keyword">new</span> String[<span class="number">2</span>][<span class="number">3</span>];<span class="comment">//动态初始化</span></span><br><span class="line"></span><br><span class="line">String[][] arr3 = <span class="keyword">new</span> String[<span class="number">3</span>][];<span class="comment">//动态初始化，但不能直接使用，还需指定列</span></span><br><span class="line"><span class="comment">//指定列后才可以使用，否则报空指针异常。注意，指定哪个(实例化哪个)用哪个可用</span></span><br><span class="line">arr3[<span class="number">0</span>] = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>长度</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">arr1.length;<span class="comment">//3</span></span><br><span class="line">arr1[<span class="number">0</span>].length;<span class="comment">//3</span></span><br><span class="line">arr1[<span class="number">1</span>].length;<span class="comment">//2</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>内存解析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//规定：二维数组分为外层数组的元素，内层数组的元素</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">//外层元素：arr[0],arr[1]等</span></span><br><span class="line"><span class="comment">//内层元素：arr[0][0],arr[1][2]等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组元素的默认初始化值 </span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">//外层元素的初始化值为：地址值</span></span><br><span class="line"><span class="comment">//内层元素的初始化值为：与一维数组初始化情况相同</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][];</span><br><span class="line"><span class="comment">//外层元素的初始化值为：null</span></span><br><span class="line"><span class="comment">//内层元素的初始化值为：不能调用，否则报错。</span></span><br></pre></td></tr></table></figure>

<p>   <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-java8-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90.jpg"
                     
                ></p>
</li>
</ul>
<h2 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h2><ul>
<li><strong>ArrayIndexOutOfBoundsException</strong>：角标越界异常</li>
<li><strong>NullPointerException</strong>：空指针异常</li>
</ul>
<h1 id="内存结构与变量"><a href="#内存结构与变量" class="headerlink" title="内存结构与变量"></a>内存结构与变量</h1><p>JVM基本结构</p>
<ul>
<li><p><strong>虚拟机堆</strong>(heap)：存放<strong>数组</strong>、<strong>对象实例</strong>(含非static属性)</p>
</li>
<li><p><strong>虚拟机栈</strong>(stack)：存放<strong>局部变量</strong>、<strong>对象引用</strong></p>
</li>
<li><p><strong>方法区</strong>(method area)：存储虚拟机<strong>已加载</strong>的、<strong>类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>编译后的代码</strong></p>
</li>
<li><p>本地方法栈(native method stack)：</p>
</li>
<li><p>程序计数器(PC)：</p>
</li>
<li><p>加载流程：<strong>编译</strong> —&gt; 一个或多个<strong>字节码文件</strong>(class) —&gt; JVM<strong>类加载器</strong>和<strong>解析器</strong>进行<strong>解析运行</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE回炉-JVM内存结构图.jpge.bmp"
                      style="zoom:120%;" /
                >



</li>
</ul>
<h2 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型"></a>变量的类型</h2><h2 id="变量的初始化及默认值"><a href="#变量的初始化及默认值" class="headerlink" title="变量的初始化及默认值"></a>变量的初始化及默认值</h2><h2 id="不同变量的内存结构"><a href="#不同变量的内存结构" class="headerlink" title="不同变量的内存结构"></a>不同变量的内存结构</h2><ul>
<li><p>Java变量的类型**：局部变量，成员变量</p>
<ul>
<li><p><strong>局部变量</strong>：形参、方法内变量、代码块内变量</p>
</li>
<li><p><strong>成员变量</strong>：类中方法外的变量</p>
<ul>
<li>实例变量(非static修饰)</li>
<li>类变量(static修饰)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>不同变量的内存结构</strong></li>
</ul>
<ul>
<li><strong>变量的默认值</strong></li>
</ul>
<ul>
<li><p>声明一个变量后，必须用赋值语句对变量进行<strong>显式初始化</strong>(赋值)<strong>才能使用</strong>，使用未初始化的变量，出现<strong>编译错误</strong></p>
<p><strong>注意</strong>：对于<strong>引用数据类型</strong>，有别于基本数据类型。如初始化的<strong>数组</strong>元素，类中属性等，系统<strong>会默认给予初始值</strong>。</p>
<ul>
<li>整型（byte、short、int、long：0）</li>
<li>浮点型（float、double：0.0）</li>
<li>字符型（char：0  （或’\u0000’））</li>
<li>布尔型（boolean：false）</li>
<li>引用数据类型（类、数组、接口：null）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure>
</li>
<li><p>变量的作用域：其定义所在的一对{ }内 ，变量只有在其作用域内才有效 ，同一个作用域内，不能定义重名的变量</p>
</li>
</ul>
<p>掌握局部变量和全局变量： 局部变量： 定义：在函数内定义的变量，包括形式变量，程序块，都属于局部变量。只在函数内有效 存储特性：仅在需要时才开辟内存单元，使用完毕后释放。 注意：程序块是由{}构成的，它的作用范围更加小，程序块里定义的变量只在程序块{}内有效13 全局变量： 定义：函数外定义的变量属于外部变量/全局变量。有效范围从定义位置到当前源文件(.c)结束。 存储特性：在程序的全部执行过程中始终占用存储单元 注意：变量名习惯第首字母用大写 2、理解数据的存储类别含义：指数据在内存中的存储方式 1、变量存储类别的两种方式：静态存储方式和动态存储方式 (都是在内存中开辟空间) 静态存储区：在程序开始执行时就开始分配存储单元，程序执行完才释放。在程序执行过程 中始终占据固定的存储单元，而不是动态地进行分配和释放。如全局变量 动态存储区：仅在使用(函数调用，实参传入等)的时分配空间。代码功能执行完后就释放。 如：形参，自动变量(未加 static 声明的局部变量)，函数调用现场保护和返回地址</p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类成员及内存结构"><a href="#类成员及内存结构" class="headerlink" title="类成员及内存结构"></a>类成员及内存结构</h2><p><strong>类成员</strong>：属性、方法、构造器、代码块、内部类</p>
<ul>
<li><p><strong>基础概念</strong></p>
<ul>
<li><strong>类</strong>：对一类事物的描述，是抽象的，概念上的定义</li>
<li><strong>对象</strong>：某个类的具体实体，也成为<strong>实例</strong>(instance)，创建一个对象 == <strong>实例化</strong></li>
<li><strong>属性</strong>：类中的<strong>成员的变量</strong>(field)，调用 <code>对象.属性;</code></li>
<li><strong>行为</strong>：类的<strong>成员的方法</strong>(method)，调用 <code>对象.方法()</code></li>
</ul>
</li>
<li><p><strong>属性</strong>与<strong>局部变量</strong>异同点</p>
<ul>
<li><strong>属性</strong>：<ul>
<li><strong>直接定义</strong>在<strong>类</strong>的一对{}内</li>
<li>声明属性可<strong>指明其权限</strong>：<strong>private</strong>、<strong>public</strong>、<strong>缺省</strong>(默认不写权限)、<strong>protected</strong></li>
</ul>
</li>
<li><strong>局部变量</strong>：<ul>
<li>声明在<strong>方法</strong>内、<strong>方法形参</strong>、<strong>代码块内</strong>、<strong>构造器形参、构造器内部</strong>的变量</li>
<li><strong>不可使用</strong>权限修饰符</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">method(<span class="string">&quot;Tom&quot;</span>);<span class="comment">//传入的为实参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String name)</span></span>&#123;&#125;<span class="comment">//方法参数。形式参数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方法(method)</strong></p>
<ul>
<li><p><strong>创建</strong>：<code>public static void method(String name)&#123;&#125;</code></p>
</li>
<li><p><strong>重载</strong>：“两同一不同”。与<strong>权限修饰符、返回值类型、形参变量名、方法体均无关</strong>(按<strong>可区分调用角度</strong>理解即可)</p>
<ul>
<li>同一个<strong>类</strong>、相同<strong>方法名</strong></li>
<li>参数列表不同：参数<strong>个数不同</strong>，参数<strong>类型不同</strong></li>
</ul>
</li>
<li><p><strong>可变个数形参</strong>(jdk 5.0)： </p>
<ul>
<li><p><strong>格式</strong>：<code>数据类型 ... 变量名,如 String...strs </code></p>
<p>tips：当方法<strong>不止一个形参</strong>且<strong>含可变形参</strong>时，可变形参<strong>只能置于末尾</strong>，否则编译不通过(不可区分变量类型)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public void show(String...strs,int i); //错误情况，</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i,String...strs)</span></span>;<span class="comment">// 正确情况</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>内在逻辑：除与数组作为新参的<strong>实参传入格式不一样</strong>外(可变形参用逗号)，可变个数形参<strong>等价于数组</strong></p>
</li>
<li><p>因此可与数组类型构成<strong>重写</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">show(<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Wang&quot;</span>,<span class="string">&quot;Deng&quot;</span>)<span class="comment">//可连续传入多个数据，用逗号隔开。</span></span><br><span class="line">show(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Wang&quot;</span>,<span class="string">&quot;Deng&quot;</span>&#125;);<span class="comment">//同样可以通过数组的方式传入实参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String...strs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; stes.length;i++)&#123;<span class="comment">//等价与数组</span></span><br><span class="line">        System.out.println(strs[i]);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String name)</span></span>&#123;&#125;<span class="comment">//可以构成重载</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>return</strong>关键字：</p>
<ul>
<li><strong>无返回值</strong>：结束当前方法</li>
<li><strong>有返回值</strong>：结束当前方法且返回指定变量</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>匿名对象</strong>：<code>new Person().run();</code></p>
<ul>
<li>匿名对象<strong>只能调用一次</strong></li>
</ul>
</li>
<li><p><strong>变量类型及其内存结构</strong></p>
</li>
</ul>
<ul>
<li><p><strong>方法传递机制</strong>：Java方法参数传递方式<strong>只有一种</strong>，<strong>值传递！</strong></p>
<ul>
<li>基本数据类型：变量<strong>值</strong></li>
<li>引用数据类型：地址<strong>值</strong></li>
</ul>
<hr>
<ul>
<li><p><strong>String与值传递机制</strong></p>
<ul>
<li>字符串是存储在字符串常量池，是<strong>不可变</strong>(特性)的字符序列</li>
</ul>
</li>
<li><p>当字符串常量池中已经有相同的字符串，则直接复用执行该字符串的地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s1);<span class="comment">//仍输出hello </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    str = <span class="string">&quot;hi~&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* String确实是**引用数据类型**，值传递也确实在传递s1的**地址值**，但由于字**符串常量池的特性**(不可变序列)导致没有改变</span><br><span class="line">* 由于字符串在java中大量使用，因此JVM特意开辟一个空间专门用于存储字符串，若同时又两个相同的字符串，常量池只记录一个</span><br><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;gitee.com&#x2F;yihangdeng&#x2F;blogImage&#x2F;raw&#x2F;master&#x2F;img&#x2F;javaSE回炉-String内存与值传递机制.png)</span><br><span class="line"></span><br><span class="line">1. 在字符串常量池创建字符串&quot;hello&quot;，因为字符串底层是通过char[]存储的，确定后是不可变的字符序列</span><br><span class="line">1. 把“hello”字符串与s1关联起来</span><br><span class="line">1. 调用方法时，实参传入s1的地址值，并赋值给str</span><br><span class="line">1. 由于字符串常量池不可变的特性，拟赋值的“hi~~”字符串只能新建一份</span><br><span class="line">1. 并将“hi~~”字符串与赋值语句中的str关联</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>值传递机制例题分析</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//需实现调用method方法后，打印除a=100,b=200,请写出method方法代码</span></span><br><span class="line">        method(a,b);</span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;b=&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>由于Java基本数据类型<strong>无指针操作</strong>，若想通过<strong>方法调用</strong>实现交换两个<strong>基本数据类型</strong>的值。严格来说是<strong>不行的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现方式1：方法内打印，立即终止程序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        a = a*<span class="number">10</span>;</span><br><span class="line">        b = b*<span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;b=&quot;</span> + b);</span><br><span class="line">    	System.exit(<span class="number">0</span>);<span class="comment">//终止程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现方式2：方法重写/覆盖</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    PrintStream ps = <span class="keyword">new</span> PrintStream(System.out)&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span></span>&#123;</span><br><span class="line">              <span class="keyword">if</span>(<span class="string">&quot;a=10&quot;</span>.equals(x))&#123;</span><br><span class="line">                  x = <span class="string">&quot;a=100&quot;</span>;</span><br><span class="line">              &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;b=10&quot;</span>.equals(x))&#123;</span><br><span class="line">                  x = <span class="string">&quot;b=200&quot;</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">super</span>.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    System.setOut(ps);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>若想通过调用一个方法实现数组两个元素值交换，则必须通过<strong>引用类型</strong>作为<strong>引导媒介</strong>进行交换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：若想通过调用一个方法的形式交换数组中某两个值，只能如下写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = arr[i];   </span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul>
<li><p><strong>基本概念</strong></p>
<ul>
<li><strong>高内聚</strong> ：类的内部数据操作细节自己完成，不允许外部干涉；</li>
<li><strong>低耦合</strong> ：仅对外暴露少量的方法用于使用</li>
</ul>
</li>
<li><p><strong>封装性的一些体现</strong>：具体体现在面向对象程序设计上</p>
<ul>
<li>属性私有化(private)、公共(public)方法来调用</li>
<li>不对外暴露的私有方法</li>
<li>单例模式…</li>
</ul>
</li>
<li><p><strong>权限修饰符</strong>：<strong>private</strong>、<strong>缺省</strong>(默认不写权限)、<strong>protected</strong>、<strong>public</strong>(从小到大)，可添加到<strong>类的成员</strong>与<strong>类</strong>(class)前</p>
<ul>
<li><p><strong>类的成员</strong>(全支持)：属性、方法、构造器、内部类、<del>代码块</del></p>
<ul>
<li>注意：以下权限范围的调用对象是<strong>类的成员可以不可被调用，不是类可不可以创建</strong></li>
<li>常用private与public，需注意是(缺省)与protected的对比</li>
</ul>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类内部</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>同一工程</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>(缺省)</td>
<td>Yes</td>
<td><strong>Yes</strong>(需注意)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>Yes</td>
<td>Yes</td>
<td><strong>Yes</strong>(需注意)</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>df</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p><strong>类</strong>(仅public与缺省可用)：<strong>缺省情况</strong>下可通过<strong>import</strong>在不同包中调用类</p>
</li>
</ul>
</li>
<li><p><strong>构造器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建类的对象：new + 构造器</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person(); <span class="comment">//new Person()就是调用构造器</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果<strong>没显式</strong>的定义类的构造器的话，则系统默认提供一个<strong>空参的构造器</strong></li>
<li>构造器<strong>不可定义返回值</strong>，其实构造器的作用就是返回引用的地址值，因此不能自定义</li>
<li>定义构造器的格式：<code>权限修饰符  类名(形参列表)&#123;&#125;</code></li>
<li>一个类中定义的<strong>多个构造器</strong>，彼此<strong>构成重载</strong></li>
<li>一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</li>
<li>一个类中，<strong>至少会有一个构造器</strong></li>
</ul>
<hr>
<ul>
<li><p><strong>属性赋值</strong>的先后顺序：默认初始化 —&gt; 显示初始化 —&gt; 构造器初始化 —&gt; 属性或方法调用赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>);<span class="comment">//name：null - &gt; &quot;Tom&quot;</span></span><br><span class="line">p.setName(<span class="string">&quot;Deng&quot;</span>);<span class="comment">//name: &quot;Deng&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        name = str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        name = str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>JavaBean</strong>：由java语言编写的<strong>可重用组件</strong></p>
<ul>
<li>类是公共的</li>
<li>有一个公共的无参构造器</li>
<li>有属性，且含属性对应的get和set方法</li>
</ul>
</li>
<li><p><strong>this关键字</strong>：this理解为“<strong>当前创建的对象</strong>”，谁掉它，谁就是this</p>
<ul>
<li><p><strong>调用的结构</strong>：适用于，<strong>属性、方法；构造器</strong></p>
<ul>
<li><p><strong>属性、方法</strong>：解决形参与属性<strong>同名</strong>时，通过<strong>this特指类成员</strong>的属性/方法</p>
<ul>
<li>格式：<code>this.field; 或 this.method();</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;<span class="comment">//同名解决</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>* **构造器**：用于**构造器中调用其他重载构造器**，常用于解决重载构造器代码冗余问题

  * 格式：`this(); //调用空参构造器`
  * 构造器中**不能**通过this调用构造器产生**死循环回调**
    1. 构造器中不能通过调用自己
    1. 同理如类中有n个构造器，则最多有 n - 1构造器中使用了&quot;this(形参列表)&quot;
  * 构造器中&quot;this(形参列表)&quot;必须声明在当前**构造器的首行**
  * 构造器内部，**只能使用一次**this调用其他构造器

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需求：&quot;Person初始化时，需要考虑如下的1,2,3,4...(共40行代码)&quot;;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//通过在空参构造器中书写“1,2,3,4...(共40行代码)”</span></span><br><span class="line">		System.out.println(info);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>();<span class="comment">//其他构造器调用空参构造器逻辑即可</span></span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>();<span class="comment">//其他构造器调用空参构造器逻辑即可</span></span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(age);<span class="comment">//还可以通过形参指定构造器调用</span></span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li><p><strong>UML简述</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE回炉-UML简述.png"
                      style="zoom:80%;" /
                >
</li>
<li><p><strong>package关键字</strong></p>
<ul>
<li>为了<strong>方便管理</strong>项目中的<strong>类</strong>，提供包的概念，一个包含多个类</li>
<li>使用package声明类或接口所属的包时，应声明在<strong>头部</strong></li>
</ul>
<hr>
<ul>
<li><strong>MVC设计常用包定义</strong><ul>
<li><strong>Model</strong> 模型层：处理数据<ul>
<li>数据对象封装：model.bean/domain</li>
<li>数据库操作类：model.dao</li>
<li>数据库：model.db</li>
</ul>
</li>
<li><strong>Controller</strong> 控制层：处理业务逻辑<ul>
<li>应用界面相关：controller.activity</li>
<li>存放fragment：controller.fragment</li>
<li>显示列表的适配器：controller.adapter</li>
<li>服务相关的：controller.service</li>
<li>抽取的基类：controller.base</li>
</ul>
</li>
<li><strong>View</strong> 视图层： 显示数据<ul>
<li>相关工具类：view.utils</li>
<li>自定义view：view.ui</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>import关键字</strong></p>
<ul>
<li><p>在源文件中显式的使用import结构<strong>导入指定包</strong>下的<strong>类、接口</strong></p>
</li>
<li><p>声明在<strong>包</strong>的声明和<strong>类</strong>的声明<strong>之间</strong></p>
</li>
<li><p>可以使用”xxx.*”的(通配符)方式，表示可以导入xxx包下的**所有结构 **<code>import java.util.*;</code></p>
</li>
<li><p>如果使用的类或接口是<strong>java.lang包</strong>下定义的，则<strong>可以省略import</strong>结构</p>
</li>
<li><p>如果在源文件中，使用了<strong>不同包</strong>下的<strong>同名的类</strong>，则必须<strong>至少一个</strong>类需要以<strong>全类名</strong>的方式显示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若存在com.test.java1.Account与com.test.java2.Account</span></span><br><span class="line"><span class="comment">//想同时使用不同包下的Account类则至少一个使用全类名的方式使用</span></span><br><span class="line"><span class="keyword">import</span> com.test.java1;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Account acct = <span class="keyword">new</span> Account();<span class="comment">//使用了com.test.java1</span></span><br><span class="line">        <span class="comment">//通过全类名的方式指定使用</span></span><br><span class="line">        com.test.java2.Account acct2 = <span class="keyword">new</span> com.test.java2.Account();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用”xxx.*”方式表明可以调用xxx包下的所结构。但是如果使用的是<strong>xxx子包下的结构</strong>，则仍需要<strong>显式导入</strong></p>
<ul>
<li><p><strong>子包</strong>：如存在<code>存在 com.test.java1与com.test.java1.son</code>，则son属于<code>com.test.java1</code>的子包</p>
<p>即就算<code>import com.test.java1;</code>若使用<code>com.test.java1.son</code>仍需显式导入</p>
</li>
</ul>
</li>
<li><p>import static:<strong>导入</strong>指定类或接口中的<strong>静态结构</strong>(非类结构)，而是静态的<strong>属性和方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如JDK中System类</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;<span class="comment">//此时所有System静态的书写和方法都被导入</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//此时使用打印语句可以省略System</span></span><br><span class="line">out.println(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li><strong>继承的效果</strong>(extends：<strong>延展、扩展</strong>)：<ul>
<li>若子类继承父类后，子类A中就<strong>获取</strong>了父类B中声明的<strong>所有</strong>的<strong>属性和方法</strong>(包括间接父类)。包括<strong>private私有</strong>属性和方法。</li>
<li>注意，子类获取父类属性和方法肯定是<strong>全部获取</strong>到了，但<strong>子类调用</strong>父类的属性和方法时<strong>受父类的权限修饰符影响</strong>。不能直接调用private修是的类成员。<strong>因此</strong>，继承应理解为子类对父类在<strong>调用角度上</strong>的<strong>扩展</strong>，<strong>而非代码的直接import，或copy</strong>。</li>
<li><strong>创建子类</strong>的对象，在<strong>堆空间</strong>中，就会<strong>加载</strong>所有<strong>父类中声明的属性和方法</strong></li>
</ul>
</li>
<li><strong>继承的作用</strong><ul>
<li><strong>减少</strong>了代码的<strong>冗余</strong>，<strong>提高</strong>了代码的<strong>复用性</strong><ul>
<li>便于<strong>功能的扩展</strong></li>
<li>为之后<strong>多态性</strong>的使用，提供了<strong>前提</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p><strong>继承的使用</strong></p>
<ul>
<li><p><strong>继承的格式</strong>：<code>class A extends B&#123;&#125;</code>，若B is A == true ，在逻辑上符合继承</p>
<ul>
<li>A：子类、派生类、<strong>sub</strong>class</li>
<li>B：父类、超类、基类、<strong>super</strong>class</li>
</ul>
<ul>
<li><p><strong>Java的单继承性</strong>：一个类<strong>只能有一个父类</strong>，但可<strong>多层单继承</strong>。</p>
<ul>
<li>子类<strong>直接继承</strong>的父类称为，<strong>直接父类</strong></li>
<li>子类<strong>间接继承</strong>的父类称为，<strong>间接父类</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-java%E7%B1%BB%E5%8D%95%E7%BB%A7%E6%89%BF%E6%80%A7.jpg"
                     
                ></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Object类</strong></p>
<ul>
<li>若<strong>没显式的声明</strong>一个类的父类的话，则<strong>此类继承于java.lang.Object类</strong></li>
</ul>
<ol start="2">
<li>因此除java.lang.Object类，<strong>所有java类</strong>都<strong>直接或间接</strong>的继承于java.lang.<strong>Object类</strong></li>
<li>意味着，所有java类具有java.lang.Object类声明的功能。</li>
</ol>
</li>
<li><p><strong>重写</strong>(override/overwrite)：子类继承父类以后，可以<strong>对父类</strong>中<strong>同名同参</strong>的<strong>方法</strong>，进行<strong>覆盖操作</strong></p>
<ul>
<li><p><strong>只能重写方法，</strong>属性无重写之说</p>
<blockquote>
<p>若<strong>子类</strong>与<strong>父类</strong>声明<strong>同名属性</strong>，则子类非多态实例化时，按就近原则调用<strong>自己(子类)定义</strong>的同名属性</p>
</blockquote>
<ul>
<li><strong>子类重写</strong>的方法的<strong>权限修饰符</strong>  <strong>≥ 父类</strong>被重写方法的权限修饰符</li>
</ul>
</li>
<li><p><strong>子类不能重写</strong>，父类中声明为<strong>private</strong>权限的方法</p>
<ul>
<li><p>返回值类型</p>
<ul>
<li><strong>父类</strong>被重写的返回值类型<strong>是void</strong>，则子类重写的方法的返回值类型<strong>只能是void</strong></li>
<li><strong>父类</strong>被重写的返回值类型是<strong>A类型</strong>(引用数据类型)，则<strong>子类</strong>重写的返回值类型可以是<strong>A类或A类的子类</strong></li>
<li>父类被重写的返回值类型是<strong>基本数据类型</strong>(如double)，则子类重写的返回值类型<strong>必须是相同</strong>(必需是double)</li>
</ul>
</li>
<li><p><strong>子类重写</strong>的方法<strong>抛出的异常类型</strong> <strong>≤ 父类</strong>被重写的方法<strong>抛出的异常类型</strong></p>
</li>
<li><p>父类被<strong>static</strong>修饰的属性和方法<strong>不能被重写</strong>。但<strong>可以</strong>在子类中声明<strong>同名同参的static</strong>属性和方法(但此时<strong>不是重写</strong>)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>super关键字</strong>：指调用父类的结构</p>
<ul>
<li><p><strong>调用的结构</strong>：类this关键字，同样适用于，<strong>属性、方法；构造器</strong></p>
</li>
<li><p>super关键字定位父类结构，默认先按直接父类到间接父类一层层往上找，一旦匹配则结束</p>
<hr>
</li>
<li><p><strong>属性，方法相关</strong>：</p>
</li>
<li><p>常用于在子类中调用<strong>父类同名的属性</strong>(属性无重写之说)</p>
</li>
<li><p>常用在子类中调用<strong>父类被重写的方法</strong></p>
<hr>
</li>
<li><p><strong>构造器相关</strong>：</p>
</li>
<li><p>可以在子类的构造器中显式的使用”super(形参列表)”的方式，<strong>调用父类</strong>中声明的<strong>指定的构造器</strong></p>
</li>
<li><p>super(形参列表)”的使用，必须声明在<strong>子类构造器</strong>的<strong>首行</strong></p>
</li>
<li><p>this与super调用构造器<strong>只能二选一</strong>，<strong>不能同时出现</strong></p>
<hr>
<p>在子类构造器的首行，没显式的声明”this(形参列表)”或”super(形参列表)”，则<strong>默认调用</strong>的是<strong>父类中空参的构造器</strong></p>
</li>
<li><p>在类的多个构造器中，<strong>至少一个构造器</strong>中使用了”super(形参列表)”，<strong>调用父类中的构造器</strong></p>
</li>
</ul>
</li>
<li><p><strong>子类对象实例化过程</strong></p>
<ul>
<li>子类对象创建时，<strong>系统一定</strong>会<strong>直接或间接</strong>的<strong>调用其父类的构造器</strong>，进而调用父类的父类的构造器，…<strong>直到</strong>调用了java.lang.<strong>Object类</strong>中<strong>空参的构造器</strong>为止。同时，正因为加载过所有直接或间接父类的结构，所以才可以看到内存中这些父类中的结构，子类对象也才可以调用所有父类的属性和方法</li>
<li>虽然创建子类对象时，调用了父类的构造器，但是<strong>自始至终就创建过一个对象</strong>，即为new的子类对象。</li>
</ul>
</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li><p><strong>何为多态</strong>：多态是<strong>一个行为</strong>具有<strong>多个不同</strong>表现<strong>形式或形态</strong>的能力</p>
<ul>
<li>代码语法层面看，多态指，<strong>父类的引用</strong>指向<strong>子类的对象</strong>，同时对<strong>父类</strong>进行<strong>虚拟方法调用</strong></li>
<li>菜鸟教程：多态就是<strong>同一个接口</strong>，使用<strong>不同的实例</strong>而<strong>执行不同操作</strong></li>
</ul>
</li>
<li><p><strong>多态性的使用</strong>：</p>
<ul>
<li><p>多态使用书写：<strong>父类的引用</strong>指向<strong>子类的对象</strong>，<code>Person p = new Man();</code></p>
</li>
<li><p>编译期，<strong>只能</strong>调用<strong>父类中</strong>声明<strong>属性和方法</strong></p>
</li>
<li><p>运行期：</p>
<ul>
<li><p>属性：<strong>父类的属性</strong>(属性无重写即无多态 ; 可通过向下转型调用子类的内容)</p>
</li>
<li><p>方法：<strong>父类</strong>声明的方法，若方法<strong>被子类重写</strong>则<strong>调用子类重写的方法</strong>(虚拟方法调用)</p>
<blockquote>
<p>一般多态的使用，主要集中在虚拟方法的调用，因为一般子类继承父类都常重写父类的特定方法。因此粗略归纳多态的使用条件可以有两点</p>
<ul>
<li>类的继承关系</li>
<li>方法的重写</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>注意，内存实际上加载了子类特有的属性和方法，但是由于变量声明为父类类型，导致编译时只能调用父类声明的属性和方法</p>
</li>
</ul>
</li>
<li><p><strong>多态的作用</strong></p>
<ul>
<li><p>消除类型之间的耦合关系</p>
</li>
<li><p>可替换性</p>
</li>
<li><p>可扩充性，(自带，归类分配控制器，减少编写重载方法)</p>
</li>
<li><p>接口性</p>
</li>
<li><p>灵活性</p>
</li>
<li><p>简化性</p>
<blockquote>
<p>多态的作用与优点不仅几段文字描述，需从面向对象程序设计思想中学习多态的作用</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;动物，在进食&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;动物，在跑&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Dog，在进食&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Dog，在跑&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Cat，在进食&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Cat，在跑&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Animal a = <span class="keyword">new</span> Dog();</span><br><span class="line">		active(a);<span class="comment">//输出：Dog，在进食，Dog，在跑</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//多态的使用，只需编写一个方法，减少重载方法的编写</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">active</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">		animal.eat();</span><br><span class="line">		animal.run();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//若不使用多态</span></span><br><span class="line"><span class="comment">//	public static void active(Dog dog)&#123;</span></span><br><span class="line"><span class="comment">//		dog.eat();</span></span><br><span class="line"><span class="comment">//		dog.run();</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	public static void active(Cat cat)&#123;</span></span><br><span class="line"><span class="comment">//		cat.eat();</span></span><br><span class="line"><span class="comment">//		cat.run();</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重载与重写的区别</strong></p>
<ul>
<li><p><strong>重载</strong>：不表现为多态性</p>
<p>​    对于编译器而言，这些同名方法就成了不同的方法。在方法调用之前，<strong>编译器</strong>就已经确定了所要调用的方法，这称为“<strong>早绑定</strong>”或“<strong>静态绑定</strong>”；属于一个<strong>编译型行为</strong>。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。</p>
</li>
<li><p><strong>重写</strong>：表现为多态性</p>
<p>​    对于多态，只有等到方法调用的那一刻，<strong>解释运行器</strong>才会确定所要调用的具体方法，这样的方法调用在编译时其无法确定，称为“<strong>晚绑定</strong>”或“<strong>动态绑定</strong>”。属于一个<strong>运行时行为</strong></p>
</li>
</ul>
<blockquote>
<p>引用一句Bruce Eckel的话：“不要犯傻，如果它不是<strong>晚绑定</strong>，它就不是<strong>多态</strong>！”</p>
</blockquote>
</li>
<li><p><strong>多态的向下转型</strong></p>
<ul>
<li>多态的Java类可通过 <code>()</code>进行强制向下转型，通常情况，强转之前先用<code>instanceof</code> 关键字判别一下再转，否则不兼容类型强转会报出 ClassCastException 异常</li>
<li>向下转型后的对象是子类对象的引用与实例，此时则可调用子类特用的属性和方法</li>
<li><strong>instancof关键字</strong>：<ul>
<li><code>a instanceof A</code>：判断<strong>对象a</strong>是否是<strong>类A的实例</strong>。如果是，<strong>返回true</strong>；否则返回false。</li>
<li>若<code>a instanceof A == true</code>，则A类及其A类<strong>所有直接间接父类</strong>(顶级父类Object)<strong>都返回true</strong>，多态实例也是实例</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE回炉-java8-多态向下上转型.jpg"
                      style="zoom: 80%;" /
                >

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用上述例子的Animal、Dog、Cat类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Animal a = <span class="keyword">new</span> Dog();</span><br><span class="line">        <span class="comment">//强制向下转型</span></span><br><span class="line">        Dog dog = (Dog)a;<span class="comment">//通过</span></span><br><span class="line">        Cat cat = (Cat)a;<span class="comment">//报错</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;向下转型成功，此对象为Dog&quot;</span>);<span class="comment">//正常输出</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练习</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//问题一：编译时通过，运行时不通过</span></span><br><span class="line">		<span class="comment">//举例一：</span></span><br><span class="line"><span class="comment">//	Person p3 = new Woman();</span></span><br><span class="line"><span class="comment">//	Man m3 = (Man)p3;</span></span><br><span class="line">	<span class="comment">//举例二：</span></span><br><span class="line"><span class="comment">//	Person p4 = new Person();</span></span><br><span class="line"><span class="comment">//	Man m4 = (Man)p4;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//问题二：编译通过，运行时也通过</span></span><br><span class="line"><span class="comment">//	Object obj = new Woman();</span></span><br><span class="line"><span class="comment">//	Person p = (Person)obj;</span></span><br><span class="line">		</span><br><span class="line">	<span class="comment">//问题三：编译不通过</span></span><br><span class="line"><span class="comment">//	Man m5 = new Woman();</span></span><br><span class="line"><span class="comment">//	String str = new Date();</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldMethodTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Sub s = <span class="keyword">new</span> Sub();</span><br><span class="line">		System.out.println(s.count);<span class="comment">//20</span></span><br><span class="line">		s.display();<span class="comment">//20</span></span><br><span class="line">		</span><br><span class="line">		Base b = s;<span class="comment">//多态性</span></span><br><span class="line">		<span class="comment">//==：对于引用数据类型来讲，比较的是两个引用数据类型变量的地址值是否相同</span></span><br><span class="line">		System.out.println(b == s);<span class="comment">//true</span></span><br><span class="line">		System.out.println(b.count);<span class="comment">//10</span></span><br><span class="line">		b.display();<span class="comment">//20</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><ul>
<li><p><strong>基础说明</strong></p>
<ul>
<li>java.lang.Object类是所Java类的<strong>根父类</strong>，<strong>所有类</strong>的直接或间接地继承它<ul>
<li>因此Object类中的功能(属性、方法)就具<strong>通用性</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Object部分功能</strong>：无属性，方法 + 构造器</p>
<ul>
<li><p>Object类只声明了一个空参的构造器(所有对象实例化都调用)</p>
<hr>
</li>
<li><p><strong>clone</strong>()：对象克隆</p>
</li>
<li><p><strong>finalize</strong>()：对象垃圾回收之前被系统自动调用，一般不主动调用</p>
</li>
<li><p><strong>getClass</strong>()：获取对象的类，反射相关</p>
</li>
<li><p>hashCode()：集合相关</p>
</li>
<li><p>wait、notify、notifyAll：线程相关</p>
</li>
<li><p>…</p>
<hr>
</li>
</ul>
</li>
<li><p><strong>当前重点的Object功能</strong>：equals(Object)、toString()</p>
<ul>
<li><p>两者重写都可以通过eclipse快速生成</p>
</li>
<li><p><strong>equals</strong> 与 == 的使用</p>
<hr>
<ul>
<li><strong>Object类</strong>equals功能：与 == 的<strong>作用是相同</strong>的，比较<strong>两个对象</strong>的<strong>地址值是否相同</strong></li>
<li>常重写equals后功能：比较两个引用类型<strong>实体内容</strong>是否相等</li>
</ul>
<hr>
<ul>
<li><p><strong>==</strong> ： 是个<strong>运算符</strong>、可以使用在<strong>基本数据</strong>类型和<strong>引用数据</strong>类型</p>
<ul>
<li><p><strong>基本数据类型</strong>：<strong>数值</strong>上的相等(类型不一定一样，底层是数值即可、因为会自动类型转换)</p>
</li>
<li><p><strong>引用数据类型</strong>：引用的地址值是否相等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、基本数据类型：数值</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">10.0</span>;</span><br><span class="line">System.out.println(i == d);<span class="comment">//输出true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、引用数据类型：地址值(数值)</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>,<span class="number">21</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>,<span class="number">21</span>);</span><br><span class="line">System.out.println(p1 == p2);<span class="comment">//输出false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>boolean <strong>equals</strong>(Object)：是个<strong>方法</strong>，<strong>只能</strong>使用在<strong>引用数据类型中</strong>，只要用于(自定义)对比<strong>引用数据类型</strong>中<strong>内容</strong>是否相等。常提供子类对equals方法进行重写来实现自定义实体内容相等判别效果</p>
<ul>
<li><p>Object类中的equals(<strong>)源码</strong>定义：Object原生功能与 == 的<strong>作用是相同</strong>的，比较<strong>两个对象</strong>的<strong>地址值是否相同</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>String、Date、File、包装类等都重写了Object类中的equals()方法：被重写成<strong>实体内容</strong>是否相等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//1、未重写Object equals()方法：等同==，比较两个引用地址值</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>,<span class="number">21</span>);</span><br><span class="line">    Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>,<span class="number">21</span>);</span><br><span class="line">    System.out.println(p1.equals(p2));<span class="comment">//输出false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、某java提供类重写了equals()实现了比较实体内容是否相等的功能</span></span><br><span class="line">    String s1 = <span class="keyword">new</span> String(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">    String s2 = <span class="keyword">new</span> String(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">    System.out.println(s1.equals(s2));<span class="comment">//输出true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里主要通过String new的方式说明源码重写了String的equals方法</span></span><br><span class="line">    <span class="comment">//但通过 == 的方式直接创建字符串会因字符串常量池原理而出现== 为true情况</span></span><br><span class="line">    <span class="comment">//String s3 = &quot;ABC&quot;;</span></span><br><span class="line">    <span class="comment">//String s4 = &quot;ABC&quot;;</span></span><br><span class="line">    <span class="comment">//System.out.println(s3 == s4);//输出true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、自定义重写equals方法实现自定义类实体内容上的比较</span></span><br><span class="line">    <span class="comment">//简陋版</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">if</span>(<span class="keyword">this</span> == obj)</span><br><span class="line">    			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    		</span><br><span class="line">    		<span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">    			Person anObj = (Person)obj;</span><br><span class="line">    			<span class="keyword">return</span> <span class="keyword">this</span>.name.equals(anObj.name) &amp;&amp; <span class="keyword">this</span>.age == anObj.age;</span><br><span class="line">    		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(p1.equals(p2));<span class="comment">//输出true</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//eclipse自动生成equals方法(标准高效参考)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">        Person other = (Person) obj;</span><br><span class="line">        <span class="keyword">if</span> (age != other.age)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (other.name != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>String，equals方法重写源代码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line"> 		<span class="comment">//1、若引用地址都一样，则内容肯定一样(重写equals通用代码)</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    	<span class="comment">//2、若与String比较的传入类型不是String，则不允许，返回false</span></span><br><span class="line">   <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">           String anotherString = (String)anObject;</span><br><span class="line">       <span class="keyword">int</span> n = value.length;<span class="comment">//String底层通过char [] value;数组存储</span></span><br><span class="line">           <span class="comment">//3、若字符序列的长度都不一样，则内容肯定不一样</span></span><br><span class="line">           <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">               <span class="keyword">char</span> v1[] = value;</span><br><span class="line">               <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">               <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">               <span class="comment">//4、挨个字符比较</span></span><br><span class="line">             <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                   i++;</span><br><span class="line">             &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">      </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>eclipse自动生成equals重写源码分析</strong>：</p>
<ul>
<li><p>SSS</p>
</li>
<li><p><strong>重写equals()方法原则</strong></p>
</li>
<li><p><strong>Null-false</strong>：任何情况下，x.equals(null)，永远返回是“false” </p>
<ul>
<li><strong>类型一致</strong>：x.equals(和x不同类型的对象)永远返回是“false”</li>
</ul>
</li>
<li><p><strong>对称性</strong>：如果x.equals(y)返回是“true” ，那么y.equals(x)也应该返回是 “true”</p>
<ul>
<li><strong>自反性</strong>：x.equals(x)必须返回是“true”</li>
<li><strong>传递性</strong>：如果x.equals(y)返回是“true” ，而且y.equals(z)返回是“true” ， 那么z.equals(x)也应该返回是“true”</li>
<li><strong>一致性</strong>：如果x.equals(y)返回是“true” ，只要x和y内容一直不变，不管你 重复x.equals(y)多少次，返回都是“true”</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>toString</strong>：</p>
<hr>
<ul>
<li><strong>Object类</strong>toString功能：输出<strong>类名及其堆空间存储地址</strong>(虚拟地址)<ul>
<li>System.out.<strong>println</strong>(引用数据类型)输出语句，底层也是<strong>调用toString</strong></li>
</ul>
</li>
<li>常重写toString后功能：<strong>打印</strong>引用类型<strong>实体的内容</strong></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>当<strong>输出</strong>一个<strong>对象的引用</strong>时，实际上就是调用当前对象的<strong>toString</strong>()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;ABV&quot;</span>, <span class="number">10</span>);</span><br><span class="line">System.out.println(p1); <span class="comment">//输出：com.yhd.test.Person@15db9742</span></span><br><span class="line">System.out.println(p1.toString()); <span class="comment">//输出：com.yhd.test.Person@15db9742</span></span><br></pre></td></tr></table></figure>

<ul>
<li>源码分析</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PrintStream.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">      String s = String.valueOf(x); <span class="comment">//主要通过调用了String.valueOf();</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            print(s);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//String.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (obj == <span class="keyword">null</span>) ? <span class="string">&quot;null&quot;</span> : obj.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>Object</strong>类中toString()的<strong>源码</strong>定义：输出<strong>类名及其堆空间存储地址</strong>(虚拟地址)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//类名 + 堆空间存储地址(通过hashCode计算出来数值并转换为十六进制的)</span></span><br><span class="line">   <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：Java中的地址都是虚拟地址，操作系统之上的JVM，非真实的物理地址</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>String、Date、File、包装类等都重写了Object类中的toString()方法</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul>
<li><p><strong>基本含义</strong>：为了使基本数据类型的变量具有类的特征。java提供8种基本数据类型的包装类，这些包装类可以完成对应基本数据类型的所有功能操作(都含对应基本数据类型的value属性)。同时，因为封装成类，还可提供各种丰富的方法调用。</p>
</li>
<li><p><strong>自动装箱与拆箱</strong>(JDK5.0)：</p>
</li>
<li><p>小结：</p>
<ul>
<li>基本数据类型 &lt;—&gt; 包装类：自动/手动(构造器)装拆箱</li>
<li>数值(基本数据+包装) &lt;—&gt; String：调类(包装类/String类)的重载方法，</li>
</ul>
</li>
</ul>
<p>​    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-%E5%8C%85%E8%A3%85%E7%B1%BB.png"
                     
                ></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、基本数据类型 ——&gt; 包装类</span></span><br><span class="line">    <span class="comment">//1、手动装箱：构造器封装/创建</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    Integer itg1 = <span class="keyword">new</span> Integer(i);</span><br><span class="line">    Integer itg2 = <span class="keyword">new</span> Integer(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="comment">//Integer itg3 = new Integer(&quot;2B&quot;);//异常：数字格式/匹配异常</span></span><br><span class="line">    System.out.println(<span class="string">&quot;itg1: &quot;</span> + itg1 + <span class="string">&quot; , itg2：&quot;</span> + itg2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、自动装箱</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    Integer j_itg1 = j;</span><br><span class="line">    System.out.println(<span class="string">&quot;j_itg1: &quot;</span> + j_itg1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、包装类 ——&gt; 基本数据类型(多种类型)</span></span><br><span class="line">    <span class="comment">//1、手动拆箱：调用包装类的 xxxValue();方法</span></span><br><span class="line">    Float flt = <span class="keyword">new</span> Float(<span class="number">1F</span>);</span><br><span class="line">    <span class="keyword">float</span> f = flt.floatValue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、自动拆箱</span></span><br><span class="line">    <span class="keyword">float</span> f2 = flt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有了自动拆装箱的便利，基本可以成整体</span></span><br><span class="line"><span class="comment">//3、[数值型] —— &gt; String</span></span><br><span class="line">    <span class="comment">//方式1：与空串 &quot;&quot; 进行连接运算</span></span><br><span class="line">    String s1 = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式2：调用String重载的valueOf(XXX xxx) 重载方法</span></span><br><span class="line">    String s2 = String.valueOf(i);<span class="comment">//基本数据类型</span></span><br><span class="line">    s2 = String.valueOf(itg1);<span class="comment">//包装类/obj多态传入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式3：调用包装类的toStrin方法</span></span><br><span class="line">    s2 = itg1.toString();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、String ——&gt; [数值型]</span></span><br><span class="line">    <span class="comment">//方式1：调用包装类parseXxx()方法</span></span><br><span class="line">    String s3 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> num1 = Integer.parseInt(s3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//tips：除了boolean，其他有关字符串的装拆箱，与转换若存在字符匹配问题都会报错，需注意</span></span><br></pre></td></tr></table></figure>



<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul>
<li><strong>可修饰结构</strong>：属性、方法、代码块、内部类</li>
</ul>
<h3 id="修饰属性"><a href="#修饰属性" class="headerlink" title="修饰属性"></a>修饰属性</h3><ul>
<li><p>被static修饰的变量称为<strong>静态变量</strong>或<strong>类变量</strong>，该变量将会被同一个类多个对象共享。某个对象改变该静态变量，类中所有对象的该变量斗会被改变(因为共用一份)</p>
</li>
<li><p>静态变量随着<strong>类的加载而加载</strong>。可以<strong>直接通过类名</strong>进行调用”<code>类.静态变量</code>“</p>
<ul>
<li>静态变量的加载要<strong>早于对象的创建</strong></li>
<li>由于<strong>类只会加载一次</strong>，则静态变量在内存中也<strong>只会存在一份</strong>：存在<strong>方法区的静态域</strong>中</li>
<li>静态属性举例：<code>System.out; Math.PI;</code></li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE回炉-静态变量内存解析.jpg"
                      style="zoom:80%;" /
                >



<h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h3><ul>
<li>同样随着类的加载而加载，可以通过”<code>类.静态方法</code>“的方式进行调用</li>
<li><strong>静态方法</strong>中，<strong>只能</strong>调用<strong>静态的方法或属性</strong>(因为静态方法和属性比对象<strong>加载的早</strong>)<ul>
<li>同理：在静态的方法内，<strong>不能使用this关键字、super</strong>关键字(因为这些都是创建对象使用的关键字)</li>
</ul>
</li>
<li><strong>非静态方法</strong>中，<strong>既可</strong>以调用非静态的方法或属性，<strong>也可</strong>以调用静态的方法或属性</li>
</ul>
<h3 id="静态属性和方法应用场景"><a href="#静态属性和方法应用场景" class="headerlink" title="静态属性和方法应用场景"></a>静态属性和方法应用场景</h3><ul>
<li><p><strong>属性</strong>：</p>
<ul>
<li>当属性是可以被多个<strong>对象共享</strong>的，<strong>不会随着对象的不同而不同</strong>的</li>
<li>类中的<strong>常量</strong>也常常声明为static</li>
</ul>
</li>
<li><p><strong>方法</strong>：</p>
<ul>
<li><strong>操作静态属性</strong>的方法，通常设置为static的</li>
<li><strong>工具类</strong>中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections</li>
</ul>
<hr>
</li>
<li><p><strong>常见应用</strong>：单例模式，懒汉式、饿汉式</p>
<ul>
<li><strong>单例模式</strong>：采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</li>
</ul>
<blockquote>
<p>若让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为<strong>private</strong>，这样，就不能用new操作符在类的外部产生 类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的<strong>某个静态方法</strong>以返回类内部创建的对象， <strong>静态方法只能访问类中的静态成员变量</strong>，所以，指向类内部产生的该类对象 的变量也必须定义成静态的。</p>
</blockquote>
<ul>
<li><strong>两种单例模式编写</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、(简单/不安全)懒汉式：什么时候用，什么时候创建</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//1、构造器私有化</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Bank instance;<span class="comment">//2、静态化</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="comment">//2、静态化</span></span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">			instance = <span class="keyword">new</span> Bank();</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、饿汉式：不管什么，先创建再说</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//1、构造器私有化</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">new</span> Order();<span class="comment">//2、直接实例化(静态只有一份)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>懒汉式和饿汉式的对比<ul>
<li><strong>饿汉式</strong>：<ul>
<li>缺点：对象加载时间过长</li>
<li>优点：线程安全</li>
</ul>
</li>
<li><strong>懒汉式</strong>：<ul>
<li>缺点：目前写法线程不安全(两个线程挤入if == null)</li>
<li>优点：延迟对象的创建</li>
</ul>
</li>
</ul>
</li>
<li><strong>常见单例模式应用场景</strong><ul>
<li>网站的计数器，一般也是单例模式实现，否则难以同步</li>
<li>应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志 文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加</li>
<li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库 资源</li>
<li>项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置 文件数据，都生成一个对象去读取</li>
<li>Application 也是单例的典型应用</li>
<li>Windows的Task Manager (任务管理器)就是很典型的单例模式</li>
<li>Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程 中，回收站一直维护着仅有的一个实例。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><p><strong>基本含义</strong>：</p>
<ul>
<li>main()方法作为程序的入口</li>
<li>main()方法也是一个普通的静态方法</li>
<li>main()方法可以作为我们与控制台<strong>交互的方式</strong>（如之前使用Scanner的方式）</li>
</ul>
<p><strong>将控制台获取的数据传入main函数形参</strong>String[] args：</p>
<ul>
<li><p>eclipse交互：</p>
<ul>
<li><strong>1</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-eclipse%E6%96%B9%E5%BC%8F%E4%B8%8Emain%E5%BD%A2%E5%8F%82%E4%BA%A4%E4%BA%921.jpg"
                     
                ></p>
<ul>
<li><p><strong>2</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-eclipse%E6%96%B9%E5%BC%8F%E4%B8%8Emain%E5%BD%A2%E5%8F%82%E4%BA%A4%E4%BA%922.jpg"
                     
                ></p>
</li>
</ul>
</li>
</ul>
<p>​    </p>
<ul>
<li><p>控制台交互：</p>
<ul>
<li><p>注意：记事本方式javac编译需把 packeage 代码去掉</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE回炉-控制台方式与main形参交互.jpg"
                      style="zoom:150%;" /
                >



</li>
</ul>
</li>
</ul>
<p>运行时：java 类名 “Tom” “Jerry” “123” “true”</p>
<p>sysout(args[0]);//“Tom”<br>sysout(args[3]);//“true”  –&gt;Boolean.parseBoolean(args[3]);<br>sysout(args[4]);//报异常</p>
<p>小结：一叶知秋<br>public static void main(String[] args){//方法体}</p>
<p>权限修饰符：private 缺省 protected pubilc —-&gt;封装性<br>修饰符：static \ final \ abstract \native 可以用来修饰方法<br>返回值类型： 无返回值 / 有返回值 –&gt;return<br>方法名：需要满足标识符命名的规则、规范；”见名知意”<br>形参列表：重载 vs 重写；参数的值传递机制；体现对象的多态性<br>方法体：来体现方法的功能</p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ul>
<li><p><strong>代码块使用</strong>：如同方法一般的声明位置，格式为<code>&#123;&#125;</code></p>
</li>
<li><p><strong>代码块的作用</strong>：用来初始化类、对象的信息</p>
</li>
<li><p><strong>代码块的修饰</strong>：只能用static修饰</p>
<ul>
<li>静态代码块：<ul>
<li><strong>随着类的加载</strong>而执行，<strong>且只执行一次</strong></li>
<li>类中定义了多个静态代码块，则按照声明的先后顺序执行(一般只写一个)</li>
</ul>
</li>
<li>非静态代码块<ul>
<li>随着<strong>对象的创建而执行</strong>，每创建一次执行一次</li>
<li>多个非静态代码块，则按照声明的先后顺序执行(一般只写一个)</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>static修饰类同性质<ul>
<li>静态代码块随类的加载而加载一次，非静态随对象创建而加载</li>
<li>静态代码块的执行要优先于非静态代码块的执行</li>
<li>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</li>
<li>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>应用场景</strong></p>
<ul>
<li>静态代码块：常用于不以创建对象而调用方法，即为<strong>静态方法</strong>提供的看似为”<strong>静态构造器</strong>“的作用，完成一种静态的初始化(一次性初始化)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如JDBC连接池</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//一次性初始化/实例化，DataSource 数据库连接池</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		InputStream is = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			is = DBCPTest.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;);</span><br><span class="line">			Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">			pros.load(is);</span><br><span class="line">			<span class="comment">//调用BasicDataSourceFactory的静态方法，获取数据源。</span></span><br><span class="line">			dataSource = BasicDataSourceFactory.createDataSource(pros);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(is != <span class="keyword">null</span>)&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					is.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//使用DBCP数据库连接池获取数据库的连接</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">		Connection conn = dataSource.getConnection();</span><br><span class="line">		System.out.println(conn);</span><br><span class="line">		<span class="keyword">return</span> conn;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>再谈子类对象实例化加载顺序</strong>：</p>
<ul>
<li>无论使静态还是非静态，<strong>代码块</strong>都在<strong>构造器前</strong>执行</li>
<li>由父及子，静态先行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java3;</span><br><span class="line"><span class="comment">//总结：由父及子，静态先行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Root</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的无参数的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mid</span> <span class="keyword">extends</span> <span class="title">Root</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的无参数的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		<span class="comment">//通过this调用同一类中重载的构造器</span></span><br><span class="line">		<span class="keyword">this</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的带参数构造器，其参数值：&quot;</span></span><br><span class="line">			+ msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Mid</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//通过super调用父类中有一个字符串参数的构造器</span></span><br><span class="line">		<span class="keyword">super</span>(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeafTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Leaf(); </span><br><span class="line">		System.out.println();</span><br><span class="line">		<span class="keyword">new</span> Leaf();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果如下：</span></span><br><span class="line"><span class="comment">Root的静态初始化块</span></span><br><span class="line"><span class="comment">Mid的静态初始化块</span></span><br><span class="line"><span class="comment">Leaf的静态初始化块</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Root的普通初始化块</span></span><br><span class="line"><span class="comment">Root的无参数的构造器</span></span><br><span class="line"><span class="comment">Mid的普通初始化块</span></span><br><span class="line"><span class="comment">Mid的无参数的构造器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Mid的带参数构造器，其参数值：尚硅谷</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Leaf的普通初始化块</span></span><br><span class="line"><span class="comment">Leaf的构造器</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代码块属性赋值执行顺序</strong>：系统初始化 —&gt; 显示初始化 / <strong>代码块初始化</strong> —&gt; 构造器初始化 —&gt;外部调用初始化</p>
</li>
</ul>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul>
<li><strong>可修饰结构</strong>：类、方法、变量</li>
</ul>
<hr>
<ul>
<li><strong>类</strong>：此类<strong>不能被其他类所继承</strong>(无子类)，如：String类、System类、StringBuffer类</li>
</ul>
<ul>
<li><p><strong>方法</strong>：表明此方法<strong>不可以被重写</strong>，如：Object类中getClass()</p>
<ul>
<li><p><strong>变量</strong>：称为是一个<strong>常量</strong></p>
<ul>
<li><p><strong>属性</strong>：</p>
<ul>
<li>常量赋值的位置：(只能自动化初始化)显式初始化、代码块中初始化、构造器中初始化</li>
<li>必须初始化，只能使用，不能重新赋值</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>局部变量/形参</strong>：必须初始化，只能使用，不能重新赋值</p>
<ul>
<li>可以数据类型，也可引用类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本数据类型形参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="comment">//i++; //报错，只能使用不能赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用数据类型形参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">(<span class="keyword">final</span> Person p)</span></span>&#123;</span><br><span class="line">    p.age++;<span class="comment">//通过</span></span><br><span class="line">    p = <span class="keyword">new</span> Person();<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>static final 同时修饰</strong>结构交集：属性与方法</p>
<ul>
<li><strong>属性</strong>：全局常量(常见)</li>
<li><strong>方法</strong>：静态方法且不可重写</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="抽像类"><a href="#抽像类" class="headerlink" title="抽像类"></a>抽像类</h2><p>关键字：<strong>abstract</strong>，可修饰结构，<strong>类、方法</strong></p>
<ul>
<li><p>修饰类：<strong>抽象类</strong></p>
<ul>
<li>此类<strong>虽不能实例化，但一定要有构造器</strong>，便于子类实例化时调用（涉及：子类对象实例化的全过程）</li>
<li>开发中，都会<strong>提供抽象类的子类</strong>，让子类对象实例化，完成相关的操作 —&gt;抽象的使用前提：继承性</li>
</ul>
</li>
<li><p>除此之外，抽象类可以定义一般类的成员，如，属性、方法、代码块…</p>
</li>
<li><p>修饰方法：<strong>抽象方法</strong></p>
<ul>
<li><p>抽象方法只有声明，没方法体</p>
<p><code>public abstract void eat();</code></p>
</li>
<li><p>抽象方法只能声明在<strong>抽像类中</strong>。反之，抽象类中可以没有抽象方法的。</p>
</li>
<li><p>继承抽象类的子类<strong>必须强制实现</strong>(重写)所有抽象父类中的<strong>所有的抽象方法</strong>，若<strong>子类也是抽象</strong>类则不用。</p>
</li>
<li><p>补充说明</p>
<ul>
<li><p>abstract不能用来修饰<strong>私有方法</strong>(子类无法重写)、静态方法、final的方法、final的类</p>
</li>
<li><p>抽线类除不能被实例化外，如下<code>Person p = new Person();</code>符合面向对象类的其他定义操作，如继承，多态，子类自身实例化等等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person p = new Person();//不允许</span></span><br><span class="line">Person p = <span class="keyword">new</span> Man();<span class="comment">//允许，假设class Man extends Person </span></span><br><span class="line">Man m = <span class="keyword">new</span> Man();<span class="comment">//允许</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>创建抽象类的匿名子类</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽线类Person</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//书写步骤：Person p = new Person()&#123;&lt;回车&gt;&#125;;</span></span><br><span class="line"><span class="comment">//创建一个匿名子类对象(其实是通过多态的一种方式实现了匿名实例化)</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个匿名子类的匿名对象</span></span><br><span class="line"><span class="comment">//书写：method(new Person()&#123;&lt;回车&gt;&#125;);</span></span><br><span class="line">method(<span class="keyword">new</span> Person()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>常见应用场景</strong></p>
<ul>
<li><p>IO流中设计到的抽象类：InputStream/OutputStream / Reader /Writer。在其内部<br>定义了抽象的read()、write()方法。</p>
</li>
<li><p><strong>模板方法的设计模式</strong></p>
</li>
</ul>
<blockquote>
<p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模 板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象 类的行为方式。 </p>
<p>解决的问题：</p>
<ul>
<li>当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以 把不确定的部分暴露出去，让子类去实现。</li>
<li>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用， 这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽 象出来，供不同子类实现。这就是一种模板模式</li>
</ul>
</blockquote>
<ul>
<li>例1</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		TemplateSub ts = <span class="keyword">new</span> TemplateSub();</span><br><span class="line">		ts.spendTime();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模板方法设计模式体现</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spendTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		code();<span class="comment">//易变部分，不确认部分</span></span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;运行时间：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemplateSub</span> <span class="keyword">extends</span> <span class="title">Template</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j=<span class="number">0</span>;i &lt; <span class="number">100000</span>;i++)</span><br><span class="line">			j+=j;</span><br><span class="line">		System.out.println(<span class="string">&quot;代码执行中...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>例2</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类的应用：模板方法的设计模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethodTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		BankTemplateMethod btm = <span class="keyword">new</span> DrawMoney();</span><br><span class="line">		btm.process();</span><br><span class="line"></span><br><span class="line">		BankTemplateMethod btm2 = <span class="keyword">new</span> ManageMoney();</span><br><span class="line">		btm2.process();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTemplateMethod</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 具体方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;取号排队&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">transact</span><span class="params">()</span></span>; <span class="comment">// 办理具体的业务 //钩子方法</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evaluate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;反馈评分&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模板方法，把基本操作组合到一起，子类一般不能重写</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.takeNumber();</span><br><span class="line">		<span class="keyword">this</span>.transact();<span class="comment">// 像个钩子，具体执行时，挂哪个子类，就执行哪个子类的实现代码</span></span><br><span class="line">		<span class="keyword">this</span>.evaluate();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DrawMoney</span> <span class="keyword">extends</span> <span class="title">BankTemplateMethod</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我要取款！！！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManageMoney</span> <span class="keyword">extends</span> <span class="title">BankTemplateMethod</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我要理财！我这里有2000万美元!!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>场景应用场景</li>
</ul>
<p>模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的 影子，比如常见的有：</p>
<ul>
<li>数据库访问的封装</li>
<li>Junit单元测试</li>
<li>JavaWeb的Servlet中关于doGet/doPost方法调用</li>
<li>Hibernate中模板程序</li>
<li>Spring中JDBCTemlate、HibernateTemplate等</li>
</ul>
</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote>
<ul>
<li>一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又 没有is-a的关系，仅仅是具有<strong>相同的行为特征</strong>而已。例如：鼠标、键盘、打 印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都 支持USB连接。</li>
<li>另一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。</li>
</ul>
<p>接口就是<strong>规范</strong>，定义的是<strong>一组规则</strong>，体现了现实世界中“如果你是/要…则 必须能…”的思想。继承是一个”是不是”的关系，而接口实现则是 “能不能” 的关系。 </p>
<p>接口的本质是<strong>契约，标准，规范</strong>，就像我们的法律一样。制定好后大家都要遵守</p>
<p>接口聚焦点在<strong>行为</strong>，是相同的<strong>行为</strong></p>
<p>同抽象类，接口也体现多态性</p>
</blockquote>
<ul>
<li><p><strong>例1</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-%E6%8E%A5%E5%8F%A3%E4%B8%BE%E4%BE%8B01.jpg"
                     
                ></p>
</li>
<li><p><strong>例2</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-%E6%8E%A5%E5%8F%A3%E4%B8%BE%E4%BE%8B02.jpg"
                     
                ></p>
</li>
</ul>
<ul>
<li><p><strong>接口的使用</strong></p>
<ul>
<li><p>接口使用<strong>interface</strong>来定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口内可定义成员：</p>
<ul>
<li><strong>JDK7</strong>前：只能定义<strong>全局常量</strong>与<strong>抽像方法</strong><ul>
<li><strong>全局常量</strong>：<code>public static final</code> ，书写时，可省略不写。<ul>
<li><code>public static final int MAX;等价于 int MAX </code></li>
</ul>
</li>
<li><strong>抽象方法</strong>：<code>public abstract void method();</code>，书写时，可省略不写。<ul>
<li><code>public abstract void  method();等价于 void method();</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接口中<strong>不能定义构造器</strong>的！即接口不可以实例化</p>
</li>
<li><p><strong>接口和类</strong>是<strong>并列</strong>的两个结构，接口通过让类去<strong>实现</strong>(<strong>implements</strong>)的方式来使用</p>
<ul>
<li><p>实现接口后类<strong>同继承效果</strong>，拥有了接口定义的成员</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//习题</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">小结：单继承与实现中出现同名属性或方法</span></span><br><span class="line"><span class="comment">属性：编译错误</span></span><br><span class="line"><span class="comment">方法：类优先原则，调用父类同名方法而非接口同名方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//编译不通过。类与接口是并列关系，导致属性x是不明确的</span></span><br><span class="line">		<span class="comment">// System.out.println(x);</span></span><br><span class="line">		System.out.println(<span class="keyword">super</span>.x);<span class="comment">//1</span></span><br><span class="line">		System.out.println(A.x);<span class="comment">//0，切勿忘记接口属性的public static final 修饰</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> C().pX();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>同理抽象类</p>
<ul>
<li>若<strong>实现类非抽像</strong>类，则必须<strong>实现接口所有抽象方法</strong>，才可实例化</li>
<li>若实现类为<strong>抽像类</strong>，则不要求实现接口的抽象方法</li>
</ul>
<ul>
<li><p>Java类可以<strong>实现多个接口</strong>(弥补了Java单继承性的局限性)</p>
<p><code>class AA extends BB implements CC,DD,EE&#123;&#125;</code></p>
</li>
<li><p><strong>接口与接口</strong>之间可以<strong>多继承</strong></p>
<p><code>interface CC entends AA,BB&#123;&#125; </code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>接口匿名实现类</strong>：同抽象类的匿名实现类创建方式</p>
</li>
<li><p><strong>接口应用场景</strong></p>
<ul>
<li><p><strong>代理模式</strong>(Proxy)</p>
<blockquote>
<p>应用场景：</p>
<ul>
<li>安全代理：屏蔽对真实角色的直接访问</li>
<li>远程代理：通过代理类处理远程方法调用（RMI） </li>
<li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象 比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有 100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理 模式，当需要查看图片时，用proxy来进行大图片的打开。 </li>
<li>分类 <ul>
<li>静态代理（静态定义代理类） </li>
<li>动态代理（动态生成代理类）<ul>
<li>JDK自带的动态代理，需要反射等知识</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>工厂模式</strong></p>
</li>
</ul>
</li>
<li><p><strong>JDK8</strong>接口特性：还可以定义<strong>静态方法、默认方法</strong></p>
<ul>
<li><p>接口中定义的<strong>静态方法</strong>，<strong>只能通过接口</strong>来调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.prnitln();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/****************************/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">implements</span> <span class="title">CompareA</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CompareA.method();</span><br><span class="line">        <span class="keyword">new</span> SubClass().method();<span class="comment">//错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>应用场景：</p>
<ul>
<li>在标准库中 找到像Collection(接口)/Collections(工具类)或者Path/Paths这样成对的接口和类</li>
<li>在JDK8中，可以将Collection与Collections工具类提供的静态方法合并一起</li>
</ul>
</blockquote>
</li>
<li><p>通过实现类的对象，可以调用接口中的<strong>默认方法</strong>，通过<strong>default</strong>关键字修饰(public可以省略)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareA</span></span>&#123;</span><br><span class="line">	<span class="comment">//默认方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123; <span class="comment">//public可以省略</span></span><br><span class="line">         System.out.prnitln();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>若实现类<strong>重写</strong>了接口中的默认方法，调用时，仍然<strong>调用的是重写</strong>以后的方法</p>
</li>
<li><p>若实现类实现了多个接口，多个接口中存在同名同参数的<strong>默认方法</strong>，且实现类没重写此方法的情况下，出现编译错误。接口冲突。这就需要我们必须在实现类中重写此方法</p>
</li>
<li><p>在子类(或实现类)的方法中调用父类、接口中被重写的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    method3();<span class="comment">//调用自己定义的重写的方法</span></span><br><span class="line">    <span class="keyword">super</span>.method3();<span class="comment">//调用的是父类中声明的</span></span><br><span class="line">    <span class="comment">//调用接口中的默认方法</span></span><br><span class="line">    CompareA.<span class="keyword">super</span>.method3();</span><br><span class="line">    CompareB.<span class="keyword">super</span>.method3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
</li>
</ul>
</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul>
<li><p><strong>使用场景</strong>：当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的结构又只为该事物提供服务，那么整个内部的完整结构最好使用内部类。</p>
</li>
<li><p><strong>内部类的类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 内部类类型，对应变量类型</span></span><br><span class="line"><span class="comment"> * 1、成员变量：属性(成员内部类)</span></span><br><span class="line"><span class="comment"> * 		非静态成员变量：属性(非静态内部类)</span></span><br><span class="line"><span class="comment"> * 		静态变量：类变量(静态内部类)</span></span><br><span class="line"><span class="comment"> * 2、局部变量：方法、构造器、代码块内</span></span><br><span class="line"><span class="comment"> * 		(局部内部类)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestInClass</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//非静态成员内部类</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员内部类</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BB</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">EE</span></span>&#123;<span class="comment">//局部内部类</span></span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TestInClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//局部内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">CC</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#123;	<span class="comment">//局部内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">DD</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>成员内部类</strong></p>
<ul>
<li>作为外部类的成员(属性理解)：<ul>
<li>可以<strong>调用外部类</strong>的结构</li>
<li>可以<strong>被static修饰</strong>(外部类-普通类不可以)</li>
<li>可以被<strong>4种权限修饰符修饰</strong>(普通类只有缺省和public)<ul>
<li>作为类：拥有普通类的常见情况</li>
</ul>
</li>
<li>类内可以定义属性、方法、构造器等</li>
<li>可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</li>
<li>可以被abstract修饰</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p><strong>实例化成员内部类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建静态的Dog内部类的实例(静态的成员内部类):</span></span><br><span class="line">Person.Dog dog = <span class="keyword">new</span> Person.Dog();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建非静态的Bird内部类的实例(非静态的成员内部类):</span></span><br><span class="line"><span class="comment">//Person.Bird bird = new Person.Bird();//错误的</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person.Bird bird = p.<span class="function">new <span class="title">Bird</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内部类与外部类同名属性调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	String name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//非静态成员内部类</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">		String name = <span class="string">&quot;杜鹃&quot;</span>;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		System.out.println(name);<span class="comment">//方法的形参</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);<span class="comment">//内部类的属性</span></span><br><span class="line">        System.out.println(Person.<span class="keyword">this</span>.name);<span class="comment">//外部类的属性</span></span><br><span class="line">        <span class="comment">//Person.this.eat();</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>局部内部类</strong></p>
<ul>
<li><p>在局部内部类的方法中的调用方法的局部变量话,要求此局部变量声明为final的。</p>
<ul>
<li>jdk 7及之前版本：要求此局部变量显式的声明为final的</li>
<li>jdk 8及之后的版本：可以省略final的声明</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="comment">//num = 20;//错误，num默认为final</span></span><br><span class="line">				System.out.println(num);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<pre><code>   * 成员内部类和局部内部类，在编译以后，都会生成字节码文件。</code></pre>
<ul>
<li><p>成员内部类：<code>外部类$内部类名.class</code></p>
</li>
<li><p>局部内部类：<code>外部类$数字 内部类名.class</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个实现了Comparable接口的类的对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Comparable <span class="title">getComparable</span><span class="params">()</span></span>&#123;</span><br><span class="line">  		</span><br><span class="line">  	<span class="comment">//创建一个实现了Comparable接口的类:局部内部类</span></span><br><span class="line">  	<span class="comment">//方式一：</span></span><br><span class="line">  	<span class="class"><span class="keyword">class</span> <span class="title">MyComparable</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">  		<span class="meta">@Override</span></span><br><span class="line">  		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  		&#125;</span><br><span class="line">  			</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">new</span> MyComparable();</span><br><span class="line">  		</span><br><span class="line">  	<span class="comment">//方式二：</span></span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">new</span> Comparable()&#123;</span><br><span class="line">  		<span class="meta">@Override</span></span><br><span class="line">  		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  		&#125;	</span><br><span class="line">  	&#125;;	</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>







</li>
</ul>
<h1 id="Java基础类库"><a href="#Java基础类库" class="headerlink" title="Java基础类库"></a>Java基础类库</h1><h2 id="JUnitTest"><a href="#JUnitTest" class="headerlink" title="JUnitTest"></a>JUnitTest</h2><ul>
<li><p><strong>JUnitTest单元测试类</strong>：</p>
</li>
<li><p><strong>快捷步骤</strong>：</p>
<ol>
<li>直接在想要测试的方法上添加<code>@Test</code>注解，通过eclipse提示导入相关内容</li>
</ol>
</li>
<li><p><strong>详细步骤与细节</strong></p>
<ol>
<li>中当前工程 - 右键择：build path - add libraries - JUnit 4 - 下一步</li>
<li>单元测试类要求：public、供公共的无参的构造器</li>
<li>单元测试方法的要求：public、无返回值，无形参</li>
<li>单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test;</li>
<li>左键双击单元测试方法名，右键：run as - JUnit Test</li>
</ol>
<hr>
<ul>
<li>执行结果没任何异常：绿条</li>
<li>执行结果出现异常：红条</li>
</ul>
</li>
</ul>
<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.exit(<span class="number">0</span>);<span class="comment">//终止JVM的执行</span></span><br></pre></td></tr></table></figure>





<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><ul>
<li><p>操作数组的工具类：有封装好的快排，二分排等操作(可查看源码学习)</p>
<table>
<thead>
<tr>
<th>method</th>
<th>meaning</th>
</tr>
</thead>
<tbody><tr>
<td>boolean equals(int[] a,int[] b)</td>
<td>判断两个数组是否相等。</td>
</tr>
<tr>
<td>String toString(int[] a)</td>
<td>输出数组信息</td>
</tr>
<tr>
<td>void fill(int[] a,int val)</td>
<td>将指定值均填充到数组之中</td>
</tr>
<tr>
<td>void sort(int[] a)</td>
<td>对数组进行排序</td>
</tr>
<tr>
<td>int binarySearch(int[] a,int key)</td>
<td>对排序后的数组进行二分法检索指定的值</td>
</tr>
<tr>
<td>…..详细查看API</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">//如一些二分查找等都有封装好</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">boolean equals</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br></pre></td></tr></table></figure>



<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.random();<span class="comment">//[0.0,1.0)</span></span><br><span class="line">Math.PI;</span><br><span class="line"><span class="keyword">long</span> Math.round(<span class="keyword">double</span> d)<span class="comment">//四舍五入取整</span></span><br></pre></td></tr></table></figure>









<p>复用：方法，继承</p>
<p>可扩展性：继承，多态(自带，归类分配控制器，减少编写重载方法)</p>
<p>解耦：封装</p>
<p>封装：</p>
<p>继承：复用，易扩展</p>
<p>多态性：提高代码的通用性，如Object 的equals方法</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h1 id="有关源码的题"><a href="#有关源码的题" class="headerlink" title="有关源码的题"></a>有关源码的题</h1><h2 id="包装类相关"><a href="#包装类相关" class="headerlink" title="包装类相关"></a>包装类相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    Integer m = <span class="number">1</span>;</span><br><span class="line">    Integer n = <span class="number">1</span>;</span><br><span class="line">    System.out.println(m == n);<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意，如果数值不一样是肯定不一样的</span></span><br><span class="line">    Integer a = <span class="number">210</span>;</span><br><span class="line">    Integer b = <span class="number">211</span>;</span><br><span class="line">    System.out.println(a == b);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    Integer x = <span class="number">128</span>;</span><br><span class="line">    Integer y = <span class="number">128</span>;</span><br><span class="line">    System.out.println(x == y);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[],</span></span><br><span class="line"><span class="comment">//  保存了从-128~127范围的整数。如果我们使用自动装箱的方式，给Integer赋值的范围在</span></span><br><span class="line"><span class="comment">//  -128~127范围内时，可以直接使用数组中的元素，不用再去new了。目的：提高效率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Integer m = 1; //-128~127范围内相当于同一个数组地址</span></span><br><span class="line"><span class="comment">//  Integer n = 1;</span></span><br><span class="line"><span class="comment">//  Integer x = 128;//相当于new了一个Integer对象</span></span><br><span class="line"><span class="comment">//  Integer y = 128;//相当于new了一个Integer对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>原理</strong></li>
</ul>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/03/14/%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E6%96%87%E6%A1%A3/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">个人电子文档</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2020/12/12/video%20interface%20set/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">video interface set</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Keep Team</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.1</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8DOS%E5%91%BD%E4%BB%A4"><span class="nav-number">1.</span> <span class="nav-text">常用DOS命令</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">语言概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E5%8E%86%E5%8F%B2"><span class="nav-number">2.1.</span> <span class="nav-text">语言历史</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9"><span class="nav-number">2.2.</span> <span class="nav-text">语言特点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="nav-number">3.</span> <span class="nav-text">开发环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87"><span class="nav-number">3.1.</span> <span class="nav-text">知识储备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85"><span class="nav-number">3.2.</span> <span class="nav-text">环境安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK%E5%86%85%E5%AE%B9%E6%A6%82%E8%A6%81"><span class="nav-number">3.3.</span> <span class="nav-text">JDK内容概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.4.</span> <span class="nav-text">环境变量详解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91"><span class="nav-number">4.</span> <span class="nav-text">.Java程序运行逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91"><span class="nav-number">4.1.</span> <span class="nav-text">java程序执行逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%8F%8A%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.2.</span> <span class="nav-text">编译及运行命令的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%94%E7%A4%BA"><span class="nav-number">4.3.</span> <span class="nav-text">演示</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">5.1.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E4%BF%9D%E7%95%99%E5%AD%97%E3%80%81%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-number">5.2.</span> <span class="nav-text">关键字、保留字、标识符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.3.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.4.</span> <span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">5.5.</span> <span class="nav-text">流程控制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">6.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">6.1.</span> <span class="nav-text">一维数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">6.2.</span> <span class="nav-text">多维数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="nav-number">6.3.</span> <span class="nav-text">常见异常</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8F%98%E9%87%8F"><span class="nav-number">7.</span> <span class="nav-text">内存结构与变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.1.</span> <span class="nav-text">变量的类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">7.2.</span> <span class="nav-text">变量的初始化及默认值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">7.3.</span> <span class="nav-text">不同变量的内存结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">8.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%8A%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">8.1.</span> <span class="nav-text">类成员及内存结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">8.2.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">8.3.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">8.4.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object"><span class="nav-number">8.5.</span> <span class="nav-text">Object</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">8.6.</span> <span class="nav-text">包装类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static"><span class="nav-number">8.7.</span> <span class="nav-text">static</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E5%B1%9E%E6%80%A7"><span class="nav-number">8.7.1.</span> <span class="nav-text">修饰属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="nav-number">8.7.2.</span> <span class="nav-text">修饰方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">8.7.3.</span> <span class="nav-text">静态属性和方法应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main%E6%96%B9%E6%B3%95"><span class="nav-number">8.7.4.</span> <span class="nav-text">main方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">8.8.</span> <span class="nav-text">代码块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final"><span class="nav-number">8.9.</span> <span class="nav-text">final</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E5%83%8F%E7%B1%BB"><span class="nav-number">8.10.</span> <span class="nav-text">抽像类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.11.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">8.12.</span> <span class="nav-text">内部类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93"><span class="nav-number">9.</span> <span class="nav-text">Java基础类库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JUnitTest"><span class="nav-number">9.1.</span> <span class="nav-text">JUnitTest</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#System"><span class="nav-number">9.2.</span> <span class="nav-text">System</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Arrays"><span class="nav-number">9.3.</span> <span class="nav-text">Arrays</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Scanner"><span class="nav-number">9.4.</span> <span class="nav-text">Scanner</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Math"><span class="nav-number">9.5.</span> <span class="nav-text">Math</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">10.</span> <span class="nav-text">反射</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%89%E5%85%B3%E6%BA%90%E7%A0%81%E7%9A%84%E9%A2%98"><span class="nav-number">11.</span> <span class="nav-text">有关源码的题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9B%B8%E5%85%B3"><span class="nav-number">11.1.</span> <span class="nav-text">包装类相关</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/dark-light-toggle.js"></script>


    <script src="/js/local-search.js"></script>



    <script src="/js/code-copy.js"></script>



    <script src="/js/lazyload.js"></script>


<div class="post-scripts">
    
        <script src="/js/left-side-toggle.js"></script><script src="/js/libs/anime.min.js"></script><script src="/js/toc.js"></script>
    
</div>



</body>
</html>
