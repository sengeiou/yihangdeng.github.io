<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="yhd">
    
    <title>
        
            多线程编程基础 |
        
        DyhBlog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/MyLogo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"yoursite.com","root":"/","language":"en","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.jpg","favicon":"/images/MyLogo.svg","article_img_align":"left","left_side_width":"230px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.jpeg"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.1"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.1.1"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                DyhBlog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">多线程编程基础</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">yhd</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-06-06 17:15:32
    </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/JavaSE/">JavaSE</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>12.9k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>50 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p><strong>引言</strong>：本文主要基于JDK8介绍JavaSE中多线程基础使用，包含：多线程概念，线程调度、优先级、生命周期等。包含四种创建线程的方式，Thread、Runnable、Callable、线程池技术。介绍了线程安全、线程通信的基础知识，说明了同步监视器的原理。</p>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>​    <strong>程序</strong>(programm)：是为完成特定任务、用某种语言编写的一组指令的集合。即指<strong>一段静态的代码</strong>。(如软件安装的物理位置中的文件)</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><strong>进程</strong>(process)：<strong>程序的一次执行过程</strong>，或是<strong>正在运行</strong>的一个程序。</p>
<ul>
<li>进程作为<strong>资源分配的单位</strong>，系统在运行时会为每个进程分配不同的内存区域。(如软件启动后在任务管理器”进程”看到的状态)</li>
<li>有其自身产生、存在合消亡的过程——<strong>生命周期</strong></li>
<li>每一个进程占用内存区域中的方法区与堆结构</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><strong>线程</strong>(thread)：进程可进一步细化为线程，是一个程序内部的<strong>一条执行路径</strong>。</p>
<ul>
<li>若一个进程同一时间<strong>并行执行多个线程</strong>，就是支持<strong>多线程的</strong></li>
<li>线程作为<strong>调度和执行的单位</strong>，每个线程拥<strong>独立</strong>的<strong>运行栈和程序计数器</strong>(pc)，线程切换的开销小。</li>
<li>一个进程中的多个线程<strong>共享相同</strong>的内存单元/内存地址空间(堆和方法区)，使得<strong>线程间通信</strong>更简便、高效。但多个线程操作共享的系统资 源可能就会带来<strong>安全的隐患</strong>。</li>
</ul>
<hr>
<ul>
<li><strong>重点小结</strong>：<ul>
<li><strong>每个线程</strong>，拥有自己独立的：栈、程序计数器</li>
<li>多个线程，共享同一个<strong>进程中</strong>的结构：方法区、堆。</li>
</ul>
</li>
</ul>
<h2 id="线程的分类"><a href="#线程的分类" class="headerlink" title="线程的分类"></a>线程的分类</h2><p>Java中的线程分为两类：一种是守护线程，一种是用户线程。</p>
<ul>
<li>守护线程是用来服务用户线程的，用户线程都结束了，守护线程才回结束</li>
<li>通过在start()方法前调用<code>thread.setDaemon(true)</code>可以把一个用户线程变成一个守护线程。 </li>
<li>Java垃圾回收就是一个典型的守护线程</li>
</ul>
<h2 id="单核与多核CPU"><a href="#单核与多核CPU" class="headerlink" title="单核与多核CPU"></a>单核与多核CPU</h2><ul>
<li><p><strong>单核CPU</strong>：其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。只是CPU主频非常高，在快速切换地执行不同的线程。使其感觉像并行的多线程</p>
</li>
<li><p><strong>多核CPU</strong>：若是多核的CPU，才能真正更好的发挥多线程的效率</p>
</li>
<li><p>一个Java应用程序java.exe至少有三个线程：<strong>main主线程</strong>、<strong>GC垃圾回收线程</strong>、<strong>异常处理线程</strong></p>
</li>
</ul>
<h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><ul>
<li><strong>并行</strong>：<strong>多个CPU</strong>同时执行<strong>多个任务</strong>。比如：多个人同时做不同的事</li>
<li><strong>并发</strong>：<strong>一个CPU</strong>(采用时间片)同时执行<strong>多个任务</strong>。比如：多个人做同一件事</li>
</ul>
<h2 id="多线程的优势"><a href="#多线程的优势" class="headerlink" title="多线程的优势"></a>多线程的优势</h2><ul>
<li><strong>背景</strong>：以单核CPU为例，只使用单个线程先后完成多个任务（调用多个方 法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？ </li>
<li>多线程程序的<strong>优点</strong>：<ol>
<li>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。</li>
<li>提高计算机系统CPU的利用率。</li>
<li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。</li>
</ol>
</li>
<li>多线程的常见<strong>需求场景</strong>：<ol>
<li>程序需要同时<strong>执行</strong>两个或<strong>多个任务</strong>。</li>
<li>程序需要实现一些<strong>需要等待的任务</strong>时，如用户输入、文件读写 操作、网络操作、搜索等。</li>
<li>需要一些<strong>后台运行</strong>的程序时。</li>
</ol>
</li>
<li><strong>小结</strong>：多线程优势总的来说归纳成两个方向：<ul>
<li><ol>
<li>刚需：界面程序、等不得不进行一些并行操作的程序。</li>
<li>弯道超车的效率提升：虽然对于程序内单一任务多线程还不如单线程。但多任务中多线程利用了时机并行性，形成了流水线加速，远远超过单线程(顺序等待)</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="Thread线程创建"><a href="#Thread线程创建" class="headerlink" title="Thread线程创建"></a>Thread线程创建</h1><ul>
<li><p>Java语言的JVM允许程序运行多个线程，它通过<strong>java.lang.Thread</strong> 类来体现。</p>
</li>
<li><p><strong>JDK5.0之前</strong>，最原始创建线程的方式有如下两种。</p>
<ul>
<li>通过<strong>继承Thread类</strong>方式实现</li>
<li><strong>实现Runnable接口</strong>的方式实现</li>
</ul>
</li>
</ul>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>继承Thread实现方式步骤如下：</p>
<ol>
<li>创建一个基础于<strong>Thread类的子类</strong></li>
<li><strong>重写</strong>Thread类的<strong>run()方法</strong>，并将<strong>执行的代码</strong>写在run方法中</li>
<li>以<strong>多态</strong>的方式，创建Thread类的<strong>子类的对象</strong></li>
<li><strong>调用start()方法</strong>启动线程</li>
</ol>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><ul>
<li>继承Thread创建子线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如下创建一个线程打印100以内的偶数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//多线程代码编写处：打印100以内的偶数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                System.out.println(<span class="string">&quot;MyThread-run()：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//多态的方式创建</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程 main，也打印100以内的偶数，多次尝试运行可以发现两个线程存在交替执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                System.out.println(<span class="string">&quot;main()：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="start-amp-run"><a href="#start-amp-run" class="headerlink" title="start&amp;run"></a>start&amp;run</h2><ul>
<li><p>start()方法的作用：</p>
<ol>
<li><strong>启动当前线程</strong></li>
<li><strong>让 JVM 去调用</strong>当前线程的run()方法</li>
</ol>
</li>
<li><p>启动一个线程，<strong>必须调用start()**，</strong>不能调用run()**的方式启动线程。</p>
<ul>
<li>若直接调用run()方法执行代码。则只是在当前线程调用子类重写父类的一个方法而已，属于<strong>单线程</strong>。</li>
</ul>
</li>
</ul>
<h2 id="多个线程创建"><a href="#多个线程创建" class="headerlink" title="多个线程创建"></a>多个线程创建</h2><ul>
<li><p>每一个Thread对象只允许执行一次start方法</p>
</li>
<li><p>若想<strong>再启动一个线程执行同一个任务</strong>，<strong>是不允许连续调用两次start()方法</strong>，否则报出IllegalThreadStateException异常。</p>
</li>
<li><p>因此在必须<strong>重新创建一个新</strong>的Thread子类的对象，调用此**对象的start()**方法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//多次尝试运行可以发现两个线程存在交替执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//t1.start();错误写法</span></span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> MyThread();<span class="comment">//正确写法，重新创建</span></span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名方式创建"><a href="#匿名方式创建" class="headerlink" title="匿名方式创建"></a>匿名方式创建</h2><ul>
<li>若子线程只执行一次后无操作，则可以使用匿名子类方式创建<ol>
<li>new Thread().start();</li>
<li>new Thread(){&lt;回车&gt;}.start();</li>
<li>展开后在{}内重写run方法</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.exer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-05 7:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、new Thread().start();</span></span><br><span class="line">        <span class="comment">//2、new Thread()&#123;&lt;回车&gt;&#125;.start();</span></span><br><span class="line">        <span class="comment">//3、展开后在&#123;&#125;内重写run方法</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>tips</strong>：在继承Thread方式创建线程时，在子类中可以直接调用Thread方法(继承作用)，即在run()方法中<code>Thread.currentThread().getName()</code>等价于<code>getName()</code></li>
</ul>
<h1 id="Thread-API"><a href="#Thread-API" class="headerlink" title="Thread-API"></a>Thread-API</h1><p>其实Thread类也是实现Runnable接口的</p>
<h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h2><table>
<thead>
<tr>
<th>构造器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Thread()</td>
<td>创建新的Thread对象</td>
</tr>
<tr>
<td>Thread(String threadname)</td>
<td>创建线程并指定线程实例名</td>
</tr>
<tr>
<td>Thread(Runnable target)</td>
<td>指定创建线程的目标对象<br/>该对象实现了Runnable接口中的run方法</td>
</tr>
<tr>
<td>Thread(Runnable target, String name)</td>
<td>创建新的Thread对象</td>
</tr>
</tbody></table>
<ul>
<li><strong>tips</strong>：除Thread()外，其他带参数的Thread构造器都需要使用在子类构造器中通过super(形参)显式调用。</li>
</ul>
<h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>start()</td>
<td>启动当前线程，让JVM调用当前线程的run()</td>
</tr>
<tr>
<td>run()</td>
<td>通常需重写此方法，将创建的线程要执行的操作声明在此方法中</td>
</tr>
<tr>
<td>currentThread()</td>
<td><strong>静态方法</strong>，返回执行当前代码的线程</td>
</tr>
<tr>
<td>getName()</td>
<td>获取当前线程的名字(别名，非唯一标识符)</td>
</tr>
<tr>
<td>setName()</td>
<td>设置当前线程的名字(别名，非唯一标识符)</td>
</tr>
<tr>
<td>yield()</td>
<td>手动让出当前cpu的执行权，<br/>不是结束线程;且有可能下次分配给的还是调用yield的线程</td>
</tr>
<tr>
<td>join()</td>
<td>在线程a中通过线程b调用join()，此时线程a就进入<strong>阻塞状态</strong>，<br/>线程b<strong>加入</strong>执行，直到线程b完全执行完以后，线程a才结束阻塞状态<br/><strong>含异常</strong></td>
</tr>
<tr>
<td>sleep(long millitime)</td>
<td><strong>静态方法</strong>，让当前线程“睡眠”指定的millitime毫秒<br/>在指定的millitime毫秒时间内，当前线程是<strong>阻塞状态</strong><br/><strong>含异常</strong></td>
</tr>
<tr>
<td>isAlive()</td>
<td>判断当前线程是否存活</td>
</tr>
<tr>
<td><del>stop()</del></td>
<td>已过时，当执行此方法时，强制结束当前线程</td>
</tr>
</tbody></table>
<ul>
<li>部分示例代码</li>
<li>join();</li>
</ul>
<h1 id="线程调度策略"><a href="#线程调度策略" class="headerlink" title="线程调度策略"></a>线程调度策略</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>线程调度</strong>是指按照特定机制为多个线程分配CPU 的使用权。一般为用户级线程调度，与特定的线程调度调度实现。（Java是由JVM中的线程计数器来实现线程调度）</p>
<h2 id="常见调度策略"><a href="#常见调度策略" class="headerlink" title="常见调度策略"></a>常见调度策略</h2><ul>
<li><strong>时间片轮转法</strong>：时间片轮转法在进制调度中常用于分时系统<ul>
<li>CPU将执行资源均匀分配为若干个相同的时间间隔，称为时间片q</li>
<li>让处于就绪状态的线程轮流使用一段时间片q(当然存在q时间内还没执行完的线程)</li>
<li>通过这种轮流使用相同cpu平均分配出的资源执行完所有线程。</li>
</ul>
</li>
<li><strong>优先级调度</strong>(抢占式-线程)：<ul>
<li>有别于<strong>进程</strong>优先级调度，高优先级的线程只是比低优先级的线程先获得CPU资源的<strong>概率要高</strong></li>
<li>但并非一定高优先级线程被调用后，甚至被执行完后低优先级的线程才被调用。</li>
</ul>
</li>
</ul>
<h2 id="Java调度策略"><a href="#Java调度策略" class="headerlink" title="Java调度策略"></a>Java调度策略</h2><ul>
<li>同优先级：先到先服务 + 时间片轮转法</li>
<li>不同优先级：抢占式优先级调度</li>
</ul>
<h1 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h1><p>java优先级范围<strong>1~10</strong>，下列三个为<strong>Thread静态全局常量</strong>：</p>
<ul>
<li><strong>Thread.MAX_PRIORITY</strong>：10 （最高优先级10）</li>
<li><strong>Thread.MIN _PRIORITY</strong>：1   （最低优先级1）</li>
<li><strong>Thread.NORM_PRIORITY</strong>：5 (normal，通常,默认5，主线程默认就是5) </li>
</ul>
<hr>
<ul>
<li>优先级涉及的方法：<ul>
<li><strong>getPriority</strong>() ：返回线程优先值</li>
<li><strong>setPriority</strong>(int newPriority) ：改变线程的优先级</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>优先级线程调度说明：<ul>
<li>线程创建时<strong>继承</strong>父线程的优先级</li>
<li>高优先级线程要抢占低优先级线程cpu的执行权，但低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用。</li>
</ul>
</li>
</ul>
<h1 id="Runnable线程创建"><a href="#Runnable线程创建" class="headerlink" title="Runnable线程创建"></a>Runnable线程创建</h1><h2 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h2><ul>
<li>创建多线程的方式二：实现Runnable接口<ol>
<li>创建一个实现了Runnable接口的类</li>
<li>实现类去实现Runnable中的抽象方法：run()</li>
<li>创建实现类的对象</li>
<li>创建Thread类的对象，并将此实现类对象作为参数传递到Thread类的构造器中</li>
<li>通过Thread类的对象调用start()</li>
</ol>
</li>
</ul>
<hr>
<h2 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h2><ul>
<li>实现Runnable接口创建线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.exer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建一个类实现Runnable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//2、实现接口中的run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过实现Runnable接口创建子线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-05 10:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3、创建实现类对象</span></span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">//4、创建Thread类的对象，并将此实现类对象作为参数传递到Thread类的构造器中</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myThread);</span><br><span class="line">        <span class="comment">//5、调用Thread对象的start()方法启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>tips</strong>：由于实现Runnable接口方式实现线程创建，当前实现类继承的是Object，是没有Thread方法的，因此，只能通过调用<code>Thread.currentThread()</code>后执行Thread相关方法。</li>
</ul>
<h2 id="start-amp-run-1"><a href="#start-amp-run-1" class="headerlink" title="start&amp;run"></a>start&amp;run</h2><ul>
<li><p>Thread对象是如何调用实现类中的run方法？</p>
</li>
<li><p>深入Thread源码可以看到，run方法执行前先判断<strong>target</strong>属性是否为空，若不为空调用target的run方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从Thread类定义中可知，target属性就是Runnable类型的，target.run调用了Runnable的run</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* What will be run. */</span></span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相同线程创建"><a href="#相同线程创建" class="headerlink" title="相同线程创建"></a>相同线程创建</h2><p>当通过实现Runnable方式为一个实现类创建多个线程执行时：</p>
<ul>
<li>实现类的对象只有一个，即对应的资源只有一份。</li>
<li>此时<strong>多个</strong>线程<strong>共用,争夺</strong>这<strong>一个</strong>实现类的资源</li>
<li>类似对于多个Thread对象来说，该实现类像是一个static静态资源。</li>
<li>若通过Thread方式创建线程且共享一个类的数据时，共享的数据则需要设置成static</li>
<li>因此实现Runnable方式与生俱来<strong>更适合来处理多个线程有共享数据</strong>的情况</li>
</ul>
<hr>
<p>示例代码：</p>
<ul>
<li><p>由于一个Thread只能start()一次</p>
</li>
<li><p>因此需要创建一个新的Thread对象</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myThread);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再创建两个线程</span></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(myThread);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(myThread);</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名方式创建-1"><a href="#匿名方式创建-1" class="headerlink" title="匿名方式创建"></a>匿名方式创建</h2><p>若子线程只执行一次后无操作，则可以使用匿名实现类方式创建</p>
<ol>
<li>new Thread().start();</li>
<li>new Thread( new Runnable() { [&lt;回车&gt;] } ).start();</li>
<li>展开后在{}内实现run方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Thread与Runnable比较"><a href="#Thread与Runnable比较" class="headerlink" title="Thread与Runnable比较"></a>Thread与Runnable比较</h2><p>比较创建线程的两种方式。</p>
<ol>
<li><p><strong>开发中，优先选择实现Runnable接口的方式</strong></p>
<ul>
<li>原因是，实现的方式没有类的单继承性的局限性。即如果需要多线程执行的类，原本就还有自己的一套继承体系，则通过继承Thread是无法实现的。</li>
</ul>
</li>
<li><p><strong>实现的方式更适合来处理多个线程有共享数据的情况</strong></p>
</li>
<li><p><strong>Runnable与Thread联系</strong>：</p>
<ul>
<li>Thread本身也是实现Runnable接口：<code>public class Thread implements Runnable</code></li>
<li>甚至如run这些方法都是Runnable的，Thread也是其实现者而已</li>
<li>如通过继承Thread重写run或实现Runnable本质都一样</li>
<li>综合所述，结合Runnable是一个接口的特性，也能看出整个线程是被上层机制管理的(JVM)</li>
</ul>
</li>
<li><p>相同点：两种方式<strong>都需要重写run()</strong>,将线程要执行的逻辑声明在run()中</p>
</li>
</ol>
<h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>线程一个完整的生命周期中通常要经历如下的五种状态(类进程状态)：</p>
<ul>
<li><strong>新建</strong>： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</li>
<li><strong>就绪</strong>：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已 具备了运行的条件，只是没分配到CPU资源</li>
<li><strong>运行</strong>：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能</li>
<li><strong>阻塞</strong>：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态</li>
<li><strong>死亡</strong>：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li>
</ul>
<h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210605144159.png"
                     
                ></p>
<h2 id="Thread-State"><a href="#Thread-State" class="headerlink" title="Thread.State"></a>Thread.State</h2><p>Java语言使用Thread类<strong>内部枚举类State</strong>来描述Java语言中线程的多种状态：</p>
<ul>
<li>描述的状态：少了就绪状态(操作系统给予的状态)，多了两个等待状态</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">            NEW,<span class="comment">//新建状态</span></span><br><span class="line">            RUNNABLE,<span class="comment">//运行状体，执行完start方法且获取到cpu资源代码执行中</span></span><br><span class="line">            BLOCKED,<span class="comment">//阻塞状态</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 等待状态</span></span><br><span class="line"><span class="comment">             * 调用如下：wait()、join()或LockSupport#park()时候切换至等待</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            WAITING,</span><br><span class="line"></span><br><span class="line">             <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 指定时长等待状态</span></span><br><span class="line"><span class="comment">             * 调用如带参方法：wait(long)、join(long)或</span></span><br><span class="line"><span class="comment">             * LockSupport#parkNanos LockSupport.parkNanos</span></span><br><span class="line"><span class="comment">             * LockSupport#parkUntil LockSupport.parkUntil</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            TIMED_WAITING,</span><br><span class="line">            TERMINATED;<span class="comment">//终止(结束)状态，[ˈtɜːmɪneɪtɪd] </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="基础概念-1"><a href="#基础概念-1" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="线程安全-1"><a href="#线程安全-1" class="headerlink" title="线程安全"></a>线程安全</h3><p>在拥有<strong>共享数据</strong>的多条线程并行执行的程序中，线程安全的代码会通过<strong>同步机制</strong>保证各个线程都可以正常且正确的执行，不会出现<strong>共享资源的数据污染</strong>等意外情况。</p>
<h3 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h3><p>在多线程环境中，线程之间相互影响又各自独立运行，彼此之间具有<strong>相互协作</strong>(同步)或<strong>相互竞争</strong>(互斥)的关系。</p>
<ul>
<li><strong>同步</strong>：多个线程<strong>协同完成</strong>一项任务</li>
<li><strong>互斥</strong>：多个线程<strong>竞争同一资源</strong>而发生相互制约</li>
</ul>
<hr>
<ul>
<li>无论是线程同步，还是互斥，都存在共享资源。对共享资源的操作不造成数据污染，则是线程安全所要做的事情。</li>
<li>一般习惯将安全地解决<strong>线程同步</strong>与<strong>线程互斥</strong>关系的机制同一称为“<strong>线程同步进制</strong>”。</li>
</ul>
<h3 id="线程安全判断"><a href="#线程安全判断" class="headerlink" title="线程安全判断"></a>线程安全判断</h3><p>若存在<strong>共享数据资源</strong>，且为<strong>多线程操作</strong>，则肯定有可能存在线程安全问题。</p>
<h2 id="卖票模型"><a href="#卖票模型" class="headerlink" title="卖票模型"></a>卖票模型</h2><p>现有引入一个场景，100张票，开启三个线程去售卖，每一个线程每次售卖一张。</p>
<h3 id="Runnable方式"><a href="#Runnable方式" class="headerlink" title="Runnable方式"></a>Runnable方式</h3><p>注意：</p>
<ul>
<li><p>Runnable方式Window对象只有一份，ticket不用设置为static</p>
</li>
<li><p>同一任务多个线程的创建方式，作为将实现类作为Thread()构造器的形参传入创建</p>
</li>
<li><p><strong>示例代码</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.exer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-05 15:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//提供100张车票售卖</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//卖票子线程，当目前票数 &gt; 0，则可以卖出一张票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//手动阻塞线程100ms，增加错票机率</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String threadName = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(threadName + <span class="string">&quot;卖出：第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启卖票</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个Window对象</span></span><br><span class="line">        Window window = <span class="keyword">new</span> Window();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启三个售卖窗口，一同卖出100张票</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(window);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Thread方式"><a href="#Thread方式" class="headerlink" title="Thread方式"></a>Thread方式</h3><p>注意：</p>
<ul>
<li><p>ticket参数需<strong>修改为static</strong>类型</p>
</li>
<li><p>多个同一任务线程的方式是<strong>多态</strong>创建</p>
</li>
<li><p><strong>示例代码</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.java;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-05 15:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">//提供100张车票售卖</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//卖票子线程，当目前票数 &gt; 0，则可以卖出一张票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//手动阻塞线程100ms，增加错票机率</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String threadName = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(threadName + <span class="string">&quot;卖出：第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始售票</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//开启三个售卖窗口，一同卖出100张票</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Window();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Window();</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Window();</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>错票输出情况打印结果：</li>
<li>如一开始的三张第100张票，末尾的9，9;6，6;3，3;的重票，0，0的错票情况。都是线程不安全的表现。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Thread-1卖出：第100张票</span><br><span class="line">Thread-0卖出：第100张票</span><br><span class="line">Thread-2卖出：第100张票</span><br><span class="line">Thread-0卖出：第97张票</span><br><span class="line">Thread-2卖出：第96张票</span><br><span class="line">Thread-1卖出：第95张票</span><br><span class="line">...忽略</span><br><span class="line">Thread-2卖出：第10张票</span><br><span class="line">Thread-1卖出：第9张票</span><br><span class="line">Thread-0卖出：第9张票</span><br><span class="line">Thread-2卖出：第7张票</span><br><span class="line">Thread-1卖出：第6张票</span><br><span class="line">Thread-0卖出：第6张票</span><br><span class="line">Thread-2卖出：第4张票</span><br><span class="line">Thread-1卖出：第3张票</span><br><span class="line">Thread-0卖出：第3张票</span><br><span class="line">Thread-2卖出：第1张票</span><br><span class="line">Thread-0卖出：第0张票</span><br><span class="line">Thread-1卖出：第0张票</span><br></pre></td></tr></table></figure>

<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>卖票过程中，出现了重票、错票，出现了线程的安全问题</p>
<ul>
<li><strong>理想状态</strong>：售票时一一按序卖出，且同时检测到票数为0不操作</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210605163208.png"
                     
                ></p>
<ul>
<li><strong>极端错误状态</strong>：三个线程依次在最后一张票进入if判断后进入阻塞状态，后执行完毕</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210605163241.png"
                     
                ></p>
<ul>
<li><p><strong>问题的原因</strong>：</p>
<ul>
<li>是当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。</li>
<li>其实该卖票程序，纯属一个<strong>线程互斥</strong>的问题，解决方案自然是对<strong>互斥共享资源，加锁</strong>。</li>
</ul>
</li>
<li><p><strong>解决思路</strong>：</p>
<ul>
<li>当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。</li>
<li>即使线程a出现了阻塞，也不仍需要等待a执行完一个操作后再给其他线程操作。</li>
</ul>
</li>
</ul>
<h2 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h2><p>​    Java提供的线程同步机制有许多，JDK5.0之前有同步代码块与同步方法，JDK5.0之后</p>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><ul>
<li><p><strong>功能</strong>：同步代码块使其多个线程在<strong>任意时刻只能有一个线程进入同步代码块中执行</strong>，执行完后其他线程才能再进去，以此类推。</p>
</li>
<li><p><strong>语法</strong>：synchronized(v.使同步)<code>[ˈsɪŋkrənaɪzd]</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line">    <span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<ul>
<li><strong>共享数据</strong>：多个线程共同操作的变量(类操作系统中的互斥共享资源-<strong>临界资源</strong>概念)。比如场景引入中卖票程序的ticket就是共享数据。</li>
<li><strong>操作共享数据的代码</strong>：即为需要被同步的代码。(类操作系统-<strong>临界区</strong>概念)，<ul>
<li>注意同步代码块不能包含多了代码，也不能少了</li>
<li>包含<strong>少了</strong>同步数据不完整<strong>线程不安全</strong>，包含<strong>多了</strong>，有可能<strong>退化成为单线程</strong></li>
<li>能完成功能的前提下，能包含代码<strong>越少越好，性能越高</strong></li>
</ul>
</li>
<li><strong>同步监视器</strong>：俗称：锁。任何一个<strong>类的对象</strong>，都可以充当锁。但要求多个线程必须要共用<strong>同一把锁</strong><ul>
<li><strong>同一把锁的含义</strong>：参与该同步进制的<strong>所有线程</strong>都必须<strong>含有该对象</strong>，而且是<strong>同一个的对象</strong>。<ul>
<li>检测同一把锁：就看多个线程进入synchronize代码块之前同步监视器<strong>是不是同一个对象</strong></li>
<li>其实底层原理是：要保证这些参与同步机制的所有线程都是操作在<strong>同一个互斥信号量</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Runnable方式-1"><a href="#Runnable方式-1" class="headerlink" title="Runnable方式"></a>Runnable方式</h4><ul>
<li><p>由于实现<strong>Runnable接口</strong>创建多线程的方式，本身只有一个对象。</p>
</li>
<li><p>因此可以考虑使用<strong>this充当同步监视器</strong>，或内部属性也可以作为锁。</p>
</li>
<li><p><strong>示例代码</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.exer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-05 15:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//提供100张车票售卖</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任意对象作为锁，且为同一把锁</span></span><br><span class="line">    <span class="comment">//private Object obj = new Object();//正确代码，同一把锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//卖票子线程，当目前票数 &gt; 0，则可以卖出一张票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Object obj = new Object();//错误代码，不是同一把锁</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//同步代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span> <span class="comment">/* obj */</span>) &#123;<span class="comment">//正确代码，this指唯一的window对象</span></span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    String threadName = Thread.currentThread().getName();</span><br><span class="line">                    System.out.println(threadName + <span class="string">&quot;卖出：第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始售票</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window window = <span class="keyword">new</span> Window();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启三个售卖窗口，一同卖出100张票</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(window);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Thread方式-1"><a href="#Thread方式-1" class="headerlink" title="Thread方式"></a>Thread方式</h4><ul>
<li>在<strong>Thread</strong>方式中，由于创建的实现类<strong>对象是多份的</strong>，则需<strong>慎用、甚至不用this</strong>做为同步监视器。</li>
<li>一般使用<strong>实现类.class(推荐)、或static资源的对象</strong>，或保证多个线程操作同一对象的其他对象。</li>
<li><strong>示例代码</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.java;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-05 15:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">//提供100张车票售卖</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任意对象作为锁，且为同一把锁</span></span><br><span class="line">    <span class="comment">//private static Object obj = new Object();//正确代码，static同一把锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//卖票子线程，当目前票数 &gt; 0，则可以卖出一张票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Object obj = new Object();//错误代码，不是同一把锁</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Window.class /* obj */) &#123;//正确代码，Window.class只会加载一次</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    String threadName = Thread.currentThread().getName();</span><br><span class="line">                    System.out.println(threadName + <span class="string">&quot;卖出：第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始售票</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//开启三个售卖窗口，一同卖出100张票</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Window();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Window();</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Window();</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>Runnable方式天生具备共享资源特性，属性资源不用static修饰也是一份的</li>
<li>Thread方式共享资源则需要添加static关键字</li>
<li>Runnable常用this作为同步监视器</li>
<li>Thread常用实现类.class作为同步监视器</li>
<li>因此<strong>通用的同步监视器</strong>应为，<code>实现类.class</code></li>
</ul>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>如果操作共享数据的代码完整的声明在<strong>一个方法中</strong>，我们不妨将<strong>此方法声明同步的</strong>。</p>
<h4 id="使用说明-1"><a href="#使用说明-1" class="headerlink" title="使用说明"></a>使用说明</h4><ul>
<li><strong>功能</strong>：多个线程在<strong>任意时刻只能有一个线程进入同步方法中执行</strong></li>
<li><strong>语法</strong>：在方法返回值前加入synchronized关键字，使其整个方法声明为同步的</li>
<li><strong>隐式同步监视器</strong>：<ul>
<li><strong>普通方法</strong>：系统默认使用的同步监视器为<strong>this</strong></li>
<li><strong>静态方法</strong>：系统默认使用的同步监视器为<strong>方法所在类.class</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Runnable方式-2"><a href="#Runnable方式-2" class="headerlink" title="Runnable方式"></a>Runnable方式</h4><ul>
<li><p>由于实现<strong>Runnable接口</strong>创建多线程的方式，本身只有一个对象。</p>
</li>
<li><p>因此synchronized可以修饰到<strong>普通方法</strong>上，</p>
</li>
<li><p>由于普通方法，<strong>系统默认</strong>使用<strong>this</strong>充当同步监视器，此时的<strong>this也正好是唯一的</strong></p>
</li>
<li><p><strong>示例代码</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.exer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-05 15:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//提供100张车票售卖</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//卖票子线程，当目前票数 &gt; 0，则可以卖出一张票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            method();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将售票操作抽取出为一个方法，并加上synchronized关键字</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;<span class="comment">//系统自动使用this作为同步监视器</span></span><br><span class="line">        <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String threadName = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(threadName + <span class="string">&quot;卖出：第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始售票</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window window = <span class="keyword">new</span> Window();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启三个售卖窗口，一同卖出100张票</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(window);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Thread方式-2"><a href="#Thread方式-2" class="headerlink" title="Thread方式"></a>Thread方式</h4><ul>
<li>在<strong>Thread</strong>方式中，由于创建的实现类<strong>对象是多份的</strong></li>
<li>不能修饰到<strong>普通方法</strong>上使用，因为this此时不是唯一的</li>
<li>因此synchronized可以<strong>只能</strong>修饰到<strong>静态普通方法</strong>上，</li>
<li>由于静态方法，<strong>系统默认</strong>使用<strong>该方法所在类.class</strong>充当同步监视器，此时的<strong>同步监视器是唯一的</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.java;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-05 15:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">//提供100张车票售卖</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//卖票子线程，当目前票数 &gt; 0，则可以卖出一张票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            method();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将售票操作抽取出为一个方法，并加上synchronized关键字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;<span class="comment">//正确代码：加静态修饰，同步监视器为Window.class，唯一</span></span><br><span class="line">    <span class="comment">//public synchronized void method()&#123;//错误代码：普通方法，同步监视器为this，当前不唯一</span></span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String threadName = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(threadName + <span class="string">&quot;卖出：第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始售票</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//开启三个售卖窗口，一同卖出100张票</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Window();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Window();</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Window();</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li><p>对于Runnable方式，synchronized修饰在普通方法和静态方法都可以实现同步</p>
</li>
<li><p>对于Thread方式，只能修饰在静态方法中才能实现同步</p>
<hr>
</li>
<li><p>反过来：在静态方法上使用synchronized一定能实现同步</p>
</li>
<li><p>在非静态方法上使用synchronized不一定能实现同步</p>
</li>
</ul>
<h3 id="懒汉式改装"><a href="#懒汉式改装" class="headerlink" title="懒汉式改装"></a>懒汉式改装</h3><h4 id="原始代码"><a href="#原始代码" class="headerlink" title="原始代码"></a>原始代码</h4><ul>
<li>存在线程安全的懒汉式代码：有可能多个线程挤入(if == null)里</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.java;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存在线程安全的懒汉式单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-05 21:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BankTest</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、懒汉式，需要才创建，因此先声明不而创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、提供外部方法进行实例创建</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Bank();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步方法改装"><a href="#同步方法改装" class="headerlink" title="同步方法改装"></a>同步方法改装</h4><ul>
<li>由于getInstance()方法刚好是静态方法</li>
<li>因此可兼容Runnable方式和Thread方式的多线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BankTest</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Bank();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步代码块改装"><a href="#同步代码块改装" class="headerlink" title="同步代码块改装"></a>同步代码块改装</h4><ul>
<li>虽然能解决问题，但是性能低，存在优化空间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BankTest</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (BankTest.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Bank();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="高性能同步代码块改装"><a href="#高性能同步代码块改装" class="headerlink" title="高性能同步代码块改装"></a>高性能同步代码块改装</h4><ul>
<li>其实当第一个在线程在线程安全情况下进入到<code>instance==null</code>判断中，实例化了单例后，其他线程不需要再参与到整个进程同步代码块内再执行判断<code>instance == null</code>。</li>
<li>完全可以放开资源几乎并行地获取到单例。</li>
</ul>
<hr>
<ul>
<li>以多人等待实体店开门抢一台首发手机时为场景<ul>
<li><strong>初级的同步代码块改装</strong>：所有人任意一时刻只允许一个人进入大门，看到有手机时拿走，没手机时从后门离去。</li>
<li><strong>高性能同步代码块改装</strong>：所有人任意一时刻只允许一个人进入大门，第一个看到有手机拿走后，门口树立一个牌子，上面写着“已经售空”。其他等待的人不用进入大门也知道要离开了。</li>
</ul>
</li>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BankTest</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">synchronized</span> (BankTest.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Bank();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步监视器原理"><a href="#同步监视器原理" class="headerlink" title="同步监视器原理"></a>同步监视器原理</h3><p>同步代码块和同步方法原理一致</p>
<ul>
<li>synchronized(同步监视器)：其实底层原理是一个<strong>互斥信号量</strong>(mutex=1)，俗称<strong>锁</strong></li>
<li>当线程<strong>进入synchronized</strong>(同步监视器)的操作：等价于<strong>P操作，上锁</strong>操作。</li>
<li>当synchronized所包含的代码执行完毕时：等价自定执行<strong>V操作</strong>，<strong>释放锁</strong>操作。</li>
</ul>
<hr>
<ul>
<li>使用synchronized(同步监视器)时，<strong>不是一定要保证是同一个同步监视器</strong>。</li>
<li>上述强调要同一个同步监视器只是解决互斥共享资源只有一个的情况，保证操作的是同一个互斥信号量。</li>
<li>实际开发中，常常出现需要同时上多个不同的锁(同步监视器)</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="基础概念-2"><a href="#基础概念-2" class="headerlink" title="基础概念"></a>基础概念</h4><ul>
<li><p><strong>死锁</strong>：<strong>指不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源</strong>，就形成了线程的死锁。</p>
</li>
<li><p>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于 阻塞状态，无法继续执行完毕。</p>
</li>
<li><p><strong>死锁的避免与解决方法</strong>：</p>
<ul>
<li>专门的算法、原则</li>
<li><strong>尽量减少同步资源的定义</strong></li>
<li><strong>尽量避免同步资源嵌套</strong></li>
</ul>
</li>
</ul>
<h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.java;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死锁演示demo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-05 22:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        StringBuffer sb1 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        StringBuffer sb2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动一个子线程，先申请sb1、再申请sb2锁资源</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(sb1)&#123;<span class="comment">//向sb1锁申请资源</span></span><br><span class="line">                    sb1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    sb2.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">					</span><br><span class="line">                    <span class="comment">//增加发生死锁的概率</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (sb2) &#123;<span class="comment">//向sb2锁申请资源</span></span><br><span class="line">                        sb1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">                        sb2.append(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1_sb1：&quot;</span> + sb1);</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1_sb2：&quot;</span> + sb2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再启动一个子线程，先申请sb2、再申请sb1锁资源</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(sb2)&#123;<span class="comment">//向sb2锁申请资源</span></span><br><span class="line">                    sb1.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">                    sb2.append(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//增加发生死锁的概率</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (sb1) &#123;<span class="comment">//向sb1锁申请资源</span></span><br><span class="line">                        sb1.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">                        sb2.append(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;线程2_sb1：&quot;</span> + sb1);</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程2_sb2：&quot;</span> + sb2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>死锁效果</strong>：没有任何输出，代码无法执行完毕，一直卡着。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210605224324.png"
                     
                ></p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ul>
<li><p>从<strong>JDK 5.0开始</strong>，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。 </p>
</li>
<li><p>java.util.concurrent.locks.Lock是一个接口，是控制多个线程对共享资源进行访问的工具。通常我们使用的使其实现类，常用的有<strong>ReentrantLock</strong><code>[riːˈɛntrənt]</code>，可以<strong>手动</strong>加锁、释放锁。它拥有与 synchronized 相同的并发性和内存语义。</p>
</li>
<li><p>锁提供了对共享资源的独占访问，每次只能有<strong>一个线程对Lock对象加锁</strong>，线程开始访问共享资源之前应先<strong>获得Lock对象</strong>。</p>
</li>
</ul>
<h4 id="使用说明-2"><a href="#使用说明-2" class="headerlink" title="使用说明"></a>使用说明</h4><p><strong>注意：Lock对象本身就作为同步监视器</strong></p>
<ol>
<li>创建Lock实现类ReentrantLock对象<ul>
<li>ReentrantLock()：空参构造器</li>
<li>ReentrantLock(boolean fair)：当fair = true，公平锁先来先服务，否则按实际竞争</li>
</ul>
</li>
<li>为了防止任何情况下(异常)都能执行释放锁操作，先将要同步的代码用try-finally方式包裹</li>
<li>在try内需要需要同步的代码开始处调用Lock对象的lock()方法</li>
<li>在finally处使用Lock对象调用unlock()方法，释放锁资源</li>
</ol>
<hr>
<h4 id="Runnable方式-3"><a href="#Runnable方式-3" class="headerlink" title="Runnable方式"></a>Runnable方式</h4><ul>
<li>示例代码：</li>
<li>由于同样以卖票模型为例，因此还要<strong>保证Lock是同一把锁</strong>。</li>
<li>由于Runnable特性，作为类属性就是同一把锁，不用static修饰</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.exer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-05 15:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//提供100张车票售卖</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、创建Lock实现类对象，这里使用ReentrantLock实现类</span></span><br><span class="line">    <span class="comment">//且由于Runnable特性，此lock对象为同一把锁</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//卖票子线程，当目前票数 &gt; 0，则可以卖出一张票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();<span class="comment">//2、申请锁资源</span></span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    String threadName = Thread.currentThread().getName();</span><br><span class="line">                    System.out.println(threadName + <span class="string">&quot;卖出：第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();<span class="comment">//3、释放锁资源</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始售票</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window window = <span class="keyword">new</span> Window();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启三个售卖窗口，一同卖出100张票</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(window);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Thread方式-3"><a href="#Thread方式-3" class="headerlink" title="Thread方式"></a>Thread方式</h4><ul>
<li>由于同样以卖票模型为例，因此还要<strong>保证Lock是同一把锁</strong>。</li>
<li>由于Thread特性，作为类属性就<strong>不是是同一把锁</strong>，<strong>需要用static修饰</strong></li>
</ul>
<h4 id="Lock与synchronized异同"><a href="#Lock与synchronized异同" class="headerlink" title="Lock与synchronized异同"></a>Lock与synchronized异同</h4><p>synchronized 与 Lock的异同？</p>
<ul>
<li><strong>相同点</strong>：<ul>
<li>二者都可以解决线程安全问题</li>
<li>都有同步监视器，Lock对象本身就作为同步监视器</li>
</ul>
</li>
<li><strong>不同点</strong>：<ul>
<li><strong>自动管理</strong>同步资源监视器：进程进入synchronized机制时自动申请同步监视器(上锁)，在执行完相应的同步代码以后，自动的释放同步监视器(释放锁)。</li>
<li><strong>手动管理</strong>同步资源监视器：Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()），因此Lock操作比synchronized方式<strong>更加灵活</strong></li>
</ul>
</li>
</ul>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><h3 id="同步机制特点"><a href="#同步机制特点" class="headerlink" title="同步机制特点"></a>同步机制特点</h3><ul>
<li><p><strong>优势</strong>：有效解决线程安全问题</p>
</li>
<li><p><strong>劣势</strong>：效率低，且有可能造成死锁</p>
<blockquote>
<p>操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，因此效率低</p>
</blockquote>
</li>
</ul>
<h3 id="不同机制比较"><a href="#不同机制比较" class="headerlink" title="不同机制比较"></a>不同机制比较</h3><ul>
<li><strong>两种同步机制</strong><ol>
<li>synchronized：同步代码块、同步方法</li>
<li>Lock</li>
</ol>
</li>
<li><strong>同步机制的性能</strong><ul>
<li>原理：<ul>
<li>同步代码块包含代码少了<strong>线程不安全</strong>，包含<strong>多了</strong>，有可能<strong>退化成为单线程</strong></li>
<li>能完成功能的前提下，能包含代码<strong>越少越好，性能越高</strong></li>
</ul>
</li>
<li><strong>推荐使用同步机制顺序</strong>：<ul>
<li>Lock ——&gt; 同步代码块 ——&gt; 同步方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="同步监视器"><a href="#同步监视器" class="headerlink" title="同步监视器"></a>同步监视器</h3><ul>
<li><p>不同机制的同步监视器</p>
<ul>
<li>同步代码块：显式自定义，推荐Thread用<code>类.class</code>、Runnable使用<code>this</code></li>
<li>同步方法：static方法，默认使用<code>类.class</code>，非static使用<code>this</code></li>
<li>Lock：Lock对象本身就是同步监视器，若需保证同步监视器唯一性，则就是要保证Lock对象的唯一性</li>
</ul>
</li>
<li><p>同步监视器原理</p>
<ul>
<li>底层原理是一个<strong>互斥信号量</strong>(mutex=1)，俗称<strong>锁</strong></li>
<li>当线程<strong>进入synchronized</strong>(同步监视器)的操作：等价于<strong>P操作，上锁</strong>操作。</li>
<li>当synchronized所包含的代码执行完毕时：等价自定执行<strong>V操作</strong>，<strong>释放锁</strong>操作。</li>
</ul>
<hr>
<ul>
<li>使用synchronized(同步监视器)时，<strong>不是一定要保证是同一个同步监视器</strong></li>
<li>只有在操作互斥<strong>共享资源数为1个</strong>时，<strong>才需保证只操作同一个同步监视器</strong></li>
</ul>
</li>
</ul>
<h3 id="同步方法修饰"><a href="#同步方法修饰" class="headerlink" title="同步方法修饰"></a>同步方法修饰</h3><ul>
<li><p>对于Runnable方式，synchronized修饰在普通方法和静态方法都可以实现同步</p>
</li>
<li><p>对于Thread方式，只能修饰在静态方法中才能实现同步</p>
<hr>
</li>
<li><p>反过来：在静态方法上使用synchronized一定能实现同步</p>
</li>
<li><p>在非静态方法上使用synchronized不一定能实现同步</p>
</li>
</ul>
<h3 id="共享资源唯一性"><a href="#共享资源唯一性" class="headerlink" title="共享资源唯一性"></a>共享资源唯一性</h3><ul>
<li>多线程操作与共享资源在同一个类时<ul>
<li>Runnable方式天生具备共享资源特性，属性资源不用static修饰也是一份的</li>
<li>Thread方式共享资源则需要添加static关键字</li>
</ul>
</li>
<li>多线程操作与共享资源不是同一个类时<ul>
<li>可以在多线程操作类中将共享资源类作为类属性并通过构造器引入</li>
</ul>
</li>
</ul>
<h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><h2 id="基础概念-3"><a href="#基础概念-3" class="headerlink" title="基础概念"></a>基础概念</h2><p>这里通过借鉴“进程的通信”一概念来阐述“线程的通信”。 </p>
<ul>
<li><strong>线程通信</strong>：当多个线程<strong>协调一致</strong>完成一个作业时，常需要<strong>交换一定数量的信息</strong>(状态、数值等)<ul>
<li>协调工作：<ul>
<li><strong>线程协调工作</strong>：如如两个线程交替执行，先后执行，等待执行等等….</li>
<li><strong>线程同步</strong>是指通过修改线程信号量，可向另一个线程资源表明临界资源<strong>是否可用</strong>，<strong>本身就是一种简单的通信方式</strong></li>
</ul>
</li>
<li>交换数据：<ul>
<li>信号量机制作为同步工具是卓有成效的，但作为通信工具则不够理想，因为其效率低，称为低级通信方式。</li>
</ul>
</li>
</ul>
</li>
<li>此时线程通信更强调与多线程的各种协调工作。</li>
</ul>
<h2 id="synchronized线程通信"><a href="#synchronized线程通信" class="headerlink" title="synchronized线程通信"></a>synchronized线程通信</h2><h3 id="使用说明-3"><a href="#使用说明-3" class="headerlink" title="使用说明"></a>使用说明</h3><p>如下方法使用说明：</p>
<ul>
<li>均定义在java.lang.Object类中</li>
<li>均<strong>只能在synchronized范围内使用</strong>，即同步代码块或同步方法内使用</li>
<li>以下方法的<strong>调用对象</strong>默认均是<strong>当前synchronized的同步监视器对象</strong></li>
<li>若当前的同步监视器和调用如下方法的对象<strong>不是同一个对象</strong>，则会<strong>报出IllegalMonitorStateException非法监视器异常</strong>。因此建议同步监视器定义如下：<ul>
<li>在java中，方法调用没有显式写出调用对象，则默认普通方法为<code>this</code>，静态方法为<code>定义类.class</code></li>
<li>一般定义同步监视器时，配合上述的调用方法默认机制设置同步监视器。调用时就不用写调用对象</li>
<li>同步代码块：<ul>
<li>显式定义：Thread建议<code>继承类.class</code>，Runnable建议<code>this</code></li>
</ul>
</li>
<li>同步方法：<ul>
<li>系统隐式定义：同，同步代码块的显示定义</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>wait()</td>
<td>使其调用wati()方法的线程阻塞<br/>并释放该线程的所有同步监视器(锁)</td>
</tr>
<tr>
<td>notify()</td>
<td>会唤醒处于阻塞状态的一个线程<br/>如果有多个线程被wait，则唤醒优先级高的那个</td>
</tr>
<tr>
<td>notifyAll()</td>
<td>唤醒所有处于阻塞状态的线程</td>
</tr>
</tbody></table>
<h3 id="交替打印"><a href="#交替打印" class="headerlink" title="交替打印"></a>交替打印</h3><ul>
<li>两个线程交替打印0~100数字</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.java;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程通信案例：两个线程交替打印：1~100</span></span><br><span class="line"><span class="comment"> * 前提是在线程安全的情况下</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-06 9:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任意对象充当锁</span></span><br><span class="line">    <span class="comment">//当使用obj作为同步监视器时，wait、notify、notifyAll均需用obj对象调用</span></span><br><span class="line">    <span class="comment">//private Object obj = new Object();</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span> <span class="comment">/*obj*/</span>)&#123;</span><br><span class="line">                <span class="comment">//2、线程获取到锁进入后首先尝试唤醒另一个阻塞状态的线程</span></span><br><span class="line">                <span class="comment">//若不存在阻塞状态的其他线程，则相当于空操作</span></span><br><span class="line">                notify();<span class="comment">//obj.notify();</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印一个数字</span></span><br><span class="line">                <span class="keyword">if</span>(number &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + number);</span><br><span class="line">                    number++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//1、一个线程操作完后，通过调用wait()进入阻塞状态(并释放锁)</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();<span class="comment">//obj.wait();</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommunicationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Number number = <span class="keyword">new</span> Number();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(number);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(number);</span><br><span class="line"></span><br><span class="line">        thread1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        thread2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="wait-amp-sleep"><a href="#wait-amp-sleep" class="headerlink" title="wait&amp;sleep"></a>wait&amp;sleep</h3><p> sleep() 和 wait()的异同？</p>
<ol>
<li><p>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。</p>
</li>
<li><p>不同点：</p>
<ul>
<li><p>方法定义位置：Thread类中声明sleep() , Object类中声明wait()</p>
</li>
<li><p>调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中</p>
</li>
<li><p>关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。</p>
</li>
</ul>
</li>
</ol>
<h2 id="Lock线程通信"><a href="#Lock线程通信" class="headerlink" title="Lock线程通信"></a>Lock线程通信</h2><p>略</p>
<h2 id="生产者与消费者问题"><a href="#生产者与消费者问题" class="headerlink" title="生产者与消费者问题"></a>生产者与消费者问题</h2><ul>
<li>示例代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.exer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处</span></span><br><span class="line"><span class="comment"> * 取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图</span></span><br><span class="line"><span class="comment"> * 生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通</span></span><br><span class="line"><span class="comment"> * 知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如</span></span><br><span class="line"><span class="comment"> * 果店中有产品了再通知消费者来取走产品。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-06 10:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//店员对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CAPACITY = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity = <span class="number">0</span>;<span class="comment">//当前店员产品数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//进货函数，当库存满时，让生产者进程等待</span></span><br><span class="line">    <span class="comment">//由于Clerk对象只有一份，this能保证同步监视器的唯一性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(capacity &lt; MAX_CAPACITY)&#123;</span><br><span class="line">            capacity++;</span><br><span class="line">            <span class="comment">//Thread.sleep(500);</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进货1&quot;</span> + <span class="string">&quot;,当前库存&quot;</span> + capacity);</span><br><span class="line">            notify();<span class="comment">//唤醒有可能被阻塞的消费者线程</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;库存已满，请&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;等待&quot;</span>);</span><br><span class="line">            wait();<span class="comment">//阻塞生产者线程，让其等等，等候消费者线程将其唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//售卖商品函数，当库存为0时，让消费者进程等待</span></span><br><span class="line">    <span class="comment">//由于Clerk对象只有一份，this能保证同步监视器的唯一性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(capacity &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            capacity--;</span><br><span class="line">            <span class="comment">//Thread.sleep(500);</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费1&quot;</span> + <span class="string">&quot;,当前库存&quot;</span> + capacity);</span><br><span class="line">            notify();<span class="comment">//唤醒有可能被阻塞的生产者线程</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;库存已空，请&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;等待&quot;</span>);</span><br><span class="line">            wait();<span class="comment">//阻塞消费者线程，让其等等，等候生产者线程将其唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Clerk clerk)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从店员不断那买入商品</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clerk.sell();<span class="comment">//在店员处买入商品</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Clerk clerk)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不断往店员那进货商品</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clerk.stock();<span class="comment">//往店员那进货</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多线程执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Clerk clerk = <span class="keyword">new</span> Clerk();<span class="comment">//共享资源</span></span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(clerk);</span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer(clerk);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程执行操作</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(producer);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(customer);</span><br><span class="line"></span><br><span class="line">        thread1.setName(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">        thread2.setName(<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程安全与通信比较"><a href="#线程安全与通信比较" class="headerlink" title="线程安全与通信比较"></a>线程安全与通信比较</h2><ul>
<li><p><strong>线程安全</strong>的<strong>同步监视器身份</strong>的是<strong>方法的调用者，即调用对象</strong></p>
</li>
<li><p><strong>线程通信</strong>的<strong>操作对象</strong>是<strong>执行代码的线程</strong>，而<strong>非调用代码的对象</strong></p>
<ul>
<li>如wait、notify、sleep是看当前执行代码的线程是谁，而不是执行代码的对象是谁</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>互斥关系</strong>：用线程安全解决，synchronized 或 Lock</li>
<li><strong>同步关系</strong>：用线程通信解决，wait()，notify()，notifyAll()，或Thread.join()</li>
</ul>
<h1 id="多线程编程分析"><a href="#多线程编程分析" class="headerlink" title="多线程编程分析"></a>多线程编程分析</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li>是否是多线程问题？</li>
<li>是否存在共享资源，是什么？</li>
<li>哪些线程操作是互斥关系，哪些是同步关系<ul>
<li><strong>互斥关系</strong>：用线程安全解决，synchronized 或 Lock</li>
<li><strong>同步关系</strong>：用线程通信解决，wait()，notify()，notifyAll()，或Thread.join()</li>
</ul>
</li>
</ol>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>共享资源和多线程操作不是同一个类(<strong>常用</strong>)</p>
<ol>
<li><p><strong>多线程操作类</strong></p>
<ul>
<li><p>实现多线程操作，extends Thread，或 implements Runnable</p>
</li>
<li><p>声明共享资源属性</p>
</li>
<li><p>通过构造器的方式传入共享资源的引用，依次来保证其共享资源的同一性</p>
</li>
<li><p>在run方法里通过共享资源对象调用共享资源类中共享资源的操作方法</p>
</li>
</ul>
</li>
<li><p><strong>共享资源类中</strong></p>
<ul>
<li>由于多线程操作类通过引入该类对象方式操作共享资源，因此共享资源类中的共享资源<strong>不需要static修饰</strong></li>
<li>在共享资源类中定义多线程操作需调用的方法操作共享资源</li>
<li>对于操作共享资源的方法，需要利用线程安全与通信知识来控制多线程的操作</li>
</ul>
</li>
</ol>
<hr>
<ul>
<li><strong>参考代码</strong>：线程通信中的”生产者与消费者问题“实现代码</li>
</ul>
</li>
<li><p>共享资源和多线程操作都是同一个类中执行(不常用)</p>
<ul>
<li>将其类直接实现多线程：Thread或Runnable</li>
<li>将共享资源作为该类的属性：Thread用static修饰，Runnable则不用</li>
</ul>
<hr>
<ul>
<li><strong>参考代码</strong>：经线程安全改造的<strong>卖票模型</strong></li>
</ul>
</li>
</ol>
<h1 id="Callable线程创建"><a href="#Callable线程创建" class="headerlink" title="Callable线程创建"></a>Callable线程创建</h1><ul>
<li><strong>JDK5.0之后</strong>新增了<strong>实现Callable接口</strong>，与使用<strong>线程池</strong>创建多线程的方式</li>
</ul>
<h2 id="使用步骤-2"><a href="#使用步骤-2" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>实现Callable接口创建多线程的步骤如下：</p>
<ol>
<li>创建一个实现Callable接口的实现类，可以<strong>定义泛型</strong>用来表示<strong>返回值的类型</strong></li>
<li>实现call方法，将此线程需要执行的操作声明在call方法中</li>
<li>创建实现类的对象</li>
<li>创建FutureTask对象，并将Callable实现类对象作为参数传递到FutureTask类的构造器中，可以<strong>定义泛型</strong>用来表示<strong>返回值的类型</strong></li>
<li>创建Thread类的对象，并将Future实现类对象作为参数传递到Thread类的构造器中</li>
<li>通过Thread类的对象调用start()启动线程</li>
</ol>
<hr>
<ol start="7">
<li>若有需要<strong>获取call方法中的返回值</strong>：线程启动执行完毕后，通过调用Future实现类对象的get();方法获取call的返回值参数。</li>
</ol>
<h2 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h2><ul>
<li>创建一个子线程，将0~100以内的偶数打印出来并累加其结果返回</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-06 15:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadNum</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;<span class="comment">//指明返回值类型</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; i = &quot;</span> + i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        ThreadNum threadNum = <span class="keyword">new</span> ThreadNum();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(threadNum);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取线程执行的返回值结果</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer integer = futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;累加和结果为：integer = &quot;</span> + integer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><p>相比Runnable，Callable的<strong>功能更强大</strong></p>
<ul>
<li>相比run()方法，call()方法可以<strong>有返回值</strong></li>
<li>方法<strong>可以抛出异常</strong></li>
<li><strong>支持泛型</strong>的返回值</li>
<li>需要借助<strong>FutureTask</strong>类，比如获取返回结果</li>
</ul>
<h2 id="FutrueTask"><a href="#FutrueTask" class="headerlink" title="FutrueTask"></a>FutrueTask</h2><ul>
<li>可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等操作</li>
<li><strong>FutrueTask</strong>是Futrue接口的<strong>唯一的实现类</strong>，同样也<strong>支持泛型操作</strong></li>
<li>FutureTask同时实现了Runnable, Future接口。因此它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</li>
<li>注意，使用的时候要用FutureTask，Future没有实现任何接口</li>
</ul>
<h1 id="线程池创建线程"><a href="#线程池创建线程" class="headerlink" title="线程池创建线程"></a>线程池创建线程</h1><p>​    由于在实际开发中需大量创建线程操作，如一些资源的异步加载，而这些资源数是非常庞大的，如果没有给资源加载都是创建一个新的线程去执行，消耗的资源是很大的。因此基本很少会自己亲自的去造一个个线程，实际效率不好，开发中大多数都是使用线程池技术。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><p><strong>背景</strong>：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程， 对性能影响很大。</p>
</li>
<li><p><strong>思路</strong>：<strong>提前创建好多个线程</strong>，放入线程池中，使用时直接获取，使用完放回池中。可以<strong>避免频繁创建销毁</strong>、实现重复利用。类似生活中的公共交通工具、数据库连接池、缓冲池技术</p>
</li>
<li><p><strong>好处</strong>： </p>
<ul>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li>
<li>便于线程管理<ul>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>JDK 5.0起提供了线程池相关API：ExecutorService 和 Executors</p>
<p>Executors是一个<strong>工具类</strong>、线程池的工厂类，用于<strong>创建并返回不同类型的线程池</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Executors.newCachedThreadPool()</td>
<td>创建一个可根据需要创建新线程的线程池</td>
</tr>
<tr>
<td>Executors.newFixedThreadPool(n)</td>
<td>创建一个可重用，固定线程数量的线程池</td>
</tr>
<tr>
<td>Executors.newSingleThreadExecutor()</td>
<td>创建一个只有一个线程的线程池</td>
</tr>
<tr>
<td>Executors.newScheduledThreadPool(n)</td>
<td>创建一个线程池，<br/>它可安排在给定延迟后运行命令或者定期地执行</td>
</tr>
</tbody></table>
<h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><p>ExecutorService：真正的线程池<strong>接口</strong>，常见子类<strong>ThreadPoolExecutor</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void execute(Runnable command)</td>
<td>执行任务/命令，没有返回值，一般用来执行Runnable</td>
</tr>
<tr>
<td><T>Future<T> submit(Callable task)</td>
<td>执行任务，有返回值，一般又来执行 Callable</td>
</tr>
<tr>
<td>void shutdown()</td>
<td>关闭连接池</td>
</tr>
</tbody></table>
<h2 id="使用步骤-3"><a href="#使用步骤-3" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol>
<li>通过Runnable(含Thread)或Callable的方式创建好线程执行的内容</li>
<li>通过调用Executors工具类的静态方法创建线程池对象</li>
<li>可以选择强制转换为ThreadPoolExecutor类型进行一些线程池的管理操作</li>
<li>通过调用线程池对象的execute或submit方法去执行多线程操作的执行体</li>
</ol>
<h2 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-05 21:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 多线程执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可选择性对线程池进行参数设置，强制转换为ThreadPoolExecutor实现类，</span></span><br><span class="line">        <span class="comment">//ThreadPoolExecutor tpe = (ThreadPoolExecutor) executorService;</span></span><br><span class="line">        <span class="comment">//tpe.setCorePoolSize(20);</span></span><br><span class="line">        <span class="comment">//tpe.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line">        ThreadTest thread1 = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        ThreadTest thread2 = <span class="keyword">new</span> ThreadTest();</span><br><span class="line"></span><br><span class="line">        executorService<span class="comment">/* tpe */</span>.execute(thread1);<span class="comment">//执行线程</span></span><br><span class="line">        executorService<span class="comment">/* tpe */</span>.execute(thread2);<span class="comment">//执行线程</span></span><br><span class="line"></span><br><span class="line">        executorService<span class="comment">/* tpe */</span>.shutdown();<span class="comment">//关闭线程池</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>














        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：多线程编程基础</li>
        <li>Post author：yhd</li>
        <li>Create time：2021-06-06 17:15:32</li>
        <li>
            Post link：https://keep.xpoet.cn/2021/06/06/多线程编程基础/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/06/04/Gitee-API%E4%BD%BF%E7%94%A8HTTP%E5%8D%8F%E8%AE%AE%E6%9C%89%E6%84%9F/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Gitee-API使用HTTP协议有感</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">yhd</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.1</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.1.</span> <span class="nav-text">程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.4.</span> <span class="nav-text">线程的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E6%A0%B8%E4%B8%8E%E5%A4%9A%E6%A0%B8CPU"><span class="nav-number">1.5.</span> <span class="nav-text">单核与多核CPU</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="nav-number">1.6.</span> <span class="nav-text">并行与并发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">1.7.</span> <span class="nav-text">多线程的优势</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Thread%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">2.</span> <span class="nav-text">Thread线程创建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.1.</span> <span class="nav-text">使用步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">2.2.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#start-amp-run"><span class="nav-number">2.3.</span> <span class="nav-text">start&amp;run</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">2.4.</span> <span class="nav-text">多个线程创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA"><span class="nav-number">2.5.</span> <span class="nav-text">匿名方式创建</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Thread-API"><span class="nav-number">3.</span> <span class="nav-text">Thread-API</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Constructor"><span class="nav-number">3.1.</span> <span class="nav-text">Constructor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#method"><span class="nav-number">3.2.</span> <span class="nav-text">method</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="nav-number">4.</span> <span class="nav-text">线程调度策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">4.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="nav-number">4.2.</span> <span class="nav-text">常见调度策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="nav-number">4.3.</span> <span class="nav-text">Java调度策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">5.</span> <span class="nav-text">线程的优先级</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Runnable%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">6.</span> <span class="nav-text">Runnable线程创建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4-1"><span class="nav-number">6.1.</span> <span class="nav-text">使用步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="nav-number">6.2.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#start-amp-run-1"><span class="nav-number">6.3.</span> <span class="nav-text">start&amp;run</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%90%8C%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">6.4.</span> <span class="nav-text">相同线程创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA-1"><span class="nav-number">6.5.</span> <span class="nav-text">匿名方式创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread%E4%B8%8ERunnable%E6%AF%94%E8%BE%83"><span class="nav-number">6.6.</span> <span class="nav-text">Thread与Runnable比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">7.</span> <span class="nav-text">线程的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">7.1.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">7.2.</span> <span class="nav-text">线程状态转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-State"><span class="nav-number">7.3.</span> <span class="nav-text">Thread.State</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">8.</span> <span class="nav-text">线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-1"><span class="nav-number">8.1.</span> <span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-1"><span class="nav-number">8.1.1.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="nav-number">8.1.2.</span> <span class="nav-text">同步与互斥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%A4%E6%96%AD"><span class="nav-number">8.1.3.</span> <span class="nav-text">线程安全判断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%96%E7%A5%A8%E6%A8%A1%E5%9E%8B"><span class="nav-number">8.2.</span> <span class="nav-text">卖票模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Runnable%E6%96%B9%E5%BC%8F"><span class="nav-number">8.2.1.</span> <span class="nav-text">Runnable方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E6%96%B9%E5%BC%8F"><span class="nav-number">8.2.2.</span> <span class="nav-text">Thread方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="nav-number">8.2.3.</span> <span class="nav-text">问题分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">8.3.</span> <span class="nav-text">线程同步机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">8.3.1.</span> <span class="nav-text">同步代码块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="nav-number">8.3.1.1.</span> <span class="nav-text">使用说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Runnable%E6%96%B9%E5%BC%8F-1"><span class="nav-number">8.3.1.2.</span> <span class="nav-text">Runnable方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread%E6%96%B9%E5%BC%8F-1"><span class="nav-number">8.3.1.3.</span> <span class="nav-text">Thread方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">8.3.1.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-number">8.3.2.</span> <span class="nav-text">同步方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E-1"><span class="nav-number">8.3.2.1.</span> <span class="nav-text">使用说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Runnable%E6%96%B9%E5%BC%8F-2"><span class="nav-number">8.3.2.2.</span> <span class="nav-text">Runnable方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread%E6%96%B9%E5%BC%8F-2"><span class="nav-number">8.3.2.3.</span> <span class="nav-text">Thread方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="nav-number">8.3.2.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%E6%94%B9%E8%A3%85"><span class="nav-number">8.3.3.</span> <span class="nav-text">懒汉式改装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%A7%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">8.3.3.1.</span> <span class="nav-text">原始代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E6%94%B9%E8%A3%85"><span class="nav-number">8.3.3.2.</span> <span class="nav-text">同步方法改装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E6%94%B9%E8%A3%85"><span class="nav-number">8.3.3.3.</span> <span class="nav-text">同步代码块改装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E6%94%B9%E8%A3%85"><span class="nav-number">8.3.3.4.</span> <span class="nav-text">高性能同步代码块改装</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E7%9B%91%E8%A7%86%E5%99%A8%E5%8E%9F%E7%90%86"><span class="nav-number">8.3.4.</span> <span class="nav-text">同步监视器原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">8.3.5.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-2"><span class="nav-number">8.3.5.1.</span> <span class="nav-text">基础概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-2"><span class="nav-number">8.3.5.2.</span> <span class="nav-text">示例代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock"><span class="nav-number">8.3.6.</span> <span class="nav-text">Lock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="nav-number">8.3.6.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E-2"><span class="nav-number">8.3.6.2.</span> <span class="nav-text">使用说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Runnable%E6%96%B9%E5%BC%8F-3"><span class="nav-number">8.3.6.3.</span> <span class="nav-text">Runnable方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread%E6%96%B9%E5%BC%8F-3"><span class="nav-number">8.3.6.4.</span> <span class="nav-text">Thread方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lock%E4%B8%8Esynchronized%E5%BC%82%E5%90%8C"><span class="nav-number">8.3.6.5.</span> <span class="nav-text">Lock与synchronized异同</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="nav-number">8.4.</span> <span class="nav-text">小结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%89%B9%E7%82%B9"><span class="nav-number">8.4.1.</span> <span class="nav-text">同步机制特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E6%9C%BA%E5%88%B6%E6%AF%94%E8%BE%83"><span class="nav-number">8.4.2.</span> <span class="nav-text">不同机制比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E7%9B%91%E8%A7%86%E5%99%A8"><span class="nav-number">8.4.3.</span> <span class="nav-text">同步监视器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E4%BF%AE%E9%A5%B0"><span class="nav-number">8.4.4.</span> <span class="nav-text">同步方法修饰</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E5%94%AF%E4%B8%80%E6%80%A7"><span class="nav-number">8.4.5.</span> <span class="nav-text">共享资源唯一性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">9.</span> <span class="nav-text">线程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-3"><span class="nav-number">9.1.</span> <span class="nav-text">基础概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">9.2.</span> <span class="nav-text">synchronized线程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E-3"><span class="nav-number">9.2.1.</span> <span class="nav-text">使用说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#API"><span class="nav-number">9.2.2.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0"><span class="nav-number">9.2.3.</span> <span class="nav-text">交替打印</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait-amp-sleep"><span class="nav-number">9.2.4.</span> <span class="nav-text">wait&amp;sleep</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">9.3.</span> <span class="nav-text">Lock线程通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">9.4.</span> <span class="nav-text">生产者与消费者问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%80%9A%E4%BF%A1%E6%AF%94%E8%BE%83"><span class="nav-number">9.5.</span> <span class="nav-text">线程安全与通信比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-number">10.</span> <span class="nav-text">多线程编程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%9E%90"><span class="nav-number">10.1.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4"><span class="nav-number">10.2.</span> <span class="nav-text">步骤</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Callable%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">11.</span> <span class="nav-text">Callable线程创建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4-2"><span class="nav-number">11.1.</span> <span class="nav-text">使用步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-3"><span class="nav-number">11.2.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Callable%E6%8E%A5%E5%8F%A3"><span class="nav-number">11.3.</span> <span class="nav-text">Callable接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FutrueTask"><span class="nav-number">11.4.</span> <span class="nav-text">FutrueTask</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">12.</span> <span class="nav-text">线程池创建线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">12.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Executors"><span class="nav-number">12.2.</span> <span class="nav-text">Executors</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ExecutorService"><span class="nav-number">12.3.</span> <span class="nav-text">ExecutorService</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4-3"><span class="nav-number">12.4.</span> <span class="nav-text">使用步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-4"><span class="nav-number">12.5.</span> <span class="nav-text">示例代码</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>



<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
