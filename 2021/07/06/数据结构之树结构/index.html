<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="yhd">
    
    <title>
        
            数据结构之树结构 |
        
        DyhBlog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/MyLogo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"yoursite.com","root":"/","language":"en","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.jpg","favicon":"/images/MyLogo.svg","article_img_align":"left","left_side_width":"230px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.jpeg"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.1"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.1.1"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                DyhBlog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">数据结构之树结构</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">yhd</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-07-06 20:55:45
    </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>6.4k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>23 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p><strong>引言</strong>：本文主要介绍了树相关的数据结构。主要内容有树的基本概念、树的遍历、树的存储结构，如双亲表示法、孩子表示法、孩子兄弟表示法。以及二叉树的定义、分类、遍历。二叉树的性质、二叉树的顺序存储结构、链式存储结构，及其二叉链表的实现。最后介绍了森林相关概念以及与二叉树、树之间的转化。最后包含哈夫曼树及其编码的介绍。</p>
<blockquote>
<p><strong>参考资料</strong>：</p>
<ul>
<li>《数据结构——从概念到C++实现》（第3版）- 王红梅 - 清华大学出版社</li>
<li>《数据结构——从概念到Java实现》（第2版）- 王红梅 - 清华大学出版社</li>
<li>《大话数据结构》（第1版）- 程杰 - 清华大学出版社 </li>
</ul>
</blockquote>
<ul>
<li><strong>树结构知识图谱之思维导图</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%A0%91%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png"
                     
                ></p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="树的逻辑结构"><a href="#树的逻辑结构" class="headerlink" title="树的逻辑结构"></a>树的逻辑结构</h2><ol>
<li>树(Tree)是n(n ≥ 0)个结点的<strong>有限集</strong>，n = 0则为<strong>空树</strong>，与图一样是一种<strong>非线性结构</strong></li>
<li>在任意一颗树中，<strong>有且仅有一个</strong>称为<strong>根</strong>(Root)的结点</li>
<li>当结点 n &gt; 1，<strong>其余结点</strong>可分为m个<strong>互不相交</strong>的有限集T<sub>1</sub>、T<sub>2</sub>、…T<sub>m</sub></li>
<li>其中每个互不相交的有限集本身<strong>又是一颗树</strong>，并称为<strong>根的子树</strong>(SubTree)</li>
</ol>
<p><strong>总结</strong>：有且只有有一个<strong>根结点</strong>，且<strong>子树互不相交</strong>的有限集</p>
<h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><ul>
<li><strong>结点的度</strong>、<strong>树的度</strong>（结点最大的度）</li>
<li><strong>叶子节点</strong>/终端结点（度为0）、<strong>分支结点</strong>/内部结点/非终端结点（度 &gt; 1）</li>
<li><strong>孩子节点、双亲结点、兄弟结点、祖先、子孙</strong></li>
<li><strong>路径、路径长度</strong>（路径所经过的<strong>边数</strong>）</li>
<li><strong>结点的层数</strong>（根结点为第1层）、<strong>树的深度、树的宽度</strong>（某一层结点个数最大值）</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%A0%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B52.jpg"
                     
                ></p>
<h2 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ADT  Tree</span><br><span class="line">DataModel</span><br><span class="line">    树由一个根结点和若干棵子树构成，树中结点具有层次关系</span><br><span class="line">Operation</span><br><span class="line">    initTree：初始化一棵树 </span><br><span class="line">    preOrder：前序遍历树</span><br><span class="line">    postOrder：后序遍历树</span><br><span class="line">    leverOrder：层序遍历树	&#x2F;&#x2F;简单起见，只讨论树的遍历</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>

<h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><ul>
<li>树的遍历指，按照某种次序，访问树中所有结点，且每个结点有且只有一次被访问。</li>
<li>若规定<strong>从左到右</strong>遍历，树的遍历一般<strong>存在3种</strong><ul>
<li>前序(根)遍历：<strong>每一颗子树</strong>的遍历顺序都是，<strong>根结点、从左到右</strong></li>
<li>后序(根)遍历：<strong>每一颗子树</strong>的遍历顺序都是，<strong>从左到右、根结点</strong></li>
<li>层序遍历，又称广度遍历：从根结点开始，<strong>自上而下，从左到右，逐层遍历</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>若树为二叉树、还存在一种中序(根)遍历</p>
<p>树的遍历都是递归遍历</p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul>
<li>若存在一颗树结构如下图，则三种遍历的结果如下所示</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210706081106.png"
                     
                ></p>
<ul>
<li>前根遍历：ABDEIFCGH</li>
<li>后根遍历：DIEFBGHCA</li>
<li>层序遍历：ABCDEFGHI</li>
</ul>
<h1 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h1><table>
<thead>
<tr>
<th>树的存储结构</th>
<th>设计依据</th>
<th>存储结构类型</th>
</tr>
</thead>
<tbody><tr>
<td><strong>双亲表示法</strong></td>
<td>双亲唯一</td>
<td>顺序存储结构（<strong>数组 + 下标</strong>）</td>
</tr>
<tr>
<td><strong>孩子表示法</strong></td>
<td>长子唯一</td>
<td>顺序存储 + 链式存储结构（<strong>数组 + 下标 + 链表</strong>）</td>
</tr>
<tr>
<td><strong>孩子兄弟表示法</strong></td>
<td>长子 与 右兄弟唯一</td>
<td>链式存储结构（<strong>链表</strong>）</td>
</tr>
</tbody></table>
<h2 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h2><ul>
<li>除根结点外，每个一结点的只有一个双亲（parent）</li>
</ul>
<h3 id="结构实现"><a href="#结构实现" class="headerlink" title="结构实现"></a>结构实现</h3><h4 id="数组元素"><a href="#数组元素" class="headerlink" title="数组元素"></a>数组元素</h4><ul>
<li><strong>数据域</strong>（data）：存放结点数据实体</li>
<li><strong>指针域</strong>（parent）：指向父节点在数组中的下标值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentNode</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> parent;</span><br><span class="line">    <span class="comment">//省略getter和setter方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例图"><a href="#示例图" class="headerlink" title="示例图"></a>示例图</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/ds-%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%952.jpg"
                     
                ></p>
<h3 id="性能与优化"><a href="#性能与优化" class="headerlink" title="性能与优化"></a>性能与优化</h3><ul>
<li>双亲表示法查找性能</li>
</ul>
<table>
<thead>
<tr>
<th>查找要素</th>
<th>查找思路</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><strong>双亲结点</strong></td>
<td>取待查找结点的parent值在数组中取得双亲结点</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>孩子结点</strong></td>
<td>取待查找结点的下标索引值在数组中遍历为此索引值的parent值</td>
<td>O(n)</td>
</tr>
</tbody></table>
<ul>
<li>快速查找孩子：<strong>增设firstChild</strong>域可使查找第一个孩子的时间复杂度O(1)</li>
<li>块速查找兄弟：查找兄弟结点 &gt; 2的孩子，可在以上基础<strong>再增设一个rightSib域</strong></li>
</ul>
<h2 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h2><ul>
<li>把每一个结点（子树）都看作是它的孩子（由长子带领）所组成的链表结构</li>
</ul>
<h3 id="结构实现-1"><a href="#结构实现-1" class="headerlink" title="结构实现"></a>结构实现</h3><h4 id="表头结点"><a href="#表头结点" class="headerlink" title="表头结点"></a>表头结点</h4><ul>
<li><strong>结点数据域</strong>（data）：存放结点数据实体</li>
<li><strong>长子指针域</strong>（firstChild）：指向第一个孩子的引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> ChildNode firstChild;</span><br><span class="line">    <span class="comment">//省略getter和setter方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="孩子结点"><a href="#孩子结点" class="headerlink" title="孩子结点"></a>孩子结点</h4><ul>
<li><strong>指向孩子结点实体的引用</strong>（child）：孩子结点在表头数组中的<strong>数组下标位置</strong></li>
<li><strong>指向下一个孩子的指针域</strong>（next）：指向下一个孩子的引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> child;</span><br><span class="line">    <span class="keyword">private</span> ChildNode next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例图-1"><a href="#示例图-1" class="headerlink" title="示例图"></a>示例图</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210706092206.png"
                     
                ></p>
<h3 id="性能与优化-1"><a href="#性能与优化-1" class="headerlink" title="性能与优化"></a>性能与优化</h3><ul>
<li>孩子表示法查找性能</li>
</ul>
<table>
<thead>
<tr>
<th>查找要素</th>
<th>查找思路</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><strong>双亲结点</strong></td>
<td>得到待查找结点的下标值，遍历表头数组，再遍历孩子链表，寻找<br>孩子索引，即需要扫描整个表，即树的所有元素，因此时间复杂度总体为O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>孩子结点</strong></td>
<td>没有指明需要哪个孩子，则直接可获得孩子链表</td>
<td>O(1)</td>
</tr>
</tbody></table>
<ul>
<li>快速查找双亲：增设一个parent域，使其查找性能为O(1)</li>
</ul>
<h2 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h2><ul>
<li>孩子兄弟表示法，又称为二叉链表，只通过链式存储结构实现</li>
<li>依据每个结点具有唯一的长子和右兄弟来实现</li>
</ul>
<h3 id="结构实现-2"><a href="#结构实现-2" class="headerlink" title="结构实现"></a>结构实现</h3><h4 id="结点结构"><a href="#结点结构" class="headerlink" title="结点结构"></a>结点结构</h4><ul>
<li><strong>数据域</strong>（data）：存储元素数据实体内容</li>
<li><strong>长子指针域</strong>（firstChild）：指向该结点的第一个孩子的引用</li>
<li><strong>兄弟指针域</strong>（rightSib）：指向该结点的右边第一个兄弟的引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CSNode</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> ChildNode firstChild;</span><br><span class="line">    <span class="keyword">private</span> ChildNode rightSib;</span><br><span class="line">    <span class="comment">//省略getter和setter方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例图-2"><a href="#示例图-2" class="headerlink" title="示例图"></a>示例图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210706093904.png"
                     
                ></p>
<h4 id="性能与优化-2"><a href="#性能与优化-2" class="headerlink" title="性能与优化"></a>性能与优化</h4><ul>
<li>孩子兄弟表示法查找性能</li>
</ul>
<table>
<thead>
<tr>
<th>查找要素</th>
<th>查找思路</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><strong>双亲结点</strong></td>
<td>扫描整个树</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>兄弟结点</strong></td>
<td>没有指明获取哪个兄弟结点，则直接取rightSib指针域内容</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>孩子结点</strong></td>
<td>没有指明获取哪个孩子结点，则直接取firstChild开始的rightSib链</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h2 id="了解-存储结构的演变"><a href="#了解-存储结构的演变" class="headerlink" title="(了解)存储结构的演变"></a>(了解)存储结构的演变</h2><ul>
<li>可能存在描述性错误，仅供了解和参考</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg"
                     
                ></p>
<h2 id="存储结构选型"><a href="#存储结构选型" class="headerlink" title="存储结构选型"></a>存储结构选型</h2><ul>
<li><p>树的存储结构中，“<strong>Xxx</strong>表示法”，则对<strong>Xxx</strong>的查找时间复杂度一般是O(1)，<strong>非Xxx对象</strong>操作则一般O(n)，O(n)即需要扫描整个树</p>
<blockquote>
<ul>
<li>如<strong>双亲</strong>表示法，对<strong>双亲</strong>的查找时间复杂度为O(1)，对孩子查找时间复杂度则为O(n)</li>
<li><strong>孩子</strong>表示法，对<strong>孩子</strong>的查找时间复杂度O(1)，对双亲查找实际则为O(n)</li>
</ul>
</blockquote>
</li>
<li><p>因此，当需要使用树结构的场景<strong>只对一种树的元素要求频繁操作</strong>，则可以从传统的三大树的存储结构中挑选</p>
<blockquote>
<ul>
<li>如并查集都只涉及某节点的双亲，因此可以采用双亲表示法存储，使对双亲的操作性能上更高</li>
</ul>
</blockquote>
</li>
<li><p>如果使用树结构的场景<strong>需对多种树的元素都具有高频的操作</strong>，则需要基于<strong>传统的树的存储结构基础上进行增强</strong>。即通过<strong>添加对应其他树的元素的指针域</strong>，来实现复杂的应用场景。这一定程度上就需要通过空间复杂度和代码复杂度来换取整体的时间复杂度了</p>
<blockquote>
<ul>
<li>如孩子表示法，可通过增加parent域，来弥补孩子表示法对双亲操作时间复杂度O(n)的缺陷。由此来应对要求高的树结构应用场景</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="定义与分类"><a href="#定义与分类" class="headerlink" title="定义与分类"></a>定义与分类</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><ul>
<li>每个结点<strong>最多只有2颗子树</strong>（或者为空），且<strong>分别为左右子树</strong>（<strong>有序</strong>）</li>
<li>二叉树和树是两种独立的树结构</li>
<li><strong>性质与特点</strong>：二叉树的度不大于2</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210706095745.png"
                     
                ></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="斜树"><a href="#斜树" class="headerlink" title="斜树"></a>斜树</h4><ul>
<li><strong>定义</strong>：<strong>斜树</strong>，又分为左斜树和右斜树<ul>
<li><strong>左斜树</strong>：所有结点都只有左子树的二叉树</li>
<li><strong>右斜树</strong>：所有结点都只有右子树的二叉树</li>
</ul>
</li>
<li><strong>性质与特点</strong>：<ul>
<li>每一层只有一个结点</li>
<li>斜树的结点个数与其深度相同</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210706095808.png"
                     
                ></p>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><ul>
<li><strong>定义</strong>：二叉树中<strong>所有结点都有两个子树</strong></li>
<li><strong>性质与特点</strong>：<ul>
<li>叶子节点只出现再最下层</li>
<li>只有度为0，和度为2的结点</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210706095945.png"
                     
                ></p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><ul>
<li>定义：若某二叉树<strong>按层序遍历</strong>编号，与<strong>同样深度</strong>的<strong>完全二叉树</strong>的<strong>每个位置的结点编号一致</strong></li>
<li><strong>性质与特点</strong>：<ul>
<li>一棵满二叉树肯定是一棵完全二叉树，反之则不然</li>
<li>完全二叉树，除去叶子结点这一层后为满二叉树</li>
<li>如果有度为1的结点，则该结点只有可能是左孩子</li>
<li>完全二叉树所有叶子节点只能集中在最下两层</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210706101625.png"
                     
                ></p>
<h2 id="遍历与逆推导"><a href="#遍历与逆推导" class="headerlink" title="遍历与逆推导"></a>遍历与逆推导</h2><h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><ul>
<li>二叉树由于规定了子树具有顺序，即分左子树和右子树</li>
<li>因此在基于树的遍历类型下，更明确遍历的树的顺序同数，还增加了中序(根)遍历方式</li>
<li>同样，二叉树的遍历和树的遍历，树的定义一致，属于子树的递归性操作</li>
</ul>
<blockquote>
<p>在进行理论层面的遍历推导时，要脱离代码进行纯理论的递归 演算，如没有左孩子，则继续分析下去，不要联想 null ，return等递归细节…</p>
</blockquote>
<h4 id="前根遍历"><a href="#前根遍历" class="headerlink" title="前根遍历"></a>前根遍历</h4><ul>
<li>理论：<strong>每一颗子树</strong>的遍历顺序都是，<strong>根结点、左子树、右子树</strong></li>
<li>实际：从根节点开始遍历，从上到下，按先左子树，后右子树的顺序遍历每一颗子树</li>
<li>特点：<strong>根节点</strong>总是在<strong>序列的首位</strong></li>
</ul>
<h4 id="中根遍历"><a href="#中根遍历" class="headerlink" title="中根遍历"></a>中根遍历</h4><ul>
<li>理论：<strong>每一颗子树</strong>的遍历顺序都是，<strong>左子树、根结点、右子树</strong></li>
<li>实际：从根节点出发，一直寻找左子树到底（没有左子树），再遍历此时的根，再遍历右子树，再回返一步递归执行</li>
<li>特点：在通过遍历逆推树结构中，<strong>唯一能确定一颗二叉树</strong></li>
</ul>
<h4 id="后根遍历"><a href="#后根遍历" class="headerlink" title="后根遍历"></a>后根遍历</h4><ul>
<li>理论：<strong>每一颗子树</strong>的遍历顺序都是，<strong>左子树、右子树、根结点</strong></li>
<li>实际：根结点出发(不遍历)，从下到上，同样按先左子树<strong>，</strong>后右子树的顺序遍历每一颗子树。最后再遍历每颗子树的根结点</li>
<li>特点：<strong>根节点</strong>总是在<strong>序列的末位</strong></li>
</ul>
<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><ul>
<li>同树的层序遍历，从根结点开始，<strong>自上而下，从左子树到右子树，逐层遍历</strong></li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210706102436.png"
                     
                ></p>
<h3 id="遍历逆推导"><a href="#遍历逆推导" class="headerlink" title="遍历逆推导"></a>遍历逆推导</h3><h4 id="推到方法"><a href="#推到方法" class="headerlink" title="推到方法"></a>推到方法</h4><ol>
<li><p><strong>寻找根节点</strong>：前序遍历（序列首位），后序遍历（序列末位） </p>
</li>
<li><p><strong>根据每个子树的根节点与缩减孩子集范围间，循环推导</strong></p>
<ul>
<li>从前序或后序遍历得出根结点后</li>
<li>在中序遍历中找到根结点，从而划分该根节点的左右子树范围</li>
<li>先取一个子树的范围序列，在前序或后续中找到该子树范围的根结点</li>
<li>再把得出的子树的根结点在中序遍历中找到，并进一步划分出子树的左右子树范围</li>
<li>以此循环类推….</li>
</ul>
</li>
<li><p><strong>经验总结</strong></p>
<ul>
<li><strong>必须含中序遍历</strong>的条件则<strong>才能唯一确定</strong>一颗二叉树</li>
<li><strong>前序遍历</strong>，用于<strong>确定根后</strong>与<strong>中序遍历占位</strong>后，<strong>来确定左孩子</strong>(同时也确定子树的根，再中序域划分…)</li>
<li><strong>中序遍历</strong>，主要用于，<strong>范围划分，且占位！</strong></li>
<li><strong>后序遍历</strong>，只要用于，<strong>被划分范围后，确定根结点(范围尾部)</strong></li>
</ul>
</li>
</ol>
<h4 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%86%E6%8E%A8%E5%AF%BC.png"
                     
                ></p>
<h2 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h2><ul>
<li>从满二叉树开始推到是最简单的，因为满二叉树非常规整，便于进行数学运算</li>
</ul>
<h3 id="满二叉树性质"><a href="#满二叉树性质" class="headerlink" title="满二叉树性质"></a>满二叉树性质</h3><ul>
<li>深度为 k 的二叉树<strong>必有</strong>有 2<sup> k</sup>-1个结点</li>
<li>第 i 层上<strong>必为</strong>的结点数为 2<sup>i -1 </sup></li>
<li>具有n个结点的满二叉树深度<strong>必为</strong> log<sub>2</sub>(n + 1)</li>
</ul>
<h3 id="二叉树性质-1"><a href="#二叉树性质-1" class="headerlink" title="二叉树性质"></a>二叉树性质</h3><ul>
<li>深度为 k 的二叉树<strong>最多</strong>有 2<sup> k </sup> -1个结点</li>
<li>第 i 层上<strong>最多</strong>的结点数为 2<sup>i -1 </sup></li>
<li>n<sub>0</sub> = n<sub>2</sub> + 1：叶子结点个数 = 度为 2 结点数 + 1</li>
</ul>
<h3 id="完全二叉树性质"><a href="#完全二叉树性质" class="headerlink" title="完全二叉树性质"></a>完全二叉树性质</h3><ul>
<li>具有 n 个结点完全二叉树深度为 ⌊𝒍𝒐𝒈𝟐𝒏)⌋ + 1</li>
<li>设从 1 开始按层序编号，n 为结点总数，关系如下<ul>
<li>若 i &gt; 1，则结点 i 的双亲编号为⌊𝒊/𝟐⌋，否则为根节点</li>
<li>若 2i ≤ n，则结点 i 的左孩子编号为 2i，否则 i 结点无左孩子</li>
<li>若 2i+1 ≤ n，则结点 i 的右孩子编号为 2i + 1，否则无右左孩子</li>
</ul>
</li>
</ul>
<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><ul>
<li>二叉树的存储结构一般可分为两种<ul>
<li>顺序存储结构：完全二叉树层序遍历编码顺序存储</li>
<li>链式存储：二叉链表，三叉链表等</li>
</ul>
</li>
</ul>
<h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><ul>
<li>由于二叉树定义严格，是一种特殊的树，因此可以<strong>仅使用顺序存储结构也能实现</strong>，</li>
<li>通过数组下标的数量关系就能体现结点之间的全部逻辑关系</li>
</ul>
<h4 id="存储原理"><a href="#存储原理" class="headerlink" title="存储原理"></a>存储原理</h4><ul>
<li>将二叉树以<strong>完全二叉树</strong>的<strong>层序遍历编码</strong>，<strong>空缺部分</strong>均填入<strong>空指针null</strong></li>
<li>对于完全二叉树，可以通过下标的数量性质就可以还原出二叉树的结构</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"
                     
                ></p>
<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><ul>
<li>若二叉树表现出一条<strong>深度为k的 左/右斜树</strong>，则需开辟 2<sup>k</sup>-1 个空间存储（满二叉树存储）</li>
<li><strong>造成大量空间的浪费</strong>，因此<strong>二叉树的顺序存储结构</strong>一般只用于<strong>完全二叉树</strong></li>
</ul>
<h3 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h3><h4 id="存储原理-1"><a href="#存储原理-1" class="headerlink" title="存储原理"></a>存储原理</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><ul>
<li>二叉链表（binary linked list）令二叉树的<strong>每个结点</strong>对应一个<strong>链表结点</strong></li>
<li>链表结点除存放<strong>数据本身外</strong>，还分别有<strong>指示左右孩子的指针</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png"
                     
                ></p>
<h5 id="链表结点属性"><a href="#链表结点属性" class="headerlink" title="链表结点属性"></a>链表结点属性</h5><ul>
<li><strong>数据域</strong>（data）：存放数据元素实体</li>
<li><strong>左孩子指针域</strong>（lchild）：指向该结点的左孩子结点</li>
<li><strong>右孩子指针域</strong>（rchild）：指向该结点的右孩子结点</li>
</ul>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BiNode</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;	<span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">private</span> BiNode&lt;T&gt; lChiled,rChild; <span class="comment">//左右孩子指针域</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BiNode</span><span class="params">(T element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三叉链表"><a href="#三叉链表" class="headerlink" title="三叉链表"></a>三叉链表</h3><ul>
<li>在二叉链表中，如果需要找到它的双亲结点则需要从根结点开始扫描</li>
<li>若需频繁搜寻双亲结点，则建议使用<strong>三叉链表</strong>，即在二叉链表基础添加一个指向双亲的引用</li>
</ul>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li><strong>数据域</strong>（data）：存放数据元素实体</li>
<li><strong>左孩子指针域</strong>（lchild）：指向该结点的左孩子结点</li>
<li><strong>右孩子指针域</strong>（rchild）：指向该结点的右孩子结点</li>
<li><strong>双亲指针域</strong>（parent）：指向该结点的双亲结点</li>
</ul>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TirNode</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;	<span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">private</span> BiNode&lt;T&gt; lChiled,rChild,parent; <span class="comment">//左右孩子指针域、双亲指针域</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BiNode</span><span class="params">(T element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉链表实现"><a href="#二叉链表实现" class="headerlink" title="二叉链表实现"></a>二叉链表实现</h2><h3 id="ADT-1"><a href="#ADT-1" class="headerlink" title="ADT"></a>ADT</h3><ul>
<li>依据二叉树的抽象数据类型，定义二叉树的Java接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BinaryTreeInterface</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;	<span class="comment">//前根遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;	<span class="comment">//中根遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>;	<span class="comment">//后根遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>;	<span class="comment">//层序遍历二叉树</span></span><br><span class="line">    <span class="comment">//创建二叉树,返回根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BiNode&lt;T&gt; <span class="title">creatBiTree</span><span class="params">(SequentialList&lt;T&gt; treeElement)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>二叉链表实现，二叉链表结点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BiNode</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;	<span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">private</span> BiNode&lt;T&gt; lChiled,rChild; <span class="comment">//左右孩子指针域</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BiNode</span><span class="params">(T element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>二叉链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">BinaryTreeInterface</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BiNode&lt;T&gt; root;	<span class="comment">//根节点</span></span><br><span class="line">    <span class="comment">//实现相关ADT定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建二叉树"><a href="#构建二叉树" class="headerlink" title="构建二叉树"></a>构建二叉树</h3><h4 id="扩展二叉树"><a href="#扩展二叉树" class="headerlink" title="扩展二叉树"></a>扩展二叉树</h4><ul>
<li>由于前、中、后根遍历<strong>任何一个单一的序列都不能唯一确定一棵二叉树</strong>（主要是度为1的左右子树）</li>
<li>为了能<strong>让每个结点确认是否有左右孩子</strong>，将其每个结点的<strong>空指针处引出一个虚结点</strong></li>
<li>这种扩展后的二叉树称为<strong>扩展二叉树</strong>，它遍历后的序列<strong>能唯一确定一颗二叉树</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%89%A9%E5%B1%95%E4%BA%8C%E5%8F%89%E6%A0%91.jpeg"
                     
                ></p>
<h4 id="构建原理"><a href="#构建原理" class="headerlink" title="构建原理"></a>构建原理</h4><ul>
<li>通过扩展二叉树构建二叉树的原理在于，把每<strong>一个结点都看作一个子树的根结点</strong></li>
<li>根据给出的扩展二叉树遍历序列，以同样的遍历次序扫描序列，<strong>若不为”#”则创建结点</strong></li>
</ul>
<h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><ul>
<li><strong>version 1.0</strong>：逻辑更贴切，但代码可优化，将if-else的条件反转，可减少一个取反操作 !</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录序列顺序表遍历的索引。由于java没有具备static，因此只能通过声明全局变量的方式实现</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 通过前序扩展二叉树序列，初始化二叉链表</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> treeElement 扩展二叉树序列</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 初始化后的二叉链表根结点</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BiNode&lt;T&gt; <span class="title">creatBiTree</span><span class="params">(SequentialList&lt;T&gt; treeElement)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明待创建结点引用</span></span><br><span class="line">    BiNode&lt;T&gt; node = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ++index;</span><br><span class="line">    <span class="comment">//结点存在</span></span><br><span class="line">    <span class="comment">//index &lt; treeElement.length，相当于在递归中进行for循环遍历</span></span><br><span class="line">    <span class="keyword">if</span>(index &lt; treeElement.length()</span><br><span class="line">       &amp;&amp; !(<span class="string">&quot;#&quot;</span>.equals(treeElement.getElement(index))))&#123;</span><br><span class="line">        node = <span class="keyword">new</span> BiNode&lt;&gt;(treeElement.getElement(index));</span><br><span class="line">        node.setlChild(creatBiTree(treeElement));</span><br><span class="line">        node.setrChild(creatBiTree(treeElement));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>version 2.0</strong>，反转了if-else判别条件，功能一样，代码效率更高，<strong>推荐</strong>！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序表遍历索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 通过前序扩展二叉树序列，初始化二叉链表</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> treeElement 扩展二叉树序列</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 初始化后的二叉链表根结点</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BiNode&lt;T&gt; <span class="title">creatBiTree</span><span class="params">(SequentialList&lt;T&gt; treeElement)</span> </span>&#123;</span><br><span class="line">    BiNode&lt;T&gt; node = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ++index;</span><br><span class="line">    <span class="keyword">if</span>(index &gt; treeElement.length()</span><br><span class="line">       || <span class="string">&quot;#&quot;</span>.equals(treeElement.getElement(index)))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        node = <span class="keyword">new</span> BiNode&lt;&gt;(treeElement.getElement(index));</span><br><span class="line">        node.setlChild(creatBiTree(treeElement));</span><br><span class="line">        node.setrChild(creatBiTree(treeElement));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="前根遍历-1"><a href="#前根遍历-1" class="headerlink" title="前根遍历"></a>前根遍历</h3><h4 id="遍历原理"><a href="#遍历原理" class="headerlink" title="遍历原理"></a>遍历原理</h4><ul>
<li>如同树与二叉树所定义的前根遍历，过程本身就是一个递归过程</li>
<li>因此代码实现可以考虑同样使用<strong>递归实现</strong><ul>
<li>其他的<strong>中根、后根遍历代码类似，只是遍历顺序不一样而已</strong></li>
</ul>
</li>
<li>二叉树前序遍历的递归调用过程示意图，有需要可以参考</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210706155241.png"
                     
                ></p>
<h4 id="递归实现-1"><a href="#递归实现-1" class="headerlink" title="递归实现"></a>递归实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 二叉树前序遍历</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    preOrder(root);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 前序遍历递归实现的重载方法</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BiNode&lt;T&gt; node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.print(node.getData() + <span class="string">&quot; &quot;</span>); <span class="comment">//根结点先遍历</span></span><br><span class="line">        preOrder(node.getlChild()); <span class="comment">//左子树遍历</span></span><br><span class="line">        preOrder(node.getrChild()); <span class="comment">//右子树遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中根遍历-1"><a href="#中根遍历-1" class="headerlink" title="中根遍历"></a>中根遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同理前根遍历代码</span></span><br><span class="line">inOrder(node.getlChild()); <span class="comment">//左子树先遍历</span></span><br><span class="line">System.out.print(node.getData() + <span class="string">&quot; &quot;</span>); <span class="comment">//根结点遍历</span></span><br><span class="line">inOrder(node.getrChild()); <span class="comment">//右子树遍历</span></span><br></pre></td></tr></table></figure>

<h3 id="后根遍历-1"><a href="#后根遍历-1" class="headerlink" title="后根遍历"></a>后根遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同理前根遍历代码</span></span><br><span class="line">postOrder(node.getlChild()); <span class="comment">//左子树先遍历</span></span><br><span class="line">postOrder(node.getrChild()); <span class="comment">//右子树遍历</span></span><br><span class="line">System.out.print(node.getData() + <span class="string">&quot; &quot;</span>); <span class="comment">//根结点最后遍历</span></span><br></pre></td></tr></table></figure>

<h3 id="层序遍历-1"><a href="#层序遍历-1" class="headerlink" title="层序遍历"></a>层序遍历</h3><h4 id="遍历原理-1"><a href="#遍历原理-1" class="headerlink" title="遍历原理"></a>遍历原理</h4><ul>
<li>层序遍历规定，先访问完一层的结点后，再对下一层的结点访问。不涉及递归访问</li>
<li>此时可以利用<strong>队列作为辅助结构</strong><ol>
<li>初始化队列</li>
<li>若二叉树非空，则将根节点入队</li>
<li><strong>循环直到队列为空</strong><ol>
<li><strong>队头结点q出队并返回其数据域，输出结果</strong></li>
<li><strong>若q存在左孩子，则将左孩子入队</strong></li>
<li><strong>若q存在右孩子，则将右孩子入队</strong></li>
</ol>
</li>
</ol>
</li>
<li>下图为通过队列实现层序遍历的过程示意图：</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0.png"
                     
                ></p>
<h4 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 二叉树层序遍历实现</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkedQueue&lt;BiNode&gt; queue = <span class="keyword">new</span> LinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue.enQueue(root);</span><br><span class="line">    BiNode&lt;T&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        node = queue.deQueue();</span><br><span class="line">        System.out.print(node.getData() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(node.getlChild() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.enQueue(node.getlChild());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.getrChild() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.enQueue(node.getrChild());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li><strong>森林</strong>：<em>m</em>（<em>m</em>≥0）棵<strong>互不相交的树</strong>的<strong>集合</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210706163920.png"
                     
                ></p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ul>
<li>同树遍历定义</li>
</ul>
<h2 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h2><p>树转换为二叉树：“<strong>加兄保子调层次</strong>”</p>
<ul>
<li><strong>加兄</strong>： 所有兄弟节点之间加一条线</li>
<li><strong>保子</strong>：每个结点，<strong>只保留 firstchild 的连线</strong>，其余均删除</li>
<li><strong>层次调整</strong>： <strong>原树为基准</strong>每个结点<strong>除第一个孩子</strong>为左孩子外，<strong>其余孩子</strong>为<strong>这个左孩子</strong>的<strong>右孩子的右孩子的右孩子…</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210706164616.png"
                     
                ></p>
<h2 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h2><p>森林转换为二叉树：“<strong>森林变树，依次连根</strong>”</p>
<ul>
<li><strong>森林变树</strong>：把森林的<strong>每颗树</strong>转换为<strong>二叉树</strong></li>
<li><strong>依次连根</strong>：第一颗树不动，其余树<strong>依次</strong>成为<strong>上一颗树</strong>根结点的右孩子</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210706164936.png"
                     
                ></p>
<h2 id="二叉树转化为树或森林"><a href="#二叉树转化为树或森林" class="headerlink" title="二叉树转化为树或森林"></a>二叉树转化为树或森林</h2><p>二叉树转换为树或森林：“<strong>加线、去线，若二叉树有右孩子，则会转换为森林</strong>”</p>
<ul>
<li><strong>加线</strong>：把每个结点<strong>第一个左孩子</strong>的<strong>右孩子序列</strong>，<strong>与该结点相连</strong></li>
<li>去线：删除<strong>原二叉树</strong>每个结点与<strong>右孩子的连线</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210706165335.png"
                     
                ></p>
<h1 id="最优二叉树"><a href="#最优二叉树" class="headerlink" title="最优二叉树"></a>最优二叉树</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li><strong>最优二叉树</strong>又称为哈夫曼树或赫夫曼树，其应用是<strong>哈夫曼编码</strong>，用于<strong>数据压缩和解压</strong></li>
<li>哈夫曼编码的目的是，让单一的线性的区分结构，通过权/频率，且用<strong>二叉树来体现权</strong>。从而开始基于从路径长度上进行优化，从而使得，在代码执行上缩短总的执行次数。</li>
<li>在存储空间上可以应用在<strong>设计长短不等的编码</strong>，在通过<strong>编码的层面上实现无损的数据压缩</strong>(哈夫曼编码)</li>
</ul>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="带权路径长度"><a href="#带权路径长度" class="headerlink" title="带权路径长度"></a>带权路径长度</h3><ul>
<li>若给二叉树中的每个<strong>叶子结点</strong>赋予一个有意义的数值量，即<strong>权值</strong></li>
<li>此时<strong>从根节点</strong>到<strong>各个叶子结点</strong>的<strong>路径长度</strong>与相应<strong>叶子结点权值的乘积</strong>，<strong>之和</strong>称为该二叉树的<strong>带权路径长度WPL</strong>（weighted path length）</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210706170846.png"
                     
                ></p>
<h3 id="最优二叉树定义"><a href="#最优二叉树定义" class="headerlink" title="最优二叉树定义"></a>最优二叉树定义</h3><ul>
<li>其中一棵二叉树中<strong>带权路径WPL最小的形态</strong>为该树的<strong>最优二叉树</strong>，也称为<strong>哈夫曼树</strong></li>
</ul>
<h2 id="构建哈夫曼树"><a href="#构建哈夫曼树" class="headerlink" title="构建哈夫曼树"></a>构建哈夫曼树</h2><h3 id="理论指导"><a href="#理论指导" class="headerlink" title="理论指导"></a>理论指导</h3><p>若想一颗二叉树的WPL最小，即构建最优二叉树，则必须</p>
<ul>
<li><strong>权值越大</strong>的叶子节点<strong>越靠近根结点</strong></li>
<li><strong>权值越小</strong>的结点越<strong>远离根结点</strong></li>
<li>而且<strong>不存在度为1的结点</strong></li>
</ul>
<h3 id="构建方法"><a href="#构建方法" class="headerlink" title="构建方法"></a>构建方法</h3><ol>
<li><strong>选取合并</strong>：从给定权值集合中选取权值最大的两个结点合并，将合并的权值作为这两个结点双亲结点(新结点)</li>
<li><strong>删除与加入</strong>：<ul>
<li><strong>删除</strong>：从给定权值集合中删除刚刚合并的结点权值</li>
<li><strong>加入</strong>：将合并权值后的双亲结点作为新结点加入权值集合中</li>
</ul>
</li>
<li><strong>重复步骤1，2</strong>直至权值<strong>集合为空</strong></li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210706171600.png"
                     
                ></p>
<h3 id="哈夫曼结点结构"><a href="#哈夫曼结点结构" class="headerlink" title="哈夫曼结点结构"></a>哈夫曼结点结构</h3><ul>
<li>若采用<strong>顺序存储结构</strong>，则一个哈夫曼结点结构如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> parent = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lChild = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rChild = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HuffmanNode</span><span class="params">(<span class="keyword">int</span> weight,<span class="keyword">int</span> iChild,<span class="keyword">int</span> rChild)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        <span class="keyword">this</span>.iChild = iChild;</span><br><span class="line">        <span class="keyword">this</span>.rChild = rChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略getter和setter方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>表示字符集的简单方法是列出所有字符，<strong>给每个字符赋予一个二进制位串</strong>，称为<strong>编码</strong>（coding）</li>
<li>假设所有<strong>编码都等长</strong>，则表示n个不同的字符需要⌈log<sub>2 </sub>n⌉位，这称为<strong>等长编码</strong>（equal-length code）<ul>
<li>如果每个字符的<strong>使用频率相等</strong>，则等<strong>长编码是空间效率最高的方法</strong></li>
</ul>
</li>
<li>如果<strong>字符出现的频率不等</strong>，可以让<strong>频率高的字符</strong>采用<strong>尽可能短的编码</strong>，频率低的字符采用稍长的编码，来构造一种<strong>不等长编码</strong>（unequal-length code），这也是<strong>文件压缩技术的核心思想</strong></li>
<li>而<strong>不等长编码实现</strong>的最基本条件是<strong>前缀无歧义编码</strong>，简称<strong>前缀编码</strong></li>
<li>而通过<strong>哈夫曼树进行的编码</strong>正是<strong>最优的不等长编码</strong>，因此也称为<strong>哈夫曼编码</strong></li>
</ul>
<h3 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h3><ol>
<li>通过给定的字符频率表建立哈夫曼编码树<ul>
<li>将<strong>字符数据本身</strong>作为<strong>叶子结点</strong></li>
<li>将字符出现的<strong>频率</strong>作为叶子节点的<strong>权值</strong></li>
</ul>
</li>
<li>规定编码，左子树路径为二进制0/1，右子树路径为二进制1/0</li>
<li>则每个字符的编码即是<strong>从根节点</strong>到该字符<strong>叶子</strong>结点<strong>路径上构成的二进制串</strong></li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E8%BF%87%E7%A8%8B.png"
                     
                ></p>
<h3 id="解码过程"><a href="#解码过程" class="headerlink" title="解码过程"></a>解码过程</h3><ul>
<li>从左到右<strong>逐位判别</strong>，直到先确认一个字符为止，(“先确先得”) </li>
<li>如上图示例：编码为<code>110100101</code>，解码为 <code>ADBE</code></li>
</ul>
<h3 id="性质与特点"><a href="#性质与特点" class="headerlink" title="性质与特点"></a>性质与特点</h3><ul>
<li>不等长编码且唯一解码</li>
<li>所有结点度为 0 或 2(不存在度为 1 的最优二叉树)</li>
</ul>
<h3 id="相关指标"><a href="#相关指标" class="headerlink" title="相关指标"></a>相关指标</h3><ul>
<li><strong>平均编码长度</strong>：叶子结点的平均深度</li>
<li><strong>编码总长度</strong>：带权路径长度</li>
</ul>
<h3 id="非二进制哈夫曼编码"><a href="#非二进制哈夫曼编码" class="headerlink" title="非二进制哈夫曼编码"></a>非二进制哈夫曼编码</h3><ul>
<li>多于二进制的哈夫曼编码：多分支，不够结点组合加入权值 0 结点组合</li>
</ul>
<h1 id="扩展与应用"><a href="#扩展与应用" class="headerlink" title="扩展与应用"></a>扩展与应用</h1><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="二叉树非递归遍历"><a href="#二叉树非递归遍历" class="headerlink" title="二叉树非递归遍历"></a>二叉树非递归遍历</h3><h3 id="线索链表"><a href="#线索链表" class="headerlink" title="线索链表"></a>线索链表</h3><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="堆与优先队列"><a href="#堆与优先队列" class="headerlink" title="堆与优先队列"></a>堆与优先队列</h3><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3>
        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：数据结构之树结构</li>
        <li>Post author：yhd</li>
        <li>Create time：2021-07-06 20:55:45</li>
        <li>
            Post link：https://keep.xpoet.cn/2021/07/06/数据结构之树结构/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E7%BB%93%E6%9E%84(%E6%9C%AA%E5%AE%8C%E6%88%90)/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">数据结构之图结构(未完成)</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/07/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">数据结构之字符串和多维数组</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">yhd</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.1</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">树的逻辑结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-number">1.2.</span> <span class="nav-text">基本术语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ADT"><span class="nav-number">1.3.</span> <span class="nav-text">ADT</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">2.</span> <span class="nav-text">树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">树的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">3.1.</span> <span class="nav-text">双亲表示法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.1.1.</span> <span class="nav-text">结构实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">数组元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E5%9B%BE"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">示例图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="nav-number">3.1.2.</span> <span class="nav-text">性能与优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">孩子表示法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">结构实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E5%A4%B4%E7%BB%93%E7%82%B9"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">表头结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%A9%E5%AD%90%E7%BB%93%E7%82%B9"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">孩子结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E5%9B%BE-1"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">示例图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%B8%8E%E4%BC%98%E5%8C%96-1"><span class="nav-number">3.2.2.</span> <span class="nav-text">性能与优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text">孩子兄弟表示法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">3.3.1.</span> <span class="nav-text">结构实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">结点结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E5%9B%BE-2"><span class="nav-number">3.3.2.</span> <span class="nav-text">示例图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%B8%8E%E4%BC%98%E5%8C%96-2"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">性能与优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E6%BC%94%E5%8F%98"><span class="nav-number">3.4.</span> <span class="nav-text">(了解)存储结构的演变</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E9%80%89%E5%9E%8B"><span class="nav-number">3.5.</span> <span class="nav-text">存储结构选型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">4.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="nav-number">4.1.</span> <span class="nav-text">定义与分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.1.</span> <span class="nav-text">逻辑结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-number">4.1.2.</span> <span class="nav-text">分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%9C%E6%A0%91"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">斜树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">满二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">4.1.2.3.</span> <span class="nav-text">完全二叉树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E4%B8%8E%E9%80%86%E6%8E%A8%E5%AF%BC"><span class="nav-number">4.2.</span> <span class="nav-text">遍历与逆推导</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86"><span class="nav-number">4.2.1.</span> <span class="nav-text">二叉树遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E6%A0%B9%E9%81%8D%E5%8E%86"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">前根遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%A0%B9%E9%81%8D%E5%8E%86"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">中根遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E6%A0%B9%E9%81%8D%E5%8E%86"><span class="nav-number">4.2.1.3.</span> <span class="nav-text">后根遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">4.2.1.4.</span> <span class="nav-text">层序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">4.2.1.5.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E9%80%86%E6%8E%A8%E5%AF%BC"><span class="nav-number">4.2.2.</span> <span class="nav-text">遍历逆推导</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A8%E5%88%B0%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">推到方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">实例演示</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%A7%E8%B4%A8"><span class="nav-number">4.3.</span> <span class="nav-text">二叉树性质</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%A7%E8%B4%A8"><span class="nav-number">4.3.1.</span> <span class="nav-text">满二叉树性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%A7%E8%B4%A8-1"><span class="nav-number">4.3.2.</span> <span class="nav-text">二叉树性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%A7%E8%B4%A8"><span class="nav-number">4.3.3.</span> <span class="nav-text">完全二叉树性质</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">4.4.</span> <span class="nav-text">二叉树的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="nav-number">4.4.1.</span> <span class="nav-text">顺序存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86"><span class="nav-number">4.4.1.1.</span> <span class="nav-text">存储原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-number">4.4.1.2.</span> <span class="nav-text">性能分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="nav-number">4.4.2.</span> <span class="nav-text">二叉链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86-1"><span class="nav-number">4.4.2.1.</span> <span class="nav-text">存储原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">4.4.2.1.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%E5%B1%9E%E6%80%A7"><span class="nav-number">4.4.2.1.2.</span> <span class="nav-text">链表结点属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.4.2.1.3.</span> <span class="nav-text">代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="nav-number">4.4.3.</span> <span class="nav-text">三叉链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7"><span class="nav-number">4.4.3.1.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">4.4.3.2.</span> <span class="nav-text">代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.5.</span> <span class="nav-text">二叉链表实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ADT-1"><span class="nav-number">4.5.1.</span> <span class="nav-text">ADT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">4.5.2.</span> <span class="nav-text">构建二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">4.5.2.1.</span> <span class="nav-text">扩展二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%8E%9F%E7%90%86"><span class="nav-number">4.5.2.2.</span> <span class="nav-text">构建原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.5.2.3.</span> <span class="nav-text">递归实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E6%A0%B9%E9%81%8D%E5%8E%86-1"><span class="nav-number">4.5.3.</span> <span class="nav-text">前根遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E5%8E%9F%E7%90%86"><span class="nav-number">4.5.3.1.</span> <span class="nav-text">遍历原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">4.5.3.2.</span> <span class="nav-text">递归实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%A0%B9%E9%81%8D%E5%8E%86-1"><span class="nav-number">4.5.4.</span> <span class="nav-text">中根遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E6%A0%B9%E9%81%8D%E5%8E%86-1"><span class="nav-number">4.5.5.</span> <span class="nav-text">后根遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-1"><span class="nav-number">4.5.6.</span> <span class="nav-text">层序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E5%8E%9F%E7%90%86-1"><span class="nav-number">4.5.6.1.</span> <span class="nav-text">遍历原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.5.6.2.</span> <span class="nav-text">队列实现</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A3%AE%E6%9E%97"><span class="nav-number">5.</span> <span class="nav-text">森林</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="nav-number">5.1.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">5.1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86"><span class="nav-number">5.1.2.</span> <span class="nav-text">遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.2.</span> <span class="nav-text">树转换为二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.3.</span> <span class="nav-text">森林转换为二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%A0%91%E6%88%96%E6%A3%AE%E6%9E%97"><span class="nav-number">5.4.</span> <span class="nav-text">二叉树转化为树或森林</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">6.</span> <span class="nav-text">最优二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">6.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">6.2.</span> <span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span class="nav-number">6.2.1.</span> <span class="nav-text">带权路径长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9A%E4%B9%89"><span class="nav-number">6.2.2.</span> <span class="nav-text">最优二叉树定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-number">6.3.</span> <span class="nav-text">构建哈夫曼树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E6%8C%87%E5%AF%BC"><span class="nav-number">6.3.1.</span> <span class="nav-text">理论指导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="nav-number">6.3.2.</span> <span class="nav-text">构建方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84"><span class="nav-number">6.3.3.</span> <span class="nav-text">哈夫曼结点结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-number">6.4.</span> <span class="nav-text">哈夫曼编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="nav-number">6.4.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E8%BF%87%E7%A8%8B"><span class="nav-number">6.4.2.</span> <span class="nav-text">编码过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E7%A0%81%E8%BF%87%E7%A8%8B"><span class="nav-number">6.4.3.</span> <span class="nav-text">解码过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%B4%A8%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="nav-number">6.4.4.</span> <span class="nav-text">性质与特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%8C%87%E6%A0%87"><span class="nav-number">6.4.5.</span> <span class="nav-text">相关指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-number">6.4.6.</span> <span class="nav-text">非二进制哈夫曼编码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="nav-number">7.</span> <span class="nav-text">扩展与应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95"><span class="nav-number">7.1.</span> <span class="nav-text">扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="nav-number">7.1.1.</span> <span class="nav-text">二叉树非递归遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E9%93%BE%E8%A1%A8"><span class="nav-number">7.1.2.</span> <span class="nav-text">线索链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-number">7.2.</span> <span class="nav-text">应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="nav-number">7.2.1.</span> <span class="nav-text">堆与优先队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">7.2.2.</span> <span class="nav-text">并查集</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>



<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
