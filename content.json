{"meta":{"title":"yhdblog","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"Repositories","date":"2020-08-25T13:03:56.000Z","updated":"2020-08-25T13:08:55.059Z","comments":true,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-08-25T12:50:00.000Z","updated":"2020-08-25T13:04:12.688Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mybatis3","slug":"Mybatis3","date":"2021-08-24T10:28:47.000Z","updated":"2021-08-25T15:27:11.624Z","comments":true,"path":"2021/08/24/Mybatis3/","link":"","permalink":"http://yoursite.com/2021/08/24/Mybatis3/","excerpt":"","text":"引言：本文主要介绍了Mybatis基础背景，基于Mybais3的官方文档说明了Mybatis的配置文件标签、SQL映射文件标签、动态SQL语句的编写，以及Mybatis的缓存机制，含一级二级缓存说明。其中补充了SSM的整合基础示例，Mybatis的逆向工程、以及Mybatis使用批量操作、调用存储过程、以及自定义类型处理器内容。 Mybatis概述背景历史原是Apache的一个开源项目iBatis, 2010年6月这 个项目由Apache Software Foundation 迁移到了 Google Code，随着开发团队转投Google Code 旗下， iBatis3.x正式更名为MyBatis ，代码于 2013年11月迁移到Github Mybatis的优势java领域中，对比最常见的三种数据库编程。 相关工具对比 相关工具：JDBC—&gt;Dbutils(QueryRunner)—&gt;JdbcTemplate(Spring) SQL夹在Java代码块里，耦合度高导致硬编码，维护不易且实际开发需求中sql是有变化，频繁修改的情况多见。 若改动一下数据库或改变一下sql语句，则整个项目需要重新打包构建部署 HibernateHibernate：全自动ORM（Object Relation Mapping）框架 全黑箱操作，想优化sql，必须再学习Hibernate的HQL定制sql语句，开发者希望sql语句交给开发人员编写，不失去其灵活性。 只能全自动全映射，数据表有100个列，则即使只查询某一个字段都需要把全部列映射过来。导致数据库性能下降 Mybatis MyBatis将需定制化 SQL部分抽取出来，以XML方式配置，实现可定制化SQL。 因此Mybatis是半自动，轻量级的持久层框架。 MyBatis 避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。 MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO(Plain Old Java Objects，普通的Java对象)映射成数据库中的记录 Mybatis下载下载步骤 进入GitHub页面，Mybatis-Github 选的特定版本下载 基本资料介绍 解压mybatis-3.4.1，使用mybatis只需要导入mybatis-3.4.1.jar即可 lib目录下的jar包是mybatis需要添加其他功能才需要选择性导入的包 HelloWorld快速开始 打开，mybatis在线官方文档。操作基本按照官方文档进行 准备jar包 mybatis-3.4.1.jar：mybatis核心jar包 mysql-connector-java-5.1.37-bin.jar：数据库连接jar包 创建测试数据库：本例数据库名为 mybatis，创建测试数据表tbl_employee 新建一个基于maven的java项目，并建立对应的JavaBean 依据mybatis官方文档从XML中构建SqlSessionFactory 本例是直接在类路径下（maven项目在java或resources目录下）创建名为mybatis-config.xml (全局配置)文件，从官方文档中复制如下内容 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- tips：数据源信息(需修改部分) --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- 将写好的sql映射文件注册到全局配置文件中。文件创建在全类路径下，因此直接写即可 --&gt; &lt;mapper resource=&quot;EmployeeMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 修改XML中的数据源信息： 123456 &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;!-- 驱动 --&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt;&lt;!-- 数据库地址 --&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;&lt;!-- 用户名 --&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;!-- 密码 --&gt;&lt;/dataSource&gt; 同样在类路径下（maven项目在java或resources目录下）创建映射的EmployeeMapper.xml文件 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!-- sql映射文件 --&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- 名称空间：暂时来说名字可以随便起，一般映射哪个实体对象就起名为 xxxMapper --&gt;&lt;mapper namespace=&quot;com.company.bean.EmployeeMapper&quot;&gt; &lt;!-- id：唯一标识，一般起名为[操作类型 + 操作对象]selectXxx --&gt; &lt;!-- resultTupe：返回类型，若返回是一个对象，则填入这个类的全类名 --&gt; &lt;!-- #&#123;id&#125;：从传递过来的参数中取出id指，类似java占位符&#x27;?&#x27; --&gt; &lt;select id=&quot;selectEmp&quot; resultType=&quot;com.company.bean.Employee&quot;&gt; select id,last_Name lastName,gender,email from tbl_employee where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 执行查询操作 1234567891011121314151617181920212223242526272829303132333435363738package com.company.test;import com.company.bean.Employee;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;/** * @author yhd * @create 2021-08-13 14:43 */public class MybatisTest &#123; public static void main(String[] args) throws IOException &#123; //1、从mybatis-config.xml 中构建SqlSessionFactory InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory build = new SqlSessionFactoryBuilder().build(is); //2、获取 SqlSession对象 SqlSession sqlSession = build.openSession(); //3、开始执行查询操作，能查询已映射的 SQL语句 //形参1：sql映射XML文件的唯一标识符，可直接填入XML的id(若存在重名) // 但建议使用XML中 namespace.id 的方式唯一标识 //形参2：执行sql语句的传入参数，如下查询id=1的员工信息 try&#123; String id = &quot;com.company.bean.EmployeeMapper.selectEmp&quot;; Employee employee = (Employee) sqlSession.selectOne(id, 1); System.out.println(employee); &#125;finally&#123; sqlSession.close(); &#125; &#125;&#125; 最终效果 小结 根据xml全局配置文件创建一个SqlSessionFactrory 创建sql映射文件，配置了每一个sql，以及sql的 封装规则等 将sql映射文件注册在全局配置文件中 代码部分 根据全局配置文件得到SqlSessionFactory 使用sqlSession工厂，获得sqlSession对象来执行增删改查 一个sqlSession就是代表和数据库的一次会话，用完关闭 使用sql的唯一标志来告诉Mybatis执行哪个sql，sqk均保存在sql映射文件中 接口式编程 对于上述方式执行sql操作，mybatis还提供了一种更为智能，受众面更广的实现方式。 即接口与配置文件进行动态绑定。以后使用mybatis均使用这种方式操作 操作步骤 如日常开发首先需创建dao操作对应的接口，EmployeeMapper.java 规范化sql映射文件中的namespace与id的值，形成如下对应关系 namespace ：对应dao操作的接口的全类名 id 值：对应接口中的抽象方法名（方法返回类型与传入参数也要对应sql语句本身） resultType：对应抽象方法的返回类型的全类名 使用自动生成的接口代理对象替代mybatis的session对象进行数据库操作 通过调用session.getMapper();方法，传入接口的类型，使其自动创建一个代理对象 随后通过这个代理对象实现类去执行增删改查（与之前的开发更贴切） 123456789101112try&#123; //旧：不再直接使用session对象进行数据库操作 //String id = &quot;com.test.mybatis.bean.EmployeeMapper.selectEmp&quot;; //Employee employee = (Employee) session.selectOne(id, 1); //新：获取代理类对象直接进行抽象方法对应的配置文件信息进行调用 EmployeeMapper mapper = session.getMapper(EmployeeMapper.class); Employee employee = mapper.getEmpById(1); System.out.println(employee);&#125;finally&#123; session.close();&#125; 优势 代码更清晰 不用担心传入类型安全，由接口的抽象方法规范化了（selectOne()方法传入的1是Object类型） 减少字符串字面值使用，减低出错率（id的填入）。返回类型不需要考虑类型转换安全 小结原生比较 原生开发（不使用Mybatis）： Dao ====&gt; DaoImpl Mybatis（接口式编程）：Mapper ===&gt; xxMapper.xml SqlSession SqlSession代表和数据库的一次会话，用完必须关闭（底层就是connection对象） SqlSession和connection一样是非线程安全。每次使用都应该去获取新的对象 代理对象 自定义的Dao接口是没有实现类对象，是由mybatis为接口生成一个代理对象(将接口和xml进行绑定) 1EmployeeMapper empMapper = sqlSession.getMapper(EmployeeMapper.class); 配置文件 全局配置文件（非必须）：包含数据库连接池信息，事务管理器信息等…系统运行环境信息 sql映射文件（必须）：保存了每一个sql语句的映射信息(将sql抽取出来) 配置文件标签标签书写提示检查若配置文件书写中无法弹出mybatis标签的提示，可以进行如下操作，一般IDE都有 准备mybatis-3-config.dtd文件 联网状态下可以点击xml文件中链接下载：http://mybatis.org/dtd/mybatis-3-config.dtd 或者在mybatis-3,4,1.jar包中ibatis.builder.xml中解压出来 进入eclipse 进行如下设置 最后在IDE中关闭所有xml文件，再打开测试即可 以下介绍均为最基本，最常用的使用方式。详细使用与功能介绍可参详官方文档 标签编写顺序mybatis配置文件的标签编写顺序有严格要求，必须按照以下顺序编写，不能打乱 properties, settings, typeAliases, typeHandlers, objectFactory, objectWrapperFactory, reflectorFactory, plugins, environments, databaseIdProvider, mappers? properties说明mybatis可以使用properties标签引入外部 .properties配置文件的内容，主要使用在数据源信息上。 resource（二选一）：引入类路径下的资源 url（二选一）：引入网络路径或者磁盘路径下的资源 示例 如在类路径已经存在一个dbconfig.properties文件，用于存放数据源信息，内容如下 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatisjdbc.username=rootjdbc.password=root 通过properties标签引入dbconfig.properties文件 12345678910111213141516171819202122&lt;configuration&gt; &lt;!-- 引入properties文件 --&gt; &lt;!-- 若不在类路径下，则按包名斜杠的格式定位到，如com/test/dbconfig.properties --&gt; &lt;properties resource=&quot;dbconfig.properties&quot;&gt;&lt;/properties&gt; &lt;!-- 对引入的properties文件的内容进行引用$&#123;properties键&#125; --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;EmployeeMapper.xml&quot; /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 最终效果 settings说明初步认识：这是 MyBatis中极为重要的调整设置，它们会改变MyBatis的运行时行为。一般使用默认即可，不需要配置，需要再查看文档进行相应的配置。 name为要设置对应的配置信息， value就是配置的值 示例例如：选取官方文档其中一个设置mapUnderscoreToCamelCase 设置名 描述 有效值 默认值 mapUnderscoreToCamelCase 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn true|false False 默认是false。若开启后，数据库列名为 last_Name 可直接映射java属性名lastName，而无需使用别名修改为lastName进行映射 123&lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; typeAliases自定义类别名说明typeAliases[ˈeɪlɪæsɪz]为别名处理器、为某个Java类的全类名起别名。此后在mybatis配置文件中可用别名替代全类名 type：指定待取别名的类的全类名（默认别名为类名小写，不分大小写) alias：指定新的别名 示例 方式1.1：使用默认别名（默认别名为类名小写但不区分大小写，即employee、EmPloyee等） 123&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.test.mybatis.bean.Employee&quot;/&gt;&lt;/typeAliases&gt; 方式1.2：在方式1的基础上，使用alias属性自定义别名 123&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.test.mybatis.bean.Employee&quot; alias=&quot;emp&quot;/&gt;&lt;/typeAliases&gt; 方式2.1：为指定包下所有类起别名，此时只能使用默认别名 123&lt;typeAliases&gt; &lt;package name=&quot;com.test.mybatis.bean&quot;/&gt;&lt;/typeAliases&gt; 方式2.2：若指定某包名或其子包下存在两个同名的类，则使用@Alias(&quot;Name&quot;)注解直接起别名以区分 XML文件 1234&lt;typeAliases&gt; &lt;!-- 注意：需要指明使用别名注解的包是什么，即要保留方式2.1的package标签，否则会报错 --&gt; &lt;package name=&quot;com.test.mybatis.bean&quot;/&gt;&lt;/typeAliases&gt; Java文件 1234@Alias(&quot;ABC&quot;)public class Employee &#123; ...&#125; 示例方式1.2效果如下，在sql映射文件中的resultType直接使用别名替代全类名 默认别名Mybatis官方已默认为java常用的一些基本数据类型，包装类型，集合操作等起了别名。自定义别名时注意不要于其发生冲突。别名的规律大致可分为以下两种 基本数据类型：基本数据类型前加下划线’’_’’ Java类：类名的小写 别名 原Java类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal object Object map Map hashmap HashMap list List arraylist ArrayList collection Collection iterator Iterator typeHandlers初步认识：类型处理器，主要用于架起java类型和数据库类型转换的桥梁。比如，如何将java中String类型变量存储在数据库兼容适配成char，varchar等。反之，从数据库中查出的Integer如何转换成java使用的Integer。 plugins初步认识：MyBatis 允许在映射语句执行过程中的某一点进行拦截调用。默认情况下，使用插件机制来实现拦截。对应以下对象方法执行前后进行拦截，动态代理，可以改变mybatis的一些默认行为，达到自定义的效果。（底层使用动态代理实现） Executor（update、query、flushStatement、commit、rollback、getTransaction、close、isClosed） ParameterHandler（getParameterObject、setParameters） ResultSetHandler（handleResultSets、handleOutputParameters） StatementHandler（prepare、parameterize、batch、update、query） environments MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境都需要有不同的配置 或者想在具有相同 Schema的多个生产数据库中使用相同的 SQL 映射。还有许多类似的使用场景 说明 environments：“环境们”，mybatis可以配置多种环境，即environment标签。default属性指明当前使用的环境，即environment标签的id属性值 environment：配置一个具体的环境信息，必须含以下两个标签；id属性代表当前环境的唯一标识 transactionManager：事务管理器标签（了解、一般使用Spring做事务控制） type属性指定事务管理器的类型，可选项有JDBC|MANAGED|自定义 JDBC指使用JDBC来进行事务控制，MANAGED是使用JEE容器来控制事务 JDBC与MANAGED其实是别名，实际对应操作类在Configuration.class中注JDBC(JdbcTransactionFactory)|MANAGED(ManagedTransactionFactory) 自定义事务管理器：实现TransactionFactory接口，type指定为实现类的全类名 dataSource：type属性指定数据源类型，可选项为 UNPOOLED | POOLED | JNDI | 自定义（了解，常在Spring中进行配置） UNPOOLED ：不适用连接池技术，每次数据库操作都与数据库建立一次新的连接。 POOLED ：适用连接池技术（默认自带） JNDI ：略，有兴趣再了解 自定义数据源：如想使用C3P0等，实现DataSourceFactory接口，type属性填入实现类的全类名 别名说明： UNPOOLED(UnpooledDataSourceFactory.java) POOLED(PooledDataSourceFactory.java) JNDI(JndiDataSourceFactory.java) 示例 配置两个数据库环境示例，Mysql与Oracle 123456789101112131415161718192021222324&lt;!-- 通过default属性指定使用某个环境 --&gt;&lt;environments default=&quot;dev_mysql&quot;&gt; &lt;!-- 环境1：mysql数据库环境 --&gt; &lt;environment id=&quot;dev_mysql&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!-- 环境2：Oracle数据库环境 --&gt; &lt;environment id=&quot;dev_oracle&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;orcl.driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;orcl.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;orcl.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;orcl.password&#125;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; databaseldProvider databaseldProvider，译为“数据库供应商”。 利用该标签，可以为某些SQL操作的运行加上数据库厂商的约束。即只有当前数据库环境符合设置的数据库厂商，才能够被执行。 MyBatis可根据不同的数据库厂商(MySQL、Oracle…)，去执行对应产商格式的语句，也就是mybatis在移植性的支持。 说明 databaseIdProvider： type属性使用固定默认值type=&quot;DB_VENDOR&quot; DB_VENDOR也是别名，对应操作类为VendorDatabaseIdProvider，该操作类就是通过得到数据库厂商的标识(调用JDBC驱动的getDatabaseProductName()方法获取)，来区分执行不同的sql语句 property：可通过该标签为某个数据库厂商标识起别名 name：数据库厂商标识 value：自定义数据库厂商标识别名 常见数据库厂商标识： MySQL标识：MySQL Oracle标识：Oracle SQL Server标识：SQL Server 示例使用方式：若想为某一条数据库操作添加上两种不同数据库环境下的完整操作，需以下步骤 准备好不同数据库的数据源信息： 通过environment标签创建拟操作数据库对应数据源信息 修改environments标签的default属性指定使用指定的数据源 启用databaseldProvider标签，并为数据库厂商标识起别名 在sql映射xml文件中， 按需创建多个id相同的不同环境下的sql语句操作 为这些sql语句操作添加databaseId属性，指定在哪个数据库厂商标识别名对应的环境下执行 相同id而没有添加databaseId属性的标签任何数据库环境下均被匹配，当存在多个相同id标签被匹配时，最终默认匹配更精确的标签（如有databaseId属性描述的标签） 不同数据源准备123456789101112131415161718192021222324&lt;!-- 通过default属性指定使用某个环境 --&gt;&lt;environments default=&quot;dev_mysql&quot;&gt; &lt;!-- 环境1：mysql数据库环境 --&gt; &lt;environment id=&quot;dev_mysql&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!-- 环境2：Oracle数据库环境 --&gt; &lt;environment id=&quot;dev_oracle&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;orcl.driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;orcl.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;orcl.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;orcl.password&#125;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 启用并为数据库厂商标识起别名123456&lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt; &lt;!-- 为不同的数据库厂商起别名 --&gt; &lt;property name=&quot;MySQL&quot; value=&quot;mysql&quot;/&gt; &lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot;/&gt; &lt;property name=&quot;SQL Server&quot; value=&quot;sqlserver&quot;/&gt;&lt;/databaseIdProvider&gt; 指明sql语句的执行厂商 在sql映射配置文件中指明每条相同id的sql语句执行的数据库厂商的别名，对应databaseIdProvider 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.company.mybatis.dao.EmployeeMapper&quot;&gt; &lt;select id=&quot;getEmpById&quot; resultType=&quot;com.company.mybatis.bean.Employee&quot;&gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- mysql数据库环境执行 --&gt; &lt;select id=&quot;getEmpById&quot; resultType=&quot;com.company.mybatis.bean.Employee&quot; databaseId=&quot;mysql&quot;&gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- Oracle数据库环境执行 --&gt; &lt;select id=&quot;getEmpById&quot; resultType=&quot;com.company.mybatis.bean.Employee&quot; databaseId=&quot;oracle&quot;&gt; select EMPLOYEE_ID id,LAST_NAME lastName,EMAIL email from employees where EMPLOYEE_ID=#&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 个文件id对照关系 mappersmappers标签用于将sql映射xml文件注册到全局配置文件中，而实现注册有以下三种不同的方式 普通注册方式 resource属性（三选一）：引用类路径下的sql映射文件， 若不在类路径下，则按包名斜杠的格式定位到，如com/test/dbconfig.properties url属性（三选一）：引用网络路径或者磁盘路径下的sql映射文件 class属性（三选一）：通过配置匹配映射文件的映射接口全类名来实现注册（配置需有前提） 方式1（推荐）：将sql映射文件与接口同一目录下，且映射文件名必须与接口同名 方式2：没有sql映射文件，sql操作直接写在接口抽象方法的注解上，如@Select(&quot;select...&quot;) 1234public interface EmployeeMapperAnnotation &#123; @Select(&quot;select * from tbl_employee where id=#&#123;id&#125;&quot;) Employee getEmpById(Integer id);&#125; 重要且复杂的Dao接口（sql），建议写sql映射文件实现（mybatis就是为了将sql抽取出xml文件里） 不重要，简单的Dao（sql）接口为了开发快速可以使用注解； 1234&lt;mappers&gt; &lt;mapper resource=&quot;mybatis/mapper/EmployeeMapper.xml&quot;/&gt; &lt;!-- &lt;mapper class=&quot;com.company.mybatis.dao.EmployeeMapperAnnotation&quot;/&gt; --&gt;&lt;/mappers&gt; tips：eclipse下可采用在不同文件夹下建立与接口同包名的文件夹存放接口对应的sql映射文件，达到方便管理的要求（最终都会被合并到同一个目录下） 批量注册方式 批量注册使用package子标签，是基于使用class属性注册上的一种方式。 因此使用package标签对包名进行注册时，必须满足class属性注册的两个前提之一（有映射文件必须同名同目录，无映射文件必须使用注解方式） 123&lt;mappers&gt; &lt;package name=&quot;com.company.mybatis.dao&quot;/&gt;&lt;/mappers&gt; objectFactory 了解，objectFactory用于配置对象工程，即mybatis查询数据后封装成java对象的工厂类，一般不用修改，即不用配置，了解即可 映射文件标签CRUD基础 CRUD即增加(Create)、查询/检索(Retrieve[rɪˈtriːv])、更新(Update)、删除(Delete)四个单词的首字母缩写 CRUD标签 Mybatis中CRUD操作分别对应，insert、select、update、delete标签 注意，标签内填写的SQL语句末尾不要带分号; 传入参数设置单个参数传入 基本数据类型：则占位参数名无要求 因此传入参数类型parameterType设置是可选，由于并不是关键匹配因素 Java对象类型： 要求设置传入的占位参数名必须和传入对象类型的属性名对应，即#&#123;属性名&#125;取值 数组与集合类型：同多个参数设定，也会将其包装成一个Map类型 Collection类型（List、Set） key：”collection”（如果是List类型、还可使用”list”） value：集合对象本身 Array类型： key：”array” value：数组对象本身 多个参数传入默认行为 无论参数类型由哪些构成，一旦传入多个参数，都会被MyBatis包装成一个Map 其中每一个参数的Map的key是param1…paramN **或 索引从0开始，1，2…。值**就是传入参数的值 12345&lt;!-- public Employee getEmpByIdAndLastName(Integer id,String lastName);--&gt;&lt;select id=&quot;getEmpByIdAndLastName&quot; resultType=&quot;com.company.mybatis.bean.Employee&quot;&gt; select * from tbl_employee where id = #&#123;param1&#125; and last_name=#&#123;param2&#125;&lt;/select&gt; @Param 由于默认的Map封装的Key不便于开发识别 Mybatis提供**@Param**注解对接口的抽象方法的形参在映射文件中所表示的占位参数名而命名 Dao接口：为接口的形参绑定命名 123public interface EmployeeDao &#123; public Employee getEmpByIdAndLastName(@Param(&quot;id&quot;)Integer id,@Param(&quot;lastName&quot;)String lastName);&#125; 映射文件：此时就可以使用注解设定的名字 123&lt;select id=&quot;getEmpByIdAndLastName&quot; resultType=&quot;com.company.mybatis.bean.Employee&quot;&gt; select * from tbl_employee where id = #&#123;id&#125; and last_name=#&#123;lastName&#125;&lt;/select&gt; 传入Map 由于无论哪种方式，Mybatis都会将其封装成一个Map，然后编写SQL语句时用Map的Key作为占位符。 因此用户可以选择直接将抽象方法的形参设置为Map类型，传入操作参数时就一并设置好键和值 此时xml文件中编写SQL语句使用的参数占位符名就为传入时Map的键名 自封装TO TO，（Transfer Object）数据传输对象 如果多个参数不是业务模型中的数据，但是经常要使用，推荐封装成一个类用于传输数据，即为TO 特殊传入场景 示例1： public Employee getEmp(@Param(&quot;id&quot;)Integer id,String lastName); 取值：id==&gt;#&#123;id/param1&#125; lastName==&gt;#&#123;param2&#125; 示例2： public Employee getEmp(Integer id,@Param(&quot;e&quot;)Employee emp); 取值：id==&gt;#&#123;param1&#125; lastName===&gt;#&#123;param2.lastName/e.lastName&#125; 示例3： public Employee getEmpById(List&lt;Integer&gt; ids);取值：取出第一个id的值， `#&#123;list[0]&#125;` 传入源码分析（略）、教学视频中由讲解 传入参数获取Mybatis在映射文件中获取map中的值或者pojo对象属性的值时，可通过#&#123;&#125;或#$&#123;&#125;方式获取 #&#123;&#125;：是以预编译的形式，将参数设置到sql语句中（PreparedStatement）防止sql注入 $&#123;&#125;：取出的值直接拼装在sql语句中；会有安全问题 #{}方式 基于安全因素，一般普通情况下，建议都使用#&#123;&#125;方式，特殊情况才使用${}方式 其次，#&#123;&#125;方式支持在获取参数时指定一些特殊属性，使用上更丰富。常用的为jdbcType和mode 参数规则 含义 javaType jdbcType mode 存储过程 numericScale 设置获取的数字类型小数点保留 resultMap typeHandler jdbcTypeName expression 表达式、未来准备支持的功能 jdbcType：用于处理不能传入null值进行SQL操作的数据库环境 当进行SQL语句操作，而传入的数据存在null时，有些数据库可能不能识别Mybatis对null值的默认处理而直接报错 Mybatis默认将null值处理为OTHER类型。比如Oracle数据库则会因无法识别OTHER类型直接报错 因此需设置Mybatis遇到null值时不以OTHER类型处理而是以NULL类型处理（Mysql和Oracle都支持） 1#&#123;email,jdbcType=NULL&#125;; 还有一种解决方案就是通过在&lt;settings&gt;标签中设置Mybatis当遇到null值时以NULL类型处理 123&lt;settings&gt; &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;NULL&quot;/&gt;&lt;/settings&gt; ${}方式 在某些原生jdbc不支持使用占位符的位置（表名、排序规则）就可以使用$&#123;&#125;进行取值 比如分表需改变表名时、排序需改变排序顺序时、或按照年份分表拆分，此时只能使用拼接方式 12select * from $&#123;year&#125;_salary where xxx;select * from tbl_employee order by $&#123;f_name&#125; $&#123;order&#125; 影响条数返回 Mybatis对增删改操作都封装其返回值，无需在xml配置，仅需在接口方法定义其返回值类型即可 默认支持Integer、Long(影响行数)和Boolean(大于一行返回true)三种包装类型 获取自增主键在实际操作中，常常需要获取insert操作后的由数据库产生的自增主键 Mysql 由于Mysql本身就支持自增主键的获取，Mybatis自然可以将其封装后提供用户使用 Mybatis对于增删改的，获取自增的主键操作也给予了实现。在增删改操作标签中添加如下属性 useGeneratedKeys：默认为false、设置为true启用自增主键获取功能 keyProperty：指定获取到的自增主键值，存储到javaBean的哪个属性 mysql也是使用原生的JDBC提供的statement.getGenreatedKeys()方法实现 Oracle（了解） 某种需求或某些数据库插入的主键需要从其他地方获取 如Oracle本身不支持数据插入主键自增。而需要在插入前先获取下一个序列值作为主键去模拟插入自增 此时需要在CRUD标签内设置，&lt;selectKey&gt;子标签，用于描述获取插入数据的主键值 标签体：编写获取插入数据主键值的SQL语句 keyProperty：指定获取到的自增主键值，存储到javaBean的哪个属性 order：选择selectKey子标签相对于CRUD标签的SQL语句执行顺序 BEFORE：当前sql在插入sql之前运行（建议使用） 查出序列的下一个id值封装给javaBean的id属性，并封装到bean的属性内 将查出的id值一并插入到数据库中； AFTER：当前sql在插入sql之后运行（同时插入多条数据有可能出现问题） 即先运行插入的sql（从序列中自动取出新值作为id）， 再运行selectKey查询当前序列中的id值（即步骤1插入数据时的新值）封装到bean属性内 resultType：查出的数据的返回值类型 1234567&lt;insert id=&quot;addEmp&quot; databaseId=&quot;oracle&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;Integer&quot;&gt; select EMPLOYEES_SEQ.nextval from dual &lt;/selectKey&gt; insert into employees(EMPLOYEE_ID,LAST_NAME,EMAIL) values(#&#123;id&#125;,#&#123;lastName&#125;,#&#123;email&#125;) &lt;/insert&gt; CRUD基础示例DAO接口12345678910package com.company.dao;import com.company.bean.Employee;public interface EmployeeDao &#123; Employee getEmployeeById(Integer id); Integer addEmployee(Employee employee); Integer updateEmployee(Employee employee); Integer deleteEmployeeById(Integer id);&#125; CRUD配置12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.company.dao.EmployeeDao&quot;&gt; &lt;!-- 查询，返回类型需用resultType属性指明 --&gt; &lt;select id=&quot;getEmployeeById&quot; resultType=&quot;com.company.bean.Employee&quot;&gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 增加，parameterType可选 主要占位参数名与传入对象属性名要对应 --&gt; &lt;!-- 默认就配置了修改操作(增删改)的影响条数返回值 --&gt; &lt;!-- useGeneratedKeys与keyProperty返回新增数据的自增主键并注入bean的id属性中 --&gt; &lt;insert id=&quot;addEmployee&quot; parameterType=&quot;com.company.bean.Employee&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot; &gt; insert into tbl_employee(last_name,email,gender) values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;) &lt;/insert&gt; &lt;!-- 修改：同理增加操作 --&gt; &lt;update id=&quot;updateEmployee&quot;&gt; update tbl_employee set last_name=#&#123;lastName&#125;,gender=#&#123;gender&#125;,email=#&#123;email&#125; where id=#&#123;id&#125; &lt;/update&gt; &lt;!-- 删除：同理增加操作 --&gt; &lt;delete id=&quot;deleteEmployeeById&quot;&gt; delete from tbl_employee where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 测试123456789101112131415161718192021222324252627282930public class MybatisTest &#123; public static void main(String[] args) throws IOException &#123; InputStream inputStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //openSession()无参，默认自动提交session SqlSession sqlSession = builder.build(inputStream).openSession(); try&#123; EmployeeDao mapper = sqlSession.getMapper(EmployeeDao.class); //查找 Employee employee = mapper.getEmployeeById(1); System.out.println(employee); //增加 Employee deny = new Employee(&quot;Deny&quot;, &quot;男&quot;, &quot;333@qq.com&quot;); mapper.addEmployee(deny); System.out.println(deny.getId()); //能返回新增数据的数据库自增主键 //修改 deny.setGender(&quot;女&quot;); mapper.updateEmployee(deny); //删除 mapper.deleteEmployeeById(1); &#125;finally&#123; sqlSession.close(); &#125; &#125;&#125; select详解返回类型对象类型 直接设置resultType为返回类型的全类名、若为基本数据类型则使用对应包装类 集合类型如果返回的是一个集合，resultType属性要写集合中元素的类型 接口方法返回类型：List&lt;Employee&gt; 1public List&lt;Employee&gt; getEmpsByLastNameLike(String lastName); 映射文件返回类型：Employee 123&lt;select id=&quot;getEmpsByLastNameLike&quot; resultType=&quot;com.company.mybatis.bean.Employee&quot;&gt; select * from tbl_employee where last_name like #&#123;lastName&#125;&lt;/select&gt; Map类型返回一条记录将查询的一条数据对应的POJO封装对象，以Map的形式返回，即对象中的每个属性按键值对方式返回 key：某条记录对应POJO对象的属性名 value：POJO对象属性名对应的属性值 抽象方法返回类型：Map&lt;String, Object&gt; 1public Map&lt;String, Object&gt; getEmpByIdReturnMap(Integer id); 映射文件返回类型：Map 123&lt;select id=&quot;getEmpByIdReturnMap&quot; resultType=&quot;map&quot;&gt;&lt;!-- 使用了默认别名 --&gt; select * from tbl_employee where id=#&#123;id&#125;&lt;/select&gt; 返回多条记录 查询多条记录返回，将多条数据封装到Map集合中 设置返回类型 key：每条记录的主键 value：主键对应的每条记录 抽象方法返回类型：Map&lt;Integer, Employee&gt;，并通过@MapKey注解指明由Bean的哪个属性充当主键 123//指明为当前bean（Employee）的id属性作为主键@MapKey(&quot;id&quot;)public Map&lt;Integer, Employee&gt; getEmpByLastNameLikeReturnMap(String lastName); 映射文件返回类型：Employee 123&lt;select id=&quot;getEmpByLastNameLikeReturnMap&quot; resultType=&quot;com.company.mybatis.bean.Employee&quot;&gt; select * from tbl_employee where last_name like #&#123;lastName&#125;&lt;/select&gt; resultMap属性引言自动映射 autoMappingBehavior默认是PARTIAL，开启自动映射的功能 唯一的要求是列名和javaBean属性名一致 如果autoMappingBehavior设置为null则会取消自动映射 若数据库字段命名规范，POJO属性符合驼峰命名法，如 A_COLUMN ——&gt; aColumn 可以开启自动驼峰命名规则映射功能，mapUnderscoreToCamelCase=true 除上述两种方法外，第三种就是通过resultMap属性自定义bean属性和数据库字段的映射关系 手动映射 resultMap属性可以自定义结果集映射规则，即查询字段名与bean属性名之间的映射关系 resultMap属性和resultType属性只能二选一使用 定义映射规则&lt;resultMap&gt;标签：用于自定义结果集映射规则 type属性：自定义数据库数据拟映射的Java类型 id属性：用于唯一标识当前resultMap标签的映射规则，方便后续引用 &lt;id/&gt;与&lt;result/&gt;子标签：一般主键字段用id标签定义（底层有优化），非主键字段用result标签定义 column属性：指定映射的数据库字段名 property属性：指定被字段映射的Bean属性名 可以只指定部分字段的映射规则，其他不指定的列会自动封装。但建议只要使用resultMap就把全部的映射规则都写上 最后，在select标签的resultMap属性上引用自定义的resultMap映射规则的id名，表示使用该映射规则 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.company.mybatis.dao.EmployeeMapperPlus&quot;&gt; &lt;!-- 自定义映射规则 --&gt; &lt;resultMap type=&quot;com.company.mybatis.bean.Employee&quot; id=&quot;MySimpleEmp&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt; &lt;/resultMap&gt; &lt;!-- public Employee getEmpById(Integer id); --&gt; &lt;select id=&quot;getEmpById&quot; resultMap=&quot;MySimpleEmp&quot;&gt; select * from tbl_employee where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 关联查询对象需求场景 在查询Employee的同时查询员工所在部门（对象）的数据并封装到Employee内 级联属性方式查询所有字段 通过原生sql的级联查询（多表查询），查询封装Employee对象需要的所有属性值（含Eepartment） 123SELECT * FROM tbl_employee e,tbl_dept d WHERE e.`d_id` = d.`id` AND e.`id` = 1; 查询结果字段：id last_name gender email d_id id dept_name 注意在resultMap设置映射不能够出现同名字段，因此需起别名或者直接用employee的d_id封装到Department id（建议先建立外键保持一致性） 123SELECT e.*,dept_name FROM tbl_employee e,tbl_dept d WHERE e.`d_id` = d.`id` AND e.`id` = 1; 查询结果字段： id last_name gender email d_id dept_name (Department对象封装) 映射规则 Employee对象内部的Department对象通过属性名.内部属性名的方式为bean中的对象中的属性赋值 1234567891011121314151617181920&lt;mapper namespace=&quot;com.company.dao.EmployeeDao&quot;&gt; &lt;!--sql语句查询结果字段: id last_name gender email d_id dept_name --&gt; &lt;resultMap id=&quot;employeeMapping&quot; type=&quot;com.company.bean.Employee&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt; &lt;!-- 直接为department属性的id、name属性赋值 --&gt; &lt;result column=&quot;d_id&quot; property=&quot;department.id&quot;/&gt; &lt;result column=&quot;dept_name&quot; property=&quot;department.name&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getEmployeeById&quot; resultMap=&quot;employeeMapping&quot;&gt; SELECT e.*,dept_name FROM tbl_employee e,tbl_dept d WHERE e.`d_id` = d.`id` AND e.`id` = 1; &lt;/select&gt;&lt;/mapper&gt; 查询结果 1Employee&#123;id&#x3D;1, lastName&#x3D;&#39;Priscilla&#39;, gender&#x3D;&#39;女&#39;, email&#x3D;&#39;8888@qq.com&#39;, departmentId&#x3D;Department&#123;id&#x3D;2, name&#x3D;&#39;销售部&#39;&#125;&#125; 嵌套对象方式查询所有字段同上“级联熟悉方式”的sql语句 映射规则在resultMap标签内使用&lt;association&gt;子标签来定义引用类型数据相关的映射关系 &lt;association&gt;标签 property属性：bean内嵌的引用数据类型属性名 javaType属性：property属性所属的java类型（全类名或别名） &lt;id/&gt;与&lt;result/&gt;子标签同上述“定义映射规则”用法，用于关联映射规则 1234567891011121314151617181920212223&lt;mapper namespace=&quot;com.company.dao.EmployeeDao&quot;&gt; &lt;!-- id last_name gender email d_id dept_name --&gt; &lt;resultMap id=&quot;employeeMapping&quot; type=&quot;com.company.bean.Employee&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt; &lt;!-- 使用内嵌的联合标签定义引用类型数据映射关系 --&gt; &lt;association property=&quot;department&quot; javaType=&quot;com.company.bean.Department&quot;&gt; &lt;id column=&quot;d_id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;dept_name&quot; property=&quot;name&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;getEmployeeById&quot; resultMap=&quot;employeeMapping&quot;&gt; SELECT e.*,dept_name FROM tbl_employee e,tbl_dept d WHERE e.`d_id` = d.`id` AND e.`id` = 1; &lt;/select&gt;&lt;/mapper&gt; 分步查询方式普通方式sql语句 第一步，通过员工id查询员工信息（含部门id的d_id字段） 1SELECT * from tbl_employee where id = #&#123;id&#125; 映射规则可以使用&lt;association&gt;标签对关联查询以分步查询的方式实现 property属性：bean内嵌的引用数据类型属性名 select属性：表明当前属性是通过调用其他select标签指定的方法查出的结果赋值的。以完整的[命名空间 + select标签id]方式指明 column属性：使用当前bean的哪个属性传入select标签执行调用 通过部门id查询部门信息的sql映射文件 12345&lt;mapper namespace=&quot;com.company.dao.DepartmentDao&quot;&gt; &lt;select id=&quot;getDepartmentById&quot; resultType=&quot;com.company.bean.Department&quot;&gt; select id,dept_name name from tbl_dept where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 在&lt;association&gt;标签中调用查询部门信息的select标签进行数据获取并封装 123456789101112131415161718192021&lt;mapper namespace=&quot;com.company.dao.EmployeeDao&quot;&gt; &lt;resultMap id=&quot;employeeMapping&quot; type=&quot;com.company.bean.Employee&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt; &lt;!-- 使用内嵌的联合标签通过调用其他select标签查询的结果进行属性封装 --&gt; &lt;association property=&quot;department&quot; select=&quot;com.company.dao.DepartmentDao.getDepartmentById&quot; column=&quot;d_id&quot;&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!-- 仅查询employee数据表的数据 --&gt; &lt;select id=&quot;getEmployeeById&quot; resultMap=&quot;employeeMapping&quot;&gt; SELECT * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 延迟加载 分步查询支持延迟加载机制，即只有在程序调用相关查询步骤的数据时才执行sql查询 开启延迟加载，只需在主配置文件中的&lt;settings&gt;标签中增加以下setting标签配置信息 lazyLoadingEnabled：懒加载开启属性，当程序调用数据时才执行相关的sql语句，需开启为true aggressiveLazyLoading：侵略性加载属性，即全部一次性查询结果。需关闭为false 1234&lt;!--显式的指定每个我们需要更改配置的值，即使他是默认的，防止版本更新带来的问题--&gt;&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; 关联查询集合需求场景 如获取一个部门信息，其中部门id、名称、以及集合类型的该部门的所有员工信息 嵌套集合方式查询所有字段 原生SQL查询语句，查询部门id=1的部门信息及其下所有员工信息（使用别名使字段不能重复） 123SELECT d.id dept_id,d.`dept_name`,e.* FROM tbl_dept d,tbl_employee e WHERE d.id = e.`d_id`AND d.id = 1 返回结果字段：dept_id dept_name id last_name gender email d_id 映射规则在resultMap标签内使用&lt;collection&gt;子标签来定义集合类型数据相关的映射关系 &lt;collection&gt;子标签： property属性：bean内嵌的集合数据类型属性名 ofType属性：集合中的元素所属的java类型（全类名或别名） &lt;id/&gt;与&lt;result/&gt;子标签同上述“定义映射规则”用法，用于关联映射规则 123456789101112131415161718192021&lt;mapper namespace=&quot;com.company.dao.DepartmentDao&quot;&gt; &lt;!-- dept_id dept_name | id last_name gender email d_id--&gt; &lt;resultMap id=&quot;departmentMapping&quot; type=&quot;com.company.bean.Department&quot;&gt; &lt;id column=&quot;dept_id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;dept_name&quot; property=&quot;name&quot;/&gt; &lt;collection property=&quot;employeeList&quot; ofType=&quot;com.company.bean.Employee&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;getDepartmentById&quot; resultMap=&quot;departmentMapping&quot;&gt; SELECT d.id dept_id,d.`dept_name`,e.* FROM tbl_dept d,tbl_employee e WHERE d.id = e.`d_id` AND d.id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 分步查询方式 同理“关联查询对象”的分步查询方式，支持懒加载设置 sql语句 第一步，先通过部门id查询部门信息 1SELECT * from tbl_dept where id = #&#123;id&#125; 映射规则 property属性：bean内嵌的引用数据类型属性名 select属性：表明当前属性是通过调用其他select标签指定的方法查出的结果赋值的。以完整的[命名空间 + select标签id]方式指明 column属性：使用当前bean的哪个属性传入select标签执行调用 通过部门id查询所有员工的映射文件 123&lt;select id=&quot;getEmployeeListByDeptId&quot; resultType=&quot;com.company.bean.Employee&quot;&gt; select * from tbl_employee where d_id = #&#123;id&#125;&lt;/select&gt; 在&lt;collection&gt;标签中调用查询部门id对应的所有员工信息的select标签进行数据获取并封装 1234567891011121314151617&lt;mapper namespace=&quot;com.company.dao.DepartmentDao&quot;&gt; &lt;!-- dept_id dept_name | id last_name gender email d_id--&gt; &lt;resultMap id=&quot;departmentMapping&quot; type=&quot;com.company.bean.Department&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;dept_name&quot; property=&quot;name&quot;/&gt; &lt;collection property=&quot;employeeList&quot; select=&quot;com.company.dao.EmployeeDao.getEmployeeListByDeptId&quot; column=&quot;id&quot;&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;getDepartmentById&quot; resultMap=&quot;departmentMapping&quot;&gt; SELECT * from tbl_dept where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 扩展属性使用多个传入column 对于mybatis配置文件获取参数默认就是map方式获取，获取传入参数得名就是map键 因此当在&lt;association&gt;标签和&lt;collection&gt;标签中需传入多个column值时可以封装成map传入 格式：&quot;&#123;key1=value1,key2=value2&#125;&quot; 被调用select标签 123&lt;select id=&quot;getEmployeeListByDeptId&quot; resultType=&quot;com.company.bean.Employee&quot;&gt; select * from tbl_employee where d_id = #&#123;deptId&#125;&lt;/select&gt; 以map方式传入column 123456789&lt;resultMap id=&quot;departmentMapping&quot; type=&quot;com.company.bean.Department&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;dept_name&quot; property=&quot;name&quot;/&gt; &lt;collection property=&quot;employeeList&quot; select=&quot;com.company.dao.EmployeeDao.getEmployeeListByDeptId&quot; column=&quot;&#123;deptId=id&#125;&quot;&gt; &lt;/collection&gt;&lt;/resultMap&gt; fetchType属性 在使用分步查询中，可以针对当前sql操作进行延迟加载设置（开启或关闭），而不设置全局的延迟加载。 可以在&lt;association&gt;标签和&lt;collection&gt;标签中设置fetchType属性 lazy：启用延迟加载，即懒加载 eager：立即加载，即全部加载 123456789&lt;resultMap id=&quot;departmentMapping&quot; type=&quot;com.company.bean.Department&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;dept_name&quot; property=&quot;name&quot;/&gt; &lt;collection property=&quot;employeeList&quot; select=&quot;com.company.dao.EmployeeDao.getEmployeeListByDeptId&quot; column=&quot;&#123;deptId=id&#125;&quot; fetchType=&quot;eager&quot;&gt; &lt;/collection&gt;&lt;/resultMap&gt; 鉴别器简介 鉴别器指resultMap标签中的一个子标签&lt;discriminator&gt; 鉴别器可以根据某列的值，根据该值改变封装行为 示例&lt;discriminator&gt;标签 javaType属性：待判断列值对应的Java类型 column：指定用于判定的列名（字段名） &lt;case&gt;子标签：相当于判断的分支语句， value 属性：当前判定条件所匹配的值 resultType/resultMap：设置当前case语句执行sql的返回类型 例：如果查出的是女生：就把部门信息查询出来，否则不查询；如果是男生，把last_name这一列的值赋值给email; 123456789101112131415161718192021222324252627&lt;resultMap type=&quot;com.company.mybatis.bean.Employee&quot; id=&quot;MyEmpDis&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt; &lt;!-- 鉴别器 --&gt; &lt;discriminator javaType=&quot;string&quot; column=&quot;gender&quot;&gt; &lt;!--女生 --&gt; &lt;case value=&quot;女&quot; resultType=&quot;com.company.mybatis.bean.Employee&quot;&gt; &lt;association property=&quot;dept&quot; select=&quot;com.company.mybatis.dao.DepartmentMapper.getDeptById&quot; column=&quot;d_id&quot;&gt; &lt;/association&gt; &lt;/case&gt; &lt;!--男生 ;如果是男生，把last_name这一列的值赋值给email; --&gt; &lt;case value=&quot;男&quot; resultType=&quot;com.company.mybatis.bean.Employee&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt; &lt;result column=&quot;last_name&quot; property=&quot;email&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt; &lt;/case&gt; &lt;/discriminator&gt; &lt;/resultMap&gt; 动态SQL简介 动态 SQL是MyBatis强大特性之一，可以按照特定条件执行特定sql语句，极大的简化我们拼装SQL的操作 动态 SQL 元素和使用 JSTL 或其他类似基于 XML 的文本处理器相似 MyBatis 采用功能强大的基于 OGNL 的表达式来简化操作 if ：单分支 choose (when, otherwise) ：多分支，类似每个条件都带break的switch trim (where, set) ：拼接的SQL字符串截取 foreach：循环 OGNL表达式简介 OGNL（ Object Graph Navigation Language ）对象图导航语言 是一种强大的表达式语言，通过它可以非常方便的来操作对象属性。 类似EL，SpEL等 基础语法 OGNL可以通过表达式的方式实现java代码般的书写，调用方法、构造器… 在Mybatis中的OGNL表达式使用的参数是传入参数，即如果传入对象类型则为对象的属性名 基础表达式 操作 语法 访问对象属性 person.name 调用方法 person.getName() 调用静态属性/方法 @java.lang.Math@PI@java.util.UUID@randomUUID() 调用构造方法 new com.company.bean.Person(‘admin’).name 运算符 +，-，*，/，% 逻辑运算符 in，not in，and，or，&gt;，&gt;=，&lt;，&lt;=，==，!= 注意：xml中特殊符号如，” , &gt; , &lt; ‘等这些都需要使用转义字符 访问集合伪属性 类型 伪属性 伪属性对应的Java方法 List、Set、Map size、isEmpty List/Set/Map.size(),List/Set/Map.isEmpty() List、Set iterator List.iterator()、Set.iterator() Map keys、values Map.keySet()、Map.values() Iterator next、hasNext Iterator.next()、Iterator.hasNext() if标签语法格式 if类同与编程语言中的if语句，单分支的条件判断标签 123&lt;if test=&quot;判断条件(OGNL表达式)&quot;&gt; 符合后拼凑的SQL语句&lt;/if&gt; 示例查询员工：要求，传入员工信息含哪个字段（不含id），查询条件就带上这个字段的值 双引号&quot;为特殊字符，若表示字符串常量需要使用转意字符代表&quot;&quot;，如&quot;男&quot;则&amp;quot;男&amp;quot; 在OGNL中，表示空串可以用单引号替代，如email != &#39;&#39; OGNL会自动将数值型转换为字符型后比较 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.company.dao.EmployeeDao&quot;&gt; &lt;select id=&quot;getEmpsByConditionIf&quot; resultType=&quot;com.company.bean.Employee&quot;&gt; select * from tbl_employee where 1=1 &lt;if test=&quot;lastName != null and lastName != &#x27;&#x27;&quot;&gt; and last_name like #&#123;lastName&#125; &lt;/if&gt; &lt;if test=&quot;gender == &amp;quot;男&amp;quot; or gender == &amp;quot;女&amp;quot;&quot;&gt; and gender = #&#123;gender&#125; &lt;/if&gt; &lt;if test=&quot;email!=null and email.trim()!=&#x27;&#x27;&quot;&gt; and email = #&#123;email&#125; &lt;/if&gt; &lt;/select&gt;&lt;/mapper&gt; 使用if标签需注意某些条件不符合时SQL语法上的拼装问题，一般有两种解决方案 如上述方式，在主要的SQL语句where条件后添加一个 1 == 1，后续拼凑的SQL全部带上and 或使用mybatis提供的where标签将所有查询条件包括在内 where标签 where标签用于等价替代SQL语句中的where关键字 作用在于避免if标签带来的SQL拼装语法问题，但也不能完全解决 where标签可以自动去除第一个多出的and或者or 即如果and习惯写在sql语句后的，如gender = #&#123;gender&#125; and 则无法去除后面多出的and 示例：当lastName属性不存在时，gender多出的and关键字会被自动去除 12345678910111213141516&lt;select id=&quot;getEmpsByConditionIf&quot; resultType=&quot;com.company.bean.Employee&quot;&gt; select * from tbl_employee &lt;where&gt; &lt;if test=&quot;lastName != null and lastName != &#x27;&#x27;&quot;&gt; last_name like #&#123;lastName&#125; &lt;/if&gt; &lt;if test=&quot;gender == &amp;quot;男&amp;quot; or gender == &amp;quot;女&amp;quot;&quot;&gt; and gender = #&#123;gender&#125; &lt;/if&gt; &lt;if test=&quot;email!=null and email.trim()!=&#x27;&#x27;&quot;&gt; and email = #&#123;email&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; trim标签基本功能 相较于if、where标签所出现的特定条件下字符串拼接语法错误，mybatis提供更灵活的trim标签解决 可以自定义从条件拼接的SQL语句中添加、删除、前缀或后缀特定字符串 使用方式 将所有条件标签写在trim标签内 trim标签有多个可选属性，分别完成拼接后的SQL语句的添加、删除、前缀或后缀特定字符串 prefix属性：给拼串后的整个字符串加一个指定字符串前缀 prefixOverrides属性：去掉整个字符串前面多余的指定字符 suffix属性：给拼串后的整个字符串加一个指定字符串后缀 suffixOverrides属性：去掉整个字符串后面多余的指定字符 例如，下述为拼接后的SQL语句添加”where”前缀且谈若后缀出现”and”删除 123456789101112131415&lt;!-- 自定义字符串的截取规则 --&gt;&lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and&quot;&gt; &lt;if test=&quot;id!=null&quot;&gt; id=#&#123;id&#125; and &lt;/if&gt; &lt;if test=&quot;lastName!=null &amp;amp;&amp;amp; lastName!=&amp;quot;&amp;quot;&quot;&gt; last_name like #&#123;lastName&#125; and &lt;/if&gt; &lt;if test=&quot;email!=null and email.trim()!=&amp;quot;&amp;quot;&quot;&gt; email=#&#123;email&#125; and &lt;/if&gt; &lt;if test=&quot;gender==0 or gender==1&quot;&gt; gender=#&#123;gender&#125; &lt;/if&gt;&lt;/trim&gt; choose标签choose标签是一个多分支标签，而且一旦满足条件后立即退出，类似每个条件都带break的switch &lt;when&gt;子标签：用于编写每一个条件，类似于switch的case关键字 test属性：编写判别条件，OGNL表达式 &lt;otherwise&gt;子标签：当所有&lt;when&gt;标签都不满足时执行，类似于switch的default关键字 12345678910111213141516171819&lt;select id=&quot;getEmpsByConditionChoose&quot; resultType=&quot;com.company.mybatis.bean.Employee&quot;&gt; select * from tbl_employee &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;id!=null&quot;&gt; id=#&#123;id&#125; &lt;/when&gt; &lt;when test=&quot;lastName!=null&quot;&gt; last_name like #&#123;lastName&#125; &lt;/when&gt; &lt;when test=&quot;email!=null&quot;&gt; email = #&#123;email&#125; &lt;/when&gt; &lt;otherwise&gt; gender = 0 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; set标签 set标签和where标签同理，set标签用于替换set关键字并对可能多出的,进行删除 其中set就是sql中修改关键字update table set 1234567891011121314151617&lt;!--public void updateEmp(Employee employee); --&gt;&lt;update id=&quot;updateEmp&quot;&gt; &lt;!-- Set标签的使用 --&gt; update tbl_employee &lt;set&gt; &lt;if test=&quot;lastName!=null&quot;&gt; last_name=#&#123;lastName&#125;, &lt;/if&gt; &lt;if test=&quot;email!=null&quot;&gt; email=#&#123;email&#125;, &lt;/if&gt; &lt;if test=&quot;gender!=null&quot;&gt; gender=#&#123;gender&#125; &lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; foreach标签基本说明当参与SQL执行的传入数据是集合类型时，可以使用foreach标签对传入的集合数据进行遍历拼凑 collection：指定要遍历的集合，即抽象方法形参名或list类型直接key为”list“（list类型会被封装在map） item：将当前遍历出的元素赋值给指定的变量符合 separator：每个元素之间的分隔符（自动拼凑在每一项之间） open：遍历出所有结果后拼接一个开始的字符 close：遍历出所有结果后拼接一个结束的字符 index：索引 遍历list的时候是index就是索引，item就是当前值 遍历map的时候index表示的就是map的key，item就是map的值 **#{变量名}**：取出变量的值也就是当前遍历出的元素 批量查询示例模拟传入一个待查询id的List集合，遍历集合中的所有id并拼凑出in关键字的查询SQL语句 如传入getEmpsByConditionForeach(Arrays.asList(1,2,3,4)); 对应转换出SQL语句为select * from tbl_employee where id in(1,2,3,4) 接口方法1public List&lt;Employee&gt; getEmpsByConditionForeach(List&lt;Integer&gt; ids); 映射规则1234567&lt;select id=&quot;getEmpsByConditionForeach&quot; resultType=&quot;com.company.mybatis.bean.Employee&quot;&gt; select * from tbl_employee &lt;foreach collection=&quot;ids&quot; item=&quot;item_id&quot; separator=&quot;,&quot; open=&quot;where id in(&quot; close=&quot;)&quot;&gt; #&#123;item_id&#125; &lt;/foreach&gt;&lt;/select&gt; 批量保存示例多括号方式 MySQL下批量保存支持values(),(),()格式的语法，因此遍历拼凑的是后面的括号部分() 123456789&lt;!-- 批量保存 --&gt;&lt;!--public void addEmps(@Param(&quot;emps&quot;)List&lt;Employee&gt; emps); --&gt;&lt;insert id=&quot;addEmps&quot;&gt; insert into tbl_employee(last_name,email,gender,d_id) values &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt; (#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id&#125;) &lt;/foreach&gt;&lt;/insert&gt; &lt;include refid=&quot;insertColumn&quot;&gt;&lt;/include&gt; 多sql语句方式 直接拼凑多条完整的插入语句，每条语句用;号相隔。（也适用于批量删除和修改） 注意，这种方式需要在数据库连接信息中jdbc.url:追加allowMultiQueries=true，表示允许同时执行多条SQL语句 12345678&lt;!-- 这种方式需要数据库连接属性 这种分号分隔多个sql可以用于其他的批量操作（删除，修改） --&gt;&lt;insert id=&quot;addEmps&quot;&gt; &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;;&quot;&gt; insert into tbl_employee(last_name,email,gender,d_id) values(#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id&#125;) &lt;/foreach&gt;&lt;/insert&gt; Oracle方式，需有”begin”和”end”前后缀 123456&lt;insert id=&quot;addEmps&quot; databaseId=&quot;oracle&quot;&gt; &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; open=&quot;begin&quot; close=&quot;end;&quot;&gt; insert into employees(employee_id,last_name,email) values(employees_seq.nextval,#&#123;emp.lastName&#125;,#&#123;emp.email&#125;); &lt;/foreach&gt;&lt;/insert&gt; bind标签在CRUD操作的标签中可以使用bind标签，可以将OGNL表达式传入的值绑定到一个变量中 value属性：被绑定值 name属性：绑定后的变量名 示例：通过bind标签实现在绑定变量同时为其变量前后加上%实现模糊查询功能 1234567&lt;!--public List&lt;Employee&gt; getEmpsLikeName(String lastName); --&gt;&lt;select id=&quot;getEmpsLikeName&quot; resultType=&quot;com.company.mybatis.bean.Employee&quot;&gt; &lt;!-- 将lastName传入变量添加前后缀&#x27;%&#x27;，并将其重命名为_lastName --&gt; &lt;bind name=&quot;_lastName&quot; value=&quot;&#x27;%&#x27;+lastName+&#x27;%&#x27;&quot;/&gt; select * from tbl_employee where last_name like #&#123;lastName&#125;&lt;/select&gt; 一般建议不适用该方式，还是传入参数时设置好模糊规则 内置参数在mybatis中不只是接口方法传入的参数可以被使用，默认含有两个内置参数 _parameter：代表整个参数 单个参数：_parameter就是这个参数 多个参数：参数会被封装为一个map；_parameter就是代表这个map _databaseId：代表当前使用的数据库的别名（配置的databaseIdProvider标签） 示例 功能1：通过获取当前使用数据库的_databaseId数值，实现不同数据库执行不同sql语句的效果 功能2：如果传入的employee参数不为null，则加上where查询条件，此时_parameter等价于employee 12345678910111213141516171819&lt;!--public List&lt;Employee&gt; getEmpsTestInnerParameter(Employee employee); --&gt;&lt;select id=&quot;getEmpsTestInnerParameter&quot; resultType=&quot;com.company.mybatis.bean.Employee&quot;&gt; &lt;if test=&quot;_databaseId==&#x27;mysql&#x27;&quot;&gt; select * from tbl_employee &lt;if test=&quot;_parameter!=null&quot;&gt; where last_name #&#123;lastName&#125; &lt;/if&gt; &lt;/if&gt; &lt;if test=&quot;_databaseId==&#x27;oracle&#x27;&quot;&gt; select * from employees &lt;if test=&quot;_parameter!=null&quot;&gt; where last_name #&#123;_parameter.lastName&#125; &lt;/if&gt; &lt;/if&gt; &lt;/select&gt; sql标签 sql标签用于抽取可重用的sql片段，方便后续引用、复用 sql标签编写在与CRUD操作标签同级位置 &lt;sql&gt;标签：用于抽取sql片段 id属性：用于唯一标识sql标签，被后续引用sql标签所使用 &lt;include&gt;标签：用于引用sql标签所声明的sql片段 refid属性：指定引用sql标签的id &lt;property&gt;子标签：用于声明某些可被sql标签所引用的变量 name属性：自定义的变量名，sql标签通过$&#123;&#125;引用时的key值（不能使用#&#123;&#125;方式） value属性：name变量的值 12345678910111213141516&lt;insert id=&quot;addEmps&quot;&gt; insert into tbl_employee( &lt;include refid=&quot;insertColumn&quot;&gt; &lt;!-- 引用sql片段 --&gt; &lt;property name=&quot;testProperty&quot; value=&quot;abc&quot;/&gt; &lt;/include&gt; ) values &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt; (#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id&#125;) &lt;/foreach&gt;&lt;/insert&gt;&lt;sql id=&quot;insertColumn&quot;&gt; employee_id,last_name,email,$&#123;testProperty&#125; &lt;!-- 此时$&#123;testProperty&#125; == abc --&gt;&lt;/sql&gt; 缓存机制简介对于某些数据库数据使用频率高且基本稳定的场景，可以把第一次查询到的数据缓存起来，后续直接从缓存中读出数据。不用每次建立数据库连接、查询、读取、封装等一系列操作。因此可以极大的提升查询效率 MyBatis包含一个非常强大的查询缓存特性,它可以非常方便地配置和定制。 MyBatis系统中默认定义了两级缓存，分别为一级缓存和二级缓存。 默认情况下，只有一级缓存（SqlSession级别的缓存， 也称为本地缓存）开启 二级缓存需要手动开启和配置，他是基于namespace级别的缓存 mybatis为了提高扩展性，定义了缓存接口Cache。通过实现该接口来自定义二级缓存 一级缓存一级缓存体验 一级缓存，又称为本地缓存，基于sqlSession的缓存。默认一直开启（只能通过settings关闭） 与数据库同一次会话期间（SqlSession）查询到的数据会放在本地缓存中 当在同一次SqlSession中对同一数据查询了两次，只发出了一次sql语句查询，为同一对象 123456789101112131415161718public class MybatisTest &#123; public static void main(String[] args) throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory build = new SqlSessionFactoryBuilder().build(is); SqlSession session = build.openSession(); try &#123; EmployeeDao mapper = session.getMapper(EmployeeDao.class); //在同一次SqlSession中对同一数据查询了两次，只发出了一次sql语句查询 Employee employee1 = mapper.getEmployeeById(1); Employee employee2 = mapper.getEmployeeById(1); System.out.println(employee1 == employee2); //true，同一对象 &#125;finally &#123; session.close(); &#125; &#125;&#125; 缓存失效情况 sqlSession不同（重新创建新的sqlSession对象、sqlSession被关闭） sqlSession相同，查询条件不同（当前一级缓存中还没有该数据） sqlSession相同，两次查询之间执行了任意的增删改操作，缓存也会失效，重新获取新的数据 1234Employee employee1 = mapper.getEmployeeById(1);mapper.addEmployee(new Employee(null,&quot;Deny&quot;,&quot;男&quot;,&quot;333@qq.com&quot;));Employee employee2 = mapper.getEmployeeById(1);System.out.println(employee1 == employee2);//false sqlSession相同，手动清理了一级缓存（只会清除当前sqlSession的一级缓存，对二级缓存没影响） 1sqlSession.clearCache(); 一级缓存原理就是将同一个sqlSession对象中查询出来的数据都装入一个Map中，下次查询数据前先在Map中查询，如果没有则从数据库中获取，否则从Map中返回数据 二级缓存 二级缓存，又称为全局缓存，是基于namespace级别的缓存 映射文件中的一个namespace对应自己的一个二级缓存 工作原理前提：开启了Mybatis的二级缓存后 同一会话，查询一条数据，该数据会被存储在当前会话的一级缓存中 当该会话关闭后，一级缓存中的数据会被保存到获取一级缓存数据时候对应的namespace中（二级缓存） 不同的namespace查出的数据放在自己对应的缓存中，互相独立，互不干扰 注：查出的数据默认都会先存放在一级缓存中，只有当一级缓存的会话关闭或提交后，才会触发转存到二级缓存，否则二级缓存不工作 Mybatis二级缓存中，任何时都是先从二级缓存中寻找数据，再到一级，再到数据库 开启二级缓存开启二级缓存需3个步骤：在setting配置开启二级缓存、在需要的sql映射文件中启用、POJO实现序列化接口 setting配置 开启二级缓存，cacheEnabled=true 123&lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 虽然当前版本的cacheEnabled默认为true，但建议显式设置。遵循只要需设置的内容都要显式设置，避免因版本更新默认值改变导致出错 配置二级缓存在需要启用二级缓存的sql映射文件中通过&lt;cache&gt;&lt;/cache&gt;标签即可开启 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.company.dao.EmployeeDao&quot;&gt; &lt;cache eviction=&quot;LRU&quot; flushInterval=&quot;60000&quot; readOnly=&quot;false&quot; size=&quot;1024&quot;&gt;&lt;/cache&gt; &lt;select id=&quot;getEmployeeById&quot; resultType=&quot;com.company.bean.Employee&quot;&gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 若只编写&lt;cache&gt;&lt;/cache&gt; 则不指示任何策略均使用默认值。以下为可选配置属性、策略 eviction：缓存的回收策略 LRU – 最近最少使用的（默认）：移除最长时间不被使用的对象。 FIFO – 先进先出：按对象进入缓存的顺序来移除它们。 SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。 WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。 flushInterval：缓存刷新间隔，即缓存多长时间清空一次，单位为毫秒。默认不清空 readOnly：是否只读 true：只读；mybatis认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。 mybatis为了加快获取速度，直接就会将数据在缓存中的引用交给用户。&lt;u&gt;不安全，速度快&lt;/u&gt; false：非只读：mybatis觉得获取的数据可能会被修改。 mybatis会利用序列化&amp;反序列的技术**克隆一份新的数据**提供。&lt;u&gt;安全，速度慢&lt;/u&gt; size：缓存存放多少个数量的元素； type：指定自定义缓存的全类名（有默认的实现）。若自定义缓存则实现Cache接口，并填入缓存实现类全类名至此即可。 POJO实现序列化由于二级缓存使用了序列化&amp;反序列化技术，因此参与数据库操作的Java类需实现Serializable接口 二级缓存测试导入日志 二级缓存测试employee1 == employee2不可能为true，因为二级缓存中提供的数据是克隆出来的 因此查看二级缓存的效果，需借助log4j日志查看加载信息 导入log4j jar包：log4j.jar maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 配置文件 在类路径下创建名为log4j.xml的文件，并填写如下内容 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;&lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt; &lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \\n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=&quot;java.sql&quot;&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.ibatis&quot;&gt; &lt;level value=&quot;info&quot; /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 缓存测试 注意，无论何时都是先使用一级缓存，只要有当会话被结束才会转存到二级缓存中 1234567891011121314151617181920public class MybatisTest&#123; public static void main(String[] args) throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory build = new SqlSessionFactoryBuilder().build(is); //第一个会话，第一次查询id=1的数据，查询后关闭会话（数据转存到二级缓存） SqlSession session1 = build.openSession(); EmployeeDao mapper1 = session1.getMapper(EmployeeDao.class); Employee employee1 = mapper1.getEmployeeById(1); session1.close(); //获取新的sqlSession对象，查询同样的数据 SqlSession session2 = build.openSession(); EmployeeDao mapper2 = session2.getMapper(EmployeeDao.class); Employee employee2 = mapper2.getEmployeeById(1); session2.close(); System.out.println(employee1 == employee2); //false &#125;&#125; 日志输出：可以看到只执行了一条SQL语句，而且最后一行提示Cache Hit Ratio，”缓存命中” 1234567DEBUG 08-21 12:47:37,689 Cache Hit Ratio [com.company.dao.EmployeeDao]: 0.0 (LoggingCache.java:60) DEBUG 08-21 12:47:38,056 &#x3D;&#x3D;&gt; Preparing: select * from tbl_employee where id &#x3D; ? (BaseJdbcLogger.java:137) DEBUG 08-21 12:47:38,113 &#x3D;&#x3D;&gt; Parameters: 1(Integer) (BaseJdbcLogger.java:137) DEBUG 08-21 12:47:38,134 &lt;&#x3D;&#x3D; Total: 1 (BaseJdbcLogger.java:137) WARN 08-21 12:47:38,153 As you are using functionality that deserializes object streams, it is recommended to define the JEP-290 serial filter. Please refer to https:&#x2F;&#x2F;docs.oracle.com&#x2F;pls&#x2F;topic&#x2F;lookup?ctx&#x3D;javase15&amp;id&#x3D;GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66 (SerialFilterChecker.java:46) DEBUG 08-21 12:47:38,159 Cache Hit Ratio [com.company.dao.EmployeeDao]: 0.5 (LoggingCache.java:60) false 缓存相关其他属性CRUD相关 查询标签（select） useCache属性：默认为true。设置为false时表示当前标签操作关闭二级缓存 flushCache属性：默认为false，即不清除缓存 增删改标签（insert、delete、update） flushCache属性：默认为true，表示执行完增删改标签后会清除所有缓存（一级和二级） settings相关localCacheScope设置，称为本地缓存作用域（设置只对一级缓存有效），取值如下： SESSION：会话级别的一级缓存作用域，默认作用域，即sqlSession作用域 STATEMENT：可以禁用一级缓存（一般不配置） 第三方缓存整合 Mybatis自带缓存功能，但不精通缓存设计。为了扩展性设计了一个Cache接口可用于更替缓存实现类 下述介绍使用第三方缓存库ehcache整合到mybatis中 导入ehcache核心包 导入jar包方式 ehcache-core-2.6.8.jar slf4j-api-1.6.1.jar（依赖） slf4j-log4j12-1.6.2.jar（依赖） maven方式 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt; &lt;version&gt;2.6.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 下载ehcache适配包 理论上，导入第三方缓存jar包后，通过调用第三方库间接实现Cache接口中所有方法就完成了整合操作 由于Mybatis官方还提供不同第三方缓存整合时的适配包，替代完成了上述的适配实现接口操作。更方便 进入mybatis官方GitHub仓库 查找整合ehcache第三方缓存的适配包 页面滚到底部，进入ehcache整合的mybatis官方文档 点击”zip bundle“下载ehcache适配器的jar包导入或选择添加maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt;&lt;/dependency&gt; 引入ehcache.xml 在类路径下导入官方提供的ehcache.xml文件 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt; &lt;!-- 磁盘保存路径 --&gt; &lt;diskStore path=&quot;D:\\44\\ehcache&quot; /&gt; &lt;defaultCache maxElementsInMemory=&quot;10000&quot; maxElementsOnDisk=&quot;10000000&quot; eternal=&quot;false&quot; overflowToDisk=&quot;true&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt;&lt;!-- 属性说明：l diskStore：指定数据在磁盘中的存储位置。l defaultCache：当借助CacheManager.add(&quot;demoCache&quot;)创建Cache时，EhCache便会采用&lt;defalutCache/&gt;指定的的管理策略以下属性是必须的：l maxElementsInMemory - 在内存中缓存的element的最大数目 l maxElementsOnDisk - 在磁盘上缓存的element的最大数目，若是0表示无穷大l eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断l overflowToDisk - 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上以下属性是可选的：l timeToIdleSeconds - 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，这些数据便会删除，默认值是0,也就是可闲置时间无穷大l timeToLiveSeconds - 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大 diskSpoolBufferSizeMB 这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区.l diskPersistent - 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。l diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作l memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出） --&gt; 配置第三方缓存 在sql映射文件中启用二级缓存时用type属性指明缓存实现类全路径即可 1234&lt;mapper namespace=&quot;org.acme.FooMapper&quot;&gt; &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt; ...&lt;/mapper&gt; （可选、其他）引用某命名空间下所设置的缓存 1234&lt;mapper namespace=&quot;org.acme.FooMapper&quot;&gt; &lt;cache-ref namespace=&quot;org.acme.FooMapper&quot;/&gt; ...&lt;/mapper&gt; Mybatis缓存原理 SSM整合基础 下载或导入对应版本的Mybatis适配Spring框架的适配包 导入Spring依赖 web.xml、SpringMVC、Spring配置文件编写 Mybatis-Spring下载Mybatis-Spring是Mybatis官方整合Spring框架的适配包名称 Mybatis还贴心地提供了一个整合完整的SSM项目供开发人员参考，名为：jpetstore-6 进入Mybatis的GitHub仓库中的整合Spring框架项目中 mybatis的spring整合GitHub页面底部，进入整合spring的mybatis官方文档 从官方文档中查看当前需整合的Mybatis和Spring版本所支持对应的Mybatis-Spring适配器版本是多少 确定Mybatis-Spring版本后，回到mybatis整合Spring的GitHub仓库，进入release，下载需要的版本 或进入导入对应版本的maven依赖 配置文件编写web.xml 配置使Spring的IoC容器跟随web一并启动 配置SpringMVC的配置文件 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- 1、Spring配置文件配置：使Spring的IoC容器跟随web一并启动 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 指定Spring配置文件的位置（类路径下） --&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 2、SpringMVC配置文件配置 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; SpringMVCSpringMVC只控制网站跳转逻辑，即只负责控制器部分 配置组件扫描（对应当前SpringMVC的IoC容器来说，只扫描控制器注解即可） 基本标签配置，处理动态资源的标签和处理静态资源的mvc标签 配置视图解析器：使用自带的内部资源访问视图解析器，处理jsp页面 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 1、开启SpringMVC的IoC容器组件扫描，且只扫描@Controller注解 --&gt; &lt;context:component-scan base-package=&quot;com.company&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; &lt;!-- 2、基本标签配置，处理动态资源的标签和处理静态资源的mvc标签 --&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 3、配置视图解析器：使用spring自带的内部资源访问视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; SpringSpring主要用于管理所有的业务逻辑（服务逻辑、数据源、事务控制）组件 配置组件扫描（对应当前Spring的IoC容器来说，与SpringMVC刚好相反，出控制器外都需要扫描） 配置数据源（数据库连接池，当前使用c3p0数据库连接池） 配置事务管理器。开启事务注解，并指明事务管理器实现类对象。 当前使用事务管理器为DataSourceTransactionManagerg，需导入jdbcTemplate即spring-jdbc依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt;&lt;/dependency&gt; 整合mybatis，创建（配置）SqlSessionFactory对象 mybatis提供的SqlSession对象工厂类，实现了Spring的工厂bean接口。使其融合到Spring的操作逻辑中，调用工厂的getObject()方法返回sqlSession对象，提供给Spring进行持久层的访问 SqlSessionFactory相当于mybatis配置文件的Java对象，封装了配置文件的许多信息 在mybatis-config.xml配置的标签，都可以在SqlSessionFactory找到对应的属性注入设置 注入数据源 注入mybatis全局配置文件（路径；创建sqlSession需要；属于自定义路径方式） 注入sql映射文件（路径；创建代理实现类对象mapper需要） 开启扫描所有的sql映射接口标签。使其实现类（mybatis实现的代理类）能够被以自动注入方式使用 applicationContext.xml 注意：只要启用了&lt;mybatis-spring:scan base-package=”com.company.dao”/&gt;标签，Spring会自动将mybatis生成的sql操作代理实现类存放到IoC容器中，此时dao的java接口类不用添加@Repository，虽然IDEA会在service通过自动装配dao时候提示“无法找到该bean”但实际可以运行使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mybatis-spring=&quot;http://mybatis.org/schema/mybatis-spring&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring.xsd&quot;&gt; &lt;!-- 1、开启组件扫描、除@Controller外扫描所有组件 --&gt; &lt;context:component-scan base-package=&quot;com.company&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; &lt;!-- 2、配置数据源 --&gt; &lt;!-- 导入外部配置文件，获取内部的数据库连接信息 --&gt; &lt;context:property-placeholder location=&quot;classpath:dbconfig.properties&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 3、配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 开启事务注解，并指明事务管理器实现类对象 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; &lt;!-- 4、整合mybatis，实际就是创建SqlSessionFactory --&gt; &lt;bean id=&quot;sqlSessionFactoryBean&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;!-- 配置加载sql映射文件，指定类路径的mapper目录下的所有xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- 扫描所有的sql映射接口，使其实现类（mybatis实现的代理类）能够被以自动注入方式使用 --&gt; &lt;!-- 该标签需引入mybatis-spring命名空间 --&gt; &lt;mybatis-spring:scan base-package=&quot;com.company.dao&quot;/&gt;&lt;/beans&gt; 逆向工程基本概念 MyBatis Generator，译为”代码生成器”：简称MBG，是一个专门为MyBatis框架使用者定制的代码生成器 MBG可以快速的根据表生成对应的映射文件，接口，以及bean类（逆向操作——逆向工程） 支持基本的增删改查，以及QBC风格的条件查询。但是表连接、 存储过程、复杂sql定义等需要用户编写 官方文档地址 http://www.mybatis.org/generator/ 官方工程地址 https://github.com/mybatis/generator/releases 依赖下载 在Mybatis Generator的Github仓库release中下载jar包等资料（官方文档在此下载） 或选择导入maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt; mbg配置文件 基于官方提供的配置文件例子编写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!-- targetRuntime= &quot;MyBatis3Simple&quot;:生成简单版的CRUD &quot;MyBatis3&quot;:豪华版，在生成CRUD基础上带复杂条件CRUD操作 --&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3Simple&quot;&gt; &lt;!-- jdbcConnection：指定如何连接到目标数据库 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true&quot; userId=&quot;root&quot; password=&quot;123456&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- --&gt; &lt;javaTypeResolver &gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- javaModelGenerator：指定javaBean的生成策略 targetPackage=&quot;com.company.bean&quot;：设置自动生成的bean所在包名 targetProject=&quot;.\\src&quot;：生成的目标工程（当前工程的src下） --&gt; &lt;javaModelGenerator targetPackage=&quot;com.company.bean&quot; targetProject=&quot;.\\src&quot;&gt; &lt;!-- 查看官方文档 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- sqlMapGenerator:sql映射生成策略 同理上述的javaModelGenerator标签配置的两个属性 定义自动生成的sql映射文件所在包名和所在工程 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.company.dao&quot; targetProject=&quot;.\\conf&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- javaClientGenerator:指定mapper接口生成的位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.company.dao&quot; targetProject=&quot;.\\src&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定要逆向分析的表：指定待分析表对应的javaBean类名 --&gt; &lt;table tableName=&quot;tbl_dept&quot; domainObjectName=&quot;Department&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;tbl_employee&quot; domainObjectName=&quot;Employee&quot;&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 生成逆向工程 官方文档提供的启用生成逆向工程方式很多，下述才有含上述配置文件方式启动生成逆向工程 执行代码后，将会通过表格生成对应的基础的bean、mapper接口、sql映射文件等… 123456789101112@Testpublic void testMbg() throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(&quot;mbg.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null);&#125; 工作原理与源码分析 了解Mybatis底层工作原理和源码主要便于理解插件的开发 分层架构 ParameterHandler参数处理器、SqlSource（StatementHandler 语句处理器）ResultSetHandler结果集处理器、Exeutor执行器 关键步骤一般源码分析都是以HelloWorld为例起步，关键步骤可以总结为以下4点： 创建SqlSessionFactory对象 创建SqlSession对象 创建接口的代理对象（MapperProxy） 通过代理对象执行CRUD操作 123456789101112131415public class MybatisTest &#123; public static void main(String[] args) throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(); try&#123; EmployeeDao mapper = sqlSession.getMapper(EmployeeDao.class); Employee employee = mapper.getEmployeeById(1); System.out.println(employee); &#125;finally &#123; sqlSession.close(); &#125; &#125;&#125; 创建SqlSessionFactory源码起始调用代码：new SqlSessionFactoryBuilder().build(is) 创建parser解析器解析全局配置文件，并将信息保存到Configuration对象中 创建mapperParser解析器解析所有SQL映射文件，并封装成每一个MapperdStatement对象 并将每一个映射文件对应的MapperdStatement对象也保存在Configuration对象中 将Configuration作为构造器实参，创建DefaultSqlSessionFactory对象（SqlSessionFactory接口实现类）并返回 小结：把所有配置文件解析并保存在Configuration中并返回DefaultSqlSessionFactory对象（含MappedStatement对象） 补充一个封装到Configuration重要属性对象——mapperRegistry，其中knownMappers属性以Map的方式存储了接口对应的代理实现类工厂（interface——MapperProxyFactory） 创建SqlSession对象源码起始调用代码：sqlSessionFactory.openSession(); 从Configuration中获取默认执行器类型，并以此为实参调用openSessionFromDataSource()方法 当前默认执行器类型在settings中可以设置defaultExecutorType，可选值为SIMPLE（简单）、REUSE（可复用）、BATCH（批量操作） 在此创建了一个事务，并以该事务对象和监听器类型为构造器实参通过Configuration对象创建了一个Executor对象 根据全局配置文件的settings标签中的defaultExecutorType，创建对应类型的Executor对象 若开启二级缓存，则以Executor为实参传入构造器创建CachingExecutor对象 将所有配置的拦截器（插件）包装到Executor对象中并返回 最后以Configuration、Executor、AutoCommit对象为实参创建DefaultSqlSession（SqlSession接口的实现类）并返回 小结：返回一个DefaultSQLSession对象，包含Executor和Configuration 创建接口的代理对象源码起始调用代码：sqlSession.getMapper(EmployeeDao.class); 小结：使用创建SqlSessionFactory时已经创建的接口映射MapperProxyFactory的工厂对象创建MapperProxy的代理对象（实现InvocationHandler)，其中代理对象包含了SqlSession（DefaultSqlSession），SqlSession又包含了Excutor（执行CRUD） 代理对象执行CRUD源码起始调用代码：mapper.getEmployeeById(1);——&gt;代理对象执行方法都是调invoke() 执行流程总结 时序图（参考） 四大对象，Executor、StatementHandler、ParameterHandler、ResultSetHandler创建时都调用了拦截链进行包装 总结 根据配置文件（全局，sql映射）初始化出Configuration对象 创建一个DefaultSqlSession对象，该对象含Configuration以及Executor 根据全局配置文件中的defaultExecutorType创建出对应的Executor 调用DefaultSqlSession.getMapper()，拿到Mapper接口对应的MapperProxy； MapperProxy里面有（DefaultSqlSession）； 执行增删改查方法： 调用DefaultSqlSession的增删改查（调用Executor）； 创建一个StatementHandler对象。（同时创建出ParameterHandler和ResultSetHandler） 调用StatementHandler预编译参数以及设置参数值（使用ParameterHandler来给sql设置参数） 调用StatementHandler的增删改查方法； ResultSetHandler封装结果 注：四大对象创建的时都会与拦截器进行包装：interceptorChain.pluginAll(parameterHandler); 插件开发简介 MyBatis在四大对象的创建过程中，都有插件介入 插件利用动态代理机制层层包装目标对象(AOP)，实现在目标对象执行目标方法之前进行拦截的效果。 MyBatis允许在已映射语句执行过程中的某一点进行拦截调用。 默认情况下，MyBatis 允许使用插件来拦截的方法调用包括： Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) ParameterHandler(getParameterObject, setParameters) ResultSetHandler(handleResultSets, handleOutputParameters) StatementHandler(prepare 预编译, parameterize 设置参数, batch, update, query) 四大对象都是接口，具体操作实现有其实现类完成，一般命名未DefaultXxxx 插件运行原理 在四大对象创建的时不是直接返回的，而是均调用了interceptorChain.pluginAll(xxxx); 123456public Object pluginAll(Object target) &#123; for (Interceptor interceptor : interceptors) &#123; target = interceptor.plugin(target); &#125; return target;&#125; 遍历所有的Interceptor（拦截器）（开发插件需实现的接口）。最后调用interceptor.plugin(target);返回包装后的target对象 使用插件为目标对象创建一个代理对象（AOP），利用代理对象就可以拦截到四大对象的每一个执行 HelloWord 编写插件，即编写Interceptor接口的实现类 使用@Intercepts注解完成插件签名 将写好的插件注册到全局配置文件中 插件编写 实现mybatis的Interceptor接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.company.test;import org.apache.ibatis.executor.statement.StatementHandler;import org.apache.ibatis.plugin.*;import java.sql.Statement;import java.util.Properties;/** * @author yhd * @create 2021-08-23 17:04 */public class MyFirstPlugin implements Interceptor &#123; /** * 拦截器：用于拦截目标对象的目标方法执行 * @param invocation * @return 目标对象的目标方法执行后的结果（返回值） * @throws Throwable */ @Override public Object intercept(Invocation invocation) throws Throwable &#123; //调用proceed()方法表示执行目标方法，即放行。返回值为目标方法执行的返回值 //不执行proceed()方法则表示拦截 Object proceed = invocation.proceed(); System.out.println(&quot;MyFirstPlugin...intercept()拦截的方法：&quot; + invocation.getMethod()); //此时拦截器返回值为目标方法执行后的返回值 return proceed; &#125; /** * 插件：plugin方法用于包装传入的目标对象（四大对象） * - 包装的本质就是为其目标对象创建代理类，从而实现调用的拦截效果 * - 即此方法中主要实现target对象的代理对象的创建。 * @param target * @return 被包装后的对象（代理对象） */ @Override public Object plugin(Object target) &#123; //自编写原生代理实现或利用mybatis提供的Plugin类，调用wrap()方法直接包装（创建代理类） //param1：被包装的目标对象，param2：用哪个拦截器包装（this即用当前拦截器包装） Object wrap = Plugin.wrap(target, this); System.out.println(&quot;MyFirstPlugin...plugin()被包装的对象：&quot; + target); return wrap; &#125; /** * 将插件注册时的property属性设置进来 * @param properties */ @Override public void setProperties(Properties properties) &#123; System.out.println(&quot;插件的配置信息：&quot; + properties); &#125;&#125; 插件签名 插件签名即指明当前插件拦截四大对象的哪一个对象、哪一个方法（方法名和形参列表） 具体配置使用@Intercepts注解实现，该注解为@Signature注解的数组类型 12345678public @interface Signature &#123; //被拦截的四大对象的之一的Class对象 Class&lt;?&gt; type(); //被拦截的方法名：指四大对象内置存在的方法(非自定义SQL映射接口的方法) String method(); //方法对应的形参列表的Class数组（防止重载） Class&lt;?&gt;[] args();&#125; 示例：配置拦截StatementHandler对象的parameterize(Statement statement)方法 123456789@Intercepts( &#123; @Signature(type = StatementHandler.class, method = &quot;parameterize&quot;,args = &#123;Statement.class&#125;) &#125;)public class MyFirstPlugin implements Interceptor &#123; //省略上述插件开发代码....&#125; 插件注册 在mybatis全局配置文件中使用&lt;plugins&gt;标签注册自定义的插件 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 注册插件 --&gt; &lt;plugins&gt; &lt;!-- 插件的全类名 --&gt; &lt;plugin interceptor=&quot;com.company.test.MyFirstPlugin&quot;&gt; &lt;!-- 为使用的插件设置一些传入属性，可在插件内部setProperties()方法中被获取 --&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123&quot;/&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/configuration&gt; 测试结果 注意以下测试结果配置时只拦截StatementHandler对象，即只有StatementHandler被包装 而下述四大对象都打印了&quot;将被包装的对象xxx&quot;信息是由于plugin()方法无论何时都会被四大对象调用 使用Mybatis提供的Plugin类的wrap()方法实现plugin()方法时，wrap()方法内部会根据当前插件签名定义的拦截对象创建对应的代理对象，没被插件签名定义的实际是没被包装的 1234567891011插件的配置信息：&#123;password&#x3D;123, username&#x3D;root&#125;SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.SLF4J: Defaulting to no-operation (NOP) logger implementationSLF4J: See http:&#x2F;&#x2F;www.slf4j.org&#x2F;codes.html#StaticLoggerBinder for further details.MyFirstPlugin...plugin()将要被包装的对象：org.apache.ibatis.executor.CachingExecutor@f6c48acMyFirstPlugin...plugin()将要被包装的对象：org.apache.ibatis.scripting.defaults.DefaultParameterHandler@64bf3bbfMyFirstPlugin...plugin()将要被包装的对象：org.apache.ibatis.executor.resultset.DefaultResultSetHandler@10bdf5e5MyFirstPlugin...plugin()将要被包装的对象：org.apache.ibatis.executor.statement.RoutingStatementHandler@7e0b0338MyFirstPlugin...intercept()拦截的方法：public abstract void org.apache.ibatis.executor.statement.StatementHandler.parameterize(java.sql.Statement) throws java.sql.SQLExceptionEmployee&#123;id&#x3D;1, lastName&#x3D;&#39;Priscilla&#39;, gender&#x3D;&#39;女&#39;, email&#x3D;&#39;8888@qq.com&#39;&#125; 多插件运行多个插件配置拦截同一对象同一方法时，会产生多重代理 创建代理时，按插件配置顺序创建层层代理对象 执行目标时，拦截顺序按逆序执行（即先执行最大的代理对象，即最后包装的代理对象） 插件开发流程假如当前想通过插件，使查询id=1的员工SQL语句改变成查询id=5员工的SQL语句 确定四大对象：由于改变SQL参数，因此属于ParameterHandler负责的工作 也可以选择拦截StatementHandler，因为它包含ParameterHandler 确定待操作方法及相关属性：在ParameterHandler中，负责参数设置的方法为setParameters(PreparedStatement ps)，其中parameterObject属性就是被设置的参数 当前需求关键就是修改parameterObject属性 通过确定包装的对象和拦截的方法编写插件签名 实现插件内容，编写拦截逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.company.test;import org.apache.ibatis.executor.parameter.ParameterHandler;import org.apache.ibatis.executor.statement.StatementHandler;import org.apache.ibatis.plugin.*;import org.apache.ibatis.reflection.MetaObject;import org.apache.ibatis.reflection.SystemMetaObject;import java.sql.PreparedStatement;import java.sql.Statement;import java.util.Properties;/** * @author yhd * @create 2021-08-23 17:04 */@Intercepts( &#123; @Signature(type = ParameterHandler.class,method = &quot;setParameters&quot;,args = &#123;PreparedStatement.class&#125;) &#125;)public class MyFirstPlugin implements Interceptor &#123; /** * 拦截器：用于拦截目标对象的目标方法执行 * @param invocation * @return 目标对象的目标方法执行后的结果（返回值） * @throws Throwable */ @Override public Object intercept(Invocation invocation) throws Throwable &#123; /** * 可通过调用Mybatis提供的SystemMetaObject.forObject()方法，传入拦截的四大对象之一 * 创建MetaObject对象，该对象可以获取或修改传入的四大对象之一的所有属性 */ Object target = invocation.getTarget(); MetaObject metaObject = SystemMetaObject.forObject(target); //通过调用getValue()方法，传入target对象的属性名，来获取其属性值 Object parameterObject = metaObject.getValue(&quot;parameterObject&quot;); System.out.println(&quot;用户传入的参数 = &quot; + parameterObject); //通过setValue()方法，修改指定target属性名的属性值，从而达到修改设置参数的效果 metaObject.setValue(&quot;parameterObject&quot;,5); //注意，一切修改操作要在执行invocation.proceed()前才能生效 return invocation.proceed(); &#125; @Override public Object plugin(Object target) &#123; Object wrap = Plugin.wrap(target, this); System.out.println(&quot;MyFirstPlugin...plugin()将要被包装的对象：&quot; + target); return wrap; &#125; @Override public void setProperties(Properties properties) &#123; System.out.println(&quot;插件的配置信息：&quot; + properties); &#125;&#125; 输出效果：最终用户传入查询id=1，实际查询被插件修改成查询id=5的员工信息 12345678MyFirstPlugin...plugin()将要被包装的对象：org.apache.ibatis.executor.CachingExecutor@6eebc39eMyFirstPlugin...plugin()将要被包装的对象：org.apache.ibatis.scripting.defaults.DefaultParameterHandler@64bf3bbfMyFirstPlugin...plugin()将要被包装的对象：org.apache.ibatis.executor.resultset.DefaultResultSetHandler@10bdf5e5MyFirstPlugin...plugin()将要被包装的对象：org.apache.ibatis.executor.statement.RoutingStatementHandler@7e0b0338用户传入的参数 &#x3D; 1Employee&#123;id&#x3D;5, lastName&#x3D;&#39;Acer&#39;, gender&#x3D;&#39;男&#39;, email&#x3D;&#39;5551@qq.com&#39;&#125;Process finished with exit code 0 PageHelper插件简介PageHelper是Mybatis的一款分页插件 官方Github网址：https://github.com/pagehelper/Mybatis-PageHelper 使用文档：https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md 依赖下载 以下均基于官方使用文档的其中一种操作实现，具体请查询官方文档 引入分页插件有下面2种方式，推荐使用 Maven 方式。 引入 Jar 包你可以从下面的地址中下载最新版本的 jar 包 https://oss.sonatype.org/content/repositories/releases/com/github/pagehelper/pagehelper/ http://repo1.maven.org/maven2/com/github/pagehelper/pagehelper/ 由于使用了sql 解析工具，你还需要下载 jsqlparser.jar(需要和PageHelper 依赖的版本一致) ： http://repo1.maven.org/maven2/com/github/jsqlparser/jsqlparser/ 使用 Maven在 pom.xml 中添加如下依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt;&lt;/dependency&gt; 最新版本号可以从首页查看。（当前文档使用，5.2.1） 注册插件1234567&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt; &lt;property name=&quot;param1&quot; value=&quot;value1&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 基础分页 准备一个查询所有记录的接口方法（基于Mybatis） 在执行查询所有记录方法前调用分页插件的操作 调用PageHelper的静态方法startPage()，设置当前显示页码和每页显示的记录数 静态方法返回的Page对象可以获取更多分页相关的信息 返回分页后的结果 1234567891011121314151617181920212223242526272829public class MybatisTest &#123; public static void main(String[] args) throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(); try&#123; EmployeeDao mapper = sqlSession.getMapper(EmployeeDao.class); /** * 在查询所有员工方法前操作： * 使用分页插件提供的PageHelper类的静态方法，param1=当前页码，param=每页的数量 * 最终查询结果为分页后的结果 */ Page&lt;Object&gt; page = PageHelper.startPage(1, 3); List&lt;Employee&gt; employees = mapper.getEmployees();//当前数据库总共10条记录 System.out.println(employees); //返回的Page对象可以获取更多分页相关的信息 System.out.println(&quot;总记录数：&quot; + page.getTotal()); System.out.println(&quot;当前页码：&quot; + page.getPageNum()); System.out.println(&quot;每页的记录数：&quot; + page.getPageSize()); System.out.println(&quot;总页码：&quot; + page.getPages()); &#125;finally &#123; sqlSession.close(); &#125; &#125;&#125; PageInfo基本使用 在上述使用PageHelper实现的”基础分页”基础上，把分页后的结果作为PageInfo构造器实例化 PageInfo对象能获取比Page更详细的分页信息，如首页、尾页、是否存在下一页等等（详情看官方文档） 1234567891011121314151617181920212223242526public class MybatisTest &#123; public static void main(String[] args) throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(); try&#123; EmployeeDao mapper = sqlSession.getMapper(EmployeeDao.class); Page&lt;Object&gt; page = PageHelper.startPage(1, 3); List&lt;Employee&gt; employees = mapper.getEmployees();//当前数据库总共10条记录 System.out.println(employees); //将分页后的结果作为构造啊实参传入实例化PageInfo PageInfo&lt;Employee&gt; pageInfo = new PageInfo&lt;&gt;(employees); //PageInfo能获取Page能分页信息基础上，还封装了更为详细的分页信息 System.out.println(&quot;下一页页码：&quot; + pageInfo.getNextPage()); System.out.println(&quot;是否存在下一页：&quot; + pageInfo.isHasNextPage()); System.out.println(&quot;......&quot;); &#125;finally &#123; sqlSession.close(); &#125; &#125;&#125; 分页导航PageInfo除了基于Page封装的分页信息基础上，还能够获取更多信息外。还具备获取分页导航栏信息功能。省去了分页导航栏计算的麻烦 在实例化PageInfo时，除了传入分页后的结果集外，还设置要显示分页导航栏的长度 1PageInfo&lt;Employee&gt; pageInfo = new PageInfo&lt;&gt;(employees,3); 获取当前分页情况的分页导航栏页码列表 12int[] nums = pageInfo.getNavigatepageNums();System.out.println(Arrays.toString(nums)); //[1, 2, 3] 其他Mybatis批量操作背景 使用动态SQL编写的批量操作实际并非真正的SQL批量操作，只是连续执行多条SQL语句或执行一条拼凑出来的很长的SQL语句 其中可以通过settings设置项中的defaultExcutorType把处理器类型设置称为BATCH来实现批量执行SQL语句。该方式会将所有项目中所有SQL语句执行都设置为批量方式执行，**因此不建议 ! ** Mybatis提供一种方式，可以只在某个SqlSession中启用批量执行SQL语句，建议使用这种方式！ SqlSession批量执行 在调用openSession时，通过设置执行器类型，创建可执行批量操作的sqlSession 1234567891011121314151617181920@Testpublic void testBatch() throws IOException&#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); //在调用openSession时，通过设置执行器类型，创建可执行批量操作的sqlSession SqlSession openSession = sqlSessionFactory.openSession(ExecutorType.BATCH); try&#123; EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class); for (int i = 0; i &lt; 10000; i++) &#123; mapper.addEmp(new Employee(UUID.randomUUID().toString().substring(0, 5), &quot;b&quot;, &quot;1&quot;)); &#125; //提交操作 openSession.commit(); //批量：（预编译sql一次==&gt;设置参数===&gt;10000次===&gt;执行（1次）） //非批量：（预编译sql=设置参数=执行）==》10000 //批量方式在10000条SQL语句执行插入时，比非批量快接近3倍 &#125;finally&#123; openSession.close(); &#125;&#125; Spring整合中配置批量执行 在Spring的配置文件中配置一个可以进行批量执行的sqlSession 123456789101112&lt;!--整合Mybatis：配置SqlSessionFactory对象 --&gt;&lt;bean id=&quot;sqlSessionFactoryBean&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mybatis/mapper/*.xml&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置一个可以进行批量执行的sqlSession，自定义命名为sqlSessionOfBatch --&gt;&lt;bean id=&quot;sqlSessionOfBatch&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;constructor-arg name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactoryBean&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;executorType&quot; value=&quot;BATCH&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; Mybatis调用存储过程（待补充）以Oracle实现分页操作来介绍Mybatis中如何使用存储过程 Oracle分页原理Oracle中不能像Mysql中使用的limt就可以完成分页 Oracle是通过rownum，行号完成分页，即每条数据都有自己的行号 1~5条数据作为一页的分页查询就是查询 1≤ 行号 ≤ 5 而实际操作过程中，不能直接查询大于等于1，小于等于5的行号的数据，因为数据在不断变化 必须分成两步进行查询，通过一个子查询先查出行号小于等于5号的数据集（静态存储），然后再查询行号大于等于1的数据集 调用过程略…待补充 自定义类型处理器背景 Mybatis的类型处理器（TypeHandler）是四大对象之一，主要用于为数据库、后端编程语言的数据类型间搭建转换的桥梁。 TypeHandler是一个接口，某一个Java类型对应数据库某个类型的映射关系由一个实现类完成 如Java中的Long类型对应数据库类型的定义和转换由LongTypeHandler负责 通常情况下很少需要自定义Mybatis的类型处理器 由于Mybatis目前提供的Java枚举类型处理器不能满足目前开发的要求 因此一般需要自定义类型处理器为Java的枚举类型 枚举类型处理器默认类型处理器Mybatis对于Java的枚举类型默认提供了两个类型处理器 EnumTypeHandler（默认）：使用枚举的name属性（String）存储到数据库的String类型字段中 Java中，若枚举类型没有显式定义name属性，则默认为枚举对象名 EnumOrdinalTypeHandler：使用枚举对象默认的索引值（Integer）存储到数据库的int类型字段中 更换类型处理器 在全局配置文件中，使用&lt;typeHandler&gt;标签为某种具体Java类型配置类型处理器 handler属性：更换的类型处理器全类名 javaType属性：被该类型处理器处理的Java类型全类名 以下为将某个自定义的枚举类型使用官方提供的另一个枚举类型处理器（以枚举索引方式存储到数据库） 123&lt;typeHandlers&gt; &lt;typeHandler handler=&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot; javaType=&quot;com.company.mybatis.bean.EmpStatus&quot;/&gt;&lt;/typeHandlers&gt; 枚举处理器不足 目前Mybatis官方提供的处理枚举类型的类型处理器不能满足实际开发需要 通常情况下不适用枚举name属性，也不适用枚举默认索引，而是一般将枚举这种状态类型参数通过一个表示该状态的状态码表示并存储，如HTTP的状态码，404，表示”找不到目标资源” 目的的枚举类型结构如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.company.mybatis.bean;import com.sun.org.apache.bcel.internal.generic.RETURN;/** * 希望数据库保存的是100,200这些状态码，而不是默认0,1或者枚举的Name */public enum EmpStatus &#123; LOGIN(100,&quot;用户登录&quot;),LOGOUT(200,&quot;用户登出&quot;),REMOVE(300,&quot;用户不存在&quot;); private Integer code; private String msg; private EmpStatus(Integer code,String msg)&#123; this.code = code; this.msg = msg; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; //按照状态码返回枚举对象 public static EmpStatus getEmpStatusByCode(Integer code)&#123; switch (code) &#123; case 100: return LOGIN; case 200: return LOGOUT; case 300: return REMOVE; default: return LOGOUT; &#125; &#125;&#125; 自定义枚举处理器 实现TypeHandler接口，或基础BaseTypeHandler 在全局配置文件中，使用&lt;typeHandler&gt;标签为某种具体Java类型配置类型处理器 实现枚举处理器实现TypeHandler接口，或基础BaseTypeHandler 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.company.mybatis.typehandler;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import org.apache.ibatis.type.JdbcType;import org.apache.ibatis.type.TypeHandler;import com.company.mybatis.bean.EmpStatus;/** * 自定义枚举类型处理器：枚举类型对象（java） &lt;——&gt; 状态码 (database) * 实现TypeHandler&lt;E&gt;接口：泛型E为需要处理的Java类型 */public class MyEnumEmpStatusTypeHandler implements TypeHandler&lt;EmpStatus&gt; &#123; /** * Java的EmpStatus枚举数据——&gt;数据库 * - 将EmpStatus枚举类的状态码，以String方式（setString()）存储到数据库中 */ @Override public void setParameter(PreparedStatement ps, int i, EmpStatus parameter, JdbcType jdbcType) throws SQLException &#123; // TODO Auto-generated method stub System.out.println(&quot;要保存的状态码：&quot;+parameter.getCode()); ps.setString(i, parameter.getCode().toString()); &#125; /** * 数据库枚举数据——&gt;Java（1 - 通过字段名方式获取） * - 根据从数据库中拿到的枚举的状态码返回一个枚举对象 * * ResultSet rs：查询一条完整数据的结果集 * String columnName：当前要处理的数据库类型的字段名 */ @Override public EmpStatus getResult(ResultSet rs, String columnName) throws SQLException &#123; // TODO Auto-generated method stub //可以通过传入字段名在结果集中获取当前字段值 int code = rs.getInt(columnName); System.out.println(&quot;从数据库中获取的状态码：&quot;+code); EmpStatus status = EmpStatus.getEmpStatusByCode(code); return status; &#125; /** * 数据库枚举数据——&gt;Java（2 - 通过数据库字段索引方式获取） * - 代码结构类似 */ @Override public EmpStatus getResult(ResultSet rs, int columnIndex) throws SQLException &#123; // TODO Auto-generated method stub int code = rs.getInt(columnIndex); System.out.println(&quot;从数据库中获取的状态码：&quot;+code); EmpStatus status = EmpStatus.getEmpStatusByCode(code); return status; &#125; /** * 数据库枚举数据——&gt;Java（3 - 从存储过程中通过数据库字段索引方式获取） * - 代码结构类似 */ @Override public EmpStatus getResult(CallableStatement cs, int columnIndex) throws SQLException &#123; // TODO Auto-generated method stub int code = cs.getInt(columnIndex); System.out.println(&quot;从数据库中获取的状态码：&quot;+code); EmpStatus status = EmpStatus.getEmpStatusByCode(code); return status; &#125;&#125; 注册自定义枚举处理器在全局配置文件中，使用&lt;typeHandler&gt;标签为某种具体Java类型配置类型处理器 12345678910111213&lt;typeHandlers&gt; &lt;!--1、配置我们自定义的TypeHandler --&gt; &lt;typeHandler handler=&quot;com.company.mybatis.typehandler.MyEnumEmpStatusTypeHandler&quot; javaType=&quot;com.company.mybatis.bean.EmpStatus&quot;/&gt; &lt;!--2、也可以在处理某个字段的时候告诉MyBatis用什么类型处理器 保存：#&#123;empStatus,typeHandler=xxxx&#125; 查询： &lt;resultMap type=&quot;com.company.mybatis.bean.Employee&quot; id=&quot;MyEmp&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;empStatus&quot; property=&quot;empStatus&quot; typeHandler=&quot;&quot;/&gt; &lt;/resultMap&gt; 注意：如果在参数位置修改TypeHandler，应该保证保存数据和查询数据用的TypeHandler是一样的。 --&gt;&lt;/typeHandlers&gt;","categories":[],"tags":[{"name":"应用框架","slug":"应用框架","permalink":"http://yoursite.com/tags/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/"},{"name":"ORM框架","slug":"ORM框架","permalink":"http://yoursite.com/tags/ORM%E6%A1%86%E6%9E%B6/"}]},{"title":"SpringMVC5","slug":"SpringMVC5","date":"2021-08-11T15:42:12.000Z","updated":"2021-08-25T15:27:11.796Z","comments":true,"path":"2021/08/11/SpringMVC5/","link":"","permalink":"http://yoursite.com/2021/08/11/SpringMVC5/","excerpt":"","text":"引言：SpringMVC是Spring的一个子项目，是Spring的一个后续产品SpringMVC 是 Spring 为表述层（表示层）开发提供的一整套完备的解决方案。本文以Maven工程为基础，介绍SpringMVC中常用注解，如@RequestMapping，如何获取请求参数，域对象得数据共享，视图概念。同时介绍了REST的架构风格，静态资源访问、HttpMessageConverter、文件上传下载、拦截器、异常处理器、纯配置类开发、以及SpringMVC底层执行过程的了解。 SpringMVC概述MVC概念基本概念MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分 M：Model，模型层，指工程中的JavaBean，作用是处理数据 实体类Bean：专门存储业务数据的，如 Student、User 等 业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问 V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据 C：Controller，控制层，指工程中的Servlet，作用是接收请求和响应浏览器 工作流程 用户通过视图层发送请求到服务器，在服务器中请求被Controller接收 Controller 调用相应的Model层处理请求，处理完毕将结果返回到Controller Controller再根据请求处理的结果 找到相应的View视图，渲染数据后最终响应给浏览器 注：实际开发中，常将MVC重组为三层架构，表述(示)层（页面 + servlet）、业务逻辑层（service）、数据访问层（bean + dao） SpringMVC概念 SpringMVC是Spring的一个子项目，是Spring的一个后续产品 SpringMVC 是 Spring 为表述层（表示层）开发提供的一整套完备的解决方案 表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的首选方案 注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层 SpringMVC特点 Spring 家族原生产品，与 IOC 容器等基础设施无缝对接（即整合Spring时无需任何配置与jar包） 基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理 表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案（如接收请求数据封装等公共操作） 代码清新简洁，大幅度提升开发效率 内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可（通过配置组件实现功能） 性能卓著，尤其适合现代大型、超大型互联网项目要求 HelloWorld开发环境 IDE：idea 2020.3 构建工具：maven-3.6.0 服务器：tomcat-9.0.44 Spring版本：5.3.9 创建maven工程设置打包方式 在maven核心配置文件pom.xml中，将打包方式设置成war包，&lt;packaging&gt;war&lt;/packaging&gt; 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;HelloWorld&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 设置打包方式，打包成war包 --&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt; 注意IDEA环境在pom.xml文件中添加新依赖时，需观察是否有点击maven类刷新（Load Maven Changes）的按钮，加载进来 导入依赖 SpringMVC依赖（含Spring）：由于是Spring中的模块，maven将自动导入Spring相关依赖 从中可以看出SpringMVC所依赖的Jar包都来自于Spring。表明SpringMVC就是Spring里面的东西 日志依赖 Servlet API 依赖 Thymeleaf依赖 12345678910111213141516171819202122232425262728293031&lt;dependencies&gt; &lt;!-- SpringMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- logback日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- ServletAPI --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;!-- 不参与打包，因为tomcat自带，避免引发冲突--&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring5+Thymeleaf的整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.12.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 构建web目录 众所周知，基于Servlet的JavaWeb有一套需遵循的web目录结构，也是web项目的标志 在IDE中，也称为快速创建web项目（eclipse）、添加web模块（IDEA） IDEA快速添加 版权声明：本文为CSDN博主「小跟班大智慧」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/czc9309/article/details/80304074 IDEA手动添加创建web目录 由于是基于maven构建项目，因此maven下的web目录是命名为webapp maven源代码在项目\\src\\main\\目录下，因此创建的web目录路径为项目\\src\\main\\webapp\\ 注意创建webapp目录后观察有没有个小蓝点，有蓝点才被maven工程识别，否则刷新加载一下maven IDEA生成web.xml 进入project structure，定位到当前的Modules 在Deployment Descriptors栏目下点击+号，添加原始的web.xml文件 点击OK，再点击apply或OK，将自动创建web.xml，并坚持是否再规定路径下创建了web.xml文件（底部警告无需理会） 配置前端控制器 由于SpringMVC使采取“前端控制器DispatcherServlet”对请求和响应进行统一管理的 SpringMVC的“DispatcherServlet”本身就是一个Servlet，因此使用它必须像原生操作那样注册Servlet DispatcherServlet类似与自编写的反射请求分发的BaseServlet xml配置方式 在web.xml配置前端控制器有两种方式，均能实现，选其一即可 默认配置方式 不推荐在maven工程下使用该方式，因为SpringMVC的配置文件将会默认在WEB-INF目录下被自动创建 因为maven项目中，一般配置文件都希望在项目\\src\\main\\resources\\目录下创建 匹配路径设置 由于SpringMVC的机制使通过DispatcherServlet去统一管理所有请求和响应的 因此将匹配的url设置成 &quot;/&quot; （除.jsp不能匹配外） 123456789&lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; &quot;/&quot; 是不匹配.jsp结尾的请求，由于jsp本质是一种特殊的Servlet。若给予SpringMVC匹配，则会误将其当作一般的Servlet被DispatcherServlet处理，从而找不到相应的页面 &quot;/*&quot; 是能够匹配所有请求，包括.jsp。若在使用过滤器时，若需要对所有请求进行过滤则使用 SpringMVC配置文件 上述的“默认配置方式”只在web.xml中进行了Servlet的注册，并没有创建或配置SpringMVC的配置文件 此时，SpringMVC的配置文件默认位于WEB-INF下，默认名称为&lt;servlet-name&gt;-servlet.xml 例如，上述配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml 扩展配置方式创建配置文件 基于maven工程，因此在项目\\src\\main\\resources\\下创建SpringMVC的配置文件 由于SpringMVC就是Spring的其中一个模块，因此配置文件与Spring的配置文件内容一致 可以选择IDEA一键创建Spring配置文件 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 定义配置文件的路径 在上述“默认配置方式”基础上，通过&lt;init-param&gt;标签设置SpringMVC配置文件的位置和名称 通过&lt;load-on-startup&gt;标签设置SpringMVC前端控制器DispatcherServlet的初始化时间 由于DispatcherServlet用于接管web中的所有请求和响应，默认的Servlet创建/初始化时机是该Servlet被第一次访问的时候。若不修改初始化时机为web启动时候，则会严重影响第一次访问web的响应速度 1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--- 选择classpath，指maven项目中的src\\main\\java和src\\main\\resources --&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 将前端控制器DispatcherServlet的初始化时机提前到服务器启动时初始化 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 补充说明：maven中的src\\main\\java\\和src\\main\\resources\\目录下的内容都映射到类路径下，即classpath下 main：等价原生的Project（项目名称） java/resources：等价原生的src目录 注解方式创建请求控制器 前端控制器只是对所有请求进行了统一的处理，但具体不同的请求有不同的处理过程（类BaseServlet） 因此需要创建处理具体请求的类，即请求控制器。其中的每一个处理请求的方法称为控制器方法 SpringMVC的控制器定义为一个POJO（Plain Ordinary Java Object / 普通Java类） 控制器需将其标识为一个控制层组件，交给Spring的IoC容器管理后才能够被SrpingMVC识别控制器的存在 这里以通过注解的方式来实现控制器的声明操作，即使用@Controller注解 开启组件扫描 在SpringMVC配置文件中（等价Spring配置文件）添加如下组件扫描代码（目的是扫描控制器所在位置） 12&lt;!-- 开启组件扫描 --&gt;&lt;context:component-scan base-package=&quot;com.company.mvc.controller&quot;/&gt; 创建控制器 创建控制器类 在maven项目的项目名\\src\\main\\java\\目录下创建控制器类 控制器包名，建议使用controller或handler命名 控制器类上添加@Controller的Spring注解，标识为一个Spring IoC中的一个组件，且为控制器标识 123456789101112package com.company.mvc.controller;import org.springframework.stereotype.Controller;/**@author yhd@create 2021-08-05 11:29*/@Controllerpublic class HelloController&#123; &#125; 配置Thymeleaf 由于本文使用Thymeleaf作为视图解析器，因此需要配置Thymeleaf Thymeleaf简介 Thymeleaf是一个XML/XHTML/HTML5模板引擎，可用于Web与非Web环境中的应用开发 它是一个开源的Java库，基于Apache License 2.0许可，由Daniel Fernández创建，该作者还是Java加密库Jasypt的作者 因此Thymeleaf是独立于Spring家族的开源Java库，只是Spring系列框架大力推荐和支持使用Thymeleaf，而不推荐使用JSP 配置Thymeleaf 在SpringMVC的配置文件中配置视图解析器 12345678910111213141516171819202122232425262728293031&lt;!-- 配置Thymeleaf视图解析器属性（也可配置成JSP） --&gt;&lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt; &lt;!-- 注入视图解析的优先级属性。也可看出允许配置多个视图解析器对象 --&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt; &lt;!-- 注入解析视图（前端页面）所用的字符集编码属性 --&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;!-- 注入模板引擎属性 --&gt; &lt;property name=&quot;templateEngine&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt; &lt;!-- 注入视图解析策略属性，只解析下述设置的视图 --&gt; &lt;property name=&quot;templateResolver&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt; &lt;!-- 视图前缀：当接收到视图名称时附加的前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt; &lt;!-- 视图后缀：接收到视图名称时附近的后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt; &lt;!-- 注入视图模板模型属性，只处理HTML5的页面 --&gt; &lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&gt; &lt;!-- 注入字符集编码 --&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 解析策略说明 Thymeleaf模板引擎响应页面时，会要求响应页面的程序返回响应的视图名称 视图解析器解析会为返回的视图名称加上视图解析策略中的视图前缀和后缀，从而形成完整的访问路径 模板引擎得到完整的视图访问路径后，就可以访问（转发）到该页面，从而进行页面的渲染工作 由于WEB-INF目录下的资源是不能够被用户直接访问到的，重定向也不行，只能通过请求的转发 为了保证所有页面都是通过Thymeleaf模板引擎渲染，因此一般将视图前缀设置在WEB-INF目录下 首页访问测试创建页面 由于当前thymeleaf设置的视图前缀为/WEB-INF/templates/，视图后缀为.html，视图模板属性为HTM5 因此在WEB-INF目录下新建一个templates目录，并且在里面创建一个HTML5的index文件 在index.html文件上添加Thymeleaf的命名空间，xmlns:th=&quot;http://www.thymeleaf.org&quot; 若想使用Thymeleaf语法必须添加Thymeleaf命名空间 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello SpringMVC _yhd&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 工程项目目录 (补充)，在IDEA中，可以通过设置创建文件的模板来实现每次创建HTML5文件时都自动添加上该命名空间 首页控制方法理论指导 由于引入Themleaf模板引擎中设置的视图前缀在WEB-INF目录下，只能通过请求转发访问 因此任何一个页面的访问都需要有一个控制方法对应，通过请求的转发到指定页面（或用视图控制器完成） 整合Themleaf模板引擎的环境下，控制方法只需要返回视图名称即可，Themleaf会拼凑视图前后缀进行页面的请求转发访问，包括渲染操作 响应流程 浏览器通过URL发送请求 服务器接收请求后，判断请求URL是否在前端控制器DispatcherServlet的受理范围内（即web.xml中的url-pattern设置） 前端控制器读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求URL和控制器中的控制方法的**@RequestMapping注解的value属性值进行匹配**（因此控制方法名和URL请求无关） 若匹配成功，该控制器方法就是处理请求的方法，最后返回一个String类型的视图名称（页面文件名） 若匹配失败，则服务器返回404表示资源找不到 视图名称会被视图解析器解析，即把视图名加上视图前后缀组成视图的完整访问路径 通过视图完整路径找到目标视图后对其进行渲染，并通过请求转发展示出来 注：虽然点击页面后url是发生了改变，但这个改变只是SpringMVC制造的，实际还是请求的转发。因为最终url是没有变到视图的真实网络路径（WEB-INF/template/）下，而且WEB-INF也只有转发能访问得到 12345678@Controllerpublic class HelloController&#123; @RequestMapping(value = &quot;/&quot;) public String welcome()&#123; return &quot;index&quot;; &#125; &#125; @RequestMapping中，&quot;/&quot; 是被服务器所解析的，即标识web应用的根目录，即协议://ip（域名）:端口号/项目名（上下文路径）/，如http://localhost:8080/01HelloWorld/，在IDEA中的web应用对应的Tomcat设置中也叫Application Context（上下文路径），而且可任意配置 配置Tomcat 前提IDEA已经配置了Tomcat 在IDEA中创建Tomcat 引入测试项目 启动Tomcat测试 在IDEA中点击Run或者Debug按钮启动Tomcat和web应用 logback日志输出的相关请求响应信息 12313:36:19.953 [http-nio-8080-exec-4] DEBUG org.springframework.web.servlet.DispatcherServlet - GET &quot;&#x2F;01HelloWorld&#x2F;&quot;, parameters&#x3D;&#123;&#125;13:36:19.954 [http-nio-8080-exec-4] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping - Mapped to com.company.mvc.controller.HelloController#welcome()13:36:19.961 [http-nio-8080-exec-4] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK 访问页面测试 需求描述：在上述的首页中添加一个超链接，点击后跳转到指定的页面 设置超链接 若想某个属性被Thymeleaf所解析（操作），则就在该属性名前添加th:前缀。此时就可以编写语法 当Thymeleaf检测到以&quot;/&quot;开头的绝对路径格式时候，就会自动为我们添加缺少的上下文路径 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello SpringMVC _yhd&lt;/h1&gt; &lt;a th:href=&quot;@&#123;/target&#125;&quot;&gt;跳转到target页面&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 创建指定页面 在指定Thymeleaf指定目录下创建一个新的页面，target.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Target Page Content&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 创建对应的控制方法 创建traget.html页面访问的控制方法toTraget() 12345678910111213@Controllerpublic class HelloController&#123; @RequestMapping(value = &quot;/&quot;) public String welcome()&#123; return &quot;index&quot;; &#125; @RequestMapping(value = &quot;/target&quot;) public String toTarget()&#123; return &quot;target&quot;; &#125;&#125; 测试 响应流程总结响应流程总结 @RequestMapping功能描述 见名知意，@RequestMapping注解用于将请求的URL和对应的控制方法建立映射关系 当SpringMVC 接收到指定的请求，就会在这些映射关系中匹配到对应的控制器方法来处理请求 所有控制器的控制方法的**@ReuqestMapping的URL必须唯一，即不能存在一个URL对应多个控制方法,否则直接报错** @ReuqestMapping含有多个属性配置，value属性的url是必须配置的，还可以选择用method方式匹配，params请求参数匹配等等多种匹配请求的方式 注解可标识位置@RequestMapping可以标识在类（Class）和方法（Method）上 类：映射路径的初始信息（路径的前缀部分，常用区分不同访问/功能模块） 方法：映射路径的具体信息 12345678910@Controller@RequestMapping(&quot;/test&quot;)public class RequestMappingController &#123; //此时请求映射所映射的请求的请求路径为：/test/testRequestMapping @RequestMapping(&quot;/testRequestMapping&quot;) public String testRequestMapping()&#123; return &quot;success&quot;; &#125;&#125; value属性属性说明 value属性用于设置匹配的请求地址URL，且必须被设置（其他属性均属可选） value属性是一个String[]类型，表示能够配置匹配多个请求地址（满足其一即可匹配） 示例代码1234@RequestMapping(value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;)public String testRequestMapping()&#123; return &quot;success&quot;;&#125; ant风格路径在配置value属性时，SpringMVC支持ant风格，相当于一种模糊匹配风格 ant风格字符 含义 示例 ？ 表示任意的单个字符 @RequestMapping(“/a?a/testAnt”) ***** 表示任意的0个或多个字符 @RequestMapping(“/a*a/testAnt”) ** 表示任意的0层或多层目录 @RequestMapping(“/aa/**/testAnt”) 注：在使用*时，只能使用 &quot;/**/xxx&quot; 的方式。&quot;/a**a/xxx&quot;讲认为路径就是两颗\\ 占位符使用 在value属性设置中使用占位符，常用于REST风格架构中（先了解，rest下文有讲述） 原始方式：/deleteUser?id=1 rest方式：/deleteUser/1，即请求参数按一定含义的顺序成为URL结构的一部分进行传输 定义rest方式参数由于rest方式的URL将请求参数值定义在了请求路径中，因此获取参数的前提需先定义参数的位置及其含义 定义请求参数的位置及其含义 将rest方式的完整的URL配置到@RequestMapping中 将@RequestMapping注解中的rest的URL参数部分用&#123;参数名&#125;占位符替代 通过在控制方法添加形参，并在对应数据类型形参上使用@PathVariable注解绑定占位符中的参数名 示例代码请求地址1&lt;a th:href=&quot;@&#123;/testRest/1/admin&#125;&quot;&gt;testRest&lt;/a&gt; 控制方法12345@RequestMapping(&quot;/testRest/&#123;id&#125;/&#123;username&#125;&quot;) // &quot;/testRest/1/admin&quot;public String testRest(@PathVariable(&quot;id&quot;) String id,@PathVariable(&quot;username&quot;) String username)&#123; System.out.println(&quot;id: &quot; + id + &quot;，username: &quot; + username);//1，admin return &quot;success&quot;;&#125; 注：rest风格的value属性，存在占位符则访问路径一定有占位符这么多层路径再能匹配到，否则均为404 http://ip:port/projectName/testRest/：404 http://ip:port/projectName/testRest/1/：404 http://ip:port/projectName/testRest/1/admin：正确 method属性属性说明 method属性用于设置请求方式匹配的请求映射（设置后即需满足url，又需满足请求方式） method属性是一个RequestMethod[]的枚举类型数组，允许能够匹配多种请求方式的请求 1234567@RequestMapping( value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;)public String testRequestMapping()&#123; return &quot;success&quot;;&#125; 注：若请求满足请求映射的value属性，但不满足method属性，则浏览器报错405：Request method ‘POST’ not supported，表示当前请求类型不支持 派生注解 对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解（复合注解） 这些派生注解等价于每一个匹配的method属性设置，且能够在此注解上设置value属性 method = RequestMethod.? 派生注解 GET @GetMapping POST @PostMapping PUT @PutMapping DELETE @DeleteMapping … … 即要求是GET请求，请求路径还得是 /test的请求示例 1234@GetMapping(value = &quot;/test&quot;)public String test()&#123; return &quot;success&quot;;&#125; 其他请求方式 常用的请求方式有get，post，put，delete，但目前浏览器只支持get和post 若在form表单提交时，设置了非GET和POST请求（如PUT或DELETE），则默认以GET方式处理 若要发送PUT和DELETE请求，则需要通过Spring提供的过滤器HiddenHttpMethodFilter，可通过在RESTful实现 此时可以通过对同一个请求资源实现4种不同的请求方式get，post，put，delete，从而达到同一请求资源实现4种不同的功能，如获取信息用get，增加信息用post，修改信息用put，删除信息用delete。其实这种就是REST架构风格 params属性属性含义 params属性用于设置请求参数的名或名值的匹配映射条件 params属性是一个String[]类型，可通过4种表达式设置请求参数和请求映射的匹配关系 可以设置多个匹配关系，但与value、method属性不一样，多个匹配关系必须同时满足 表达式类型 含义 &quot;param&quot; 请求必须包含param请求参数名 &quot;!param&quot; 请求必须不包含param请求参数名 &quot;param=value&quot; 请求必须包含param请求参数名且该请求参数值等于value &quot;param!=value&quot; 请求必须包含param请求参数名且该请求参数值不等于value 示例代码页面请求 在Thymeleaf命名空间下的HTML文件若使用常规的GET请求参数方式IDEA会提示错误，实际可以运行的 1&lt;a th:href=&quot;@&#123;/testParamsAndHeaders?username=admin&amp;password=123&#125;&quot;&gt; 若不想看到IDEA的错误提示，可以改用Thymeleaf方式写 在在参数列表开始处添加一个()括号，把请求参数写入，多个请求参数用,逗号隔开 字符串类型需要用&#39;&#39;括起来，数值类型直接书写即可 1&lt;a th:href=&quot;@&#123;/testParamsAndHeaders(username=&#x27;admin&#x27;,password=123)&#125;&quot;&gt; 控制方法 如下示例为：用户请求必须满足value、分别满足method其一，且满足包含username、password请求参数，且password请求参数值不能为123456 12345678@RequestMapping( value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125; ,method = &#123;RequestMethod.GET, RequestMethod.POST&#125; ,params = &#123;&quot;username&quot;,&quot;password!=123456&quot;&#125;)public String testRequestMapping()&#123; return &quot;success&quot;;&#125; 注：若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions “username, password!=123456” not met for actual request parameters: username={admin}, password={123456}，表示未满足实际请求参数的要求 headers属性属性说明 headers属性通过HTTP请求头的键或键值对信息匹配请求映射（类似params属性的设置） headers属性是一个String[]类型，可以通过4种表达式设置请求头信息和请求映射的匹配关系 可以设置多个匹配关系，类似params属性的设置，多个匹配关系必须同时满足 表达式类型 具体含义 &quot;header&quot; 请求必须携带header请求头信息 “!header” 请求必须不能携带header请求头信息 &quot;header=value&quot; 请求必须携带header请求头信息，请求头的值为value “header!=value” 请求必须携带header请求头信息，请求头的值不为value 示例代码 类似params属性的使用方式 注：若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，表示此时页面显示404错误，即资源未找到 匹配异常小结 匹配属性 状态码 主要异常 含义 value 404 Not found on this server 不存在该资源 method 405 Request method ‘[请求方式]’ not supported 不支持当前请求方式 params 400 not met for actual request parameters 未满足实际请求参数的要求 headers 404 the requested resource is not available 当前请求资源不可用 获取请求参数Servlet-API方式 将HttpServletRequest作为控制器方法的形参，此时等价原生的Servlet获取参数方式 1234567@RequestMapping(&quot;/testParam&quot;)public String testParam(HttpServletRequest request)&#123; String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;success&quot;;&#125; 同名映射匹配单属性值 在控制器方法的形参位置，设置和请求参数同名的形参 当接收到请求时，DispatcherServlet会将请求参数赋值给同名的形参 测试的请求链接 1&lt;a th:href=&quot;@&#123;/testParam(username=&#x27;admin&#x27;,password=123456)&#125;&quot;&gt;testParam&lt;/a&gt; 通过同名控制器形参自动匹配获取请求参数 12345@RequestMapping(&quot;/testParam&quot;)public String testParam(String username, String password)&#123; System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;success&quot;;&#125; 多属性值 像type=checkbox的多选框，同一个请求参数含有多个值的情况。同名匹配有两种获取方式 字符串类型获取 当将形参设置同名的String参数类型时（一般String类型），返回是以**逗号相隔的多个值拼凑的一个结果** 如：多选框name=hobby，请求链接为hobby=A&amp;hobby=B&amp;hobby=C，获取后的结果是A,B,C 12345@RequestMapping(&quot;/testParam&quot;)public String testParam(String hobby)&#123; System.out.println(hobby);//&quot;A,B,C&quot; return &quot;success&quot;;&#125; 数组类型获取 当将同名方法设置为同名参数的数组类型时，返回的将时所有值构成的数组 此时效果类似原生Servlet的String[] getParameterValues(String name)方法 12345@RequestMapping(&quot;/testParam&quot;)public String testParam(String[] hobby)&#123; System.out.println(Arrays.toString(hobby));//hobby:[A,B,C] return &quot;success&quot;;&#125; 自映射匹配 当像使用新参匹配请求参数方式，又不想被请求参数名约束形参变量名的设置 此时可以通过一些注解，将互不相同的请求参数名和新参参数名进行绑定，构成两者的映射关系 @RequestParam 可在控制方法的请求参数形参前使用@RequestParam注解来构建请求参数名和形参的映射关系 通过value或name属性（两者互为别名）设置前端请求的参数名 前端测试代码 1&lt;input type=&quot;text&quot; name=&quot;user_name&quot;/&gt; 后端测试代码 12345@RequestMapping(&quot;/testParam&quot;)public String testParam(@RequestParam(&quot;user_name&quot;) String username)&#123; System.out.println(username); return &quot;success&quot;;&#125; @RequestHeader 可在控制方法的请求参数形参前使用@RequestHeader注解来构建HTTP请求头和形参的映射关系 12345@RequestMapping(&quot;/testParam&quot;)public String testParam(String username,@RequestHeader(&quot;Host&quot;) String host)&#123; System.out.println(host); return &quot;success&quot;;&#125; @CookieValue 可在控制方法的请求参数形参前使用@RequestHeader注解来构建Cookie名和形参的映射关系 12345@RequestMapping(&quot;/testParam&quot;)public String testParam(String username,@CookieValu(&quot;JSESSIONID&quot;) String JSESSIONID)&#123; System.out.println(JSESSIONID); return &quot;success&quot;;&#125; 属性解析 @ReuqestParam、@RequestHeader及@CookieValue三个注解的属性一样，含义共通 value&amp;name 两者都是设置前端请求参数的属性，两者效果等价，互为别名（@AliasFor） required&amp;defaultValue 用于指定当前@RequestParam所映射的请求参数是否必须在请求中存在 required默认为true，若请求参数不存在，且没有设置defaultValue属性，则报错 若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present 当将其设置为false时，若请求中不含此请求参数，则使用defaultValue属性值，否则为null defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为””时（空串），均使用defaultValue为形参赋值 请求参数 required defaultValue 结果 无 true（默认） 无 404 无 true 有 defaultValue 无 false 无 null 无 false 有 defaultValue 有（空串） true/false 有 defaultValue 对象属性映射匹配 若浏览器传输的请求参数名和实体类中的属性名一致 可以在控制器方法的形参位置设置一个实体类类型的形参，请求参数就会为此属性赋值并封装 框架中使用反射技术一般都是先用空参构造器创建实例，再调用setter方法进行属性设置 测试前端代码 12345678&lt;form th:action=&quot;@&#123;/testpojo&#125;&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; 邮箱：&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 测试bean结构 1234567891011public class User &#123; private Integer id; private String username; private String password; private Integer age; private String sex; private String email; //忽略空参构造器和getter setter方法...&#125; 测试控制方法 123456@RequestMapping(&quot;/testpojo&quot;)public String testPOJO(User user)&#123; System.out.println(user); return &quot;success&quot;;&#125;//最终结果--&gt;User&#123;id=null, username=&#x27;张三&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;&#125; 请求参数的乱码GET请求乱码后端获取带中文的请求参数时，打印显示???，由于HTTP协议传输URL默认编码为iso-8859-1(兼容ASCII) 方案1：先正确解码，再对应编码 1234&#x2F;&#x2F;获取请求参数String username &#x3D; req.getParameter(&quot;username&quot;);&#x2F;&#x2F;先以iso8859-1 解码，再以utf-8进行编码username &#x3D; new String(username.getBytes(&quot;iso-8859-1&quot;), &quot;UTF-8&quot;); 方案2：修改tomcat收到请求时url参数的编码方式 打开tomcat安装目录中的conf\\server.xml，修改成如下内容 1&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot; useBodyEncodingForURI=&quot;true&quot;/&gt; POST请求乱码原生方法（无效）12//一定要在获取请求参数前设置，一旦获取了请求参数后设置无效request.setCharacterEncoding(&quot;UTF-8&quot;); 由于原生Servlet的方式解决POST请求乱码的前提是必须在获取请求参数前调用才生效 SpringMVC的DispatcherServlet统一管理了所有请求和响应，已经把参数获取了，因此上述方法无法生效 因此必须在DispatcherServlet执行前执行才有效，一般选用过滤器 过滤器方式 在SpringMVC中，只有监听器和过滤器会在DispatcherServlet之前执行，且过滤器能处理每个请求 同时SpringMVC已经提供了现成的基于过滤器实现的字符编码设置，只需要在SpringMVC中配置即可 源码分析 SpringMVC提供的编码过滤器为org.springframework.web.filter.CharacterEncodingFilter 真正实现过滤器接口的是其间接抽象父类GenericFilterBean，直接父类OncePerRequestFilter实现doFilter()方法，且调用了doFilterInternal()方法 doFilterInternal()方法由编码过滤器CharacterEncodingFilter重写，因此核心代码在此 123456789101112131415161718192021222324@Overrideprotected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; //获取CharacterEncodingFilter的encoding属性，默认为null String encoding = getEncoding(); //若没设置encoding属性，则直接放行，即按默认的字符编码集请求和响应 if (encoding != null) &#123; //当设置了forceRequestEncoding(Boolean属性)，或encoding属性由被设置 //就会触发设置【请求】编码字符集，且将encoding属性设置为编码集 if (isForceRequestEncoding() || request.getCharacterEncoding() == null) &#123; request.setCharacterEncoding(encoding); &#125; //只有设置forceResponseEncoding(Boolean属性)为true，且将encoding属性设置为编码集 if (isForceResponseEncoding()) &#123; //设置相应编码字符集 response.setCharacterEncoding(encoding); &#125; &#125; filterChain.doFilter(request, response);&#125; 结论： 设置请求编码集：只需要设置encoding属性即可 设置响应编码集：需同时设置encoding属性和forceResponseEncoding=true 设置编码过滤器12345678910111213141516171819&lt;!--配置springMVC的编码过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 设置请求编码 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 设置响应编码 --&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 域对象数据共享Request域共享原生Servlet方式12345@RequestMapping(&quot;/testServletAPI&quot;)public String testServletAPI(HttpServletRequest request)&#123; request.setAttribute(&quot;testScope&quot;, &quot;hello,servletAPI&quot;); return &quot;success&quot;;&#125; ModelAndView方式 该方式属于自定义（创建）一个是ModelAndView对象返回。Model和View两个功能的结合体 Model（Object）：主要用于向请求域共享数据 View（ViewName）：主要用于设置视图，实现页面跳转 以下的SpringMVC所有响应方式（含域数据共享）最终都将封装成ModelAndView对象响应 使用ModelAndView需要将其类型作为控制方法的返回类型 在控制方法中创建ModelAndView对象，并设置域对象数据和返回的视图名称数据 123456789@RequestMapping(&quot;/testModelAndView&quot;)public ModelAndView testModelAndView()&#123; ModelAndView mav = new ModelAndView(); //向request域设置共享数据 mav.addObject(&quot;testScope&quot;, &quot;hello,ModelAndView&quot;); //设置视图，实现页面跳转 mav.setViewName(&quot;success&quot;); return mav;&#125; 前端Thymeleaf获取request域（Thymeleaf对任何html属性修改都是在html属性前加th:前缀） 修改文本域对应html属性为text 1&lt;p th:text=&quot;$&#123;testScope&#125;&quot;&gt;&lt;/p&gt; Map方式 当DispatcherServlet检测到控制方法的形参为Map类型时统一让BindingAwareModelMap作为其实现类 用户可以选择BindingAwareModelMap的不同形态（多态）去接收其实现类，来进行请求域数据的添加 常用的接收BindingAwareModelMap实现类的上层结构有，Map、Model接口和ModelMap间接父类 Model方式 传入实现类均为BindingAwareModelMap 12345@RequestMapping(&quot;/testModel&quot;)public String testModel(Model model)&#123; model.addAttribute(&quot;testScope&quot;, &quot;hello,Model&quot;); return &quot;success&quot;;&#125; Map方式 传入实现类均为BindingAwareModelMap 12345@RequestMapping(&quot;/testMap&quot;)public String testMap(Map&lt;String, Object&gt; map)&#123; map.put(&quot;testScope&quot;, &quot;hello,Map&quot;); return &quot;success&quot;;&#125; ModelMap方式 传入实现类均为BindingAwareModelMap 12345@RequestMapping(&quot;/testModelMap&quot;)public String testModelMap(ModelMap modelMap)&#123; modelMap.addAttribute(&quot;testScope&quot;, &quot;hello,ModelMap&quot;); return &quot;success&quot;;&#125; Session域共享 SpringMVC提供了一个@SessionAttribute注解使用session，但建议使用形参引入HttpSession对象方式 12345@RequestMapping(&quot;/testSession&quot;)public String testSession(HttpSession session)&#123; session.setAttribute(&quot;testSessionScope&quot;, &quot;hello,session&quot;); return &quot;success&quot;;&#125; Thymeleaf方式获取session域对象数据 1&lt;p th:text=&quot;$&#123;session.testSessionScope&#125;&quot;&gt;&lt;/p&gt; Application域共享 获取Application域对象就是ServletContext对象，获取方式很多（下述为session对象中获取） request、session对象获取 servletConfig对象获取 123456@RequestMapping(&quot;/testApplication&quot;)public String testApplication(HttpSession session)&#123; ServletContext application = session.getServletContext(); application.setAttribute(&quot;testApplicationScope&quot;, &quot;hello,application&quot;); return &quot;success&quot;;&#125; SpringMVC视图 SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户 SpringMVC视图的种类很多，默认有转发视图和重定向视图 转发视图：InternalResourceView（返回视图名称含forward） 重定向视图：RedirectView（返回视图名称含redirect） 使用JSTL技术：JstlView将会成为转发视图InternalResourceView的实现对象 使用Thymeleaf技术：配置的Thymeleaf视图解析器解析之后得到的是ThymeleafView（无前缀时） ThymeleafView基本原理 当控制器方法中所设置的视图名称没有任何前缀时 此时的视图名称会直接被SpringMVC配置文件中所配置的视图解析器解析 视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过**请求转发的方式实现跳转** 1234@RequestMapping(&quot;/testHello&quot;)public String testHello()&#123; return &quot;hello&quot;;&#125; 返回Dispatcher返回的是ThymeleafView对象 解析过程 转发视图基本原理 SpringMVC中默认的转发视图是InternalResourceView（正确来说成为内部资源访问视图） 当控制器方法中所设置的视图名称以”forward:“为前缀时，创建InternalResourceView视图 此时视图名称不会被视图解析器解析，而是内部进行一次请求转发操作，再一次被前端控制器处理 响应时会将前缀”forward:“去掉，剩余部分作为最终路径（不用进行视图前后缀拼接）且通过转发的方式实现跳转 应用场景：这种转发一般不用于转发页面，**常用于转发到另一个Servlet**（控制方法）上 1234@RequestMapping(&quot;/testForward&quot;)public String testForward()&#123; return &quot;forward:/testHello&quot;;&#125; 返回InternalResourceView对象 解析过程 重定向视图基本原理 SpringMVC中默认的重定向视图是RedirectView 当控制器方法中所设置的视图名称以”redirect:“为前缀时，创建RedirectView视图 此时的视图名称不会被配置文件中所配置的视图解析器解析，而是直接重定向浏览器，让浏览器发球第二个请求 而是会将前缀”redirect:“去掉，剩余部分作为最终路径（不用进行视图前后缀拼接）通过转发的方式实现跳转 1234@RequestMapping(&quot;/testRedirect&quot;)public String testRedirect()&#123; return &quot;redirect:/testHello&quot;;&#125; 返回RedirectView对象 解析过程 归纳与总结归纳 ThymeleafView 出现背景：视图名称不含任何前缀时（forward:、redirect:），仅表示视图名称 解析过程：响应时，将视图名称直接提交给视图解析器，拼接视图前后缀得出最终访问路径，随后通过转发访问 应用场景：请求转发的目标是页面 InternalResourceView 出现背景：视图名称含forward:前缀，此时前缀后面就是转发访问的最终路径 解析过程：响应时，去除视图名称的forward:前缀，将剩余部分直接作为最终路径转发访问 应用场景：请求转发的目标是下一个请求/页面（Servlet、控制方法、链接等） 其实能访问下一个请求，就等同于能访问页面，因为SpringMVC中使用Thymeleaf作为视图解析器的所有页面都需要有对应的控制方法才能内部转发访问得到（WEB-INF） RedirectView 出现背景：视图名称含redirect:前缀，此时前缀后面就是转发访问的最终路径 解析过程：响应时，去除视图名称的redirect:前缀，将剩余部分直接作为最终路径转发访问 应用场景：请求重定向的目标是下一个请求/页面（Servlet、控制方法、链接等） 同理请求等价于页面，由于SpringMVC中使用Thymeleaf作为视图解析器的所有页面都需要有对应的控制方法（请求）才能内部转发访问得到（WEB-INF） 视图名称 请求类型 下一跳（响应后） 最终访问路径 viewName 转发 视图解析器 视图前缀 + viewName + 视图后缀 forward:/absPath 转发 前端控制器 /（web根目录）+ absPath redirect:/absPath 重定向 浏览器 /（web根目录）+ absPath 总结 请求转发到页面，不加前缀 请求转发到下一个请求，加forward:前缀，并再后面添加要访问请求的绝对路径 请求重定向，加redirect:前缀，并再后面添加要访问重定向的绝对路径 视图控制器 当没有任何请求处理，只完成页面映射功能时候，可通过配置的方式在视图控制器上设置视图名称 在SpringMVC中配置视图控制器时需要引入mvc的XML命名空间 注意在使用视图控制器时，一般需要开启MVC的注解驱动，否则所配置页面上所有链接请求将失效 开启mvc注解驱动除上述功能外还有：对静态资源的访问、java转换json对象等都需要 将首页访问通过视图控制器配置 12345678&lt;!-- path：设置处理的请求地址 view-name：设置请求地址所对应的视图名称--&gt;&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;&gt;&lt;/mvc:view-controller&gt;&lt;!-- 开启MVC的注解驱动，否则视图控制器配置的访问页上所有链接请求将失效 --&gt;&lt;mvc:annotation-driven /&gt; JSP引入示例配置JSP视图解析器 JSP被SpringMVC处理时无论有没有转发前缀，都是内部再发起一次请求转发的效果 因此配置JSP视图解析器，只需要配置InternalResourcesView即可（在SpringMVC配置中设置） 1234&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt; Tomcat默认启动访问 index.html、index.htm、index.jsp RESTFulREST简介 REST，Representational State Transfer，称为表现层资源状态转移，是一种软件架构的风格 RESTFul，译未”Rest的..“表示，基于REST构建的API，或叫遵守了REST原则的web服务 资源（未理解）资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。 资源表述（未理解）资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。 状态转移（未理解）状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。 RestFul的实现参数传递REST 风格提倡 URL 地址使用统一的风格设计 URL个参数值使用斜杠分开，不使用问号键值对方式携带请求参数 将要发送给服务器的数据作为URL 地址的一部分，以保证整体风格的一致性 操作方式HTTP协议中，分别表示4种基本操作的请求方式：GET、POST、PUT、DELETE GET：用来获取资源 POST：用来新建资源 PUT： 用来更新资源 DELETE： 用来删除资源 操作 传统方式（URL） REST风格（URL） 查询操作 getUserById?id=1 user/1（GET请求方式） 保存操作 saveUser user（POST请求方式） 删除操作 deleteUser?id=1 user/1（DELETE请求方式） 更新操作 updateUser user（PUT请求方式） 请求方式实现 由于目前浏览器只支持发送GET和POST方式的请求，那么该如何发送PUT和DELETE请求呢？ SpringMVC 提供 HiddenHttpMethodFilter过滤器 实现将POST请求转换为DELETE 或PUT请求 源码分析 HiddenHttpMethodFilter过滤器执行过滤的方法体doFilterInternal()源码分析 123456789101112131415161718192021222324252627282930@Overrideprotected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; HttpServletRequest requestToUse = request;//将当前被拦截的HTTP请求对象暂存 //如果当前拦截的请求方式是POST，且xxx（忽略、保证==null，默认就为true） if (&quot;POST&quot;.equals(request.getMethod()) &amp;&amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) &#123; //尝试获取请求参数名为methodParam（&quot;_method&quot;）的值（一般输入其他请求方式） String paramValue = request.getParameter(this.methodParam); //hasLength()函数，表示如果存在长度，即该字符串若不为空 if (StringUtils.hasLength(paramValue)) &#123; //将请求参数名为&quot;_method&quot;的值（其他请求方式，如PUT、DELETE）转换为大写 String method = paramValue.toUpperCase(Locale.ENGLISH); //如果请求方式字符串，包含在ALLOWED_METHODS内（List、含PUT、DELETE、PATCH） if (ALLOWED_METHODS.contains(method)) &#123; //则使用HttpMethodRequestWrapper重新包装请求方式（请求对象不变） requestToUse = new HttpMethodRequestWrapper(request, method); &#125; &#125; &#125; //使用新的requestToUse作为请求参数对象传入 filterChain.doFilter(requestToUse, response);&#125; HttpMethodRequestWrapper源码分析（妙，有设计上的学习价值） 123456789101112131415161718//继承的父类HttpServletRequestWrapper是Servlet-API提供的private static class HttpMethodRequestWrapper extends HttpServletRequestWrapper &#123; private final String method; //这里妙在，通过继承 + 重写的方式，实现了即不用改变对象类型，又实现了方法定制的效果 public HttpMethodRequestWrapper(HttpServletRequest request, String method) &#123; super(request); this.method = method; &#125; //仅对getMethod()方法进行重写，因此后来的request对象都调用该重写的方法 //实现了调用getMethod重写方法时，调用的是HttpMethodRequestWrapper传入的method值 @Override public String getMethod() &#123; return this.method; &#125;&#125; 使用总结HiddenHttpMethodFilter过滤器使用PUT、DELETE等非GET/POST请求总结 发起的请求类型必须是POST 在POST请求参数中添加请求参数名为”_method“，值为后端真正处理时的请求方式（不分大小写） 在web.xml中配置受理所有请求的HiddenHttpMethodFilter过滤器 12345678&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; PUT方式 前端页面，POST请求目前一般只能由form表单和ajax这些异步请求自定义发起请求方式实现 因此一般使用form表单，并将_method属性设置称为隐藏域 1234&lt;form th:action=&quot;@&#123;/testPut&#125;&quot; method=&quot;post&quot;&gt; put：username: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt;&lt;/form&gt; DELETE方式 由于一般删除操作都是超链接，但使用隐藏请求方式又需要发起POST请求 因此采取的策略是：通过超链接事件去控制一个外部的form表单并且使其提交即可 编码过滤器优先 若项目中同时设置了编码过滤器（CharacterEncodingFilter）和HiddenHttpMethodFilter过滤器 则必须让编码过滤器先执行，即在web.xml中，编码过滤器的编码配置需在前 XX原因在于：HiddenHttpMethodFilter内部调用了request.getParameter()方法，会使编码过滤器的设置失效 RESTFul案例功能清单 功能 URL 地址 请求方式 访问首页√ / GET 查询全部数据√ /employee GET 删除√ /employee/2 DELETE 跳转到添加数据页面√ /toAdd GET 执行保存√ /employee POST 跳转到更新数据页面√ /employee/2 GET 执行更新√ /employee PUT 基本架构数据访问层实体bean123456789101112131415161718192021222324package com.atguigu.mvc.bean;public class Employee &#123; private Integer id; private String lastName; private String email; //1 male, 0 female private Integer gender; public Employee(Integer id, String lastName, String email, Integer gender) &#123; super(); this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; &#125; public Employee() &#123; &#125; //此处省略getter和setter方法，以及toString方法&#125; DAO及数据模拟 创建对应DAO对象及其在内部模拟数据库数据 1234567891011121314151617181920212223242526272829303132333435363738@Repositorypublic class EmployeeDao &#123; //数据模拟部分 private static Map&lt;Integer, Employee&gt; employees = null; static&#123; employees = new HashMap&lt;Integer, Employee&gt;(); employees.put(1001, new Employee(1001, &quot;E-AA&quot;, &quot;aa@163.com&quot;, 1)); employees.put(1002, new Employee(1002, &quot;E-BB&quot;, &quot;bb@163.com&quot;, 1)); employees.put(1003, new Employee(1003, &quot;E-CC&quot;, &quot;cc@163.com&quot;, 0)); employees.put(1004, new Employee(1004, &quot;E-DD&quot;, &quot;dd@163.com&quot;, 0)); employees.put(1005, new Employee(1005, &quot;E-EE&quot;, &quot;ee@163.com&quot;, 1)); &#125; private static Integer initId = 1006; //DAO部分 public void save(Employee employee)&#123; if(employee.getId() == null)&#123; employee.setId(initId++); &#125; employees.put(employee.getId(), employee); &#125; public Collection&lt;Employee&gt; getAll()&#123; return employees.values(); &#125; public Employee get(Integer id)&#123; return employees.get(id); &#125; public void delete(Integer id)&#123; employees.remove(id); &#125;&#125; 业务逻辑层123456789@Controllerpublic class EmployeeController &#123; @Autowired private EmployeeDao employeeDao; //各种业务对应的控制方法...&#125; 首页访问 直接使用视图控制器配置即可 123&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;/&gt;&lt;!-- 仅需添加一次 --&gt;&lt;mvc:annotation-driven/&gt; 查询所有员工数据前端代码发起请求1&lt;a th:href=&quot;@&#123;/employee&#125;&quot;&gt;查看所有数据&lt;/a&gt;&lt;br/&gt; 数据展示页123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thyemleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;employee_list&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;th colspan=&quot;5&quot;&gt;Employee Info&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;lastName&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;gender&lt;/th&gt; &lt;th&gt;option&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;employee : $&#123;employeeList&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;employee.id&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.gender&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;&quot;&gt;update&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 控制器代码12345678@RequestMapping(value = &quot;/employee&quot;,method = RequestMethod.GET)public ModelAndView getAllEmployee()&#123; Collection&lt;Employee&gt; employeeList = employeeDao.getAll(); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;employeeList&quot;,employeeList); modelAndView.setViewName(&quot;employee_list&quot;); return modelAndView;&#125; 删除操作发起请求代码1234567891011121314&lt;tr th:each=&quot;employee : $&#123;employeeList&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;employee.id&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.gender&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;!-- vue方式绑定点击事件 --&gt; &lt;a @click=&quot;deleteEmployee&quot; th:href=&quot;@&#123;/employee/&#125;+$&#123;employee.id&#125;&quot;&gt;delete&lt;/a&gt; &lt;!-- 方式2（带单引号嵌入）：&lt;a th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;delete&lt;/a&gt; --&gt; &lt;a href=&quot;&quot;&gt;update&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; vue实现表单提交引入vue.js资源 SpringMVC静态资源引入过程 编写事件代码 配合SpringMVC的HiddenHttpMethodFilter设置超链接触发提交的隐含请求转换的post请求表单 实际是向后端发起delete请求 1234&lt;!-- 用于超链接触发的form表单提交 --&gt;&lt;form id=&quot;deleteForm&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;&gt;&lt;/form&gt; vue实现超链接触发表单提交请求 为table标签添加id属性：&lt;table id=&quot;dataTable&quot;&gt; 12345678910111213141516&lt;!-- 使用vue.js实现、使用javascript也行 --&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue(&#123; el:&quot;#dataTable&quot;, //设置容器 methods:&#123; deleteEmployee:function (event)&#123; var deleteForm = document.getElementById(&quot;deleteForm&quot;); //将事件的超链接href属性设置到form表单中 deleteForm.action = event.target.href; deleteForm.submit();//通过submit方法提交表单 event.preventDefault();//取消超链接的默认行为 &#125; &#125; &#125;);&lt;/script&gt; 控制方法123456@DeleteMapping(&quot;/employee/&#123;id&#125;&quot;)public String deleteEmployee(@PathVariable(&quot;id&quot;) Integer id)&#123; employeeDao.delete(id); //通过重定向视图回访到员工页面（实际需调用请求加载数据） return &quot;redirect:/employee&quot;;&#125; 保存操作添加页面12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thyemleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;employee_add&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form th:action=&quot;@&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; lastName: &lt;input type=&quot;text&quot; name=&quot;lastName&quot;&gt; &lt;br&gt; email: &lt;input type=&quot;text&quot; name=&quot;email&quot;&gt; &lt;br&gt; gender: &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt;male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&gt;female &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;add&quot;&gt; &lt;br&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 跳转到添加页1&lt;mvc:view-controller path=&quot;/toAdd&quot; view-name=&quot;employee_add&quot;/&gt; 执行保存12345@PostMapping(&quot;/employee&quot;)public String addEmployee(Employee employee)&#123; employeeDao.save(employee); return &quot;redirect:/employee&quot;;&#125; 更新操作更新页面 含一般数据显示，单选按钮选择th:field，此时值为1或true会自定添加checked属性被选中 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thyemleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;employee_update&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form th:action=&quot;@&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:value=&quot;$&#123;employee.id&#125;&quot;&gt; lastName: &lt;input type=&quot;text&quot; name=&quot;lastName&quot; th:value=&quot;$&#123;employee.lastName&#125;&quot;&gt; &lt;br&gt; email: &lt;input type=&quot;text&quot; name=&quot;email&quot; th:value=&quot;$&#123;employee.email&#125;&quot;&gt; &lt;br&gt; gender: &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;female &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;update&quot;&gt; &lt;br&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 跳转到更新页123456@GetMapping(&quot;/employee/&#123;id&#125;&quot;)public String getEmployee(@PathVariable(&quot;id&quot;) Integer id, Model model)&#123; Employee employee = employeeDao.get(id); model.addAttribute(&quot;employee&quot;,employee); return &quot;employee_update.html&quot;;&#125; 执行更新12345@PutMapping(&quot;/employee&quot;)public String updateEmployee(Employee employee)&#123; employeeDao.save(employee); return &quot;redirect:/employee&quot;;&#125; 静态资源访问SpringMVC中引用静态资源需要一些相关设置，如下以引入vue.js静态资源为例说明 检查资源部署 注意启动前检查一下新增的静态资源加载到打包目录下没有 重新启动项目未必能更新，需要重新打包（package）web项目才能更新 重新打包后在web项目生成的字节码文件中则会出现对应的静态资源目录 开启静态资源访问 由于SpringMVC中设置了使用前端控制器处理所有请求和响应 当系统或用户访问静态资源时、即默认发起了GET请求。 此时前端控制器会率先接管，尝试去所有控制器中匹配这个请求的URL，试图寻找对应的控制方法 当然，对于用户来说静态资源不会设有控制方法，自然SpringMVC就报错，表示找不到对应映射方法 此时需要在SpringMVC配置文件中开启静态资源访问，如下标签所示 12&lt;!-- 开放对静态资源的访问 --&gt;&lt;mvc:default-servlet-handler/&gt; 开启静态资源访问工作原理： 所有请求还是被前端控制器率先受理 当前端控制器匹配不到控制方法的请求链接（如静态资源），则不报错，且交付个DefaultServlet处理（DefaultServlet是Servlet-API中处理静态资源的Servlet） HttpMessageConverter简介 HttpMessageConverter，报文信息转换器，将请求报文转换为Java数据/对象，或将Java数据/对象转换为响应报文 HttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，ResponseEntity @RequestBody @RequestBody可以获取请求体，需要在控制器方法设置一个形参接收 12345@RequestMapping(&quot;/testRequestBody&quot;)public String testRequestBody(@RequestBody String requestBody)&#123; System.out.println(requestBody); return &quot;success&quot;;&#125; 测试前端 12345&lt;form th:action=&quot;@&#123;/testRequestBody&#125;&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 输出结果：requestBody 1username&#x3D;admin&amp;password&#x3D;123456 RequestEntity RequestEntity是请求报文封装的一种类型，直接在控制器方法的形参中设置即可 请求报文会赋值给该形参，可通过getHeaders()获取请求头信息，通过getBody()获取请求体信息 123456@RequestMapping(&quot;/testRequestEntity&quot;)public String testRequestEntity(RequestEntity&lt;String&gt; requestEntity)&#123; System.out.println(requestEntity.getHeaders()); System.out.println(requestEntity.getBody()); return &quot;success&quot;;&#125; 测试前端 12345&lt;form th:action=&quot;@&#123;/testRequestBody&#125;&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 输出结果：requestHeader 1[host:&quot;localhost:8080&quot;, connection:&quot;keep-alive&quot;, content-length:&quot;27&quot;, cache-control:&quot;max-age&#x3D;0&quot;, sec-ch-ua:&quot;&quot; Not A;Brand&quot;;v&#x3D;&quot;99&quot;, &quot;Chromium&quot;;v&#x3D;&quot;90&quot;, &quot;Google Chrome&quot;;v&#x3D;&quot;90&quot;&quot;, sec-ch-ua-mobile:&quot;?0&quot;, upgrade-insecure-requests:&quot;1&quot;, origin:&quot;http:&#x2F;&#x2F;localhost:8080&quot;, user-agent:&quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;90.0.4430.93 Safari&#x2F;537.36&quot;] 输出结果：requestBody 1requestBody:username&#x3D;admin&amp;password&#x3D;123 @ResponseBody原生方式 使用Servlet-API的response获取输出流，使用print()或writer()列方法输出数据 不响应页面或请求，需控制方法设置为无返回值方法，或返回null 1234@RequestMapping(&quot;/testResponse&quot;)public void testResponse(HttpServletResponse response) throws IOException&#123; response.getWriter().print(&quot;hello,response&quot;);&#125; 注解方式 @ResponseBody用于标识一个控制方法 使控制方法的返回值以字符串的方式作为响应报文响应到浏览器。（常用与字符串数据接口编写-json） 12345@RequestMapping(&quot;/testResponseBody&quot;)@ResponseBodypublic String testResponseBody()&#123; return &quot;success&quot;;&#125; 输出结果：浏览器空白页面显示success字样 处理JSON数据小结引入jackson依赖 引入json第三方库jackson 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt;&lt;/dependency&gt; 开启MVC注解驱动 在SpringMVC的核心配置文件中开启mvc的注解驱动 1&lt;mvc:annotation-driven /&gt; 此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串 返回JSON数据 在处理器方法上使用@ResponseBody注解进行标识 将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串 12345@RequestMapping(&quot;/testResponseUser&quot;)@ResponseBodypublic User testResponseUser()&#123; return new User(1001,&quot;admin&quot;,&quot;123456&quot;,23,&quot;男&quot;);&#125; 输出结果： 1&#123;&quot;id&quot;:1001,&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;,&quot;age&quot;:23,&quot;sex&quot;:&quot;男&quot;&#125; @RestController 由于随着基于Spring家族的JavaWeb开发不断发展，json数据交互已经成为主流 其中@ResponseBody注解被大量使用，为了减少编码冗余，推出了一个派生注解（复合注解） @RestController是一个派生注解，等价于将该类添加@Controller注解和其中的每个控制方法添加了@ResponseBody注解 ResponseEntity ResponseEntity类可封装一个完整的HTTP响应报文。包含响应体、响应头、响应状态码 将ResponseEntity作为控制器方法的返回值类型，此时即为浏览器的响应报文。 即提供了一个自定义响应报文的操作（常用于文件下载、将响应体设置为字节） 文件上传和下载 使用ResponseEntity实现下载文件的功能（了解） 文件下载前端页面1&lt;a th:href=&quot;@&#123;/testDown&#125;&quot;&gt;下载1.jpg&lt;/a&gt;&lt;br&gt; 控制器方法123456789101112131415161718192021222324@RequestMapping(&quot;/testDown&quot;)public ResponseEntity&lt;byte[]&gt; testResponseEntity(HttpSession session) throws IOException &#123; //获取ServletContext对象 ServletContext servletContext = session.getServletContext(); //获取服务器中文件的真实路径 String realPath = servletContext.getRealPath(&quot;/static/img/1.jpg&quot;); //创建输入流 InputStream is = new FileInputStream(realPath); //创建字节数组（available()方法是获取输入流is所代表的文件的所有字节，即文件大小） byte[] bytes = new byte[is.available()]; //一次读完，将流读到字节数组中（配合上一句代码，使用最简单的编码方式，让底层自动完成分段传输） is.read(bytes); //创建HttpHeaders对象设置响应头信息 MultiValueMap&lt;String, String&gt; headers = new HttpHeaders(); //设置要下载方式以及下载文件的名字（attachment以附件的方式下载、下载文件的默认名） headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename=1.jpg&quot;); //设置响应状态码（OK == 200） HttpStatus statusCode = HttpStatus.OK; //创建ResponseEntity对象分别是：[响应体]、[响应体]、[响应状态码] ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;&gt;(bytes, headers, statusCode); //关闭输入流 is.close(); return responseEntity;&#125; 文件上传上传页面 文件上传要求form表单的请求方式必须为post，并且添加属性enctype=&quot;multipart/form-data&quot; 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;测试文件上传和下载&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=&quot;@&#123;/testUp&#125;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 头像：&lt;input type=&quot;file&quot; name=&quot;photo&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 引入数据解析库123456&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 控制器方法 原生Servlet-API中，获取上传文件的数据是req.getInputStream(); 在SpringMVC中将上传的文件封装到MultipartFile对象中，此对象封装了上传文件数据及其一般操作 注意，SpringMVC中MultipartFile是当作请求参数名值对的，即该形参名需对应type=file的name属性 1234567891011121314151617181920212223@RequestMapping(&quot;/testUp&quot;)public String testUp(MultipartFile photo, HttpSession session) throws IOException &#123; //1、获取上传的文件的文件名 String fileName = photo.getOriginalFilename(); //2、在服务器中准备文件上传后存放的位置（解决文件存放路径和文件重名问题） //处理文件重名问题（使用UUID作为唯一随机名） String suffixName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;));//获取文件后缀 fileName = UUID.randomUUID().toString() + suffixName; //获取服务器中photo目录的路径 ServletContext servletContext = session.getServletContext(); String photoPath = servletContext.getRealPath(&quot;photo&quot;); File file = new File(photoPath); if(!file.exists())&#123; file.mkdir(); &#125; String finalPath = photoPath + File.separator + fileName; //3、实现上传功能，直接使用封装好的方法一键上传 photo.transferTo(new File(finalPath));//可传String或File类型 return &quot;success&quot;;&#125; UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和随机数 文件上传解析器 注意，目前上传的文件还不能直接转换成为SpringMVC中的MultipartFile类型 需在SpringMVC配置文件中配置一个文件上传解析器（配置的是MultipartResolver的实现类） 文件上传解析器是提供给SpringMVC所调用的，bean id必须设置成&quot;multipartResolver&quot; SpringMVC获取文件上传解析器只通过byId获取 12&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;&lt;/bean&gt; 拦截器基本概念 SpringMVC提供一种拦截器机制（Interceptor），用于拦截控制器方法的执行 与过滤器不同，拦截器具体工作在控制器方法执行的前后、以及渲染视图后执行 实现拦截器实现HandlerInterceptor接口默认方法说明 preHandle：在控制器方法执行前执行，返回布尔类型决定是否放行（true放行、false拦截） postHandle：在控制器方法执行后执行 afterCompletion：在视图完成渲染后执行 代码示例 实现HandlerInterceptor接口（由于定义都为默认方法，需手动重写，IDEA可通Ctrl+O快捷键） 12345678910111213141516171819202122/** * @author yhd * @create 2021-08-11 10:34 */public class FirstInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;FirstInterceptor——&gt;preHandle&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;FirstInterceptor——&gt;postHandle&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;FirstInterceptor——&gt;afterCompletion&quot;); &#125;&#125; 配置拦截器 在SpringMVC的配置文件中进行配置，一般分为两类配置方式 全拦截配置 在&lt;mvc:interceptors&gt;标签内配置拦截器的&lt;bean&gt;、或引入外部拦截器的bean&lt;ref&gt; 1234&lt;mvc:interceptors&gt; &lt;bean class=&quot;com.company.rest.interceptors.FirstInterceptor&quot;&gt;&lt;/bean&gt; &lt;!-- &lt;ref bean=&quot;firstInterceptor&quot;&gt;&lt;/ref&gt; --&gt;&lt;/mvc:interceptors&gt; 自定义拦截配置12345678910111213&lt;!-- 配置拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 配置拦截规则（ant风格），下述表示拦截上下文及其任意层级任意目录 --&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!-- 配置不拦截规则（ant风格），下述表示根目录（首页）不拦截 --&gt; &lt;mvc:exclude-mapping path=&quot;/&quot;/&gt; &lt;!-- 通过bean或ref配置拦截器实体类 --&gt; &lt;bean class=&quot;com.company.rest.interceptors.FirstInterceptor&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 多拦截器执行执行顺序与拦截器在配置文件的配置顺序有关（类过滤器） 均成功放行：若每个拦截器的preHandle()都返回true preHandle()会按照配置的顺序执行（顺序遍历并记录List集合中的索引，interceptorIndex） postHandle()按配置顺序反序执行（反序List遍历） afterComplation()会按照配置的反序执行（反序interceptorIndex索引遍历） 中途拦截：若某个拦截器的preHandle()返回了false preHandle()返回false和它之前的拦截器的preHandle（并记录放行过的interceptorIndex索引） postHandle()都不执行（interceptorList中出现拦截，即返回false，被return） 返回false之前的拦截器的afterComplation()执行（反序interceptorIndex索引遍历） 源码模仿出函数调用栈的执行逻辑 部分核心源码 12345678910111213141516171819try &#123; //.... //执行所有的preHandle（如果返回false，则直接return，postHandle将得不到执行） if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; //执行控制器方法，返回mv对象(ModulAndView) mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; //执行所有的postHandle applyDefaultViewName(processedRequest, mv); mappedHandler.applyPostHandle(processedRequest, response, mv);&#125; 异常处理器基本概念 异常处理器用于在控制方法执行过程中的检测、抛出、某种异常，以及设置异常跳转到的页面 SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver（默认）和SimpleMappingExceptionResolver SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver（如指定某种异常跳转页面） 主要就是使用自定义异常处理器SimpleMappingExceptionResolver去设置某种异常的跳转页面 配置异常处理器 默认的异常处理器是DefaultHandlerExceptionResolver无需配置，配置的都是自定义异常处理器SimpleMappingExceptionResolver xml方式 配置SimpleMappingExceptionResolver的bean 注入Properties类型的exceptionMappings属性 properties的键key：表示处理器方法执行过程中出现的异常的全类名 properties的value：表示若出现指定异常时，设置跳转页面的视图名称。可以设置forward等前缀，视图生成类型和调用逻辑与控制方法使用一致 （可选）可选择注入exceptionAttribute属性的一个值，该值表示与异常处理页共享的请求域数据的键（名），存储Java异常的全类名。配置后可直接在前端页面上以请求域方式输出其键，则输出当前异常的全类名 12345678910&lt;!-- 自定义异常处理器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;java.lang.ArithmeticException&quot;&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 设置将异常信息共享到请求域中的键 --&gt; &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 注解方式 使用**@ControllerAdvice注解**将当前类标识为异常处理的组件（@Component或@Controller派生注解） 编写异常跳转控制方法，并在此方法上添加**@ExceptionHandler注解**，该注解的value是一个异常Class[]类型，用于写入待匹配的异常 （可选）异常控制方法在控制方法的基础上还提供了一个专有的异常传入形参Exception，获取当前请求处理中出现的异常对象 123456789@ControllerAdvicepublic class ExceptionController &#123; @ExceptionHandler(ArithmeticException.class) public String handleArithmeticException(Exception ex, Model model)&#123; //等价于xml中配置注入exceptionAttribute属性效果 model.addAttribute(&quot;ex&quot;, ex); return &quot;error&quot;; &#125;&#125; 无配置文件开发 无配置文件开发指，拟使用配置类和注解替代web.xml、Spring、SpringMVC的3个配置文件 注意，无配置文件开发，只是配置文件不用创建，其余的任何web结构都不能省 配置文件 类或注解开发 spring.xml 创建配置类、使用@Configuration注解 springMVC.xml 创建配置类、使用@Configuration注解 web.xml 继承AbstractAnnotationConfigDispatcherServletInitializer Spring配置类 创建一个类，并添加@Configuration注解作为Spring的配置类 1234@Configurationpublic class SpringConfig &#123; //ssm整合之后，spring的配置信息写在此类中&#125; 由于当前开发环境未进行ssm整合，因此Spring配置文件没有配置其他内容，如开启组件扫描等等… 当进行Spring整合后，这些功能应有Spring配置类完成 SpringMVC配置类 创建一个类，并添加@Configuration注解作为SpringMVC的配置类 SpringMVC常见配置内容：扫描组件、视图解析器(Thymeleaf)、视图控制器(view-controller)、mvc注解驱动、文件上传解析器、拦截器… xml中bean相关配置：直接在配置类中配置bean的方式实现 xml中其他标签配置（非bean）：对于这种非bean配置一般需实现WebMvcConfigurer接口，选择配置对应的方法重写 基本结构123456@Configuration //标识为配置类@ComponentScan(&quot;com.company.mvc&quot;) //开启注解扫描@EnableWebMvc //开启MVC注解驱动public class WebConfig &#123; &#125; 当前没有整合SSM框架，只使用SpringMVC，像扫描组件这些配置应再Spring中统一配置 配置Thymeleaf 类似这种在配置文件中属于bean的配置，直接在如同Spring配置类中配置对应的bean即可 12345678910111213141516171819202122232425262728293031323334353637@Configuration //标识为配置类@ComponentScan(&quot;com.company.mvc&quot;) //开启注解扫描@EnableWebMvc //开启MVC注解驱动public class WebConfig &#123; //配置视图解析器（Thymeleaf），以xml从里到外配置（当前代码是复制的） //配置生成模板解析器（@Bean，Spring的注解，返回类型作为IoC中的bean） @Bean public ITemplateResolver templateResolver() &#123; WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext(); // ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得 ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver( webApplicationContext.getServletContext()); templateResolver.setPrefix(&quot;/WEB-INF/templates/&quot;); templateResolver.setSuffix(&quot;.html&quot;); templateResolver.setCharacterEncoding(&quot;UTF-8&quot;); templateResolver.setTemplateMode(TemplateMode.HTML); return templateResolver; &#125; //生成模板引擎并为模板引擎注入模板解析器 @Bean public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) &#123; SpringTemplateEngine templateEngine = new SpringTemplateEngine(); templateEngine.setTemplateResolver(templateResolver); return templateEngine; &#125; //生成视图解析器并未解析器注入模板引擎 @Bean public ViewResolver viewResolver(SpringTemplateEngine templateEngine) &#123; ThymeleafViewResolver viewResolver = new ThymeleafViewResolver(); viewResolver.setCharacterEncoding(&quot;UTF-8&quot;); viewResolver.setTemplateEngine(templateEngine); return viewResolver; &#125;&#125; 配置文件上传解析器12345//配置文件上传解析器@Beanpublic MultipartResolver multipartResolver()&#123; return new CommonsMultipartResolver();&#125; 开启静态资源访问 即实现&lt;mvc:default-servlet-handler/&gt;配置 其中开启静态资源访问需重写接口的configureDefaultServletHandling()方法 12345678910@Configuration@ComponentScan(&quot;com.company.mvc&quot;)@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125;&#125; 配置拦截器 其中配置拦截器需重写WebMvcConfigurer接口的addInterceptors()方法 1234567891011121314@Configuration@ComponentScan(&quot;com.company.mvc&quot;)@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123; //配置拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //实例化拦截器 FirstInterceptor firstInterceptor = new FirstInterceptor(); //配置拦截规则，可配置一个或多个，对应重载方法（或配置不拦截规则） registry.addInterceptor(firstInterceptor).addPathPatterns(&quot;/**&quot;); &#125;&#125; 配置视图控制器 其中配置视图控制器需重写WebMvcConfigurer接口的addInterceptors()方法 12345678910@Configuration@ComponentScan(&quot;com.company.mvc&quot;)@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; //分别设置【映射路径】、与【视图名称】 registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); &#125;&#125; 配置异常解析器 配置异常解析器除了配置bean的方式实现，还可以通过重写WebMvcConfigurer接口方法实现 1234567891011121314151617181920@Configuration@ComponentScan(&quot;com.company.mvc&quot;)@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123; //配置异常映射 @Override public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123; SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver(); Properties prop = new Properties(); //设置异常映射 prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;); exceptionResolver.setExceptionMappings(prop); //设置共享异常信息的键 exceptionResolver.setExceptionAttribute(&quot;ex&quot;); resolvers.add(exceptionResolver); &#125;&#125; Servlet初始化类Servlet初始化类用于最后整合并加载Spring、SpringMVC配置类，以及替代web.xml配置文件。 基本概念 在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。 Spring提供了这个接口的实现，名为SpringServletContainerInitializer。Spring再利用这个类又会查找实现WebApplicationInitializer接口的类并将配置的任务交给它们（Spring）来完成。 最后Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类继承AbstractAnnotationConfigDispatcherServletInitializer并将其部署到**Servlet3.0容器**的时候，容器会自动发现它，并用它来配置Servlet上下文。 即在Servlet原生环境下：提供javax.servlet.ServletContainerInitializer接口实现类 Spring环境下：提供WebApplicationInitializer接口实现类（官方提供了基础实现类，用户继承后使用） 配置初始化类 整合Spring、SpringMVC配置文件以及设置DispatcherServlet的匹配规则 调用父类提供的各种方法对应设置web.xml可设置的内容（如、过滤器、监听器、初始化参数等..），创建、设置并返回对应配置的对象即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.company.rest.config;import org.springframework.web.filter.CharacterEncodingFilter;import org.springframework.web.filter.HiddenHttpMethodFilter;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;import javax.servlet.Filter;/** * @author yhd * @create 2021-08-11 16:46 */public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer &#123; //1、整合Spring、SpringMVC配置文件以及设置DispatcherServlet的匹配规则 //指定根配置类（Spring配置类），可配置多个 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[]&#123;SpringConfig.class&#125;; &#125; //指定SpringMVC的配置类，可配置多个 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[]&#123;WebConfig.class&#125;; &#125; //指定DispatcherServlet的匹配规则，即xml中的url-pattern，可配置多个 @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125; //2、通过父类提供的方法配置相当web.xml的内容，需配置什么就调用对应方法，返回配置内容对象即可 //配置过滤器：返回需要配置的过滤器对象，返回数组类型，可配置多个 @Override protected Filter[] getServletFilters() &#123; //配置编码过滤器 CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter(); characterEncodingFilter.setEncoding(&quot;UTF-8&quot;); characterEncodingFilter.setForceResponseEncoding(true); //设置隐藏HTTP请求方式过滤器 HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter(); return new Filter[]&#123;characterEncodingFilter,hiddenHttpMethodFilter&#125;; &#125; //...&#125; SpringMVC执行过程常用组件 DispatcherServlet：前端控制器，不需要工程师开发，由框架提供 作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求 HandlerMapping：处理器映射器，不需要工程师开发，由框架提供 作用：根据请求的url、method等信息查找Handler，即控制器方法 Handler（Controller）：处理器，需要工程师开发 作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理 HandlerAdapter：处理器适配器，不需要工程师开发，由框架提供 作用：通过HandlerAdapter对调用处理器（控制器方法）进行执行 ViewResolver：视图解析器，不需要工程师开发，由框架提供 作用：进行视图解析，得到相应的视图，如：ThymeleafView、InternalResourceView、RedirectView View：视图 作用：将模型数据通过页面展示给用户 DispatcherServlet初始化过程本章节只观察DispatcherServlet的初始化过程，仅包含init调用的相关部分 DispatcherServlet 本质上是一个 Servlet，因此严格遵循 Servlet 的生命周期 整个初始化过程宏观上是 Servlet 生命周期来进行调度 init调度过程 从Servlet-API的init()方法开始，最终调用到initWebApplicationContext()方法 initWebApplicationContext方法解析 该方法主要用于创建WebApplicationContext对象（即Spring在Web环境的IoC对象） 所在类：org.springframework.web.servlet.FrameworkServlet 1234567891011121314151617181920212223242526272829303132333435363738394041424344protected WebApplicationContext initWebApplicationContext() &#123; WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; //首次执行为null，不执行 if (this.webApplicationContext != null) &#123; // A context instance was injected at construction time -&gt; use it wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) &#123; ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) &#123; if (cwac.getParent() == null) &#123; cwac.setParent(rootContext); &#125; configureAndRefreshWebApplicationContext(cwac); &#125; &#125; &#125; if (wac == null) &#123; //一开始也找不到，也不执行 wac = findWebApplicationContext(); &#125; if (wac == null) &#123; // 创建WebApplicationContext（下述介绍） wac = createWebApplicationContext(rootContext); &#125; if (!this.refreshEventReceived) &#123; synchronized (this.onRefreshMonitor) &#123; // 刷新WebApplicationContext（调用了子类DispatcherServlet的初始化策略） onRefresh(wac); &#125; &#125; if (this.publishContext) &#123; String attrName = getServletContextAttributeName(); // 将IOC容器（WebApplicationContext）对象在应用域共享 getServletContext().setAttribute(attrName, wac); &#125; return wac;&#125; createWebApplicationContext()方法解析 createWebApplicationContext()方法是真正实现创建WebApplicationContext对象的方法 所在类：org.springframework.web.servlet.FrameworkServlet 1234567891011121314151617181920212223protected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) &#123; Class&lt;?&gt; contextClass = getContextClass(); if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123; throw new ApplicationContextException( &quot;Fatal initialization error in servlet with name &#x27;&quot; + getServletName() + &quot;&#x27;: custom WebApplicationContext class [&quot; + contextClass.getName() + &quot;] is not of type ConfigurableWebApplicationContext&quot;); &#125; // 通过反射创建 IOC 容器对象 ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass); wac.setEnvironment(getEnvironment()); // 设置父容器（若SSM中SS需分开整合，则需两个IoC容器，Spring的IoC作为父容器） wac.setParent(parent); String configLocation = getContextConfigLocation(); if (configLocation != null) &#123; wac.setConfigLocation(configLocation); &#125; configureAndRefreshWebApplicationContext(wac); return wac;&#125; DispatcherServlet初始化策略 FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac) 此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法 该方法表示调用初始化策略，即初始化DispatcherServlet的各个组件 所在类：org.springframework.web.servlet.DispatcherServlet 1234567891011protected void initStrategies(ApplicationContext context) &#123; initMultipartResolver(context);//上传文件解析器 initLocaleResolver(context); initThemeResolver(context); initHandlerMappings(context);//处理器映射器（匹配控制器方法） initHandlerAdapters(context);//初始化处理器适配器（调用被匹配的控制器方法） initHandlerExceptionResolvers(context);//初始异常处理器 initRequestToViewNameTranslator(context); initViewResolvers(context);//初始化视图解析器 initFlashMapManager(context);&#125; DispatcherServlet调用组件处理请求service() 同理init 方法，DispatcherServlet处理请求也应从Servlet-API的service方法看起 FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法最终都调用了processRequest(request, response) 所在类：org.springframework.web.servlet.FrameworkServlet 123456789101112131415@Overrideprotected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpMethod httpMethod = HttpMethod.resolve(request.getMethod()); if (httpMethod == HttpMethod.PATCH || httpMethod == null) &#123; processRequest(request, response); &#125; else &#123; //当调用父类的service方法，再调用对应的doXxx方法时， //这些doXxxx方法又被FrameworkServlet重写且调用 //processRequest(request, response)方法 super.service(request, response); &#125;&#125; processRequest() 所在类：org.springframework.web.servlet.FrameworkServlet 123456789101112131415161718192021222324252627282930313233343536373839protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; long startTime = System.currentTimeMillis(); Throwable failureCause = null; LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext(); LocaleContext localeContext = buildLocaleContext(request); RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor()); initContextHolders(request, localeContext, requestAttributes); try &#123; // 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写 doService(request, response); &#125; catch (ServletException | IOException ex) &#123; failureCause = ex; throw ex; &#125; catch (Throwable ex) &#123; failureCause = ex; throw new NestedServletException(&quot;Request processing failed&quot;, ex); &#125; finally &#123; resetContextHolders(request, previousLocaleContext, previousAttributes); if (requestAttributes != null) &#123; requestAttributes.requestCompleted(); &#125; logResult(request, response, failureCause, asyncManager); publishRequestHandledEvent(request, response, startTime, failureCause); &#125;&#125; doService() 所在类：org.springframework.web.servlet.DispatcherServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Overrideprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; logRequest(request); // Keep a snapshot of the request attributes in case of an include, // to be able to restore the original attributes after the include. Map&lt;String, Object&gt; attributesSnapshot = null; if (WebUtils.isIncludeRequest(request)) &#123; attributesSnapshot = new HashMap&lt;&gt;(); Enumeration&lt;?&gt; attrNames = request.getAttributeNames(); while (attrNames.hasMoreElements()) &#123; String attrName = (String) attrNames.nextElement(); if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123; attributesSnapshot.put(attrName, request.getAttribute(attrName)); &#125; &#125; &#125; // Make framework objects available to handlers and view objects. request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext()); request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver); request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver); request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource()); if (this.flashMapManager != null) &#123; FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response); if (inputFlashMap != null) &#123; request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap)); &#125; request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap()); request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager); &#125; RequestPath requestPath = null; if (this.parseRequestPath &amp;&amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) &#123; requestPath = ServletRequestPathUtils.parseAndCache(request); &#125; try &#123; // 调用处理请求和响应最终方法 doDispatch(request, response); &#125; finally &#123; if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Restore the original attribute snapshot, in case of an include. if (attributesSnapshot != null) &#123; restoreAttributesAfterInclude(request, attributesSnapshot); &#125; &#125; if (requestPath != null) &#123; ServletRequestPathUtils.clearParsedRequestPath(request); &#125; &#125;&#125; doDispatch() 真正调用控制方法，处理请求得出响应的主要函数，包含拦截器工作 所在类：org.springframework.web.servlet.DispatcherServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. /* mappedHandler：调用链，由三部分组成（封装被执行的控制方法和拦截器） - handler：浏览器发送的请求所匹配的控制器方法 - interceptorList：处理控制器方法的所有拦截器集合 - interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行 */ mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. // 通过控制器方法创建相应的处理器适配器，用于调用所对应的控制器方法 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = &quot;GET&quot;.equals(method); if (isGet || &quot;HEAD&quot;.equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; // 调用拦截器的preHandle() if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. // 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象 // 这个方法完成了编写控制方法的用户所受益的所有SpringMVC自动操作 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); // 调用拦截器的postHandle() mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we&#x27;re processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err); &#125; // 后续处理：处理模型数据和渲染视图 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(&quot;Handler processing failed&quot;, err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125;&#125; processDispatchResult() 后续处理：处理模型数据和渲染视图 所在类：org.springframework.web.servlet.DispatcherServlet 12345678910111213141516171819202122232425262728293031323334353637383940414243private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123; boolean errorView = false; //存在异常才执行 if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123; logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception); mv = ((ModelAndViewDefiningException) exception).getModelAndView(); &#125; else &#123; Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); &#125; &#125; // Did the handler return a view to render? if (mv != null &amp;&amp; !mv.wasCleared()) &#123; // 处理模型数据和渲染视图方法 render(mv, request, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125; else &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;No view rendering, null ModelAndView returned.&quot;); &#125; &#125; if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Concurrent handling started during a forward return; &#125; if (mappedHandler != null) &#123; // Exception (if any) is already handled.. // 调用拦截器的afterCompletion() mappedHandler.triggerAfterCompletion(request, response, null); &#125;&#125; 完整执行流程 用户向服务器发送请求，请求被SpringMVC前端控制器 DispatcherServlet捕获。 DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），尝试匹配请求URI对应的映射 不存在 再判断是否配置了mvc:default-servlet-handler（访问静态资源） 如果没配置，则控制台报映射查找不到，客户端展示404错误 如果有配置，则访问目标资源（一般为静态资源），找不到客户端也会展示404错误 存在 根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象，即HandlerExecutionChain执行链对象的形式返回。（包括Handler对象以及Handler对象对应的拦截器） DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter 由于HandlerAdapter也有各种类型，如处理请求的RequestHandlerAdapter 如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】 提取Request中的模型数据，填充Handler入参（形参），开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作： HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中 Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。 此时将开始执行拦截器的postHandle(…)方法【逆向】。 根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析（三种类型视图），根据Model和View，来渲染视图。 渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。 将渲染结果返回给客户端。","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"Spring5基础","slug":"Spring5基础","date":"2021-08-04T07:24:22.000Z","updated":"2021-08-25T15:27:11.864Z","comments":true,"path":"2021/08/04/Spring5基础/","link":"","permalink":"http://yoursite.com/2021/08/04/Spring5%E5%9F%BA%E7%A1%80/","excerpt":"","text":"引言：本文主要介绍Spring框架，包括Spring的相关概述、IoC原理、功能、实现。解释了依赖注入DI，讲解基于注解和XML实现Bean的创建。介绍了基于注解和xml的自动装配，以及Sring中通过Java配置类替代xml。讲解AOP的原理及其实现、介绍了JdbcTemplate。最后补充了Spring5的核心新特性等 Spring概述基础介绍 Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。 Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。 目的：解决企业应用开发的复杂性 功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能 范围：任何Java应用 Spring是一个轻量级控制反转(Ioc)和面向切面(AOP)的容器框架 本人并且认为，Spring控制反转的思想，是任何面向对象程序设计都会采用的优秀的设计思想 历史发展 Spring前身是由2002年，首次推出Spring框架的雏形，interface21框架 Spring框架是以interface21框架为基础,经过重新设计,并不断丰富其内涵,于2004年3月24日,发布了1.0正式版本 Rod Johnson ，Spring Framework创始人，著名作者。很难想象Rod johnson的学历，竟是一名悉尼大学的博士，然而他的专业不是计算机，而是音乐学。 Spring本身是一个“大杂烩”即除了IoC和AOP核心外，有自己的JDBC，MVC，DAO，cache…。基本整合了现有的技术框架！ 优缺点优势 Spring是一个开源免费的框架 , 容器 Spring是一个轻量级的框架 , 非侵入式， 非入侵式：即引入Spring对原有项目不会带来任何影响 轻量级：依赖jar包体积小数量少，而且只依赖自身jar包 控制反转 IoC , 面向切面 AOP 对事务的支持 , 对框架的支持 …… Spring是一个开源免费的轻量级的控制反转（IOC）和面向切面编程的框架！ 劣势 由于Spring随着不断发展，已经是一个大杂烩了，因此有非常多的配置，十分繁琐，人称“配置地狱” Spring的7大模块 Spring的7大模块图示（除开测试模块） Spring Core（核心容器）：核心容器提供 Spring 框架的基本功能。核心容器的主要组件BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 Spring Context（上下文）：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。 Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 扩展Spring体系 现代化的Java开发 Spring Boot Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务; 即通过约定 &gt; 配置；来减少配置的操作 Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架； Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。 SpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习SpringBoot。 而学习Spring Boot 的前提需完全掌握Spring和SpringMVC Spring Cloud Spring Cloud是基于Spring Boot实现的 IoC理论场景分析调用流程逐层调用，层次之间的实现类属于组合/依赖的关系 前端User请求 UserServlet，业务Servlet UserService，业务接口 UserServiceImpl，业务实现类 UserDao，持久层接口 UserDaoImpl，持久层是实现类 代码示例模拟DAO层 UserDao接口 123public interface UserDao &#123; User getUser(int id);&#125; UserDao实现类 12345678public class UserDaoImp implements UserDao &#123; @Override public User getUser(int id) &#123; System.out.println(&quot;UserDaoImp的方法实现&quot;); return null; &#125;&#125; 模拟业务层 UserService接口 123public interface UserService &#123; void getUser(int id);&#125; UserService实现类 123456789public class UserServiceImpl implements UserService &#123; //依赖关系 private UserDao userDao = new UserDaoImp(); @Override public void getUser(int id) &#123; userDao.getUser(id); &#125;&#125; 模拟Servlet层 UserServlet 123456789101112131415public class UserServlet &#123; //main函数调用接口对应的方法模拟web容器调用 public static void main(String[] args) &#123; new UserServlet().login(); &#125; //依赖关系 private UserService userService = new UserServiceImpl(); public void login()&#123; int id = 0; userService.getUser(id); &#125;&#125; 输出结果 1UserDaoImp的方法实现 问题分析描述 若此时用户提出需求，要在某一层中增加一个其他方式的实现类代码，如增加UserDaoOracleImpl实现类 此时需要进入到Service层的源代码中，将UserDao的实现类手动修改为UserDaoOracleImpl 在实际开发中，如果采用这种方式，则可能存在需要修改成千上万的代码，代价是非常昂贵的 代码示例 增加的UserDaoOracleImpl实现类 12345678public class UserDaoOracleImpl implements UserDao&#123; @Override public User getUser(int id) &#123; System.out.println(&quot;UserDaoOracleImpl的方法实现&quot;); return null; &#125;&#125; 修改部分，进入Service代码修改 123456789public class UserServiceImpl implements UserService &#123; private UserDao userDao = new UserDaoOracleImpl();//new UserDaoImp(); @Override public void getUser(int id) &#123; userDao.getUser(id); &#125;&#125; 输出效果 1UserDaoOracleImpl的方法实现 依赖注入设计思想 对依赖的对象通过接收该接口实现类的方式设置一个setter方法 在调用依赖对象方法前，先将依赖的对象的实现类传入后再调用 其实这个过程就是“依赖注入”（Dependency Injection,DI），即依赖关系的是实现类对象通过外部注入。从而表现出的现象做“控制反转”（Inversion of control） 代码示例 为存在依赖关系的Service层添加一个实现类注入的setter方法 在service接口中声明setter方法 1234public interface UserService &#123; void getUser(int id); void setUserDao(UserDao dao);&#125; 实现类实现 123456789101112131415public class UserServiceImpl implements UserService &#123; private UserDao userDao; //依赖注入 @Override public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void getUser(int id) &#123; userDao.getUser(id); &#125;&#125; 调用测试 12345678910111213141516171819202122232425public class UserServlet &#123; //main函数调用接口对应的方法模拟web容器调用 public static void main(String[] args) &#123; new UserServlet().login(); &#125; private UserService userService; public void login()&#123; //根据用户的需求变更实现类 String need = &quot;oracle&quot;; if(&quot;oracle&quot;.equals(need))&#123; userService = new UserServiceImpl(); userService.setUserDao(new UserDaoOracleImpl()); &#125;else &#123; userService = new UserServiceImpl(); userService.setUserDao(new UserDaoImpl()); &#125; int id = 0; userService.getUser(id); &#125;&#125; 问题分析 此时程序的控制权不再是程序员，而变成了用户 程序此时可以通过用户的需要注入对应的实现类，从而在尽量不改变原有代码的情况下变更代码 即变成了由用户的需求动态地选择了程序的实现体 小结 首先，程序开发中，不是所有类之间的关系都是继承关系(接口可以都定义)；继承关系本身是低耦合 即依赖/组合这 种类和对象的关系是必定存在的。而依赖组合本身就必定是高耦合的 当用户需求变更时，会直接影响到组合依赖关系的代码，此时需要根据用户的需求改写源代码，如果程序代码量十分大，修改成本将是巨昂的。 即其中的关系为：用户变更，促使程序变更，促使程序员手动修改源代码 难道就没有什么方法，在这种必然存在的依赖组合关系中减低程序的耦合度？ 有，就是基于依赖注入，从而实现的控制反转（Ioc），此时代码是根据用户的需求改变程序代码，而不是根据用户的需求，程序员去修改代码。 最后配合工厂模式，可以使注入的过程本身更加低耦合，增强其动态性 依赖注入实现的控制反转就是针对降低依赖/组合这种对象关系耦合度的设计思想 通过把具有依赖关系的类，创建其接口，通过外部注入接口实现类的方式让用户去管理是实现类对象 以后就不用程序员管理对象创建了，系统的耦合性大大减低，使其更专注于业务的实现 个人认为，DI就是Ioc，无论是注解方式还是配置方式、这些都是“依赖注入”的表现 IoC容器为什么有IoC容器? 所谓IOC容器就是指下述注释中的代码部分，即根据用户的需求(String need)变量去统一生产并注入其依赖关系的实现类对象。 这部分代码是进行IoC控制操作的代码，由于这部分代码的功能逻辑是具有统一性，即可考虑封装成一个通用的结构进行通用的操作。 而将这部分代码封装成一个统一的结构就是IoC的容器结构。 12345678910111213141516171819202122232425public class UserServlet &#123; //main函数调用接口对应的方法模拟web容器调用 public static void main(String[] args) &#123; new UserServlet().login(); &#125; private UserService userService; public void login()&#123; //根据用户的需求变更实现类 //IOC容器开始部分------------ String need = &quot;oracle&quot;; if(&quot;oracle&quot;.equals(need))&#123; userService = new UserServiceImpl(); userService.setUserDao(new UserDaoOracleImpl()); &#125;else &#123; userService = new UserServiceImpl(); userService.setUserDao(new UserDaoImpl()); &#125; //IOC容器结束部分-------------- int id = 0; userService.getUser(id); &#125;&#125; IoC容器结构 实际开发中并非这种简单的分支结构实现，为了更低的耦合度，基于工厂模式于反射实现。等价关系如下 具体操作 代码示例结构 实际IoC容器结构 对象创建 当前need信息同时包含表示创建的对象类型 配置信息中id和class部分(xml，注解) 依赖注入 need + 分支语句 + new操作 配置信息中property + 工厂模式 + 反射操作 IoC容器功能 IoC容器不仅相当于一个非常大的工厂。 IoC容器区别纯粹的工厂模式是IoC容器生产对象后还会通过配置信息(xml/注解)实现对存在依赖关系的属性进行依赖注入，使其依赖关系的实现类被统一管理，提高代码复用性，减低耦合度。 即我们通过IOC容器(工厂)去统一管理这些依赖关系，并在配置信息中统一去进行依赖的注入 此时程序员的身份相当于用户的身份，用户的需求变更，等价于程序员只需要修改配置文件中的注入内容 小结： IoC容器 == 工厂 + 依赖注入操作 IoC容器同时包含了对象创建和，依赖注入(关键)的两个操作，并非大一的工厂 IoC容器使对象由Spring进行对象的创建、**管理、装配**工作 Spring IoC改写 将上述案例改写成Spring实际使用方式 设置配置文件123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.company.dao.UserDaoImpl&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;userDaoOracleImpl&quot; class=&quot;com.company.dao.UserDaoOracleImpl&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.company.service.UserServiceImpl&quot;&gt; &lt;!-- ref：通过引用Srping容器中创建的对象(id)，而value是具体的值 --&gt; &lt;!-- 依赖注入操作 --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDaoOracleImpl&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 从容器中获取对象12345678910111213141516171819public class UserServlet &#123; //main函数调用接口对应的方法模拟web容器调用 public static void main(String[] args) &#123; new UserServlet().login(); &#125; private UserService userService; public void login()&#123; //用户的需求变更，变更在配置文件中，对象统一从IoC容器中获取并进行依赖注入操作 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); userService = (UserService) context.getBean(&quot;userServiceImpl&quot;); int id = 0; userService.getUser(id); &#125;&#125; 输出结果 1UserDaoOracleImpl的方法实 若想更改依赖关系对象的实现，只需在配置文件这一个位置修改配置信息即全部改动，极大降低了依赖关系的耦合度。 1234&lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.company.service.UserServiceImpl&quot;&gt; &lt;!-- 依赖注入操作 --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDaoImpl&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 输出结果2 1UserDaoImp的方法实现 HelloWorld原始方式官网介绍 官网地址：https://spring.io Spring框架版本页所在处 GA：General Availability，正式发布的版本，官方推荐使用此版本。在国外都是用GA来说明release(发行版)版本的。 SNAPSHOT：Snapshot，快照版，可以稳定使用，且仍在继续改进版本。 PRE：Preview，预览版，内部测试版，主要是给开发人员和测试人员测试和找BUG用的，不建议使用 资源下载地址 官方下载地址：https://repo.spring.io/ui/native/libs-release-local/org/springframework/spring 地址寻找步骤 进入仓库页面 找到本地发行版本仓库 选择想下载的版本 主要下载，spring-5.3.9-dist.zip 创建Java项目 略 导入IoC基础包Jar包结构每种类型的jar包均含3个，代码jar包，稳定jar包，源代码jar包 spring-aop-5.3.9 spring-aop-5.3.9.jar spring-aop-5.3.9-javadoc.jar spring-aop-5.3.9-sources.jar spring-aspects-5.3.9 spring-aspects-5.3.9.jar spring-aspects-5.3.9-javadoc.jar spring-aspects-5.3.9-sources.jar spring-beans-5.3.9 spring-beans-5.3.9.jar …… …. 导入Core Container导入Spring Core Container的核心Jar包即可，包含4个 Beans：spring-beans-5.3.9.jar Core：spring-core-5.3.9.jar Context：spring-context-5.3.9.jar Expression：spring-expression-5.3.9.jar 外部依赖的日志包：commons-logging-1.1.1.jar 准备Bean结构 无属性JavaBean 12345678910111213141516public class User &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void hello()&#123; System.out.println(&quot;I am &quot; + name); &#125;&#125; 配置Bean信息 可通过注解或者XML配置方式，暂且采用XML配置方式 创建XML文件 在src目录下创建xml文件，文件名可自定义 查询Spring的XML结构 进入官方的core文档介绍 找到xml定义 Spring的xml的命名空间。也可以通过IDEA——new——XML configuration File——Spring Config创建 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 配置Bean信息 配置User类Bean信息 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- id相当于创建的唯一变量名，calss为全类名 --&gt; &lt;bean id=&quot;user&quot; class=&quot;com.company.spring.User&quot;&gt; &lt;!-- 属性注入 --&gt; &lt;property name=&quot;name&quot; value=&quot;admin&quot;&gt;&lt;/property&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt;&lt;/beans&gt; 加载配置文件及获取对象123456789101112public class SpringTest &#123; public static void main(String[] args) &#123; //1、获取Spring的上下对象，加载配置文件，即IoC容器 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); //2、从容器中获取对象实例，调用getBean()，输入配置文件中的id User user = context.getBean(&quot;user&quot;,User.class); user.hello();//I am admin &#125;&#125; Maven方式 Spring maven依赖查询地址：https://mvnrepository.com/tags/spring 可以按需选择导入相关的包 也可以选择导入一个覆盖范围大些的 spring webmvc的maven依赖，此时maven会讲依赖的包自动导入 123456&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt;&lt;/dependency&gt; 导入Maven依赖后操作如同上述”原始方式”进行HelloWorld案例实现 IoC容器实例化IoC容器接口Spring 提供 IOC 容器实现两种方式：（两个接口） BeanFactory： IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用 懒加载，加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象 ApplicationContext：（更常用与Web开发） BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人员进行使用 加载配置文件时候就会把在配置文件对象进行创建 单从普通程序运行角度来说，BeanFactroy更占优势，懒加载模式更节省资源 从Web开发这角度来说，ApplicationContext更占优势，一般将耗时耗费内存的加载过程放到服务器启动时操作 Spring常用与Web开发，因此更推荐ApplicationContext接口 主要实现类 ClassPathXmlApplicationContext：相当于类路径xml配置文件上下文加载 FileSystemXmlApplicationContext：文件系统绝对路径xml配置文件上下文加载 IoC对象创建方式 注：设置属性值，即依赖注入。必须提供该属性的setter方法 对象实例化时机并非getBean()时机，而是xml文件被加载时，所有配置的所有bean都被一同创建了 空参构造器方式 通过调用无参构造器实例化对象，也是默认的一种方式 1&lt;bean id=&quot;user&quot; class=&quot;com.company.bean.User&quot;&gt;&lt;/bean&gt; 有参构造器方式 常用程度：参数名值对匹配 &gt; 参数位置匹配 &gt; 参数类型匹配 名值对匹配 构造器示例 12345public User(String username, String password, Date time) &#123; this.username = username; this.password = password; this.time = time;&#125; xml配置 基本数据类型：name - value 引用数据类型：ref，通过id引用容器中的其他bean对象 1234567&lt;bean id=&quot;user&quot; class=&quot;com.company.bean.User&quot;&gt; &lt;constructor-arg name=&quot;username&quot; value=&quot;admin&quot;/&gt; &lt;constructor-arg name=&quot;password&quot; value=&quot;password&quot;/&gt; &lt;!-- 引用数据类型适用ref，可通过id引用容器中的其他bean对象 --&gt; &lt;constructor-arg ref=&quot;data&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;data&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt; 位置匹配 构造器示例 1234public User(String username, String password) &#123; this.username = username; this.password = password;&#125; xml配置 1234&lt;bean id=&quot;user&quot; class=&quot;com.company.bean.User&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;admin&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;password&quot;/&gt;&lt;/bean&gt; 类型匹配 只适用于参数列表中各参数类型不同的情况 1234&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt; &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;42&quot;/&gt;&lt;/bean&gt; xml配置基础bean 用于配置一个bean的信息 id：bean的唯一标识符，相当于变量名 class：实例化对象的全类名 name：bean的别名，可以取多个，每个别名用逗号、空格、分号隔开 …… 123&lt;bean id=&quot;user&quot; class=&quot;com.company.bean.User&quot; name=&quot;user1,user2;user3&quot;&gt;&lt;/bean&gt; alias alias标签可以为某个bean配置独立设置别名 在配置文件中，或者IoC容器获取中都可以适用别名进行获取 1&lt;alias name=&quot;user&quot; alias=&quot;userAlias&quot;/&gt; import 将其他xml配置文件导入合并到当前文件，一般用于团队开发 虽然new ClassPathXmlApplicationContext();可同时传入多个配置文件 但一般团队开发都是各自创建各自xml文件，最后都导入到一个配置文件，加载时只加载一个 1&lt;import resource=&quot;bean.xml&quot;/&gt; 依赖注入 “依赖注入”（Dependency Injection,DI），即将属于依赖关系的是对象实例通过外部注入 Spring 支持具有命名空间的可扩展配置格式 依赖注入 通过命名空间设置可以使Spring支持一些额外的格式化配置方式 官方提示：命名空间不如标准 XML 格式灵活。例如，声明属性引用的格式与以 结尾的属性冲突Ref，而标准 XML 格式则不然。我们建议您谨慎选择您的方法并将其传达给您的团队成员，以避免同时使用所有三种方法生成 XML 文档。 有参构造器注入&lt;constructor-arg&gt;方式 即IoC对象创建时，构建有参构造器的方式 c命名空间方式 从概念上与p命名空间类似 c命名空间是对应 constructor，即刻构造器注入的一种方式 导入c命名空间约束 1xmlns:c=&quot;http://www.springframework.org/schema/c&quot; c命名空间的使用实例，其他配置具体对应详情看官方文档 123456789101112131415161718&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 传统标签方式 --&gt; &lt;bean name=&quot;user1&quot; class=&quot;com.company.bean.User&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;Tom&quot;/&gt; &lt;/bean&gt; &lt;!-- c命名空间方式 --&gt; &lt;bean name=&quot;user2&quot; class=&quot;com.company.bean.User&quot; c:name=&quot;Deny&quot; /&gt;&lt;/beans&gt; set注入测试准备 强调涵盖各种结构，不一定使标准规范的面向对象设计 Sutdent.java12345678910111213public class Student &#123; private String name; private Address address; private String[] books; private List&lt;String&gt; hobbies; private Map&lt;String,String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info; //只有一个空参构造器，忽略getter和setter以及toString方法...&#125; Address.java1234public class Address &#123; private String address; //只有一个空参构造器，忽略getter和setter以及toString方法...&#125; &lt;property&gt;方式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;address&quot; class=&quot;com.company.bean.Address&quot;&gt; &lt;property name=&quot;address&quot; value=&quot;中国&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;student&quot; class=&quot;com.company.bean.Student&quot;&gt; &lt;!-- 普通数据类型注入 --&gt; &lt;property name=&quot;name&quot; value=&quot;Tom&quot;/&gt; &lt;!-- Bean数据类型注入 --&gt; &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt; &lt;!-- 数组类型注入 --&gt; &lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;Spring实战&lt;/value&gt; &lt;value&gt;Spring源码揭秘&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!-- List类型注入 --&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;list&gt; &lt;value&gt;听歌&lt;/value&gt; &lt;value&gt;学习&lt;/value&gt; &lt;!-- 注入bean使用ref标签 --&gt; &lt;!-- &lt;ref bean=&quot;beanId&quot;&gt;&lt;/ref&gt; --&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- Set类型注入 --&gt; &lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;COD&lt;/value&gt; &lt;value&gt;DMC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- Map类型注入 --&gt; &lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;身份证&quot; value=&quot;123123123&quot;/&gt; &lt;entry key=&quot;银行卡&quot; value=&quot;23241231241&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- null值显示注入 --&gt; &lt;property name=&quot;wife&quot;&gt; &lt;null/&gt; &lt;/property&gt; &lt;!-- 空串注入 --&gt; &lt;!-- &lt;property name=&quot;wife&quot; value=&quot;&quot;/&gt; --&gt; &lt;!-- Properties类型注入 --&gt; &lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driver&quot;&gt;232323&lt;/prop&gt; &lt;prop key=&quot;sex&quot;&gt;男&lt;/prop&gt; &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;password&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 其他注入写法特殊属性值注入1234567&lt;!--属性值包含特殊符号 方法1：把&lt;&gt;进行转义 &amp;lt; &amp;gt; 方法2：把带特殊符号内容写到 CDATA--&gt;&lt;property name=&quot;address&quot;&gt; &lt;value&gt;&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;&lt;/value&gt;&lt;/property&gt; 内部bean注入 少用，更多使使用常规的配置到外部 12345678910111213&lt;!--内部 bean--&gt;&lt;bean id=&quot;emp&quot; class=&quot;com.company.spring5.bean.Emp&quot;&gt; &lt;!--设置两个普通属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;lucy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!--内部bean注入写法、设置对象类型属性--&gt; &lt;property name=&quot;dept&quot;&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.company.spring5.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;安保部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; get方法获取123456789&lt;!--级联赋值--&gt;&lt;bean id=&quot;emp&quot; class=&quot;com.company.spring5.bean.Emp&quot;&gt; &lt;!--设置两个普通属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;lucy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!-- 直接将注入的外部bean的属性赋值，需要该属性有getter方法 --&gt; &lt;property name=&quot;dept.dname&quot; value=&quot;技术部&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 提取集合类型注入 在 spring 配置文件中引入名称空间 util 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt; &lt;/beans&gt; 把集合注入的配置内容通过util标签独立出来 12345678910111213&lt;!-- 独立出list 集合类型属性注入--&gt;&lt;util:list id=&quot;bookList&quot;&gt; &lt;value&gt;易筋经&lt;/value&gt; &lt;value&gt;九阴真经&lt;/value&gt; &lt;value&gt;九阳神功&lt;/value&gt; &lt;!-- 注入bean使用ref标签 --&gt; &lt;!-- &lt;ref bean=&quot;beanId&quot;&gt;&lt;/ref&gt; --&gt;&lt;/util:list&gt;&lt;!-- 通过引入方式注入集合 --&gt;&lt;bean id=&quot;book&quot; class=&quot;com.company.spring5.collectiontype.Book&quot;&gt; &lt;property name=&quot;list&quot; ref=&quot;bookList&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 引入外部properties注入 准备好数据库连接池依赖，并创建数据库连接池配置文件 prop.driverClass可以直接写driverClass，只是一般这些名字会存在冲突，因此增加prop.前缀来区分 1234prop.driverClass=com.mysql.jdbc.Driverprop.url=jdbc:mysql://localhost:3306/userDbprop.userName=rootprop.password=root 引入命名空间context，并引入外部文件的路径 123456789101112131415161718192021&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--引入外部属性文件--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--配置连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;prop.driverClass&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;prop.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;prop.userName&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;prop.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; p命名空间方式 p即对应property标签。导入p命名空间可以使用一些专属的类property配置属性 导入p命名空间约束 1xmlns:p=&quot;http://www.springframework.org/schema/p&quot; p命名空间的使用实例，其他配置具体对应详情看官方文档 1234567891011121314151617181920212223&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 传统标签方式 --&gt; &lt;bean name=&quot;student1&quot; class=&quot;com.company.bean.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Tom&quot;/&gt; &lt;/bean&gt; &lt;!-- p命名空间方式 --&gt; &lt;bean name=&quot;student2&quot; class=&quot;com.company.bean.Student&quot; p:name=&quot;Tom&quot; p:address-ref=&quot;addr&quot; /&gt; &lt;bean name=&quot;addr&quot; class=&quot;com.company.bean.Address&quot;/&gt;&lt;/beans&gt; Bean作用域 在配置bean时，还可以配置bean的作用域 官方提供设置的作用域分为两大类型：普通JavaBean(单例、)，JavaWeb中作用域 singleton 单例模式（默认作用域），接无论从容器取相同id的bean多少次都是同一个对象 prototype 原型模式，每次从容器中获取bean都是一个新的实例 request JavaWeb中请求域 session JavaWeb中会话域 application javaWeb中应用域 websocket Scope Description 单例模式 单例模式（默认作用域），接无论从容器取相同id的bean多少次都是同一个对象 1&lt;bean name=&quot;user&quot; class=&quot;com.company.bean.User&quot; scope=&quot;singleton&quot;/&gt; 原型模式 原型模式，每次从容器中获取bean都是一个新的实例 1&lt;bean name=&quot;user&quot; class=&quot;com.company.bean.User&quot; scope=&quot;prototype&quot;/&gt; JavaWeb作用域 其余的request、session、application、对应JavaWeb中作用域，只能在web开发中使用 Bean自动装配 注意，一旦使用了自动装配，则必须要能匹配到装配成功，否则会报错 默认是不允许注入null值的，注入null值需另外设置，否则也会报错 何为自动装配？自动装配 “自动装配”中装配的东西就是依赖注入的东西 在上述依赖注入中，都是手动指明注入的数值或引用，而自动装配是通过软件扫描的方式实现注入内容适配工作 即Spring会在应用上下文中为某个bean寻找其依赖的bean 三种装配机制Spring中bean有三种装配机制，分别是： 在xml中显式配置； 在java中显式配置； 隐式的bean发现机制和自动装配。 自动装配原理Spring的自动装配需要从两个角度来实现，或者说是两个操作： 组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean； 自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI； 组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。 推荐不使用自动装配xml配置 , 而使用注解 . 自动装配方式 使用自动装配为bean标签的autowire属性赋值，值可取以下四种 Mode Explanation no 不适用自动装配，默认方式 byName 通过待注入bean对象的setter方法属性名匹配Srping上下文中的bean id byType 通过待注入bean对象的对象类型匹配Srping上下文中的bean 类型使用前提是上下文中不能存在重复相同类型的bean，否则编译时期报错 constructor byName 通过待注入bean对象的setter方法属性名匹配Srping上下文中的bean id 1234567891011121314&lt;!-- 待注入bean --&gt;&lt;bean id=&quot;mouth&quot; class=&quot;com.company.bean.Mouth&quot;/&gt;&lt;bean id=&quot;eye&quot; class=&quot;com.company.bean.Eye&quot;/&gt;&lt;!-- 手动装配 --&gt;&lt;bean id=&quot;person1&quot; class=&quot;com.company.bean.Person&quot;&gt; &lt;property name=&quot;eye&quot; ref=&quot;eye&quot;/&gt; &lt;property name=&quot;mouth&quot; ref=&quot;mouth&quot;/&gt;&lt;/bean&gt;&lt;!-- 自动装配之byName方式 --&gt;&lt;!-- setEye()的eye匹配id=eye 与 setMouth的mouth匹配id=mouth --&gt;&lt;bean id=&quot;person2&quot; class=&quot;com.company.bean.Person&quot; autowire=&quot;byName&quot;/&gt; byType 通过待注入bean对象的对象类型匹配Srping上下文中的bean 类型 使用前提是上下文中不能存在重复相同类型的bean，否则编译时期报错 1234567&lt;!-- 待注入bean,id都不需要写 --&gt;&lt;bean class=&quot;com.company.bean.Mouth&quot;/&gt;&lt;bean class=&quot;com.company.bean.Eye&quot;/&gt;&lt;!-- 自动装配之byName方式 --&gt;&lt;!-- 通过匹配待注入bean对象的setter属性类型进行自动装配 --&gt;&lt;bean id=&quot;person&quot; class=&quot;com.company.bean.Person&quot; autowire=&quot;byType&quot;/&gt; constructor小结 byName模式：需保证所有bean的id唯一，且bean需要和自动注入的属性的set方法的属性名值一致！ byType模式：需保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致！ 注解自动装配 jdk1.5、Spring2.5开始支持注解 从Spring4规定，使用注解的自动装配也要导入AOP的jar包 最常用为@Autowired注解 准备工作 导入context命名空间 xmlns:context属性 1xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation 12xsi:schemaLocation=&quot;http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot; 导入配置注解的支持 1&lt;context:annotation-config/&gt; 完整注解约束支持xml配置，如下 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; @Autowired基本使用 将需要依赖注入且采用自动装配的属性上添加**@Autowired**注解实现自动装配 使用@Autowired注解后不需要setter方法 @Autowired是按类型自动装配（byType）实现，不支持id匹配 某些IDE，如IDEA可以在编译时期检测到被声明@Autowired注解的属性是否能被自动匹配到 xml配置 12345&lt;!-- 待注入bean --&gt;&lt;bean class=&quot;com.company.bean.Mouth&quot;/&gt;&lt;bean class=&quot;com.company.bean.Eye&quot;/&gt;&lt;bean id=&quot;person&quot; class=&quot;com.company.bean.Person&quot;/&gt; 待注入类设置 12345678public class Person &#123; @Autowired private Eye eye; @Autowired private Mouth mouth;&#125; required属性 @Autowired注解含required属性，默认为true，设置为false时表示可以允许null值注入 123//如果允许对象为null，设置required = false,默认为true@Autowired(required = false)private Eye eye; @Qualifier 若配置环境比较复杂，可以在@Autowired基础上追加@Qualifier注解 @Qualifier[ˈkwɒlɪfaɪə(r)]，表“限定”，显式指定属性value为注入的bean的id xml配置 12345678&lt;!-- 注入的bean --&gt;&lt;bean id=&quot;mouth1&quot; class=&quot;com.company.bean.Mouth&quot;/&gt;&lt;bean id=&quot;mouth2&quot; class=&quot;com.company.bean.Mouth&quot;/&gt;&lt;bean class=&quot;com.company.bean.Eye&quot;/&gt;&lt;!-- 待注入bean --&gt;&lt;bean id=&quot;person&quot; class=&quot;com.company.bean.Person&quot;/&gt; 待注入类配置 123456789public class Person &#123; @Autowired private Eye eye; @Autowired @Qualifier(value=&quot;mouth2&quot;) private Mouth mouth;&#125; @Resource 先进行byName查找匹配（需配合name属性使用），在进行byType查找匹配 当@Resource都不能唯一匹配到bean时，可以通过name属性显式指定bean id xml配置 12345678&lt;!-- 注入的bean --&gt;&lt;bean id=&quot;mouth1&quot; class=&quot;com.company.bean.Mouth&quot;/&gt;&lt;bean id=&quot;mouth2&quot; class=&quot;com.company.bean.Mouth&quot;/&gt;&lt;bean class=&quot;com.company.bean.Eye&quot;/&gt;&lt;!-- 待注入bean --&gt;&lt;bean id=&quot;person&quot; class=&quot;com.company.bean.Person&quot;/&gt; 待注入类配置 12345678public class Person &#123; @Resource private Eye eye; @Resource(name = &quot;mouth1&quot;) private Mouth mouth;&#125; @Nullable 可以显式修饰到属性中，表示注入时可允许为null值，效果等价于@Autowired(required = false) 123456789101112public class Person&#123; private String name; @Autowired @Nullable private Eye eye; public Person(@Nullable String name)&#123; this.name = name; &#125;&#125; IoC注解开发 如今实际开发中更多是完全使用注解方式来进行依赖注入。配置文件只用于配置核心系统参数 从Spring4规定，使用注解的自动装配也要导入AOP的jar包 指定组件扫描 不设置组件扫描，默认是扫描所有的java源文件是否含Spring注解 通过context:component-scan可以指定扫描Spring注解的包的范围 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 指定扫描Spring组件(注解)的包的范围，此时Spring不再全局扫描 --&gt; &lt;!-- 如果扫描多个包，多个包使用逗号隔开 --&gt; &lt;context:component-scan base-package=&quot;com.company.pojo&quot;/&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; 指定组件类型扫描 context:include-filter 1234567891011&lt;!--示例 1 &quot;use-default-filters=&quot;false&quot; 表示现在不使用默认 filter，自己配置 filter context:include-filter ，设置扫描哪些内容，其中type=&quot;annotation&quot;表示对注解进行过滤 expression表达式定义扫描的注解类Controller，只扫描表示@Controller的注解--&gt;&lt;!-- 总的效果：只扫描com.company包下所有@Controller注解的bean --&gt;&lt;context:component-scan base-package=&quot;com.company&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; 指定组件类型不扫描 context:exclude-filter 12345678&lt;!--示例 2 context:exclude-filter： 设置哪些内容不进行扫描 总的效果：不扫描com.company包下所有@Controller注解的bean--&gt;&lt;context:component-scan base-package=&quot;com.company&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; 注：使用指定组件类型不扫描(&lt;context:exclude-filter)时，无需use-default-filters=&quot;false设置 Bean的创建 通过@Component注解的方式实现Bean的创建，被该注解标识的Bean又称为组件 默认方式 将JavaBean添加@Component注解设置为Spring组件 此时默认创建一个以类名的首字母小写的bean对象，即bean id = “user“ 123456789//等价于xml配置中的 &lt;bean id=&quot;user&quot; class=&quot;com.company.pojo.User&quot;/&gt; @Componentpublic class User &#123; private String name; public String getName() &#123; return name; &#125;&#125; 从容器中取出Bean实例 123456@Testpublic void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); User user = context.getBean(&quot;user&quot;, User.class); System.out.println(user);//com.company.pojo.User@60611244&#125; 指定Bean Id方式 通过指明组件注解的value属性自定义bean id，@Component(value = &quot;BeanId&quot;) 12345678@Component(value = &quot;userDef&quot;)public class User &#123; private String name; public String getName() &#123; return name; &#125;&#125; 从容器中取出Bean实例 123456@Testpublic void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); User user = context.getBean(&quot;userDef&quot;, User.class); System.out.println(user);&#125; 衍生注解 与@Component注解一样，下述3个注解都是声明为Spring组件，只是名字不一样，便于识别分层 MVC 等价@Component注解 dao @Repository service @Service controller @Controller 依赖注入 在需要注入的属性或setter方法上使用@Value注解 复杂的注入@Value注解不能胜任时需使用xml注解 1234567891011@Component(value = &quot;userDef&quot;)public class User &#123; //等价于 &lt;property name=&quot;name&quot; value=&quot;Tom&quot;/&gt; @Value(&quot;Tom&quot;) private String name; public String getName() &#123; return name; &#125;&#125; 自动装配详情请看讲解Bean自动装配中含注解使用自动装配 @Autowired @Resource @Nullable 作用域 使用@Scope注解配置Bean的作用域 singleton 单例模式（默认作用域），接无论从容器取相同id的bean多少次都是同一个对象 prototype 原型模式，每次从容器中获取bean都是一个新的实例 request JavaWeb中请求域 session JavaWeb中会话域 application javaWeb中应用域 websocket Scope Description 示例代码 1234567891011@Component(value = &quot;userDef&quot;)@Scope(&quot;singleton&quot;) //单例模式public class User &#123; @Value(&quot;Tom&quot;) private String name; public String getName() &#123; return name; &#125;&#125; IoC全Java类配置 JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息 在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 Java替代XML 通过@Configuration注解修饰一个Java类，使其称为Spring配置类，等价于applicationContext.xml 123456789@Configuration //等价整个xml文件public class MyConfig &#123; @Bean //等价xml文件中的&lt;bean&gt;标签配置，方法名为bean id public User getUser()&#123; return new User(); &#125;&#125; 从注解配置AnnotationConfigApplicationContext中取出Spring上下文对象 Class类形参：直接传入配置文件的Class对象 String包类名：可以传入包名，如”com.company.config” 1234567@Testpublic void test()&#123; ApplicationContext context = new AnnotationConfigApplicationContext(&quot;com.company.config&quot;); User user = context.getBean(&quot;getUser&quot;, User.class); System.out.println(user);&#125; @Configuration 被@Configuration修饰的类成为了一个applicationContent.xml文件，类名等价与文件名 @Configuration注解的本质也是@ComponentSpring组件 XML中等价的其他注解 XML文件中ComponentScan属性也有等价的@ComponentScan注解使用 Impot标签也有等价的@Import注解，以此类推…. @Bean 等价与xml文件中的bean标签 方法名等价于bean标签的id属性 方法返回值类型等价于bean标签的class属性 方法返回值等价于需要注入的对象 Bean的生命周期常规生命周期生命周期 通过构造器创建 bean 实例（无参数构造） 为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） 调用 bean 的初始化的方法（需要进行配置初始化的方法，initMethod） bean的使用（对象获取到了） 当容器关闭时（调用context.close()），调用bean的销毁的方法（需配置销毁方法destroy-method） 演示代码 生命周期测试代码 12345678910111213141516171819public class Orders &#123; //无参数构造 public Orders() &#123; System.out.println(&quot;第一步 执行无参数构造创建 bean 实例&quot;); &#125; private String oname; public void setOname(String oname) &#123; this.oname = oname; System.out.println(&quot;第二步 调用 set 方法设置属性值&quot;); &#125; //创建执行的初始化的方法，需xml配置 public void initMethod() &#123; System.out.println(&quot;第三步 执行初始化的方法&quot;); &#125; //创建执行的销毁的方法，需xml配置且调用close方法 public void destroyMethod() &#123; System.out.println(&quot;第五步 执行销毁的方法&quot;); &#125;&#125; 配置bean，并且配置初始化方法init-method和销毁方法destroy-method 123&lt;bean id=&quot;orders&quot; class=&quot;com.company.spring5.bean.Orders&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt; &lt;property name=&quot;oname&quot; value=&quot;手机&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 测试bena 的生命周期，手动关闭IoC容器触发销毁方法的调用 12345678910111213@Testpublic void testBean3() &#123; //close()方法属于实现类定义的方法，不能用ApplicationContext接口接收 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean4.xml&quot;); Orders orders = context.getBean(&quot;orders&quot;, Orders.class); System.out.println(&quot;第四步 获取创建 bean 实例对象&quot;); System.out.println(orders); //手动让 bean 实例销毁 context.close();&#125; 添加后置处理器 在常规的bean什么周期中，还有更完整的生命周期，即添加后置管理器 后置处理器会作用在所有配置的bean的初始化方法的前后 生命周期 通过构造器创建 bean 实例（无参数构造） 为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） 把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization 调用 bean 的初始化的方法（需要进行配置初始化的方法） 把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization bean 可以使用了（对象获取到了） 当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法） 示例代码 创建类，实现接口BeanPostProcessor，创建后置处理器 123456789101112131415public class MyBeanPost implements BeanPostProcessor &#123; //修改了@Nullabledefault修饰 @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;在初始化之前执行的方法&quot;); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;在初始化之后执行的方法&quot;); return bean; &#125;&#125; 只要在IoC容器中创建了后置处理器，就会自动作用在IoC的所有bean中 12&lt;!--配置后置处理器--&gt;&lt;bean id=&quot;myBeanPost&quot; class=&quot;com.company.spring5.bean.MyBeanPost&quot;&gt;&lt;/bean&gt; 重新测试上述常规生命周期测试代码即可看出后置处理器的调用 FactoryBean基本概念Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean） 普通 bean：在配置文件中定义 bean 类型就是返回类型 工厂 bean：就相当于配置了一个工厂类，和工厂模式一致，用工厂创建指定类 示例 创建类工厂类，实现接口**FactoryBean&lt;工厂返回类型&gt;**，及其抽象方法 1234567891011121314151617181920public class MyBean implements FactoryBean&lt;Course&gt; &#123; //返回工厂的生产对象的类型 @Override public Course getObject() throws Exception &#123; Course course = new Course(); course.setCname(&quot;abc&quot;); return course; &#125; //定义对象类型 @Override public Class&lt;?&gt; getObjectType() &#123; return null; &#125; //定义是否单例 @Override public boolean isSingleton() &#123; return false; &#125;&#125; 实例化工厂bean，从工厂中获取指定生成对象 XML 1&lt;bean id=&quot;myBean&quot; class=&quot;com.company.spring5.factorybean.MyBean&quot;/&gt; Java 1234567@Testpublic void test3() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean3.xml&quot;); Course course = context.getBean(&quot;myBean&quot;, Course.class); System.out.println(course);&#125; AOP理论AOP原理 AOP的原理实际上就是动态代理，因此了解AOP的前提是掌握代理模式。 代理模式概述静态代理**(静态)代理的好处:**（尤其注意2、3点，可以说AOP本质就是代理模式的大规模应用） 代理模式真正的好处在于，如果需要在原有的业务上增加一些公共的操作 可以实现不在原有代码上进行修改，而是通过代理角色间接地实现实现代码的增改 其实这就就是AOP原理，在不修改源代码情况下，进行功能添加和增加。 使其原有业务更加纯粹(维护了单一职责原则)，不会因为需要增加一些公共操作而影响到业务的本质内容 公共业务发生扩展时变得更加集中和方便 缺点 : 静态代理由于每个被代理类都配一个代理类 ,代码量翻倍，工作量变大了，开发效率降低 动态代理即有代理的好处，又可以动态生成代理类，解决了代码量翻倍的问题，而且减少代码冗余 动态代理概述 动态代理中，“动态”的关键是指动态创建实现代理接口的代理类（动态创建代理类） 这个过程在JDK层面是无法让用户实现的 因为要创建一个不存在的类 且这个类要去主动实现一个未知的由用户指定的接口（代理接口） 因此这需要更底层的操作才能实现这个功能，因此动态代理的使用是由JDK提供的，而不是用户实现的 实现方式 基于接口实现：jdk提供原生动态代理实现（Proxy、InvocationHandler） 代理类作为实现类去实现代理接口进行功能增加 基于类实现：CGLIB 代理类作为被代理类的子类，在重写方法中调用父类（被代理类）方法基础上进行方法的增强 基于Java字节码实现：Javasist（基于JBoss服务器实现） jdk实现动态代理动态性分析 静态代理存在的代码冗余 冗余1：总要传入被代理类对象去代理实现调用接口同名的所有抽象方法 冗余2：从总的代理类的结构来说，每个代理接口都需要创建所属的代理类，单这些代理类结构都类似 即对应需解决两个问题为 冗余2：如何动态创建代理类，并实现对应的接口？—— 用户无法实现，由jdk底层提供实现 Proxy 冗余1：如何让动态创建的代理类在调用代理接口方法时候自动调用同名方法 —— Proxy + InvocationHandler 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.compeny.dynamic_proxy.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * 代理类统一动态生成工厂 * @author yhd * @create 2021-07-30 22:34 */public class ProxyFactory &#123; /** * 返回被代理对象的代理类对象 * - 从静态代理可知，代理类需已知两大因素，代理接口和代理类对象（用于代理方法的实现） * - 由于通过反射可以从代理类对象中获得代理类实现的代理接口，因此形参至少需要被代理类对象 * @param obj 被代理类对象 * @return */ public static Object getProxyInstance(Object obj)&#123; //我们无法实现，只能通过jdk调用底层实现 /** * 形参： * 1、返回的代理类对象使用的类加载器：一般设为与被代理类对象的加载器一致 * 2、代理接口的Class对象数组：一般通过被代理类对象的反射操作获取其实现的接口Class实例 * 3、InvocationHandler接口实例：有别于1、2两点的硬需求。这是一个额外的回调设计 * 当通过代理类对象调用被代理类的任何方法时，都会调用InvocationHandler接口的 * 抽象方法invoke。并提供三个传入形参 * */ return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(),new MyInvocationHandler(obj)); &#125;&#125;class MyInvocationHandler implements InvocationHandler&#123; //被代理类对象，由于代理类使用反射调用方法时需要传入被调用的对象 private Object obj; public MyInvocationHandler(Object obj)&#123; this.obj = obj; &#125; /** * 代理方法调用的统一回调方法 * 通过InvocationHandler接口的invoke方法进一步缩减了代码，即讲所有被代理方法都统一在一个 * 方法体中，由于代理一般都是代理所有接口方法，因此采取了这种设计，进一步缩减代码量 * @param proxy ：代理类对象 * @param method ：代理类被调用的代理方法 * @param args ： 代理类被调用的代理方法的形参 * @return 被代理类对象调用方法的返回值 * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.print(&quot;日志开始----- : &quot;); //在代理类的环境下通过反射调用被代理类的方法，此时写成直接调用对应的方法。 //也可以让用户通过对Method对象进行判别进行自定义的反射调用 Object result = method.invoke(obj,args); System.out.print(&quot;日志结束----- : &quot;); System.out.println(); return result; &#125;&#125; 测试代码，最终效果是代码中至始至终没有出现过代理类，是动态创建的 12345678910111213//任何一个想被代理的对象都可以通过ProxyFactory获取到自己的代理类，实现代理操作public class DynamicProxyTest &#123; public static void main(String[] args) &#123; ProductDao proxyProductDao = (ProductDao) ProxyFactory.getProxyInstance(new ProductMysqlImpl()); proxyProductDao.get(); proxyProductDao.update(); UserDao proxyUserDao = (UserDao) ProxyFactory.getProxyInstance(new UserDaoOracleImpl()); proxyUserDao.add(); proxyUserDao.update(); proxyUserDao.delete(); &#125;&#125; Spring实现AOPAOP概述基本概念 AOP（Aspect Oriented Programming）意为：面向切面编程 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。 利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AspectJ Spring框架一般基于AspectJ实现AOP操作 AspectJ不是Spring组成部分，是一个独立与Spring的AOP框架 专业术语横切关注点横切关注点（cross-cutting concern）： 跨越应用程序多个模块的方法或功能。 即与业务逻辑无关的，但需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 …. 把这些横切关注点与业务逻辑相分离正是AOP所要解决的问题 切面 切面（Aspect）：横切关注点被模块化为的特殊的类，这些类称为切面。通知和切点共同定义了切面的全部内容——它是什么，在何时何处完成其功能 可以说，横切关注点就是每一个公共业务（日志、安全…）。而切面就是这些公共业务抽取出来(AOP)的模块化的抽象描述。通知和切点就是代码层面对切面的实现 通知 通知/增强（Advice）：切面完成的工作内容及其工作时间。是类中的一个方法。（实际增加的逻辑） 通知类型 描述 Spring 接口 前置通知 在目标方法被调用前执行。常用于权限管理 MethodBeforeAdvice 后置通知 在目标方法完成后执行。常用于关闭流、上传、删除临时文件 MethodAfterAdvice 返回通知 在目标方法完成后执行，且可获得返回值。常用于 AfterReturningAdvice 环绕通知 包裹被目标方法，在目标方法调用前后执行。常用于日志、事务 Around 异常通知 在目标方法抛出指定异常后执行。常用于异常记录日志 AfterThrowing 切点 切点（Pointcut）：通知所执行的位置，即切点定义了所要织入的一个或多个连接点 连接点 连接点（JointPoint）：与切点匹配的执行点，即待增强的原有方法体 织入织入（Weaving）： 把切面应用到目标对象并创建新得代理对象得过程 在目标对象的生命周期力有多个点可以进行织入 编译期：切面在目标类编译时被织入，需要特殊的编译器（AspectJ） 类加载期：切面在目标类加载到JVM时被织入，需特殊的类加载器。它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5的加载时织入（load-time weaving，LTW）就支持这种方式织入 运行期：切面在应用允许的某个时刻被织入，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。 《Spring实战》第四版 引入​ 引入允许我们向现有的类添加新方法或属性。例如，我们可以创建一个Auditable通知类，该类记录了对象最后一次修改时的状态。这很简单，只需一个方法，setLastModified（Date），和一个实例变量来保存这个状态。然后，这个新方法和实例变量就可以被引入到现有的类中，从而可以在无需修改这些现有的类的情况下，让它们具有新的行为和状态。 了解-《Spring实战》第四版 核心小结 横切关注点：跨越应用程序多个模块的公共方法或功能概述，如日志、安全、缓存、事务等 切面：切面是横切关注点的抽象实现，表现为一个类，主要由通知和切点两部分构成 通知：包含了需要用于多个应用对象的横切行为（行为内容于行为时机），表现为实际增强的内容 切点：定义了通知被应用的具体位置（在哪些连接点）、即哪些连接点会得到通知，表现为一些匹配连接点的表达式 连接点：程序执行过程中能够应用通知的所有点，表现为待被增强的内容 切点表达式基本概念 定义切点时，通过切点表达式去匹配一个或多个连接点(方法)进行切入 简而言之，即用与匹配待增强方法的表达式 语法结构语法结构：execution([权限修饰符][返回类型][类全路径].[方法名称]([参数列表])) 权限修饰符：public、protected、default、private 返回类型： 类全路径： 参数列表：用于定位重载方法，若只有一个方法时，可以使用两个点(..)表示任意的参数列表 ‘*’：表示上述4种类型的任意值 ‘ ‘：空格，表示忽略不写 注意表达式之间本身没有空格相隔，若填入空格也算占位，表示忽略不写 案例 举例 1： 问：对 com.company.dao.BookDao 类中的 add方法 进行增强 答：execution(* com.company.dao.BookDao.add(..)) 举例 2： 问：对 com.company.dao.BookDao 类里面的所有的方法进行增强 答：execution(* com.company.dao.BookDao.*(..)) 举例 3： 问：对 com.company.dao 包里面所有类，类里面所有方法进行增强 答：execution(* com.company.dao.*.*(..)) 表达式重用 在使用注解完成AOP操作时，可以通过调用一个空方法实现切点表达式的重用 12345678910//相同切入点抽取@Pointcut(value = &quot;execution(* com.company.spring5.aopanno.User.add(..))&quot;)public void pointDemo() &#123;&#125;//直接调用空方法实现切点表达式的重用@Before(value = &quot;pointDemo()&quot;)public void before() &#123; System.out.println(&quot;before.........&quot;);&#125; 导入织入依赖在Spring中使用AOP时需在Spring核心jar包基础上再导入AOP的织入依赖包 spring aspects spring-aspects-5.3.9.jar aspects其他依赖 com.springsource.net.sf.cglib-2.2.0.jar com.springsource.org.aopalliance-1.0.0 com.springsource.org.aspectj.weaver-1.6.8.RELEASE maven 123456&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt;&lt;/dependency&gt; 接口通知方式 接口方式实现需要被增强类的方法有对应的代理接口 这种方式称不上最好，但由于贴近动态代理，因此先讲解。 XML命名空间 在Spring命令空间基础上添加 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 通用命名空间结构：变动部分[?] 首句添加：xmlns:[?]=&quot;http://www.springframework.org/schema/[?]&quot;，添加在xmlns:xsi下 尾句添加：xsi:schemaLocation=&quot;http://www.springframework.org/schema/[?] https://www.springframework.org/schema/[?]/spring-[?].xsd&quot; 添加aop命名空间XML 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;/beans&gt; 实现切面(通知)假如需要通过AOP添加一个特殊指定的日志功能，执行前打印执行方法，执行后打印返回值 准备代理接口 通过接口实现AOP的方式，必须有对应的代理接口 123456public interface UserDao &#123; void add(); void update(); void query(); void delete();&#125; 编写横切行为 创建前置日志切面，并编写通知（选择切入时机和编写横切行为） 1234567891011121314151617public class AfterLog implements AfterReturningAdvice &#123; /** *通知：在目标执行完成后调用，并且接收执行结果 * @param returnValue 被调用方法的返回值 * @param method * @param args * @param target * @throws Throwable */ @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.print(target.getClass().getName() + &quot; 对象的 &quot; + method.getName() + &quot; 方法被调用，&quot;); System.out.println(&quot;方法返回值为：&quot; + returnValue); &#125;&#125; 创建后置日志 1234567891011121314151617181920/** * 实现切面BeforeLog * @author yhd * @create 2021-07-31 17:32 */public class BeforeLog implements MethodBeforeAdvice &#123; /** * 通知：选择切入时机(在执行目标前执行)，编写横切内容 * @param method 被调用(代理)方法的method封装对象 * @param args 被调用方法形参 * @param target 目标对象/被代理对象 * @throws Throwable */ @Override public void before(Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(target.getClass().getName() + &quot; 对象的 &quot; + method.getName() + &quot; 方法被调用&quot;); &#125;&#125; AOP配置注册相关bean1234&lt;!-- 1、准备相关的bean--&gt;&lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.company.dao.UserDaoImpl&quot;/&gt;&lt;bean id=&quot;afterLog&quot; class=&quot;com.company.log.AfterLog&quot;/&gt;&lt;bean id=&quot;beforeLog&quot; class=&quot;com.company.log.BeforeLog&quot;/&gt; 配置切面 配置切面包括配置切点与通知 1234567891011&lt;!-- 2、配置AOP --&gt;&lt;aop:config&gt; &lt;!-- 配置切点 --&gt; &lt;aop:pointcut id=&quot;afterLogPc&quot; expression=&quot;execution(* com.company.dao.UserDaoImpl.*(..))&quot;/&gt; &lt;aop:pointcut id=&quot;beforeLogPc&quot; expression=&quot;execution(* com.company.dao.UserDaoImpl.*(..))&quot;/&gt; &lt;!-- 配置通知(切面)：横切行为(待增加方法体) + 切点--&gt; &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;afterLogPc&quot;/&gt; &lt;aop:advisor advice-ref=&quot;beforeLog&quot; pointcut-ref=&quot;beforeLogPc&quot;/&gt;&lt;/aop:config&gt; 获取代理对象 注意接口方式实现AOP返回的bean对象为代理对象：class com.sun.proxy.$Proxy3 因此必须以代理接口通过多态的方式接收返回的实例，否则会报BeanNotOfRequiredTypeException异常 123456789101112public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //注意接口方式实现AOP返回的bean对象为代理对象：class com.sun.proxy.$Proxy3 //因此需以代理接口多态的方式接收返回的实例，否则会报BeanNotOfRequiredTypeException异常 Object obj = context.getBean(&quot;userDaoImpl&quot;); //System.out.println(obj.getClass()); //class com.sun.proxy.$Proxy3 UserDao userDaoImpl = context.getBean(&quot;userDaoImpl&quot;,UserDao.class); userDaoImpl.add();&#125; 输出结果 123com.company.dao.UserDaoImpl 对象的 add 方法被调用add方法执行com.company.dao.UserDaoImpl 对象的 add 方法被调用，方法返回值为：null 自定义切面方式配置方式XML命名空间 同接口方式实现AOP的XML命名空间 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;/beans&gt; 定义切面 只编写切面中的通知内容，即横切行为。切入时机和切点均在配置文件中配置 12345678910public class MyLog &#123; public void beforeLog()&#123; System.out.println(&quot;==代码执行前==&quot;); &#125; public void afterLog()&#123; System.out.println(&quot;==代码执行后==&quot;); &#125;&#125; AOP配置注册相关bean123&lt;!-- 1、准备相关的bean--&gt;&lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.company.dao.UserDaoImpl&quot;/&gt;&lt;bean id=&quot;myLog&quot; class=&quot;com.company.log.MyLog&quot;/&gt; 配置切面 配置切面包括配置切点和通知 1234567891011&lt;!-- 2、配置AOP --&gt;&lt;aop:config&gt; &lt;!-- 配置切点 --&gt; &lt;aop:pointcut id=&quot;myLogPc&quot; expression=&quot;execution(* com.company.dao.UserDaoImpl.*(..))&quot;/&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect ref=&quot;myLog&quot;&gt; &lt;!-- 配置通知(时机 + 增强的方法体) 和 引入切点 --&gt; &lt;aop:before method=&quot;beforeLog&quot; pointcut-ref=&quot;myLogPc&quot;/&gt; &lt;aop:after method=&quot;afterLog&quot; pointcut-ref=&quot;myLogPc&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 获取Bean 注意，此时若被增强类有实现对应的接口，则使用的还是接口实现AOP，即刻返回的还是代理类 若想通过子类方式实现AOP，则必须保证被增强类没有对应的接口。而和XML配置方式无关 因此下述是取消了UserDao接口实现后的结果 1234567public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDaoImpl userDaoImpl = context.getBean(&quot;userDaoImpl&quot;,UserDaoImpl.class); userDaoImpl.add();&#125; 输出效果 123&#x3D;&#x3D;代码执行前&#x3D;&#x3D;add方法执行&#x3D;&#x3D;代码执行后&#x3D;&#x3D; 注解方式XML命名空间 添加context和aop命名空间 开启注解支持和注解组件扫描，启用aop自动代理 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 组件扫描 --&gt; &lt;context:component-scan base-package=&quot;com.company&quot;/&gt; &lt;!-- 开启注解支持 --&gt; &lt;context:annotation-config/&gt; &lt;!-- 启用AOP自动代理 (默认)proxy-target-class=&quot;false&quot;--&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; aop:aspectj-autoproxy：说明 通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了 &lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强， 当配为&lt;aop:aspectj-autoproxy poxy-target-class=”true”/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。 注解定义切面 在类上面使用@Aspect注解将其标注为一个切面 在切入的方法上配置通知，使用@Before、@After…注解配置切入时机，方法体编写横切行为逻辑 配置切点，即在切入时机@Before、@After…的注解属性中填入execution表达式 若使用全注解方式，记得使用@Component 标注成Spring组件(Bean) 被增强的方法又要使用@Component 加载成Bean 1234567891011121314151617181920212223242526272829303132333435package com.company.log;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;/** * @author yhd * @create 2021-08-01 11:26 */@Component@Aspectpublic class MyLog &#123; @Before(&quot;execution(* com.company.dao.UserDaoImpl.*(..))&quot;) public void beforeLog()&#123; System.out.println(&quot;==代码执行前==&quot;); &#125; @After(&quot;execution(* com.company.dao.UserDaoImpl.*(..))&quot;) public void afterLog()&#123; System.out.println(&quot;==代码执行后==&quot;); &#125; @Around(&quot;execution(* com.company.dao.UserDaoImpl.*(..))&quot;) //ProceedingJoinPoint是一个可选的传入形参 public void aroundLog(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println(&quot;环绕前&quot;); joinPoint.proceed(); System.out.println(&quot;环绕后&quot;); &#125;&#125; 测试1234567public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDaoImpl userDaoImpl = context.getBean(&quot;userDaoImpl&quot;,UserDaoImpl.class); userDaoImpl.add();&#125; 输出结果 12345环绕前&#x3D;&#x3D;代码执行前&#x3D;&#x3D;add方法执行&#x3D;&#x3D;代码执行后&#x3D;&#x3D;环绕后 环绕通知与其他通知的相对顺序与环绕通知代码与其他通知代码的相对顺序有关 切面优先级设置 在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高 123456@Component@Aspect@Order(1)public class PersonProxy&#123; &#125; 配置类启用AOP 使用@EnableAspectJAutoProxy注解启用AOP注解 123456@Configuration@ComponentScan(basePackages = &#123;&quot;com.company&quot;&#125;)@EnableAspectJAutoProxy(proxyTargetClass = true)public class ConfigAop &#123; &#125; JdbcTemplate基本概念 Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作 依赖jar包 JdbcTemplate依赖（spring的libs中） spring-jdbc-5.3.9.jar spring-tx-5.3.9.jar（事务相关依赖） spring-orm-5.3.9.jar（非必须，orm框架整合依赖） mysql相关依赖 mysql-connector-java-5.1.7-bin.jar 数据库连接池（非必须） druid-1.1.9.jar 配置JdbcTemplate对象 由于JdbcTemplate也支持基于数据库连接池基础上的操作 因此采用IoC的方式创建JdbcTemplate对象时为其对象的dataSource属性注入数据库连接池对象 配置数据库连接池对象 基于Druid数据库连接池的IoC注入配置 1234567&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///user_db&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;&lt;/bean&gt; 配置JdbcTemplate12345&lt;!-- 创建JdbcTemplate对象并通过IoC方式注入 数据库连接池对象--&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!-- 实际是set方法注入 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt; 注入JdbcTemplate 采用自动装配方式 dao层 1234567@Repositorypublic class BookDaoImpl implements BookDao&#123; //自动装配JdbcTemplate对象 @Autowired private JdbcTemplate jdbcTemplate;&#125; service层 123456@Servicepublic class BookService&#123; @Autowired private BookDao bookDaoImpl;&#125; 增删改操作 类似DBUtils的封装操作，修改(增删)都使用update函数 123456@Overridepublic int addBook(Book book) &#123; String sql = &quot;INSERT INTO t_book(t_book.`book_name`,t_book.`price`) VALUES(?,?);&quot;; int update = jdbcTemplate.update(sql, book.getBookName(), book.getPrice()); return update;&#125; 查询操作查询返回某个值queryForObject(String sql,Class&lt;T&gt; requiredType)方法 String sql：sql 语句 Class&lt;T&gt; requiredType：查询结果的数据类型 Class 1234567//查询表记录数@Overridepublic int selectCount() &#123; String sql = &quot;select count(*) from t_book&quot;; Integer count = jdbcTemplate.queryForObject(sql, Integer.class); return count;&#125; 查询返回beanqueryForObjet(String sql,RowMapper&lt;T&gt; rowMapper,Object…args) String sql：sql 语句 RowMapper&lt;T&gt; rowMapper： RowMapper是一个接口，使用这个接口不同的实现类完成不同数据类型的封装 由于当前需要返回bean结构，因此选用其中的BeanPropertyRowMapper实现类 在该实现类的泛型&lt;&gt;中注入返回的Bean类型，并将Bean的Class对象作为构造器实参传入 Object…args：sql语句的传入参数 12345678//查询返回对象@Overridepublic Book findBookInfo(String id) &#123; String sql = &quot;select * from t_book where user_id=?&quot;; //调用方法 Book book = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;Book&gt;(Book.class), id); return book;&#125; 查询返回集合 query(String sql,RowMapper&lt;T&gt; rowMapper,Object…args)， 查询返回集合和查询返回bean调用的方法形参一致 12345678@Overridepublic List&lt;Book&gt; findAllBook() &#123; String sql = &quot;select * from t_book&quot;; //调用方法 List&lt;Book&gt; bookList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;Book&gt;(Book.class)); return bookList;&#125; 批量修改 批量操作指批量的修改操作(增删改)，均使用batchUpdate(String sql，List\\&lt;Object[]&gt; batchArgs)方法 String sql：操作sql语句 List&lt;Object[]&gt; batchArgs：批量修改的数据，每一个Object[]数组表示一条记录的所有字段 返回值：影响行数 批量增加示例12345678910111213141516@Overridepublic void batchAddBook(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;insert into t_book values(?,?,?)&quot;; //批量添加测试 List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;(); Object[] o1 = &#123;&quot;3&quot;,&quot;java&quot;,&quot;a&quot;&#125;; Object[] o2 = &#123;&quot;4&quot;,&quot;c++&quot;,&quot;b&quot;&#125;; Object[] o3 = &#123;&quot;5&quot;,&quot;MySQL&quot;,&quot;c&quot;&#125;; batchArgs.add(o1); batchArgs.add(o2); batchArgs.add(o3); int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints));&#125; 批量修改示例12345678910111213141516@Overridepublic void batchUpdateBook(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;update t_book set username=?,ustatus=? where user_id=?&quot;; //批量修改 List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;(); Object[] o1 = &#123;&quot;java0909&quot;,&quot;a3&quot;,&quot;3&quot;&#125;; Object[] o2 = &#123;&quot;c++1010&quot;,&quot;b4&quot;,&quot;4&quot;&#125;; Object[] o3 = &#123;&quot;MySQL1111&quot;,&quot;c5&quot;,&quot;5&quot;&#125;; batchArgs.add(o1); batchArgs.add(o2); batchArgs.add(o3); int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints));&#125; 批量删除示例1234567891011121314151617//批量删除@Overridepublic void batchDeleteBook(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;delete from t_book where user_id=?&quot;; //批量删除 List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;(); Object[] o1 = &#123;&quot;3&quot;&#125;; Object[] o2 = &#123;&quot;4&quot;&#125;; batchArgs.add(o1); batchArgs.add(o2); //调用方法实现批量删除 bookService.batchDelete(batchArgs); int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints));&#125; Spring事务操作基本概念事务的概念 事务基本概念：事务是数据库操作最基本单元，是逻辑上一组操作，要么都成功，如果有一个失败所有操 作都失败 典型场景：银行转账， lucy 转账 100 元 给 mary ；lucy 少 100，mary 多 100 事务四个特性（ACID） 原子性：不可分割，要么都执行，要么都回滚 一致性：保证数据的状态操作前和操作后保持一致（数据总量不变） 隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰 持久性：一个事务一旦提交，则数据将持久化到本地（即保证完成修改），除非其他事务对其进行修改 Spring事务管理 事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层） 在 Spring 进行事务管理操作有两种方式： 编程式事务管理：即最原始的硬编码方式添加事务相关代码 声明式事务管理（推荐使用）：基于AOP方式添加事务相关操作的代码 事务管理相关API Spring在事务管理上提供了一个接口表示事务管理器 接口针对不同的持久层框架提供不同事务管理器的实现类 编程式事务管理 所谓编程式事务管理，即最原始的事务管理代码添加操作，采用硬编码的方式编写 1234567891011121314151617181920212223242526@Servicepublic class UserService&#123; @Autowired private UserDao userDaoImpl; public void transferAccounts()&#123; double transfer = 100; //编程式事务管理：硬编码方式添加事务管理代码 try&#123; //1、开启事务 //2、执行数据库操作（业务操作） //Lucy ——&gt; Mary userDaoImpl.reduceMoney(transfer,&quot;lucy&quot;); int i = 3 / 0; userDaoImpl.addMoney(transfer,&quot;mary&quot;); //3、提交事务 System.out.println(&quot;Lucy ——&gt; Mary转账 &quot; + transfer + &quot; 成功&quot;); &#125;catch (Exception e)&#123; //4、出现异常，事务回滚 &#125; &#125;&#125; 声明式事务管理创建事务管理器 创建事务管理器 无论哪种方式实现声明式事务，一般配置bean都在xml中配置 JdbcTemplate对应就是DataSourceTransactionManager实现类 注意，DataSourceTransactionManager由org.springframework.jdbc提供，即使用前需导入JdbcTemplate（spring-jdbc）依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt;&lt;/dependency&gt; 添加事务（tx）xml命名空间，开启事务注解（若使用xml配置这不需要） 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 开启组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.company&quot;/&gt; &lt;!-- 创建数据库连接池对象 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///book_db&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;/bean&gt; &lt;!-- 创建JdbcTemplate对象并通过IoC方式注入 数据库连接池对象--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!-- 实际是set方法注入 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 创建事务管理器实现类，JdbcTemplate使用DataSourceTransactionManager实现类。并注入数据库连接池对象 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 开启事务注解，并指明事务管理器实现类对象 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;&lt;/beans&gt; 注解方式@Transactional @Transactional注解：表示事务，可添加到类和方法上。被添加的类或方法会自动植入事务机制，不用用户写try-catch，自动完成事务开启、提交、异常捕获及进行回滚操作 类：则该类的所有的方法都被添加事务 方法：则只为该方法添加事务 在Service层类（或方法）上添加事务注解 12345678910111213141516171819@Service@Transactionalpublic class UserService&#123; @Autowired private UserDao userDaoImpl; public void transferAccounts()&#123; double transfer = 100; //自动实现事务机制 //Lucy ——&gt; Mary userDaoImpl.reduceMoney(transfer,&quot;lucy&quot;); int i = 3 / 0; userDaoImpl.addMoney(transfer,&quot;mary&quot;); System.out.println(&quot;Lucy ——&gt; Mary转账 &quot; + transfer + &quot; 成功&quot;); &#125;&#125; @Transactional注解含有多个属性如下 以下选取常用的几个属性进行讲解 相关属性 含义 propagation 事务传播行为 ioslation 事务隔离级别 timeout 超时时机 readOnly 是否只读 rollbackFor 回滚 noRollbackFor 不回滚 propagation基本概念propagation[ˌprɒpə&#39;ɡeɪʃ(ə)n]，译为“传播”，该属性用于定义事务的传播行为 事务的传播行为：多个事务方法之间进行调用的过程中，Spring对事务进行管理的行为机制 事务方法：对数据库数据进行操作的方法 如上图中，有两个操作数据库的方法（事务方法），并且add方法中调用了update方法 add方法有声明Spring事务，而update方法没有事务 此时若add方法体或update方法体产生异常，Spring将怎么进行事务控制，哪部分回滚或不回滚？ 或者一个没有声明事务的事务方法操作有声明事务的事务方法会发生什么情况，这就是事务的传播行为 Spring中7种事务的传播行为，常用为required、required_new REQUIRED若存在被设置为required的A方法/类（required也是Spring的默认传播机制） 若被一个有事务的B操作调用，则A方法共用(依赖于)B的事务 若被一个无事务的B操作调用，则A方法自身建立一个事务运行 @Transactional(propagation = Propagation.REQUIRES_NEW) required在这里翻译成依赖 REQUIRED_NEW若存在被设置为required_new的A方法（或类） 无论A方法被有事务或没事务的其他方法调用，A方法都将创建自身的事务进行操作 @Transactional(propagation = Propagation.REQUIRED) isolation并发操作带来的数据不一致性事务是并发控制的基本单位，当多个事务并发操作时，若没有正确的并发控制机制，一个事务的执行将会对其他事务进行错误的影响（如丢失修改、不可重复读、度“脏数据”等），因此破坏了事务的“隔离性”特点 不可重复读： 同一个事务中对同一个数据读取两次，却得到不一致的结果。其实在两次读取之间，数据被其他事务修改、删除(幻影)、增加(幻影) 换种方式说，即一个未提交的事务多次读取到另一个已提交且为修改操作的事务后的数据。导致一个事务内每次夺取同一个数据都不一样 虚读/幻读： 一个未提交的事务多次读取到另一个已提交且为添加数据操作的事务后的数据（类似不可重复读） 换句话说一个事务在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行，好像出现幻觉一般 读“脏”数据：（主要避免操作） 一个未提交的事务读取到另一个未提交事务的数据。（如读到了回滚前的数据） 丢失修改： 后一个事务用原有的数据进行修改，从而忽略了比它先执行的事务对数据的修改操作。使其先前事务的修改像“丢失”一样 事务的隔离级别 isolation[ˌaɪsəˈleɪʃn] ，译为“隔离”，该属性是用于设置事务的隔离级别 其实Spring中事务的隔离级别等价于数据库并发控制技术中的封锁技术 隔离级别 封锁协议 脏读 不可重复读 幻读 read uncommitted（读未提交） 无锁 true true true read committed（读已提交） 一级封锁 false true true repeatable read（可重复读） 二级封锁 false false true serializable（串行化） 三级封锁 false false false 设置隔离级别 下述为设置成可重复读隔离级别，也是Spring默认的隔离级别 1@Transactional(isolation &#x3D; Isolation.REPEATABLE_READ) timeout timeout，超时时间。事务提交的超时时间，若超过该时间未提交事务，自动进行回滚 timeout属性值得单位为秒。默认值为 -1，表示无超时设定 @Transactional(timeout = -1) readOnly readOnly是一个布尔类型，设置数据操作是否只读 false：默认值，表示可以增删改查 true：只读，只能进行查询操作 @Transactional(readOnly = false) rollbackFor rollbackFor是一个Class属性，用于设置哪些异常触发事务回滚 @Transactional(rollbackFor = NullPointerException.class) noRollbackFor 反之norollbackFor用于设置哪些异常不触发事务回滚 xml文件方式 首先要创建事务管理，见上述 xml方式配置事务类似接口方式AOP的配置，只是通知本身作为了事务机制 配置通知（事务） 基于AOP配置通知的内容，通知的内容就是需要切入的事务管理的内容 12345678&lt;!-- 1、配置通知（事务） --&gt;&lt;tx:advice id=&quot;myAdvice&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 指定在哪种[规则]的方法上添加事务机制，可取通配符&quot;*&quot;或&quot;add*&quot;（表示add开头的所有方法） --&gt; &lt;!-- 支持@Transactional注解的所有属性设置 --&gt; &lt;tx:method name=&quot;transferAccounts&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 配置切面 配置切面需要配置通知和切入点（通知已在上述中配置了） 1234567&lt;!-- 2、配置切面（切点和通知） --&gt;&lt;aop:config&gt; &lt;!-- 配置切点 --&gt; &lt;aop:pointcut id=&quot;myPt&quot; expression=&quot;execution(* com.company.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!-- 引入通知--&gt; &lt;aop:advisor advice-ref=&quot;myAdvice&quot; pointcut-ref=&quot;myPt&quot;/&gt;&lt;/aop:config&gt; 配置类启用事务思路和注解方式实现Spring事务类似，只是把注解方式中剩余的xml部分写成Java配置类 准备操作：配置类一般的准备操作含：开启组件扫描、注解扫描、开启事务注解 准备bean：对应注解实现Spring事务中的xml部分，将需要创建的bean在配置类中一一创建 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.company.config;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import javax.sql.DataSource;/** * @author yhd * @create 2021-08-03 20:07 */@Configuration //标记为配置类@ComponentScan(basePackages = &quot;com.company&quot;) //开启组件扫描@EnableTransactionManagement //开启事务public class TxConfig &#123; //1、配置bean：返回类型为bean的数据类型，方法名为bean id即变量名 //配置数据库连接池 @Bean public DruidDataSource dataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); //注入的属性需要通过set方法设置进去 dataSource.setUrl(&quot;jdbc:mysql:///book_db&quot;); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); return dataSource; &#125; //配置JdbcTemplate //这些@Bean都会在IoC容器中得到创建。通过设置形参，可以实现@Autowirde根据类型自动注入（形参传入已有实例） @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource)&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125; //创建事务管理器 @Bean public DataSourceTransactionManager transactionManager(DataSource dataSource)&#123; DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; &#125;&#125; 核心新特性基于JDK8实现 Spring5 框架的代码基于 Java8，引用了Java8中增强的语法功能。运行时兼容 JDK9 许多不建议使用的类和方 法在代码库中删除 日志相关 Spring 5.0 框架自带了通用的日志封装 Spring5 已经移除 Log4jConfigListener，官方建议使用 Log4j2 手动整合Log42引入jar包 log4j-api-2.11.2.jar log4j-core-2.11.2.jar log4j-slf4j-impl-2.11.2.jar slf4j-api-1.7.30.jar 创建log4j2配置文件 创建名为log4j2.xml的配置文件，文件名固定 创建后，进行类似如下配置，Spring5将自动启用log4j2的日志功能（执行程序就可以看到） 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--Configuration后面的status用于设置log4j2自身内部的信息输出，可以不设置，当设置成TRACE时，可以看到log4j2内部各种详细输出--&gt;&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;&lt;!-- 假如定义了INFO，则&lt; INFO的所有内容（除OFF和FATAL外的error、warn）都会显示 --&gt;&lt;configuration status=&quot;INFO&quot;&gt; &lt;!--先定义所有的appender--&gt; &lt;appenders&gt; &lt;!--输出日志信息到控制台--&gt; &lt;console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!--控制日志输出的格式--&gt; &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt; &lt;/console&gt; &lt;/appenders&gt; &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt; &lt;!--root：用于指定项目的根日志，如果没有单独指定Logger，则会使用root作为默认的日志输出--&gt; &lt;loggers&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt;&lt;/configuration&gt; 当前xml日志格式配置输出效果 12021-08-03 21:27:42.953 [main] INFO com.alibaba.druid.pool.DruidDataSource - &#123;dataSource-1&#125; inited 自定义日志输出123456789public class UserLog&#123; //设置日志类（就是当前类） private static final Logger log = LoggerFactory.getLogger(UserLog.class); public static void main(String[] args)&#123; log.info(&quot;hello log4j2&quot;); log.warn(&quot;hello log4j2&quot;); &#125;&#125; @Nullable注解@Nullable 注解可以使用在方法上面，属性上面，参数上面 方法上：表示方法返回可以为空，属性值可以 为空，参数值可以为空 注解上：注解用在方法上面，方法返回值可以为空 形参上：注解使用在方法参数里面，方法参数可以为空 注解使用在属性上面，属性值可以为空 支持函数式编程 对于GenericApplicationContext和AnnotationConfigApplicationContext类的操作支持函数式编程 通过GenericApplicationContext将自定义对象注册到IoC容器中让Spring托管操作来演示函数式编程的支持 12345678910111213//函数式风格创建对象，交给 spring 进行管理@Testpublic void testGenericApplicationContext() &#123; //1 创建 GenericApplicationContext 对象 GenericApplicationContext context = new GenericApplicationContext(); //2 调用 context 的方法对象注册 context.refresh(); context.registerBean(&quot;user1&quot;,User.class,() -&gt; new User()); //3 获取在 spring 注册的对象 // User user = (User)context.getBean(&quot;com.company.spring5.test.User&quot;); User user = (User)context.getBean(&quot;user1&quot;); System.out.println(user);&#125; 测试方面的改进 Spring5对于junit5整合测试提供了一些新的注解 使其Spring5中进行测试更方便（如不用手动再创建IoC容器等） 整合junit4 junit4可以直接在spring5中引用，但整合后会有和Spring框架交互更紧密的功能(如新注解) 引入测试依赖 导入junit4相关依赖 导入spring整合测试类的相关依赖（可以使用注解）：spring-test-5.3.9.jar 使用注解完成测试 使用注解可以减少“创建IoC容器对象，从IoC容器中获取测试对象”这两个步骤的代码量 1234567891011121314151617181920212223242526package com.company.test;import com.company.service.UserService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/** * @author yhd * @create 2021-08-04 11:52 */@RunWith(SpringJUnit4ClassRunner.class) //定义单元测试框架@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) //加载配置文件public class JTest4 &#123; //JTest4将会被视为Spring组件，因此可以采用自动装配获取想要测试的bean对象 @Autowired private UserService userService; @Test public void transferAccounts()&#123; userService.transferAccounts(); &#125;&#125; 整合junit5引入测试依赖 导入junit5相关依赖，不用外部引入，直接在IDEA在线添加即可 导入spring整合测试类的相关依赖（可以使用注解）：spring-test-5.3.9.jar 使用注解完成测试 junit5整合后的新注解@ExtendWith和@SpringJUnitConfig等 12345678910111213141516171819202122232425262728package com.company.test;import com.company.service.UserService;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.ExtendWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit.jupiter.SpringExtension;import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;/** * @author yhd * @create 2021-08-04 11:52 *///@ExtendWith(SpringExtension.class) //新注解：定义单元测试框架//@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) //加载配置文件//也可以使用复合注解替代上面两个注解@SpringJUnitConfig(locations = &quot;classpath:applicationContext.xml&quot;)public class JTest5 &#123; @Autowired private UserService userService; @Test public void transferAccounts()&#123; userService.transferAccounts(); &#125;&#125; SpringWebFluxWebFlux概述 WebFlux是 Spring5 添加新的模块，用于 web 开发的，功能和 SpringMVC 类似的 Webflux 使用当前一种比较流行响应式编程出现的框架 前置基础知识：SpringMVC、SpringBoot、Maven、Java8新特性（特别使函数式编程） 响应式编程WebFlux的实现其他增强 还有对SpringMVC的增强 总结Spring核心 Spring作用是降低企业开发的复杂性，减低代码的耦合度 实现降耦的两大利器是IoC和AOP IoC(控制反转)用于减低类之间依赖关系的代码耦合度。实现方式和原理为DI(工厂 + DI) 充分发挥IoC优势的还需要自动装配功能的加持，IoC只是把所有依赖注入外部化成xml配置，但是配置的硬编码内容的数量还是一比一等价于源码编写 自动装配理想情况下只需配置bean注入操作全自动匹配实现 AOP(面向切面编程)用于减低业务之间的耦合度，实现在不修改原有代码的情况下添加功能，最大程度地维护了类的单一职责原则，常用于事务操作。实现方式和原理为动态代理 业务之间：公共的业务 (日志 , 安全等) 和领域业务（真正的需求业务） 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 IoC是减低依赖的耦合度，AOP是减低业务的耦合度。可以说Spring就是降耦利器 SpringBoot全面使用Java配置类方式，是没有一个用于bean的配置文件的 开发经验 xml与注解： xml更加万能，适用于任何场合！维护简单方便 注解不是自己类使用不了，维护相对复杂！ xml与注解最佳实践： xml用来管理bean； 注解只负责完成属性的注入； 在使用的过程中，只需要注意必须让注解生效，就需要开启注解的支持，且能扫描到需要使用注解的包","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"H5 video标签及Java实现视频流播放","slug":"H5 video标签及Java实现视频流播放","date":"2021-07-18T04:49:22.000Z","updated":"2021-08-25T15:27:11.761Z","comments":true,"path":"2021/07/18/H5 video标签及Java实现视频流播放/","link":"","permalink":"http://yoursite.com/2021/07/18/H5%20video%E6%A0%87%E7%AD%BE%E5%8F%8AJava%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E6%B5%81%E6%92%AD%E6%94%BE/","excerpt":"","text":"引言：本文主要介绍了html5中的video标签的使用，支持的格式，常用属性解析。以及如何通过Jaca后端返回视频流的方式加载视频。介绍支持视频拖拽播放，断点序连的原理及其实现。最后介绍了基于video标签的外挂字幕WebVtt的使用，格式，及其转换程序和TTML格式的字幕。其中包含个人总结和经验记录。 video标签使用实例12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;video width=&quot;320&quot; height=&quot;240&quot; controls=&quot;controls&quot; autoplay=&quot;autoplay&quot;&gt; &lt;source src=&quot;https://www.w3school.com.cn/i/movie.mp4&quot; type=&quot;video/mp4&quot; /&gt; &lt;/video&gt;&lt;/body&gt;&lt;/html&gt; 格式支持浏览器支持 元素 Chrome IE Firefox Safari Opera &lt;video&gt; 4.0 9.0 3.5 3.1 11.5 Internet Explorer 9+, Firefox, Opera, Chrome 以及 Safari 支持\\ &lt;video&gt; 标签。 注释：Internet Explorer 8 以及更早的版本不支持 &lt;video&gt; 标签。 视频格式支持 html 5中的 video 标签目前只支持MPEG4（mp4），Ogg，WebM 三种视频格式 详细说明： Ogg = 带有 Theora 视频编码 + Vorbis 音频编码 MPEG4 = 带有 H.264 视频编码 + AAC 音频编码 WebM = 带有 VP8 视频编码 + Vorbis 音频编码 实际上，个人总结经验是：其实h5支持的video真正不由协议决定，是由浏览器的支持和机制而定。如目前很多浏览器，chrome都支持播放mkv格式，只是mkv嵌入的字幕还不能被解析 参考链接：https://blog.csdn.net/qq_40340478/article/details/108309492 video属性 属性 值 描述 src url 要播放的视频的 URL。 poster url 规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像。 autoplay autoplay 如果出现该属性，则视频在就绪后自动播放 preload none、metadata、auto 此属性用于定义视频是否预加载。属性有三个可选择的值：none、metadata、auto。如果不使用此属性，默认为auto。 controls controls 如果出现该属性，则向用户显示控件，比如播放按钮。 loop loop 如果出现该属性，则当媒介文件完成播放后再次开始播放。 muted muted 规定视频的音频输出应该被静音。 height pixels 设置视频播放器的高度。 width pixels 设置视频播放器的宽度。 参考链接 w3school-html视频，&lt;video&gt;标签 关于H5中的&lt;video&gt;&lt;/video&gt;标签的用法总结 source标签 Source标签用于给媒体（因为audio标签同样可以包含此标签，所以这儿用媒体，而不是视频）指定多个可选择的（浏览器最终只能选一个）文件地址，且只能在媒体标签没有使用src属性时使用。 浏览器按source标签的顺序检测标签指定的视频是否能够播放（可能是视频格式不支持，视频不存在等等），如果不能播放，换下一个。此方法多用于兼容不同的浏览器。Source标签本身不代表任何含义，不能单独出现。 此标签包含src、type、media三个属性 常用属性 属性 值 意义 src url 用于指定媒体的地址，和video标签的一样。 type type/mp4 用于说明src属性指定媒体的类型，帮助浏览器在获取媒体前判断是否支持此类别的媒体格式。 media 用于说明媒体在何种媒介中使用，不设置时默认值为all，表示支持所有媒介 load auto，meta，none auto - 当页面加载后载入整个视频 meta - 当页面加载后只载入元数据none - 当页面加载后不载入视频 source标签具有很多类似video标签的属性，原因使video也可以直接指定视频源进行播放。实际使用中只需选取其中之一重复属性设置即可 例子代码1234&lt;video width=&quot;658&quot; height=&quot;444&quot; poster=&quot;http://www.youname.com/images/first.png&quot; autoplay=&quot;autoplay&quot; preload=&quot;none&quot; controls=&quot;controls&quot;&gt; &lt;source src=&quot;http://www.youname.com/images/first.ogv&quot; /&gt; &lt;source src=&quot;http://www.youname.com/images/first.ogg&quot; /&gt;&lt;/video &gt; 说明 这段代码在页面中定义了一个视频，此视频的预览图为poster的属性值，显示浏览器的默认媒体控制栏，预加载视频的元数据，循环播放，宽度为900像素，高度为240像素。 第一选择视频地址为第一个source标签的src属性值，视频类别为Ogg视频，视频编码译码器为Theora，音频编码译码器为Vorbis，播放媒 介为显示器；第二选择视频地址不再累述。如果你还要兼容IE的话，可以在最后一个source标签后再加上Flash播放器的标签集，或者使用一点 JavaScript代码。 ———————————————— 版权声明：本文为CSDN博主「傻小胖」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_34645412/article/details/78722729 字节流视频播放基于Java后端视频流播放前端 html5出来后，前端播放视频瞬间变得方便容易多了，一个&lt;video&gt;标签就可以搞定,只要给src属性正确的文件路径即可。 将src属性设置为请求后端视频流的接口，后端返回视频的字节流数据 12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;video width=&quot;320&quot; height=&quot;240&quot; controls=&quot;controls&quot; autoplay=&quot;autoplay&quot;&gt; &lt;source src=&quot;playerServlet?action=getVideo&quot; type=&quot;video/mp4&quot; /&gt; &lt;/video&gt;&lt;/body&gt;&lt;/html&gt; 后端准备 通过IO流操作读取视频数据后，通过流的方式返回给前端 注意，这种写法只能实现视频从头到尾按时间顺序播放，无法拖拽进度条播放，或者拖放以后要重头进行播放 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 自实现的基础的，不支持拖拽播放、断点续联的视频流获取接口 * playerServlet?action=getVideo * @param req * @param resp * @throws ServletException */protected void getVideo2(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String path = &quot;本地视频绝对路径&quot;; //设置返回类型 resp.setContentType(&quot;application/video&quot;);//或指定resp.setContentType(&quot;video/mp4&quot;); BufferedInputStream bis = null; BufferedOutputStream bos = null; try &#123; FileInputStream fis = new FileInputStream(new File(path)); OutputStream os = resp.getOutputStream(); bis = new BufferedInputStream(fis); bos = new BufferedOutputStream(os); int len = -1; byte[] buff = new byte[1024 * 8]; while ((len = bis.read(buff)) != -1)&#123; bos.write(buff,0,len); &#125; bos.flush(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(bis != null)&#123; try &#123; bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(bos != null)&#123; try &#123; bos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 视频拖拽及断点续联 通过上述实现将会出现，“无法进行拖放或者拖放以后要重头进行播放” 问题在于Video标签适配的局部字节数据请求未被响应，从而导致的进度条无法拖放 对于某些可以拖发的浏览器，如夸克浏览器，则是由于该浏览器对视频进行了本地缓存，因此是对已有的缓存进行视频拖放，而不是局部视频拖拽的数据加载，和断点续联 原理分析请求分析 当使用Html5 的video 标签播放视频时，每次播放(初始状态或拖动进度条)，都会发起一个新的请求 每次发起的请求都包含一个Range字段，表示请求字节的范围 格式：Range:(bytes=first byte pos)-[last byte pos]，表示请求范围的起始字节位置-结束字节位置 1Range: bytes&#x3D;0-[可选] 响应分析 当服务器收到含有Range字段的请求时，服务器需以206 Partial Content (from disk cache)的状态响应，给出对应的响应字段以及请求对应的字节流数据。否则前端则视为请求失败，导致进度条无法拖拽，局部加载数据 在响应头中response header至少要包含三个字段： 123Accept-Ranges: bytesContent-Length: 2097152Content-Range: bytes 0-2097151/38696534 Content-Type：明确指定视频格式，有”video/mp4”, “video/ogg”, “video/mov”等等 Content-Range：格式是 “bytes&lt;start&gt;-&lt;end&gt;/&lt;total&gt;”，其中start和end必需对应request header里的range字段，total是文件的总大小长度 Content-Length：该次请求返回的二进制长度。 其中需要说明的是，这里服务端设置了响应2MB（210241024=2097152字节）的分段加载，返回的数据流则是文件流索引0-2097151的内容，因为文件流索引是从0开始的。38696534 是视频文件的总长度。 注意，Chrome浏览器操作进度条或者播放时，请求的是 “Range: bytes=xxx - ”，即只决定从那个字节的位置开始加载，而没有指定加载多少数据。而IOS上的Safari浏览器则是规定一段段请求。如请求的Range字段为，”Range:bytes=3334523-5662322”，因此若需要兼容多种浏览器，则需要进行判别 后端实现实现步骤 由于服务器要根据Range字段对应响应三个响应头字段及其对应的字节流数据，而这些数据主要通过读取Range字段获取，因此首当其冲是解析Range字段的数据 123Accept-Ranges: bytesContent-Length: 2097152Content-Range: bytes 0-2097151&#x2F;38696534 尝试获取Range字段，由于有些视频资源请求不一定是局部数据加载，可能是全部加载 分析Range字段类型： 类型1，只指定读取位置(Chrome)：Range: bytes=92012544- startByteIndex = 92012544 endByteIndex = null contentLeng = 视频文件总大小 - startByteIndex(92012544) 类型2：指定起始和结束读取字节位置(Safari)：Range: bytes=92012544-123321133 startByteIndex = 92012544 endByteIndex = 123321133 contentLeng = endByteIndex - startByteIndex 根据对应的Range字段类型，设置对应的响应头，以及返回对应部分的字节流数据 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221/** * 支持H5 Video，拖拽播放，断点序连 * * 博主代码存在疑点？ * 1、responseStatus的重复定义，responseStatus只能为206 * int responseStatus = 206 与responseStatus = javax.servlet.http.HttpServletResponse.SC_PARTIAL_CONTENT; * 2、Range bytes=234434-33333 类型时，没有对contentLength进行计算赋值，temp2没使用 * 3、全文下载类型数据传输部分，空实现？ * 4、 * @param request * @param response * @throws Exception */public void getVideo(HttpServletRequest request,HttpServletResponse response) throws Exception &#123; String path = &quot;本地视频链接&quot;; //视频文件 File downloadFile = new File(path); // 记录文件大小 long fileLength = downloadFile.length(); // 记录已下载文件大小 long pastLength = 0; // 0：从头开始的全文下载； // 1：从某字节开始的下载（bytes=27000-）； // 2：从某字节开始到某字节结束的下载（bytes=27000-39000） int rangeSwitch = 0; // 客户端请求的字节总量 long contentLength = 0; // 记录客户端传来的形如“bytes=27000-”或者“bytes=27000-39000”的内容 String rangeBytes = &quot;&quot;; // 负责读取数据 RandomAccessFile raf = null; // 写出数据 OutputStream os = null; // 缓冲 OutputStream out = null; // 缓冲区大小 final int BUFF_SIZE = 1024; // 暂存容器 byte buff[] = new byte[BUFF_SIZE]; int responseStatus = 206; // 客户端请求的下载的文件块的开始字节 //1、尝试获取Range字段，并判断是否存在Range字段，形如“bytes=33333-”或 “bytes=3333-4444” String range = request.getHeader(&quot;Range&quot;); if (range != null &amp;&amp; range.trim().length() &gt; 0 &amp;&amp; !&quot;null&quot;.equals(range)) &#123; responseStatus = javax.servlet.http.HttpServletResponse.SC_PARTIAL_CONTENT; System.out.println(&quot;request.getHeader(\\&quot;Range\\&quot;)=&quot; + range); //去除“bytes部分字符” rangeBytes = range.replaceAll(&quot;bytes=&quot;, &quot;&quot;); //类型1：属于&quot;bytes=27000-&quot; 类型的Range字段请求，如Chrome浏览器的Range字段请求 if (rangeBytes.endsWith(&quot;-&quot;)) &#123; rangeSwitch = 1; rangeBytes = rangeBytes.substring(0, rangeBytes.indexOf(&#x27;-&#x27;)); //获取待读取的起始字节数 pastLength = Long.parseLong(rangeBytes.trim()); //由于只指定了需读取的起始字节数，则返回的数据长度因为从该读取位置后的所有数据 contentLength = fileLength - pastLength; //类型2：属于&quot;bytes=27000-33343&quot; 类型的Range字段请求，如Safari浏览器的Range字段请求 &#125; else &#123; rangeSwitch = 2; String temp0 = rangeBytes.substring(0, rangeBytes.indexOf(&#x27;-&#x27;)); String temp2 = rangeBytes.substring(rangeBytes.indexOf(&#x27;-&#x27;) + 1, rangeBytes.length()); pastLength = Long.parseLong(temp0.trim()); //这里没有赋值contentLength?，自我补充 Long endLength = Long.parseLong(temp2.trim()); contentLength = endLength - pastLength; &#125; //无Range字段，即客户端要求全文下载 &#125; else &#123; contentLength = fileLength; &#125; //2、设置三个响应头 //Accept-Ranges: bytes //Content-Length: 2097152 //Content-Range: bytes 0-2097151/38696534 //前两个请求头可以直接获取返回，最后一个Content-Range需计算设置 // 清除首部的空白行 response.reset(); // 告诉客户端允许断点续传多线程连接下载,响应的格式是:Accept-Ranges: bytes response.setHeader(&quot;Accept-Ranges&quot;, &quot;bytes&quot;); // 如果是第一次下,还没有断点续传,状态是默认的 200,无需显式设置;响应的格式是:HTTP/1.1 //含Range字段的断点序连，rangeSwitch == 1 || 2 if (rangeSwitch != 0) &#123; response.setStatus(responseStatus); // 不是从最开始下载，断点下载响应号为206 // 响应的格式是: // Content-Range: bytes [文件块的开始字节]-[文件的总大小 - 1]/[文件的总大小] switch (rangeSwitch) &#123; //Range类型1：“Range bytes=27000-”， //响应格式为 &quot;Content-Range:bytes 27000-视频最后一个字节(视频大小-1)/视频大小&quot; case 1: &#123; //暂不明白，博主为什么“new Long(xxx).toString()”，而不用&quot;String.valueOf(xxx)&quot;方式 String contentRange = new StringBuffer(&quot;bytes &quot;) .append(new Long(pastLength).toString()).append(&quot;-&quot;) .append(new Long(fileLength - 1).toString()) .append(&quot;/&quot;).append(new Long(fileLength).toString()) .toString(); response.setHeader(&quot;Content-Range&quot;, contentRange); break; &#125; //Range类型1：“Range bytes=27000-34000”， //响应格式为 &quot;Content-Range:bytes 27000-34000/视频大小&quot; //此时的range为&quot;bytes=27000-34000&quot;格式 case 2: &#123; //直接再range数据的基础上，将&quot;=&quot;替换成空格加上视频大小即可 String contentRange = range.replace(&quot;=&quot;, &quot; &quot;) + &quot;/&quot; + new Long(fileLength).toString(); response.setHeader(&quot;Content-Range&quot;, contentRange); break; &#125; default: &#123; break; &#125; &#125; //全文下载：响应头个格式为：&quot;Content-Range：bytes 0-视频最后一个字节(视频大小-1)/视频大小&quot; &#125; else &#123; String contentRange = new StringBuffer(&quot;bytes &quot;).append(&quot;0-&quot;) .append(fileLength - 1).append(&quot;/&quot;).append(fileLength) .toString(); response.setHeader(&quot;Content-Range&quot;, contentRange); &#125; //进行数据传输 try &#123; response.setContentType(&quot;video/mp4;charset=UTF-8&quot;); //response.setContentType(&quot;application/video;charset=UTF-8&quot;); response.setHeader(&quot;Content-Length&quot;, String.valueOf(contentLength)); os = response.getOutputStream(); out = new BufferedOutputStream(os); raf = new RandomAccessFile(downloadFile, &quot;r&quot;); try &#123; // 实际输出字节数 long outLength = 0; switch (rangeSwitch) &#123; //全文下载，空实现？ case 0: &#123; &#125; //读取从pastLength开始的到文件末尾 case 1: &#123; raf.seek(pastLength); int n = 0; while ((n = raf.read(buff)) != -1) &#123; out.write(buff, 0, n); outLength += n; &#125; break; &#125; case 2: &#123; raf.seek(pastLength); int n = 0; // 记录已读字节数 long readLength = 0; //由于每次写出的数据长度固定为1024个(理论上)，而实际range请求的数据大小 //有可能不是1024的整数倍，因此需要分两次写出，一次死帧数被 //大部分字节在这里读取 while (readLength &lt;= contentLength - BUFF_SIZE) &#123; n = raf.read(buff); readLength += n; out.write(buff, 0, n); outLength += n; &#125; // 余下的不足 1024 个字节在这里读取 if (readLength &lt;= contentLength) &#123; //把最后少于1024的数据，一次把它写完 n = raf.read(buff, 0, (int) (contentLength - readLength)); out.write(buff, 0, n); outLength += n; &#125; break; &#125; default: &#123; break; &#125; &#125; //System.out.println(&quot;Content-Length为：&quot; + contentLength + &quot;；实际输出字节数：&quot; + outLength); out.flush(); &#125; catch (IOException ie) &#123; // ignore &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot;调用finally回收资源&quot;); if (out != null) &#123; try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (raf != null) &#123; try &#123; raf.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 参考文章 原理参考： Chrome浏览器Video无法拖动的探索和解决方案 java web 根据video标签进度条位置传输视频流 +下载文件实现断点续传 html5中video标签实现拖动播放的原理？ javaweb播放视频通过断点续传拖动滚动条 HTTP Header里的Range和Content-Range参数 技术实现：亲测有效 H5通过数据流方式播放视频 WebVtt字幕前言 现在各种支持HTML5的浏览器都能够播放html5视频了，但是对于字幕的支持却很少，我们期待像DVD那样强大的字幕。 往往我们还不得不通过js来做，着实是一件痛苦的事情。 现在IE10率先对HTML5 Video 字幕给与内置的支持，而且还支持多语言，可任意切换，真是太给力了 IE10支持2种字幕文件格式： WebVTT : Web Video Text Track (Web视频文本轨道) TTML : Timed Text Markup Language (时序文本标记语言) 实例12345&lt;video width=&quot;320&quot; height=&quot;240&quot; controls=&quot;controls&quot; autoplay=&quot;autoplay&quot;&gt; &lt;source src=&quot;https://www.w3school.com.cn/i/movie.mp4&quot; type=&quot;video/mp4&quot; /&gt; &lt;track src=&quot;en_track.vtt&quot; srclang=&quot;en&quot; label=&quot;English&quot; kind=&quot;caption&quot; default&gt; &lt;track src=&quot;cn_track.vtt&quot; srclang=&quot;zh-cn&quot; label=&quot;简体中文&quot; kind=&quot;caption&quot;&gt; &lt;/video&gt; 通过两个&lt;track&gt;标签分别指定了一个英文字幕文件、一个中文字幕文件，默认为中文字幕，用户可以切换，也可以由程序脚本切换。 default属性存在时，表示默认开启字幕的指定字幕 注：&lt;track&gt;标签挂载的外部字幕不能在本地运行，您需要在服务器上运行它才能看到效果。 WebVTT格式WebVTT是UTF-8编码格式的文本文件，内容示例如下： 12345678WEBVTT 00:00:01.878 --&gt; 00:00:05.334 曾经有一份真诚的爱情放在我面前， 00:00:08.608 --&gt; 00:00:15.296 我没有珍惜，等我失去的时候我才后悔莫及， 人世间最痛苦的事莫过于此。 第一行必需是WEBVTT，接着空行 接下来是一行时间范围＋一行或多行字幕内容＋空行，一行时间范围＋一行或多行字幕内容＋空行，…… 时间格式是HH:MM:SS.sss，时:分:秒.毫秒， 开始时间 –&gt; 结束时间，–&gt;的两边各有一个空格，这两个时间必需写在同一行。 时间都是相对于视频开始的时间间隔。 时间之后是字幕文本，时间和字幕文本之间不能有空行，字幕文本可以是一行或多行，字幕文本中不能有空行。WebVTT字幕文件的MIME类型约定是”text/vtt“，需要在IIS或者Apache等Web服务器中配置. 字幕的样式控制 CSS中有专门的伪元素::cue可以控制字幕的样式 可以控制的CSS属性包括： 1234567891011coloropacityvisibilitytext-decoration及相关属性text-shadowbackground及相关属性outline及相关属性font及相关属性，包括line-heightwhite-spacetext-combine-uprightruby-position 示例123456::cue &#123; background: none; color: #fff; text-shadow: 0 1px #000, 1px 0 #000, -1px 0 #000, 0 -1px #000; font-size: medium;&#125; ASS转VTT程序示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * ASS字幕文件转VTT字幕文件 * 注意字幕文件编码最好是UTF-8 * 本程序也只支持UTF-8 * 如果出现编码字符集不一样，即使在程序控制台输出一致的内容， * indexof,statwith，这些匹配时，都是按编码数值比较，都会因为不一样而匹配失败 * @param ass * @param vtt * @return 转换后vtt字幕的物理绝对路径 */public static String AssToVtt(File ass, File vtt)&#123; BufferedReader br = null; BufferedWriter bw = null; try &#123; FileInputStream fis = new FileInputStream(ass); br = new BufferedReader(new InputStreamReader(fis,&quot;UTF-8&quot;)); FileOutputStream fos = new FileOutputStream(vtt); bw = new BufferedWriter(new OutputStreamWriter(fos, &quot;UTF8&quot;)); //写入vtt头结构 bw.write(WEB_VTT_HEAD + &quot;\\n\\n&quot;); String line = null; while((line = br.readLine()) != null)&#123; if(line.startsWith(ASS_SUBTITLE_START_WORD))&#123; String[] assData = line.split(&quot;,&quot;); String startDate = assData[1]; String endDate = assData[2]; if(&quot;0:00:00.00&quot;.equals(startDate) &amp;&amp; &quot;0:00:00.00&quot;.equals(endDate) || !assData[3].contains(&quot;Default&quot;) || assData.length &lt; 9)&#123; continue; &#125; //读取到内存后(字符流能保证不乱吗)，字幕部分统一用UTF-8编码写入，否则存在乱码 String content = assData[9]; //转存为vtt字幕 startDate = &quot;0&quot; + startDate + &quot;0&quot;; endDate = &quot;0&quot; + endDate + &quot;0&quot;; bw.write(startDate + &quot; --&gt; &quot; + endDate + &quot;\\n&quot;); bw.write(content + &quot;\\n&quot;); bw.write(&quot;\\n&quot;); &#125; &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(br != null)&#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(bw != null)&#123; try &#123; bw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return vtt.getAbsolutePath();&#125; 注：这种解决方案可能存在若字幕内容本身含有符号’,’有可能会被截断。 TTML格式TTML是xml格式的文件，内容示例如下： 123456789&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;UTF-8&#x27;?&gt; &lt;tt xmlns=&#x27;http://www.w3.org/ns/ttml&#x27; xml:lang=&#x27;en&#x27; &gt; &lt;body&gt; &lt;div&gt; &lt;p begin=&quot;00:00:01.878&quot; end=&quot;00:00:05.334&quot; &gt;曾经有一份真诚的爱情放在我面前，&lt;/p&gt; &lt;p begin=&quot;00:00:08.608&quot; end=&quot;00:00:15.296&quot; &gt;我没有珍惜，等我失去的时候我才后悔莫及，&lt;br/&gt;人世间最痛苦的事莫过于此。&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/tt&gt; 结构很明确了，分别是tt标签，body标签，div标签，p标签，br标签，和HTML很像啊！p元素的begin/end属性指定了字幕的起止时间。 TTML文件的MIME类型约定为application/ttml+xml 通过在video标签内使用1个或多个track标签来指定1个或多个语言的字幕文件，每个track元素对应一个字幕文件。 track标签的属性主要有4个，如下表： 属性 描述 kind 定义字幕内容类型，只能是这五种之一: subtitles, captions, descriptions, chapters, metadata. src 字幕文件的URL地址 srclang 字幕文件的语言类型，标识信息的作用，播放器不使用这个属性。 label 字幕标签，每个字幕元素必需设置一个唯一不重复的标签，切换字幕时显示的名称。 default 指定是否是默认字幕。如果每个都不指定，将不会自动显示字幕. 可以通过javascript方式访问每一个字幕元素，甚至其中的每一句台词。这一部分代码比较多，我就不展开了，有兴趣的可以自己看原文。 参考链接： https://blog.csdn.net/cuixiping/article/details/7760845 https://blog.csdn.net/weixin_33727510/article/details/88859525","categories":[],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"},{"name":"视频播放","slug":"视频播放","permalink":"http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/"}]},{"title":"数据结构之图结构(未完成)","slug":"数据结构之图结构(未完成)","date":"2021-07-11T03:14:52.000Z","updated":"2021-08-25T15:27:11.651Z","comments":true,"path":"2021/07/11/数据结构之图结构(未完成)/","link":"","permalink":"http://yoursite.com/2021/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E7%BB%93%E6%9E%84(%E6%9C%AA%E5%AE%8C%E6%88%90)/","excerpt":"","text":"引言：本文主要介绍了数据结构中的图结构，涵盖图的逻辑结构概念，基本术语、图的基本性质。以及图的遍历，深度优先与广度优先遍历。图的存储结构，邻接矩阵和邻接表，及其实现与深度广度优先遍历的实现。最小生成树算法，Prim，Kruskal以及最短路径算法Dijkstra算法、Floyed算法，AOV和AOE。 参考资料： 《数据结构——从概念到C++实现》（第3版）- 王红梅 - 清华大学出版社 《数据结构——从概念到Java实现》（第2版）- 王红梅 - 清华大学出版社 《大话数据结构》（第1版）- 程杰 - 清华大学出版社 图结构知识图谱之思维导图 概念与术语图的定义 图（graph），即有穷非空顶点的集合 + 顶点间的边的集合 顶点（vertex）：图中数据元素 边（edge）：图中任意两顶点构成的边 基本术语图涉及众多基本术语，涉及大部分离散数学的内容 边 无向边：边无方向，记作：(v0，v1) 无向图（undirected graph）：均由无向边组成的图 完全无向图（undirected completed graph）：任意两点间都含无向边 有向边/弧：边有方向，记作：&lt;v0，v1&gt;，v0 —&gt; v1，v0 弧尾，v1弧头(箭头) 有向图（directed graph）：均由有向边组成的图 完全无向图（directed completed graph）：任意两点均含**两条，方向相反**的弧 若图G = (V，E)中同时包含无向边和有向边，则称为混合图 权（weight）：对边赋予有意义的数量值，如边的长度、等级等描述 网图（network graph）：边带权构成的图称为网图 依附与邻接“依附”描述边，“邻接”描述点 依附（adhere）：一条边连接两个点，则该边依附这两个点 邻接点（adjacent）：一条边相连的两个点互为邻接点 无向图的邻接点：互为邻接点 有向图的邻接点：称弧尾邻接到弧头，弧头是弧尾的邻接点 例如：&lt;v0，v1&gt;，v0 —&gt; v1，v0 邻接到 v1， v1是v0的邻接点 度 度（degree / D）：某个顶点所依附的边的条数 无向图的度：即某个点所依附的边的条数 有向图的度： 出度（out-degree / OD）：O→ 入度（in-degree / ID）：O ← 稠密与稀疏图 边数很少的图称为稀疏图（spares graph），反之称为稠密图（dense graph） 稀疏和稠密本身就是模糊的相对的概念。但显然边数为0最稀疏，完全图最稠密 路径相关 路径（path）： 无向图路径：两个点之间通过若干条边连接的路线 有向图路径：两个点之间按出度方向相连接的路线 简单路径（simple path）：在路径中，除第一个结点和最后一个结点外，其他顶点只经过一次 通常情况下，一般所说的回路，即指简单回路 路径长度（path length）： 非网图：路径所经过的边数 网图：路径所经过边的权值之和 回路（circuit）：出发顶点 == 终点顶点的路径 简单回路（simple circuit）：在回路中，所有顶点只经过一次 通常情况下，一般所说的回路，即指简单回路 子图 某图G = (V , E)中顶点V和边E分别的子集 v’ ,e’**，所构成的图称为G的子图** 正例 反例：都出现了图中V或E集合中没有的子集 连通图相关连通图若顶点vi 和 vj之间存在路径，则称vi 和 vj 是连通的 连通图（connected graph）（无向图）：**任意两个顶点之间**(两个方向合成一个方向)都存在路径 连通分量：非连通图中的极大连通子图，存在多个 “极大”含义： 子图在满足连通条件下，包含所有连通的顶点及其关联的所有边 注意，“极大”不是边数最多的连通子图，不只有一个。而是说连通子图中尽可能去连通可连通的顶点 强连通图 强连通图（strongly connected graph）：任意两个顶点之间(两个方向，来回)都存在路径 强连通分量：非强连通图中的极大强连通子图，存在多个 “极大”同连通分量的含义 （b）非强连通是由于 不存在v0 到 v1的路径 辨别强连通图：每个顶点都有出度和入度为强连通图 ADT接口声明1234public interface GraphInterface&lt;T&gt; { void DFS(int startIndex); //图的深度优先遍历 void BFS(int startIndex); //图的广度优先遍历} 图的基本性质边与度 无向图：e = 2d，即边的总数，是度的总数的两倍 解析：”一边两度“ 有向图：ID = OD = e，入度总数等于出度总数等于边总数 解析：一条弧上所依附两个顶点必定有一个出度，另一个入度， 完全图公式 n个顶点的有向完全图含有 n x (n - 1) 条弧 n个顶点的无向完全图含有 n x (n - 1) / 2 条边 原理 通过数学归纳法，统计可以得出有向完全图n个顶点含有n x (n - 1)条弧 而无向完全图的边没有方向，相当于将有向完全图任意两个顶点依附的两条弧合并成了一条无向边 因此无向完全图应是在有向完全图数量基础上除一半，即 n x (n - 1) / 2 下图为分析有向完全图n个顶点所含有边的增量过程 图的遍历思想引导 图的遍历（traverse）和其他数据结构遍历要求类似，即所有顶点有且只有被访问一次 但由于上图结构本身的复杂性，图的遍历需要解决许多困难 遍历需解决的关键问题Q 解决方案A 没有确定的开始结点，如何选取遍历起始点？ 方案1：任意顶点出发方案2：依赖对应的存储结构进行编号，从小到大遍历 非连通图如何遍历所有结点？ 多次从各个结点遍历，取结果的不重复并集现只讨论一个顶点开始遍历图 图存在回路，如何避免不重复访问？ 设置一个访问标志数组，被访问过的顶点置为1 一个顶点会和多个顶点相邻接，如何选取下一个顶点访问的顶点？ 属于遍历次序问题，有深度优先遍历和广度优先遍历 注：由于图的结构复杂，即使确定的遍历次序，遍历序列也不是唯一的 深度优先遍历 深度优先遍历（depth-first traverse / DFS）类似树的前序遍历，属于“一条路走到死才递归返回” 深度优先遍历与树的前序遍历一样，属于递归思想实现的一种遍历 基本思想 初始化，取任意顶点v开始遍历 直至所有访问标志数组均被置数访问过 2.1. 从v的未被访问的邻接点中选取一个顶点w访问 2.2. 从w出发再进行深度优先遍历，即重复步骤2 广度优先遍历 广度优先遍历（breadth-first traverse / BFS），类似树的层序遍历，属于非递归方式遍历 规定从某个顶点开始，由近到远（路径），依次访问图的所有结点 基本思想 选取一个起始顶点入队 出队一个元素，并把该元素所有**未遍历的出度**的元素入队 若队列不为空，继续执行步骤 2 图的存储结构前言 图是一种复杂的数据结构，任意两个顶点之间都可能存在边，所以无法通过顶点的存储位置反映顶点之间的邻接关系，因此图没有顺序存储结构 从图的定义可知，一个图包括两部分：顶点的信息以及顶点之间边的信息。无论采用什么方法存储图，都要完整、准确地表示这两方面的信息 一般来说，图的存储结构应需根据具体问题的要求来设计 下面介绍两种常用的存储结构——邻接矩阵和邻接表 邻接矩阵定义邻接矩阵定义 邻接矩阵（adjacency matrix）是使用两个数组实现的图的存储结构，因此也成为数组表示法 矩阵，必定至少是个二维表。 一维数组 vertex[ ? ] = { v0 v1 v2 v3 v4}**：存储顶点信息** 二维数组 edge[ i ] [ j ] = ?**：存储两点之间的边的信息，i — j 或 i —&gt; j** 因此对于无向图的邻接矩阵一定是对称矩阵 代码实现12345678910public class MGraph&lt;T&gt; implements GraphInterface&lt;T&gt;{ private int vertices_num; //图的顶点数 private int edge_num; //图的边数 private T[] vertices; //一维数组存储图的顶点 private int[][] adjMatrix; //二维数组实现邻接矩阵 boolean[] visited; //访问标志数组 //实现接口方法...} 非网图邻接矩阵存在无向边或有向边不存在边或等于自身点 网图邻接矩阵表示边的权值即存在无向边或有向边自身点不存在边 注：∞表示计算机允许的、大于所有边上权值的树 邻接矩阵实现邻接矩阵结构12345678910public class MGraph&lt;T&gt; implements GraphInterface&lt;T&gt;{ private int vertices_num; //图的顶点数 private int edge_num; //图的边数 private T[] vertices; //一维数组存储图的顶点 private int[][] adjMatrix; //二维数组实现邻接矩阵 boolean[] visited; //访问标志数组 //实现接口方法...} 测试无向图 用于一下代码测试的无向图 无向图初始化 伪代码：建议掌握书写伪代码的能力 123456789算法：MGraph（init vertices，edge_num）输入：顶点的数据信息init vertices，边的个数edge_num输出：图的邻接矩阵 1.存储图的顶点个数和边的个数； 2.将顶点数据信息存储在一维数组 vertices中； 3.初始化邻接矩阵adjMatrix； 4.依次输入每条存在的边并存储在邻接矩阵adjMatrix中： 4.1输入边依附的两个顶点的编号i和j； 4.2将adjMatrix[i][j]和adjMatrix[j][i]的值置为1；（无向图） 示例代码 12345678910111213141516171819202122232425262728293031323334/** * 无向图构造函数 * @param init_vertices 图的顶点信息数据 * @param edge_num 无向图的边的数量 */public MGraph(T[] init_vertices,int edge_num){ if(init_vertices.length == 0){ throw new RuntimeException(\"无顶点，无向图构造失败\"); } //一系列初始操作 this.vertices_num = init_vertices.length; this.edge_num = edge_num; this.vertices = (T[]) new Object[vertices_num]; for (int i = 0; i &lt; init_vertices.length; i++) { vertices[i] = init_vertices[i]; } this.adjMatrix = new int[vertices_num][vertices_num]; Scanner reader = new Scanner(System.in); for (int i = 1; i &lt;= edge_num; i++) { System.out.print(\"请输入存在的第 \"+ i + \"条边的第1个顶点信息\"); int vertex1 = reader.nextInt(); System.out.print(\"请输入存在的第 \"+ i + \"条边的第2个顶点信息\"); int vertex2 = reader.nextInt(); //无向边初始化 adjMatrix[vertex1][vertex2] = 1; adjMatrix[vertex2][vertex1] = 1; } reader.close();} 测试代码：以测试无向图为例进行测试 123456789public static void main(String[] args) { String[] vertices = new String[]{\"0A\",\"1B\",\"2C\",\"3D\"}; MGraph&lt;String&gt; graph = new MGraph&lt;&gt;(vertices,4); //键盘输入存在的4条边，无向图是对称矩阵，任意一条边都选取一个方向的顶点对输入即可 //即只需要选取上三角或下三角的邻接矩阵值输入即可 //键盘输入内容：0,1、0,3、3,1、1,2 graph.DFS(0);} 深度优先遍历(DFT) 伪代码：建议掌握书写伪代码的能力 1234567算法：DFT输入：顶点的编号v输出：无 1.访问顶点v；修改标志 visited[v]=true； 2.w = 顶点v的第一个邻接点； 3.while（w存在） 3.1 if（w未被访问）从顶点w出发递归执行该算法； 3.2 w = 顶点v的下一个邻接点； 示例代码：原接口实现方法用于接收用户定义的起始顶点调用，另创建递归实现的方法体 1234567891011121314151617181920212223242526272829/** * 无向图深度优先遍历 * @param startIndex 用户决定起始遍历的顶点索引 */@Overridepublic void DFS(int startIndex) { if(startIndex &lt; 0 || startIndex &gt;= vertices_num){ throw new RuntimeException(\"起始遍历顶点不存在\"); } visited = new boolean[this.vertices_num]; iteratorDFT(startIndex); System.out.println();}/** * 无向图深度优先遍历递归实现 * @param startIndex 顶点索引 */public void iteratorDFT(int startIndex){ System.out.print(vertices[startIndex] + \" \"); visited[startIndex] = true; //查找该顶点下一个未被访问过的邻接顶点 for (int i = 0; i &lt; vertices_num; i++) { if(adjMatrix[startIndex][i] == 1 &amp;&amp; !visited[i]){ iteratorDFT(i);//递归存在的且未被访问的邻接结点 } }} 测试代码：以测试无向图为例进行测试 1234567public static void main(String[] args) { String[] vertices = new String[]{\"0A\",\"1B\",\"2C\",\"3D\"}; MGraph&lt;String&gt; graph = new MGraph&lt;&gt;(vertices,4); //键盘输入内容：0,1、0,3、3,1、1,2 graph.DFS(0);//0A 1B 2C 3D } 广度优先遍历(BFT) 伪代码：建议掌握书写伪代码的能力 1234567891011算法：BFTraverse输入：顶点的编号v输出：无 1.队列Q初始化； 2.访问顶点v；修改标志visited[v]=1；顶点v入队列Q； 3.while（队列Q非空） 3.1 v=队列Q的队头元素出队； 3.2 w=顶点v的第一个邻接点； 3.3 while（w存在） 3.3.1如果w未被访问，则访问顶点w；修改标志 visited[w]=1；顶点w人队列Q； 3.3.2w=顶点v的下一个邻接点； 个人实现：有别于伪代码方式，伪代码是3.3.1步骤访问输出数据，本人是以队头出队时访问并输出数据 12345678910111213141516171819202122232425262728293031323334/** * 无向图广度优先遍历 * @param startIndex 用户决定起始遍历的顶点索引 */@Overridepublic void BFS(int startIndex) { if(startIndex &lt; 0 || startIndex &gt;= vertices_num){ throw new RuntimeException(\"起始遍历顶点不存在\"); } //初始化访问标识数组 visited = new boolean[this.vertices_num]; //初始化队列，并将开始遍历顶点入队 QueueInterface&lt;Integer&gt; queue = new CircularQueue&lt;&gt;(vertices_num); queue.enQueue(startIndex); visited[startIndex] = true; //直到队列为空 while (!queue.isEmpty()){ Integer vertex = queue.deQueue(); System.out.print(vertices[vertex] + \" \"); //寻找出队顶点的所有邻接结点并入队 for (int i = 0; i &lt; vertices_num; i++) { //邻接点存在且未被访问过 if(adjMatrix[vertex][i] == 1 &amp;&amp; !visited[i]){ queue.enQueue(i); //入队时就要将要访问的结点所在访问标识数组置为true，否则会反复入队 visited[i] = true; } } } System.out.println();} 测试代码：以测试无向图为例进行测试 1234567public static void main(String[] args) { String[] vertices = new String[]{\"0A\",\"1B\",\"2C\",\"3D\"}; MGraph&lt;String&gt; graph = new MGraph&lt;&gt;(vertices,4); //键盘输入下三角部分：0,1、0,3、3,1、1,2 graph.BFS(0);//0A 1B 3D 2C } 邻接表邻接表定义定义 邻接表（adjacency list）是一种类似树的孩子表示法。 将v的所有邻接点（出度）链成一个单链表，称为顶点v的边表（有向图称出边表） 边表结点：EdgeNode int adjvex：邻接点域（引用数据下标） EdgeNode next：下一个边表结点指针域 顶点表结点：VertexNode T vertex：顶点数据域 EdgeNode first：第一个边表结点的指针域（引用域） 存储边表的头指针和顶点数据构成一个元素，为了节省开销使用数组存储，边表引用，称为顶点表 对于网图，则在边表中增加一个权值域 实现 边表结点 123456789public class EdgeNode { private int adjvex; //邻接点域（引用数据下标） private EdgeNode next; //邻接点域（引用数据下标） public EdgeNode(int adjvex){ this.adjvex = adjvex; } //省略getter和setter方法...} 顶点表结点 12345678910111213public class VertexNode&lt;T&gt; { private T data; //顶点数据域 private EdgeNode first; //第一个边表结点的指针域（引用域） public VertexNode(){ } public VertexNode(T data){ this.data = data; } //省略getter和setter方法...} 非网图邻接表 网图邻接表 边表增加一个权值域info 邻接表实现邻接表结构1234567891011//有向非网图public class ALGrapht&lt;T&gt; implements GraphInterface&lt;T&gt;{ private VertexNode&lt;T&gt;[] vertices; //顶点表 private int vertices_num; //顶点数量 private int edge_num; //边数量 boolean[] visited; //访问标志数组 //实现GraphInterface接口的方法...} 测试有向非网图 有向非网图初始化 初始化代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 初始化有向图非网图邻接表 * @param init_vertices * @param edge_num */public ALGrapht(T[] init_vertices,int edge_num){ if(init_vertices.length == 0){ throw new RuntimeException(\"顶点为空\"); } this.vertices_num = init_vertices.length; this.edge_num = edge_num; this.vertices = new VertexNode[this.vertices_num]; for (int i = 0; i &lt; vertices_num; i++) { vertices[i] = new VertexNode&lt;&gt;(init_vertices[i]); } Scanner scanner = new Scanner(System.in); for (int i = 1; i &lt;= edge_num; i++) { System.out.print(\"请输入存在的第 \"+ i + \"条边的第1个顶点信息：\"); int vertex1 = scanner.nextInt(); System.out.print(\"请输入存在的第 \"+ i + \"条边的第2个顶点信息：\"); int vertex2 = scanner.nextInt(); EdgeNode edgeNode = new EdgeNode(vertex2); VertexNode&lt;T&gt; vertex = vertices[vertex1]; EdgeNode firstEdgeNode = vertex.getFirst(); //头插法 edgeNode.setNext(firstEdgeNode); vertex.setFirst(edgeNode); //尾插法 /* if(firstEdgeNode == null){ vertex.setFirst(edgeNode); }else { EdgeNode p = firstEdgeNode; while (p.getNext() != null){ p = p.getNext(); } p.setNext(edgeNode); } */ } scanner.close(); System.out.println(\"初始化邻接表成功...\");} 测试代码，根据测试有向非网图 123456public static void main(String[] args) { String[] init = new String[]{\"V0\",\"V1\",\"V2\",\"V3\"}; ALGrapht&lt;String&gt; alGrapht = new ALGrapht&lt;&gt;(init,4); //有向非网图，键盘输入有向边，0,1、0,2、2,3、3,0 System.out.println(alGrapht);} 深度优先遍历(DFT) 伪代码 12345678算法：ALGrapht（init vertices，n，e）输入：顶点的数据信息init_vertices，顶点个数n，边的个数e输出：图的邻接表 1.存储图的顶点个数和边的个数； 2.将顶点信息存储在顶点表中，将该顶点边表的头引用初始化为NULL； 3.依次输入边的信息并存储在边表中： 3.1 输入边所依附的两个顶点的编号i和j； 3.2 生成边表结点edgeNode，其邻接点的编号为j； 3.3 将结点edgeNode插入第i个边表的表头； 示例代码 1234567891011121314151617181920212223242526/** * 邻接表深度优先遍历 * @param startIndex 用户决定起始遍历的顶点索引 */@Overridepublic void DFS(int startIndex) { this.visited = new boolean[this.vertices_num]; iteratorDFT(startIndex); System.out.println();}/** * 邻接表深度优先遍历递归实现 * @param startIndex 顶点索引 */private void iteratorDFT(int startIndex){ System.out.print(vertices[startIndex].getData() + \" \"); visited[startIndex] = true; EdgeNode p = vertices[startIndex].getFirst(); while (p != null){ if(visited[p.getAdjvex()] == false){ iteratorDFT(p.getAdjvex()); } p = p.getNext(); }} 广度优先遍历(BFT) 伪代码：建议掌握书写伪代码的能力 1234567891011算法：BFTraverse输入：顶点的编号v输出：无 1.队列Q初始化； 2.访问顶点v；修改标志visited[v]=1；顶点v入队列Q； 3.while（队列Q非空） 3.1 v=队列Q的队头元素出队； 3.2 w=顶点v的第一个邻接点； 3.3 while（w存在） 3.3.1如果w未被访问，则访问顶点w；修改标志 visited[w]=1；顶点w人队列Q； 3.3.2w=顶点v的下一个邻接点； 个人实现：有别于伪代码方式，伪代码是3.3.1步骤访问输出数据，本人是以队头出队时访问并输出数据 12345678910111213141516171819202122232425262728293031323334/** * 邻接表广度优先遍历 * @param startIndex 用户决定起始遍历的顶点索引 */@Overridepublic void BFS(int startIndex) { if(startIndex &lt; 0 || startIndex &gt;= vertices_num){ throw new RuntimeException(\"起始遍历顶点不存在\"); } visited = new boolean[vertices_num]; //初始化，将开始索引入队 CircularQueue&lt;Integer&gt; queue = new CircularQueue&lt;&gt;(vertices_num); queue.enQueue(startIndex); visited[startIndex] = true; while (!queue.isEmpty()){ Integer key = queue.deQueue(); VertexNode&lt;T&gt; vertexNode = vertices[key]; System.out.print(vertexNode.getData() + \" \"); EdgeNode p = vertexNode.getFirst(); while (p != null){ int index = p.getAdjvex(); if(!visited[index]){ queue.enQueue(index); visited[index] = true; } p = p.getNext(); } } System.out.println();} 性能比较时间复杂度出度/邻接点 **查找顶点 i 的所有出度 / 邻接点**（设图G含有n个顶点，e条边） 存储结构 原理 时间复杂度 对比 邻接矩阵 遍历第 i 行/列 数组的所有非零个数 O(n) 劣 邻接表 遍历第 i 个元素的边表 O(e/n) 优 解析：由于即使是最稠密的完全有向图，e = n(n - 1)，即e/n = n(n - 1)/n = n - 1，O(n - 1) &lt; O(n) 无向图无出入度之分，因此无向图可以选邻接表更高效率的出度方式实现无向图的某顶点求度的需求 入度 查找顶点 i 的所有入度（设图G含有n个顶点，e条边） 存储结构 原理 时间复杂度 对比 邻接矩阵 遍历第 i 列/行 数组的所有非零个数（同出度，仅翻转行列） O(n) 优 邻接表 遍历整个边表寻找含 i 的顶点 O(e) 劣 读取边/权值 读取边（ i ，j） 是否存在或权值（设图G含有n个顶点，e条边） 存储结构 原理 时间复杂度 对比 邻接矩阵 二维邻接矩阵表[ i ] [ j ]，直接取得结果 O(1) 优 邻接表 遍历 i 顶点的边表，寻找 j 顶点 O(e/n) 劣 遍历 含有向图深度优先与广度优先遍历 存储结构 原理 时间复杂度 对比 邻接矩阵 遍历每个未访问结点O(n)，的所有未访问邻接点O(n) O(n2) 劣 邻接表 遍历每个未访问结点O(n)，的所有未访问的邻接点O(e) O(n + e) 优 空间复杂度 设图G含有n个顶点，e条边 存储结构 原理 理论复杂度 稀疏图 稠密图 邻接矩阵 存储所有可能的边状态 O(n2) 劣 优 邻接表 只存储实际出现,存在的边 O(n + e) 优 劣(指针域开销占比逐渐变大) 小结 邻接矩阵优势：适合稠密图存储、读取边的信息(存在/权值)、求入度 邻接表优势(边表/出边表)： 适合稀疏图存储、读取邻接点/出度、 最小生成树算法基础概念生成树定义 连通图的生成树（spanning tree）是包含图中全部顶点的极小连通子图（边数最少） 生成树是描述全部顶点能相通所需要的最少边数的图结构（类树结构） 极小连通子图：一个连通图中连通子图 极大连通子图：一个是非连通图中的连通子图 性质 由于生成树是极小的连通子图，接边数最少的连通（子）图，因此任意两个顶点间只存在一条路径 即图中任意两个顶点间不存在回路 在生成树中添加任意一条属于原图的边必定产生回路 减少任意一条边则必定成为非连通图 因此具有 n 个顶点的生成树有且仅有 n - 1 条边 最小生成树 生成树的代价：无向连通网生成树上各边权值之和 最小生成树（minimal spanning tree）：其中代价最小的生成树称为最小生成树 Prim算法理论实现代码实现数据结构实现代码Kruskal算法最短路径算法有向无环图及其应用AOV网与拓扑排序AOE网与关键路径扩展与应用扩展图的其他存储方法十字链表邻接多重表图的连通性无向图的连通分量和生成树有向图的强连通分量应用七巧板涂色问题医院选址问题","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构之树结构","slug":"数据结构之树结构","date":"2021-07-06T12:55:45.000Z","updated":"2021-08-25T15:27:11.784Z","comments":true,"path":"2021/07/06/数据结构之树结构/","link":"","permalink":"http://yoursite.com/2021/07/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91%E7%BB%93%E6%9E%84/","excerpt":"","text":"引言：本文主要介绍了树相关的数据结构。主要内容有树的基本概念、树的遍历、树的存储结构，如双亲表示法、孩子表示法、孩子兄弟表示法。以及二叉树的定义、分类、遍历。二叉树的性质、二叉树的顺序存储结构、链式存储结构，及其二叉链表的实现。最后介绍了森林相关概念以及与二叉树、树之间的转化。最后包含哈夫曼树及其编码的介绍。 参考资料： 《数据结构——从概念到C++实现》（第3版）- 王红梅 - 清华大学出版社 《数据结构——从概念到Java实现》（第2版）- 王红梅 - 清华大学出版社 《大话数据结构》（第1版）- 程杰 - 清华大学出版社 树结构知识图谱之思维导图 基本概念树的逻辑结构 树(Tree)是n(n ≥ 0)个结点的有限集，n = 0则为空树，与图一样是一种非线性结构 在任意一颗树中，有且仅有一个称为根(Root)的结点 当结点 n &gt; 1，其余结点可分为m个互不相交的有限集T1、T2、…Tm 其中每个互不相交的有限集本身又是一颗树，并称为根的子树(SubTree) 总结：有且只有有一个根结点，且子树互不相交的有限集 基本术语 结点的度、树的度（结点最大的度） 叶子节点/终端结点（度为0）、分支结点/内部结点/非终端结点（度 &gt; 1） 孩子节点、双亲结点、兄弟结点、祖先、子孙 路径、路径长度（路径所经过的边数） 结点的层数（根结点为第1层）、树的深度、树的宽度（某一层结点个数最大值） ADT123456789ADT TreeDataModel 树由一个根结点和若干棵子树构成，树中结点具有层次关系Operation initTree：初始化一棵树 preOrder：前序遍历树 postOrder：后序遍历树 leverOrder：层序遍历树 &#x2F;&#x2F;简单起见，只讨论树的遍历endADT 树的遍历 树的遍历指，按照某种次序，访问树中所有结点，且每个结点有且只有一次被访问。 若规定从左到右遍历，树的遍历一般存在3种 前序(根)遍历：每一颗子树的遍历顺序都是，根结点、从左到右 后序(根)遍历：每一颗子树的遍历顺序都是，从左到右、根结点 层序遍历，又称广度遍历：从根结点开始，自上而下，从左到右，逐层遍历 若树为二叉树、还存在一种中序(根)遍历 树的遍历都是递归遍历 示例 若存在一颗树结构如下图，则三种遍历的结果如下所示 前根遍历：ABDEIFCGH 后根遍历：DIEFBGHCA 层序遍历：ABCDEFGHI 树的存储结构 树的存储结构 设计依据 存储结构类型 双亲表示法 双亲唯一 顺序存储结构（数组 + 下标） 孩子表示法 长子唯一 顺序存储 + 链式存储结构（数组 + 下标 + 链表） 孩子兄弟表示法 长子 与 右兄弟唯一 链式存储结构（链表） 双亲表示法 除根结点外，每个一结点的只有一个双亲（parent） 结构实现数组元素 数据域（data）：存放结点数据实体 指针域（parent）：指向父节点在数组中的下标值 12345public class ParentNode&lt;T&gt;&#123; private T data; private int parent; //省略getter和setter方法...&#125; 示例图 性能与优化 双亲表示法查找性能 查找要素 查找思路 时间复杂度 双亲结点 取待查找结点的parent值在数组中取得双亲结点 O(1) 孩子结点 取待查找结点的下标索引值在数组中遍历为此索引值的parent值 O(n) 快速查找孩子：增设firstChild域可使查找第一个孩子的时间复杂度O(1) 块速查找兄弟：查找兄弟结点 &gt; 2的孩子，可在以上基础再增设一个rightSib域 孩子表示法 把每一个结点（子树）都看作是它的孩子（由长子带领）所组成的链表结构 结构实现表头结点 结点数据域（data）：存放结点数据实体 长子指针域（firstChild）：指向第一个孩子的引用 12345public class TreeNode&lt;T&gt;&#123; private T data; private ChildNode firstChild; //省略getter和setter方法...&#125; 孩子结点 指向孩子结点实体的引用（child）：孩子结点在表头数组中的数组下标位置 指向下一个孩子的指针域（next）：指向下一个孩子的引用 1234public class ChildNode&#123; private int child; private ChildNode next;&#125; 示例图 性能与优化 孩子表示法查找性能 查找要素 查找思路 时间复杂度 双亲结点 得到待查找结点的下标值，遍历表头数组，再遍历孩子链表，寻找孩子索引，即需要扫描整个表，即树的所有元素，因此时间复杂度总体为O(n) O(n) 孩子结点 没有指明需要哪个孩子，则直接可获得孩子链表 O(1) 快速查找双亲：增设一个parent域，使其查找性能为O(1) 孩子兄弟表示法 孩子兄弟表示法，又称为二叉链表，只通过链式存储结构实现 依据每个结点具有唯一的长子和右兄弟来实现 结构实现结点结构 数据域（data）：存储元素数据实体内容 长子指针域（firstChild）：指向该结点的第一个孩子的引用 兄弟指针域（rightSib）：指向该结点的右边第一个兄弟的引用 123456public class CSNode&lt;T&gt;&#123; private T data; private ChildNode firstChild; private ChildNode rightSib; //省略getter和setter方法...&#125; 示例图 性能与优化 孩子兄弟表示法查找性能 查找要素 查找思路 时间复杂度 双亲结点 扫描整个树 O(n) 兄弟结点 没有指明获取哪个兄弟结点，则直接取rightSib指针域内容 O(1) 孩子结点 没有指明获取哪个孩子结点，则直接取firstChild开始的rightSib链 O(1) (了解)存储结构的演变 可能存在描述性错误，仅供了解和参考 存储结构选型 树的存储结构中，“Xxx表示法”，则对Xxx的查找时间复杂度一般是O(1)，非Xxx对象操作则一般O(n)，O(n)即需要扫描整个树 如双亲表示法，对双亲的查找时间复杂度为O(1)，对孩子查找时间复杂度则为O(n) 孩子表示法，对孩子的查找时间复杂度O(1)，对双亲查找实际则为O(n) 因此，当需要使用树结构的场景只对一种树的元素要求频繁操作，则可以从传统的三大树的存储结构中挑选 如并查集都只涉及某节点的双亲，因此可以采用双亲表示法存储，使对双亲的操作性能上更高 如果使用树结构的场景需对多种树的元素都具有高频的操作，则需要基于传统的树的存储结构基础上进行增强。即通过添加对应其他树的元素的指针域，来实现复杂的应用场景。这一定程度上就需要通过空间复杂度和代码复杂度来换取整体的时间复杂度了 如孩子表示法，可通过增加parent域，来弥补孩子表示法对双亲操作时间复杂度O(n)的缺陷。由此来应对要求高的树结构应用场景 二叉树定义与分类逻辑结构 每个结点最多只有2颗子树（或者为空），且分别为左右子树（有序） 二叉树和树是两种独立的树结构 性质与特点：二叉树的度不大于2 分类斜树 定义：斜树，又分为左斜树和右斜树 左斜树：所有结点都只有左子树的二叉树 右斜树：所有结点都只有右子树的二叉树 性质与特点： 每一层只有一个结点 斜树的结点个数与其深度相同 满二叉树 定义：二叉树中所有结点都有两个子树 性质与特点： 叶子节点只出现再最下层 只有度为0，和度为2的结点 完全二叉树 定义：若某二叉树按层序遍历编号，与同样深度的完全二叉树的每个位置的结点编号一致 性质与特点： 一棵满二叉树肯定是一棵完全二叉树，反之则不然 完全二叉树，除去叶子结点这一层后为满二叉树 如果有度为1的结点，则该结点只有可能是左孩子 完全二叉树所有叶子节点只能集中在最下两层 遍历与逆推导二叉树遍历 二叉树由于规定了子树具有顺序，即分左子树和右子树 因此在基于树的遍历类型下，更明确遍历的树的顺序同数，还增加了中序(根)遍历方式 同样，二叉树的遍历和树的遍历，树的定义一致，属于子树的递归性操作 在进行理论层面的遍历推导时，要脱离代码进行纯理论的递归 演算，如没有左孩子，则继续分析下去，不要联想 null ，return等递归细节… 前根遍历 理论：每一颗子树的遍历顺序都是，根结点、左子树、右子树 实际：从根节点开始遍历，从上到下，按先左子树，后右子树的顺序遍历每一颗子树 特点：根节点总是在序列的首位 中根遍历 理论：每一颗子树的遍历顺序都是，左子树、根结点、右子树 实际：从根节点出发，一直寻找左子树到底（没有左子树），再遍历此时的根，再遍历右子树，再回返一步递归执行 特点：在通过遍历逆推树结构中，唯一能确定一颗二叉树 后根遍历 理论：每一颗子树的遍历顺序都是，左子树、右子树、根结点 实际：根结点出发(不遍历)，从下到上，同样按先左子树，后右子树的顺序遍历每一颗子树。最后再遍历每颗子树的根结点 特点：根节点总是在序列的末位 层序遍历 同树的层序遍历，从根结点开始，自上而下，从左子树到右子树，逐层遍历 示例 遍历逆推导推到方法 寻找根节点：前序遍历（序列首位），后序遍历（序列末位） 根据每个子树的根节点与缩减孩子集范围间，循环推导 从前序或后序遍历得出根结点后 在中序遍历中找到根结点，从而划分该根节点的左右子树范围 先取一个子树的范围序列，在前序或后续中找到该子树范围的根结点 再把得出的子树的根结点在中序遍历中找到，并进一步划分出子树的左右子树范围 以此循环类推…. 经验总结 必须含中序遍历的条件则才能唯一确定一颗二叉树 前序遍历，用于确定根后与中序遍历占位后，来确定左孩子(同时也确定子树的根，再中序域划分…) 中序遍历，主要用于，范围划分，且占位！ 后序遍历，只要用于，被划分范围后，确定根结点(范围尾部) 实例演示 二叉树性质 从满二叉树开始推到是最简单的，因为满二叉树非常规整，便于进行数学运算 满二叉树性质 深度为 k 的二叉树必有有 2 k-1个结点 第 i 层上必为的结点数为 2i -1 具有n个结点的满二叉树深度必为 log2(n + 1) 二叉树性质 深度为 k 的二叉树最多有 2 k -1个结点 第 i 层上最多的结点数为 2i -1 n0 = n2 + 1：叶子结点个数 = 度为 2 结点数 + 1 完全二叉树性质 具有 n 个结点完全二叉树深度为 ⌊𝒍𝒐𝒈𝟐𝒏)⌋ + 1 设从 1 开始按层序编号，n 为结点总数，关系如下 若 i &gt; 1，则结点 i 的双亲编号为⌊𝒊/𝟐⌋，否则为根节点 若 2i ≤ n，则结点 i 的左孩子编号为 2i，否则 i 结点无左孩子 若 2i+1 ≤ n，则结点 i 的右孩子编号为 2i + 1，否则无右左孩子 二叉树的存储结构 二叉树的存储结构一般可分为两种 顺序存储结构：完全二叉树层序遍历编码顺序存储 链式存储：二叉链表，三叉链表等 顺序存储 由于二叉树定义严格，是一种特殊的树，因此可以仅使用顺序存储结构也能实现， 通过数组下标的数量关系就能体现结点之间的全部逻辑关系 存储原理 将二叉树以完全二叉树的层序遍历编码，空缺部分均填入空指针null 对于完全二叉树，可以通过下标的数量性质就可以还原出二叉树的结构 性能分析 若二叉树表现出一条深度为k的 左/右斜树，则需开辟 2k-1 个空间存储（满二叉树存储） 造成大量空间的浪费，因此二叉树的顺序存储结构一般只用于完全二叉树 二叉链表存储原理原理 二叉链表（binary linked list）令二叉树的每个结点对应一个链表结点 链表结点除存放数据本身外，还分别有指示左右孩子的指针 链表结点属性 数据域（data）：存放数据元素实体 左孩子指针域（lchild）：指向该结点的左孩子结点 右孩子指针域（rchild）：指向该结点的右孩子结点 代码实现1234567public class BiNode&lt;T&gt;&#123; private T data; //数据域 private BiNode&lt;T&gt; lChiled,rChild; //左右孩子指针域 public BiNode(T element)&#123; this.element = element; &#125;&#125; 三叉链表 在二叉链表中，如果需要找到它的双亲结点则需要从根结点开始扫描 若需频繁搜寻双亲结点，则建议使用三叉链表，即在二叉链表基础添加一个指向双亲的引用 属性 数据域（data）：存放数据元素实体 左孩子指针域（lchild）：指向该结点的左孩子结点 右孩子指针域（rchild）：指向该结点的右孩子结点 双亲指针域（parent）：指向该结点的双亲结点 代码实现1234567public class TirNode&lt;T&gt;&#123; private T data; //数据域 private BiNode&lt;T&gt; lChiled,rChild,parent; //左右孩子指针域、双亲指针域 public BiNode(T element)&#123; this.element = element; &#125;&#125; 二叉链表实现ADT 依据二叉树的抽象数据类型，定义二叉树的Java接口 12345678public interface BinaryTreeInterface&lt;T&gt;&#123; public void preOrder(); //前根遍历二叉树 public void inOrder(); //中根遍历二叉树 public void postOrder(); //后根遍历二叉树 public void levelOrder(); //层序遍历二叉树 //创建二叉树,返回根节点 public BiNode&lt;T&gt; creatBiTree(SequentialList&lt;T&gt; treeElement);&#125; 二叉链表实现，二叉链表结点 1234567public class BiNode&lt;T&gt;&#123; private T data; //数据域 private BiNode&lt;T&gt; lChiled,rChild; //左右孩子指针域 public BiNode(T element)&#123; this.element = element; &#125;&#125; 二叉链表 1234public class BinaryTree&lt;T&gt; implements BinaryTreeInterface&lt;T&gt;&#123; private BiNode&lt;T&gt; root; //根节点 //实现相关ADT定义&#125; 构建二叉树扩展二叉树 由于前、中、后根遍历任何一个单一的序列都不能唯一确定一棵二叉树（主要是度为1的左右子树） 为了能让每个结点确认是否有左右孩子，将其每个结点的空指针处引出一个虚结点 这种扩展后的二叉树称为扩展二叉树，它遍历后的序列能唯一确定一颗二叉树 构建原理 通过扩展二叉树构建二叉树的原理在于，把每一个结点都看作一个子树的根结点 根据给出的扩展二叉树遍历序列，以同样的遍历次序扫描序列，若不为”#”则创建结点 递归实现 version 1.0：逻辑更贴切，但代码可优化，将if-else的条件反转，可减少一个取反操作 ! 12345678910111213141516171819202122232425//记录序列顺序表遍历的索引。由于java没有具备static，因此只能通过声明全局变量的方式实现private int index = 0;/** * 通过前序扩展二叉树序列，初始化二叉链表 * @param treeElement 扩展二叉树序列 * @return 初始化后的二叉链表根结点 */@Overridepublic BiNode&lt;T&gt; creatBiTree(SequentialList&lt;T&gt; treeElement) &#123; //声明待创建结点引用 BiNode&lt;T&gt; node = null; ++index; //结点存在 //index &lt; treeElement.length，相当于在递归中进行for循环遍历 if(index &lt; treeElement.length() &amp;&amp; !(&quot;#&quot;.equals(treeElement.getElement(index))))&#123; node = new BiNode&lt;&gt;(treeElement.getElement(index)); node.setlChild(creatBiTree(treeElement)); node.setrChild(creatBiTree(treeElement)); &#125;else &#123; return null; &#125; return node;&#125; version 2.0，反转了if-else判别条件，功能一样，代码效率更高，推荐！ 12345678910111213141516171819202122//顺序表遍历索引private int index = 0;/** * 通过前序扩展二叉树序列，初始化二叉链表 * @param treeElement 扩展二叉树序列 * @return 初始化后的二叉链表根结点 */@Overridepublic BiNode&lt;T&gt; creatBiTree(SequentialList&lt;T&gt; treeElement) &#123; BiNode&lt;T&gt; node = null; ++index; if(index &gt; treeElement.length() || &quot;#&quot;.equals(treeElement.getElement(index)))&#123; return null; &#125;else &#123; node = new BiNode&lt;&gt;(treeElement.getElement(index)); node.setlChild(creatBiTree(treeElement)); node.setrChild(creatBiTree(treeElement)); &#125; return node;&#125; 前根遍历遍历原理 如同树与二叉树所定义的前根遍历，过程本身就是一个递归过程 因此代码实现可以考虑同样使用递归实现 其他的中根、后根遍历代码类似，只是遍历顺序不一样而已 二叉树前序遍历的递归调用过程示意图，有需要可以参考 递归实现12345678910111213141516171819202122/** * 二叉树前序遍历 */@Overridepublic void preOrder() &#123; preOrder(root); System.out.println();&#125;/** * 前序遍历递归实现的重载方法 * @param node */private void preOrder(BiNode&lt;T&gt; node)&#123; if(node == null)&#123; return; &#125;else&#123; System.out.print(node.getData() + &quot; &quot;); //根结点先遍历 preOrder(node.getlChild()); //左子树遍历 preOrder(node.getrChild()); //右子树遍历 &#125;&#125; 中根遍历1234//同理前根遍历代码inOrder(node.getlChild()); //左子树先遍历System.out.print(node.getData() + &quot; &quot;); //根结点遍历inOrder(node.getrChild()); //右子树遍历 后根遍历1234//同理前根遍历代码postOrder(node.getlChild()); //左子树先遍历postOrder(node.getrChild()); //右子树遍历System.out.print(node.getData() + &quot; &quot;); //根结点最后遍历 层序遍历遍历原理 层序遍历规定，先访问完一层的结点后，再对下一层的结点访问。不涉及递归访问 此时可以利用队列作为辅助结构 初始化队列 若二叉树非空，则将根节点入队 循环直到队列为空 队头结点q出队并返回其数据域，输出结果 若q存在左孩子，则将左孩子入队 若q存在右孩子，则将右孩子入队 下图为通过队列实现层序遍历的过程示意图： 队列实现12345678910111213141516171819202122232425/** * 二叉树层序遍历实现 */@Overridepublic void levelOrder() &#123; LinkedQueue&lt;BiNode&gt; queue = new LinkedQueue&lt;&gt;(); if(root == null)&#123; return; &#125; queue.enQueue(root); BiNode&lt;T&gt; node = null; while (!queue.isEmpty())&#123; node = queue.deQueue(); System.out.print(node.getData() + &quot; &quot;); if(node.getlChild() != null)&#123; queue.enQueue(node.getlChild()); &#125; if(node.getrChild() != null)&#123; queue.enQueue(node.getrChild()); &#125; &#125; System.out.println();&#125; 森林基本概念定义 森林：m（m≥0）棵互不相交的树的集合 遍历 同树遍历定义 树转换为二叉树树转换为二叉树：“加兄保子调层次” 加兄： 所有兄弟节点之间加一条线 保子：每个结点，只保留 firstchild 的连线，其余均删除 层次调整： 原树为基准每个结点除第一个孩子为左孩子外，其余孩子为这个左孩子的右孩子的右孩子的右孩子… 森林转换为二叉树森林转换为二叉树：“森林变树，依次连根” 森林变树：把森林的每颗树转换为二叉树 依次连根：第一颗树不动，其余树依次成为上一颗树根结点的右孩子 二叉树转化为树或森林二叉树转换为树或森林：“加线、去线，若二叉树有右孩子，则会转换为森林” 加线：把每个结点第一个左孩子的右孩子序列，与该结点相连 去线：删除原二叉树每个结点与右孩子的连线 最优二叉树背景 最优二叉树又称为哈夫曼树或赫夫曼树，其应用是哈夫曼编码，用于数据压缩和解压 哈夫曼编码的目的是，让单一的线性的区分结构，通过权/频率，且用二叉树来体现权。从而开始基于从路径长度上进行优化，从而使得，在代码执行上缩短总的执行次数。 在存储空间上可以应用在设计长短不等的编码，在通过编码的层面上实现无损的数据压缩(哈夫曼编码) 基础概念带权路径长度 若给二叉树中的每个叶子结点赋予一个有意义的数值量，即权值 此时从根节点到各个叶子结点的路径长度与相应叶子结点权值的乘积，之和称为该二叉树的带权路径长度WPL（weighted path length） 最优二叉树定义 其中一棵二叉树中带权路径WPL最小的形态为该树的最优二叉树，也称为哈夫曼树 构建哈夫曼树理论指导若想一颗二叉树的WPL最小，即构建最优二叉树，则必须 权值越大的叶子节点越靠近根结点 权值越小的结点越远离根结点 而且不存在度为1的结点 构建方法 选取合并：从给定权值集合中选取权值最大的两个结点合并，将合并的权值作为这两个结点双亲结点(新结点) 删除与加入： 删除：从给定权值集合中删除刚刚合并的结点权值 加入：将合并权值后的双亲结点作为新结点加入权值集合中 重复步骤1，2直至权值集合为空 哈夫曼结点结构 若采用顺序存储结构，则一个哈夫曼结点结构如下 12345678910111213public class HuffmanNode&#123; private int weight = -1; private int parent = -1; private int lChild = -1; private int rChild = -1; public HuffmanNode(int weight,int iChild,int rChild)&#123; this.weight = weight; this.iChild = iChild; this.rChild = rChild; &#125; //省略getter和setter方法...&#125; 哈夫曼编码基本概念 表示字符集的简单方法是列出所有字符，给每个字符赋予一个二进制位串，称为编码（coding） 假设所有编码都等长，则表示n个不同的字符需要⌈log2 n⌉位，这称为等长编码（equal-length code） 如果每个字符的使用频率相等，则等长编码是空间效率最高的方法 如果字符出现的频率不等，可以让频率高的字符采用尽可能短的编码，频率低的字符采用稍长的编码，来构造一种不等长编码（unequal-length code），这也是文件压缩技术的核心思想 而不等长编码实现的最基本条件是前缀无歧义编码，简称前缀编码 而通过哈夫曼树进行的编码正是最优的不等长编码，因此也称为哈夫曼编码 编码过程 通过给定的字符频率表建立哈夫曼编码树 将字符数据本身作为叶子结点 将字符出现的频率作为叶子节点的权值 规定编码，左子树路径为二进制0/1，右子树路径为二进制1/0 则每个字符的编码即是从根节点到该字符叶子结点路径上构成的二进制串 解码过程 从左到右逐位判别，直到先确认一个字符为止，(“先确先得”) 如上图示例：编码为110100101，解码为 ADBE 性质与特点 不等长编码且唯一解码 所有结点度为 0 或 2(不存在度为 1 的最优二叉树) 相关指标 平均编码长度：叶子结点的平均深度 编码总长度：带权路径长度 非二进制哈夫曼编码 多于二进制的哈夫曼编码：多分支，不够结点组合加入权值 0 结点组合 扩展与应用扩展二叉树非递归遍历线索链表应用堆与优先队列并查集","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构之字符串和多维数组","slug":"数据结构之字符串和多维数组","date":"2021-07-05T15:44:23.000Z","updated":"2021-08-25T15:27:11.801Z","comments":true,"path":"2021/07/05/数据结构之字符串和多维数组/","link":"","permalink":"http://yoursite.com/2021/07/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/","excerpt":"","text":"引言：本文主要介绍了字符串与多维数组这两种数据结构。含串的概念，模式匹配算法的介绍。含BF算法、KMP算法、解析KMP算法的实现与设计原理。介绍多维数组的逻辑结构，存储结构及其映射到内存中的计算。最后介绍了矩阵压缩存储原理，特殊矩阵、稀疏矩阵的压缩原理及其相关数据结构。 参考资料： 《数据结构——从概念到C++实现》（第3版）- 王红梅 - 清华大学出版社 《数据结构——从概念到Java实现》（第2版）- 王红梅 - 清华大学出版社 《大话数据结构》（第1版）- 程杰 - 清华大学出版社 知识结构思维导图 字符串串的定义字符串（String，简称“串”），是n（n ≥ 0）个字符组成的有限序列，字符个数称字符串长度 零个字符串称为空串(null string)即，“ ‘’” ” 子串：字符串中任意个连续的字符组成的子序列称为该串的子串 主串：包含子串的串称为主串 常见字符编码集 标准ASCII编码：用7位二进制数表示128个字符 (可表示英语为主的语言) 扩展ASCII编码：用8位二进制数表示256个字符 (可表示英语为主的语言和特殊字符) Unicode编码：用16位二进制表示216个字符，约6.5万多个字符(足以表示全世界成百上千种语言和文字) 串的比较 字符串的比较在计算机中默认以字母顺序从前往后，从小到大(ASCII码) 比较时，从左往右挨个比较串中字符 串的比较可以分为两类讨论 等长字符串比较 不等长字符串比较 等长比较 等长指串长度相同的两个字符串之间比较，从前往后挨个字符比较，首先判断到大的为大 例如：”abcde &gt; abcce“ 不等长比较不等长指串的长度不同的两个字符串之间比较，又分为两种情况 情况1：完全包含关系，即某个串只是比另一个串单纯地多出了几个字符，则长度大的字符串大 例如：“happy” &gt; “hap”，单纯多出“py”，属于完全包含关系 情况2：非包含完全包含关系，则类似与等长比较方式，挨个字符比较，优先大者为大 例如：”happy &gt; happen“ 逻辑与存储结构逻辑结构 有上述串的定义可知，串本质是一组有限字符序列，属于线性结构 存储结构由于字符串在计算机中大量使用，一般都会选择顺序存储结构实现来节省开销 方式一：将字符从数组0号单元开始存储数据，最后一个单元存储串的长度 方式二：用数组0号单元存储串的长度，其他单元存储字符串（汇编常用） 方式三：从数组0号单元开始存储数据，以特殊字符作为字符串结束符，如'\\0'（高级语言常用），这种方式不能直接得到字符串长度，需遍历获得 模式匹配 在主串S中寻找子串T的过程称为模式匹配（pattern matching），T称为模式（pattern） 一般模式匹配指返回匹配到的子串第一次出现的位置 模式匹配在计算机中使用频率非常高，因此算法性能要求尤为重要 BF算法基本概念 BF算法，即暴力(Brute Force)算法，基本思想是暴力匹配、蛮力匹配 原理 子串从主串的首位开始逐一字符匹配 若子串中任意一个字符匹配失败，则整个子串从上一次主串匹配的位置的下一个位置开始重新匹配 以此循环，直至存在子串的每一个字符均被匹配正确的情况 示例：设主串S=”abcabcacb”，模式T=”abcac”，BF算法的匹配过程如下图所示 代码实现 推荐BF实现代码，仅使用一个while循环实现，而且索引分工明确，操作清晰 一般实现思路是双重for循环，代码复杂而且索引管理麻烦 代码出处：《数据结构——从概念到Java实现》（第2版）- 王红梅 - 清华大学出版社 123456789101112131415161718192021222324252627/** * 基于BF算法实现的模式匹配 * @param str 主串 * @param substr 子串 * @return 返回子串在主串中第一次出现的位置，不存在返回-1 */public int indexOfBf(String str,String substr){ int start = 0; //主串每次进行新一轮匹配的位置 int i = 0,j = 0; //i，主串匹配中的索引变化，j，子串匹配过程中索引变化 //主串也参与循环判断条件能使主串长度 &lt; 子串长度，也可返回真确结果，即-1，找不到 while (i &lt; str.length() &amp;&amp; j &lt; substr.length()){ if(str.charAt(i) == substr.charAt(j)){ i++; j++; }else { start++; //主串回溯到上一次开始匹配位置，从下一个位置开始新一轮匹配 i = start; //为新一轮主串匹配索引变量i赋值 j = 0; //子串总是回溯到初始位置 } } //若子串匹配了所有字符，则证明匹配成功，返回该轮此的主串索引 if(j &gt;= substr.length()){ return start; } return -1;} 性能分析 BF算法，设主存长度为n，子串长度为m。最坏情况下的时间复杂度为，O(n * m) BF算法性能低下的根本原因在于，主串每一次开始匹配的位置i，进行了不必要的回溯 KMP算法基本概念 KMP算法是克努思（Knuth）、莫里斯（Morris）和普拉特（Pratt）同时设计的 KMP是一种对BF算法很大改进的模式匹配算法 改进的出发点在于主串的匹配位置不进行不必要的回溯。 原理 tips，下述原理说明默认字符串从数组下标为 1 开始存储 KMP原理 KMP算法的核心就是基于BF算法避免主串匹配位置一些不必要的回溯 这种 ” 不必要的回溯 “ 可以分为两种类型分析 情况1：匹配的子串的字符各不相同 情况2：匹配的子串内存在相同子串 实际应用是以上两种情况的结合体，可以将KMP算法总结为如下两句话： 子串的字符各不相同：”因为不同所以不同，跳过不同！“ 子串内存在相同子串：”因为相同所以相同，跳过相同！“ 注：分析每一种情况时，都是基于一定条件下分析，不要脱离了前提 子串字符各不同 情况1：子串的字符各不相同 避免回溯原理：”因为不同所以不同，跳过不同！“ 设主串S=”abcdefgab”，子串T=”abcdex“（子串的字符各不相同），分别展示BF算法与KMP都优化 BF算法 采用BF算法，匹配6次的情况 KMP优化 由于子串内的字符各不相同，子串一旦出现不匹配，在此之后子串长度下的主串不可能匹配到一个完整的子串出来 因此KMP算法对上图BF算法的2、3、4、5步这些不必要的回溯进行了优化（省略） 同样得匹配结果，KMP算法对比上述的BF算法仅需匹配2次 子串内存在相同子串 情况2：子串内存在相同子串 避免回溯原理：”因为相同所以相同，跳过相同！“ 设主串S=”abcababca”，子串T=”abcabx“（子串内存在相同子串”ab“），分别展示BF算法与KMP都优化 BF算法 采用BF算法，的6次匹配结果 KMP优化 由于子串中存在相同部分子串，因此子串在每一次进行匹配的过程中，子串中相同部分的子串都在参与匹配 在如果之前子串中的子串匹配成过或者不成功，都是跳过之前子串的子串 子串中的子串成功过：下次就从跳过子串的子串匹配成功过的位置开始匹配剩余的部分 子串中的子串刚好是匹配失败：下次就跳过子串的子串匹配失败的位置从头开始匹配子串 ，如上图的BF算法第一次匹配，子串数组下标的3、4的”ab”。则无需再对这部分相同的子串的部分子串匹配，即4、5步骤是没必要的，因为在第1步已经匹配过 KMP对于上图的BF算法优化后仅需2次匹配 综合情况KMP匹配 示例：设主串S=”abcababca”，子串T=”abcabx“，一下为基于BF算法KMP进行两步优化的过程 代码实现next数组设计 观察上述的KMP算法实现过程，可以看出主串匹配位置i，在匹配过程中没有回溯过 而子串匹配位置j则通过不同情况进行回溯，主要根据子串本身结构（互不相同，存在相同部分） 当子串没有任何重复的字符时：主串不回溯，子串匹配回溯到初始位置（上图的1） 当子串中存在重复的字符串时：主串不回溯，子串回溯到当前子串已匹配串中第一个重复子串的下一个位置(语句是正确的，只是不宜在此展开说明)，根据子串重复程度进行回溯到重复字符串的下一个位置（上图的3） 结论：主串不回溯，子串根据子串重复程度回溯，重复程度越低回溯越多 为了便于KMP算法代码实现，设计一个专门用于记录子串在任意位置匹配失败情况下，该位置对应需子串回溯的位置数组，该数组称为 ” next数组 “ 这种功能分离设计，使得KMP匹配过程的系处理的逻辑少很多 只要出现不匹配情况，调用事先计算好的next数组即可获得子串需回溯的位置了 而主串在KMP算法中一直不进行回溯 next数组结构tips：以下简述的代码实现均以字符串从数组下标为 0 开始存储说明 结构分析 next数组：专门用于记录子串在任意位置匹配失败情况下，该位置对应KMP思想需子串回溯的位置的数组 next数组结构含义：next[ j ] = k j ： 表示在匹配过程中，出现子串不匹配时的子串索引位置， 也可理解为当次匹配失败过程中，已经匹配通过的前部分子串的结束索引 k： 以KMP算法两步优化原则，将当次匹配失败过程中的已经匹配通过的子串部分进行分析(主要寻找相同)，得出匹配失败位置j需要子串回溯的位置value next功能示例 设存在子串T = “ababc“，子串匹配位置为 i ，next [ i ] = k j = 0，已匹配子串 = “”，k = -1：索引0字符匹配失败，不存在已匹配的子串，无法挖掘隐含信息，不存在回溯，即 i 不变(这种特殊情况将k记录为-1) j = 1，已匹配子串 = “a”，k = 0：索引1字符匹配失败，仅有一个字符无法挖掘隐含信息，若失败只能重写匹配，即回溯到子串初始位置，k = 0; j = 2，已匹配子串 = “ab”，k = 0：索引2字符匹配失败，此时已匹配子串字符各不相同，若失败则不应该回溯到子串的初始位置，而应该跳过这两个字符，注意，这里跳过两个字符不是通过k = 2去定位回溯位置，而是通过主串不回溯，子串从0位置开始匹配来实现跳过这两个字符，因此k=0 j = 3，已匹配子串 = “aba”，k = 1：索引3字符匹配失败，此时存在相同子串….. j = 4，已匹配子串 = “ababc”，k = 2：索引2字符匹配失败，存在最大相同子串ab 为什么最大重复子串的长度的值就是子串回溯的位置值？ 因为子串需回溯的是就是第一个最大重复子串的下一个位置，而数组从0开始存储，因此最大重复子串长度的值刚好就是第一个出现最大重复子串结尾的下一个位置的值 next指导下KMP算法示例图，同为模式T=”ababc“，则next数组的值为{-1,0,0,1,2} next数组计算 next数组数值上体现的就是，子串中每个位置前的所有字符构成的子串存在最大重复子串的串的长度 计算原理 本文采用next数组计算规约如下 公式推导示例（不常用） 个人快速计算示例（自用，常用） 代码实现 若按照next理论计算的思路编写代码，本人应该能写出时间复杂度为O(n2)的next计算代码 但暂时还无法理解《大话数据结构》中O(n)复杂度实现的next计算的代码实现思路 由于O(n)的next代码实现貌似，在求子串next数组的过程中再利用了已求得的next数组 即上一个位置next数组求值的结果作为下一次求next值辅助，是非常复杂的 参考代码：以下以j = 0时候，k = -1，且字符串从数组0开始位置存储规约下O(n)next计算代码 基于《大话数据结构》实现逻辑，以上规约，的java实现版 ————————————————版权声明：本文为CSDN博主「whattress」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_43860800/article/details/103695079 123456789101112131415161718/** * 用于生成部分匹配表next * @param sub 模式串 * @return */private static int[] getNext(String sub) { int[] next = new int[sub.length()+1]; int i = 0, j = -1; next[0] = -1; while(i&lt;sub.length()){ if (j==-1 || sub.charAt(i) == sub.charAt(j)){ next[++i] = ++j; }else { j = next[j]; } } return next;} next数组指引下的KMP匹配过程next指导下KMP算法示例图，同为模式T=”ababc“，则next数组的值为{-1,0,0,1,2} KMP代码实现 但暂时还无法理解《大话数据结构》中O(n)复杂度实现的next计算的代码实现思路 参考代码： ————————————————版权声明：本文为CSDN博主「whattress」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_43860800/article/details/103695079 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * KMP工具类 */public class KMP { /** * 用于计算匹配的位置（从头到尾） * @param str 主串 * @param sub 模式串 * @return */ public static int kmp(String str, String sub) { int i = 0,j = 0; int[] next = getNext(sub); while (i &lt; str.length() &amp;&amp; j &lt; sub.length()){ if(j == -1 || str.charAt(i) == sub.charAt(j)){ i++; j++; }else { j = next[j]; } } if(j == sub.length()) return i-j; else return -1; } /** * 用于生成部分匹配表next * @param sub 模式串 * @return */ private static int[] getNext(String sub) { int[] next = new int[sub.length()+1]; int i = 0, j = -1; next[0] = -1; while(i&lt;sub.length()){ if (j==-1 || sub.charAt(i) == sub.charAt(j)){ next[++i] = ++j; }else { j = next[j]; } } return next; }} 性能分析 KMP算法的时间复杂度O(n + m)，n为主串长度，m为子串长度 KMP核心总结 KMP算法核心思想是：”一次匹配原则“，即充分利用每一次匹配得出所有隐含信息，作为下次匹配的辅助信息，从而减少不必要的匹配过程 主串不回溯，子串根据子串重复程度回溯(根据next数组回溯)，重复程度越低回溯越多 next数组记录的是子串每一个索引位置出现匹配失败是子串匹配索引应回溯的位置 next[j] = 0，表示不存在重复子串，主串不回溯，子串回溯到0 next[j] &gt; 0，表示存在重复子串，且重复子串长度为next[j]，回溯位置为next[j]（数组从0开始） KMP算法通过对子串在匹配过程每一个位置匹配失败时，已经匹配了的那一部分的子串进行优化分析，即根据已匹配子串的特性，挖掘出对应的隐含信息，并将其记录下来(next数组)，为下次匹配提供优化 特性1，已匹配的部分子串的字符各不相同：”因为不同所以不同，跳过不同！“，主串不用回溯 特性2，已匹配的部分子串内存在相同子串：”因为相同所以相同，跳过相同！“，隐含特性1，主串不回溯且子串只回溯到最大重复子串位置的下一个位置 算法对比 BF算法： 主串回溯（总是回到上一次匹配的下一个位置），子串回溯 时间复杂度O(n * m)，n为主串长度，m为子串长度 KMP算法： 主串不回溯，子串根据子串重复程度回溯，重复程度越低回溯越多 时间复杂度O(n + m)，n为主串长度，m为子串长度 扩展KMP算法改进多维数组逻辑结构 数组（array）是由类型相同的数据元素构成的有序集合 每个数据元素称为一个数组元素，每个元素受线性关系约束 存储结构与寻址存储结构 数组是一种特殊的数据结构，一般要求能够随机存取，因此通常采用顺序存储结构 数组的基本操作：读操作、写操作 多维映射与寻址多维映射 由于内存单元是一维结构，因此顺序存储结构的多维数组需要通过计算地址映射到一维结构中 常用映射方式有两种 按行优先（行序为主序）：先行后列 按列优先（列序为主序）：先列后行 寻址计算计算方法无论是多维数组映射一维内存，还是各种矩阵压缩算法，计算步骤一致 计算以当前数据增长方向的 i - 1 行/列（占满部分）所占数目（一般用数列计算） 计算同一行/列相差的数目（最后的定位） 两种相加就是最后隐射后的结果 例题题目：数组A[0..5，0…6]的每个元素占5个字节，将其按列优先次序存储在起始地址为1000的内存单元中，则元素A[4，5]的地址是？ 答案：1170 解析：[（6 * 5 + 5）- 1 ] * 5 + 1000 = 1170，-1是因为除去第一个位置的地址 矩阵的压缩存储 实际应用中，矩阵往往存在很多相同的值，有些还分布有一定规律 因此可以对这种些类型的矩阵进行压缩存储，从而节省存储空间 一般可压缩的，有一定规律的矩阵有，特殊矩阵和稀疏矩阵 特殊矩阵概念 特殊矩阵：具有很多相同值元素，且分布有规律的矩阵 特殊矩阵一般又分为，对称矩阵、三角矩阵、对角矩阵 对称矩阵：矩阵中元素关于主对角线对称 三角矩阵（上三角/下三角）：有一三角部分的元素值是一样的（不含主对角线） 对角矩阵：除主对角线未中心的带状区域外，其他元素均为0 对称矩阵压缩存储 对称矩阵：只需存储下三角部分（包括主对角线） 存储下三角部分寻址计算示意图： 三角矩阵压缩存储 三角矩阵：只需存储存储非一致数据的那部分三角（含主对角线） 上三角矩阵存储寻址计算示意图 对角矩阵压缩存储 对角矩阵：只需存储中间带状部分的数据 对角矩阵压缩存储示意图 稀疏矩阵概念 稀疏矩阵：有很多分布没有规律的零元素 因此存储非零元素时，需要用特定的数据结构记录每一个非零元素的位置和数据 顺序存储结构：三元组顺序表 链式存储结构：十字链表 三元组顺序表结构实现属性 三元组（非零元素）：行号（row）、列号（col）、非零元素值（item） 三元组顺序表：三元组、总行数（mu）、总列数（nu）、非零元素个数（tu）、数组容量 代码实现 三元组 1234public class Element{ private int row,col; //行号row，列号col private int item; //非零元素值item} 三元组顺序表 12345public class SparseMatrix{ private final static int MAX_TERM = 100; //数组容量 private Element[] list = new Element[MAX_TERM]; private int mu,nu,tu; //总行数、总列数、非零元素个数} 存储示例 稀疏矩阵三元组顺序存储对照图 十字链表结构实现 十字链表基于三元组顺序表的基础实现，为每个三元组结构添加指向左边和下面的指针域 通过这些指针域链接起来的稀疏矩阵，即为十字链结构 属性 十字链表结点（新三元组）：element、right、down 代码实现 三元组（域三元组顺序表的三元组一致） 1234public class Element{ private int row,col; //行号row，列号col private int item; //非零元素值item} 十字链表结点 1234public class OrthNode{ private Element data; private OrthNode right,down;} 存储示例 十字链表存储稀疏矩阵示例图 扩展稀疏矩阵的转置运算广义表发纸牌八皇后问题","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构之基础与线性结构","slug":"数据结构之基础与线性结构","date":"2021-07-04T14:31:23.000Z","updated":"2021-08-25T15:27:11.752Z","comments":true,"path":"2021/07/04/数据结构之基础与线性结构/","link":"","permalink":"http://yoursite.com/2021/07/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/","excerpt":"","text":"引言：本文主要介绍了数据结构一些基础概念，算法基础，线性结构相关的数据结构。如线性表、栈、队列结构，单链表、双链表、循环链表、循环双链表、顺序与链栈、循环队列、链队列。栈包含了顺序栈、链栈结构。介绍了顺序队列的实现，假溢出现象，以及链队列的实现。 参考资料： 《数据结构——从概念到C++实现》（第3版）- 王红梅 - 清华大学出版社 《数据结构——从概念到Java实现》（第2版）- 王红梅 - 清华大学出版社 《大话数据结构》（第1版）- 程杰 - 清华大学出版社 知识思维导图 数据结构绪论相关术语 数据：能输入到计算机并能够被识别与处理的符号 数据元素：程序中以一个整体进行考虑与处理的数据。是数据的基本单位 数据项：构成数据元素的最小单位 数据结构定义 “结构即关系“，研究数据结构就是研究数据间的关系(线性关系、树形关系、图等) 数据结构是相互之间存在一定关系的数据元素的集合 数据结构主要由逻辑结构、存储结构、基本操作三大方面组成 “程序 = 数据结构 + 算法” 逻辑结构 逻辑结构：是指数据对象中数据元素之间的相互关系 常见逻辑结构有： 集合结构 线性结构 树结构 图结构 集合结构 集合结构中的数据元素除了同一个集合外，它们之间没有其他关系 它们相互平等，唯一且共同的属性就是“同属一个集合”，类似数学的集合，形如“鱼塘” 线性结构 线性结构中的数据元素之间是一对一的关系，类似“火车，项链” 在数据结构中，线性表、队列、栈都是一种线性结构 树结构 树形结构中的数据元素之间存在一种一对多的的层次关系。形如“大树”分支 不过在数据结构中，更像一颗倒置的树 图结构 图形结构的数据元素是多对多的关系，类似“人际关系”，交错复杂 存储结构 存储结构，有称物理结构，是指数据的逻辑结构在计算机中的存储形式 常见存储结构：顺序存储结构，链式存储结构 顺序存储结构 数据元素存放在连续的地址存储单元内，如数组 数据间的逻辑关系通过元素的存储位置来表示，两者之间具有直接的数量关系 因此顺序存储结构的数据结构一般具备”随机存取“特性 随机存取(不是存储)：计算任意位置元素的地址时间相等，时间复杂度O(1) 链式存储结构 数据元素存放在任意的存储单元内，如“叫号排队” 数据间的逻辑关系与元素的存储位置无关 链式存储结构是计算机存储单元的基础，即 “ 地址 ——&gt; 内容“的存储结构 一般的编程语言都会提供 ” 主动申请空间并返回该空间的引用 “ 这样的动态分配内存空间的语法操作 C语言的malloc()函数 Java中的new关键字操作 链式存储结构一般具备“顺序存取”特性 即获取任意位置元素都需要从头顺序遍历后才可得出，平均时间复杂度位O(n) ADT 抽象数据类型（Abstract Data Type，ADT），指某类数据结构的数学模型 对于代码来说就是某类数据结构所定义的一组通用操作，如增删改查等 算法概论算法的概念 算法定义：对特定问题求解步骤的描述，表现为指令的有限序列 算法的特性：输入、输出、有穷性、确定性、可行性 输入 输出 有穷性 确定性 可行性 0或n个 至少1个 有穷步骤且有穷时间内结束 每一步骤含义不存在二义性 可转换为程序语言并执行 算法分析时间复杂度分析方法 确定输入规模：一般为循环的结束索引 一般时间复杂度分析都是对循环的分析，只有分支结构约为O(1) 找出关键执行语句：一般是最内层循环的执行语句 写出在输入规模的影响下与关键执行语句执行次数变化 数列统计计算：一般前n项和为终止条件，项数即为执行次数 等差数列前n项和公式 n为项数，a1首项，an尾项，Sn为前n项和 n为项数，a1首项，d为公差，Sn为前n项和 等比数列前n项和公式： n为项数，a1首项，q公比，Sn为前n项和 n为项数，a1首项，an尾项，q公比，Sn为前n项和 化简为大O记号表示 去除所有加减运算的常数项，用常数1取代运行时间中的所有加法常数 只保留最高阶项 若最高阶项存在且不是1，则去除与这个项相乘的常数 化简示例： 例题e.g.1 代码 1234for(i = 1;i &lt; n;i++){ for(j = 1;j &lt; n;j++) x++;} 解析：大循环每执行一次，都要执行n次小循环，则x++;，时间复杂度为O(n2) e.g.2 代码 1234for(i = 1;i &lt;= n;i++){ for(j = 1;j &lt;= i-1;j++) x++;} 解析： i值(项) 关键语句执行次数(j - 1值) 1 1-1 = 0 2 2-1 = 1 3 2 … … n n-1 由上述可见，总执行次数，即为一个首项为0，尾项是n-1，公差是+1，项数是n的等差数列Sn = n(a1 + an) / 2，可算出关键语句的执行次数是，n(n-1)/2，即时间复杂度为O(n2) e.g.3 代码 123for(i = 1;i &lt;= n; i = 2*i){ x++;} 解析： 每次i乘2之后，就距离n更接，而需要乘多少次(执行多少次)，才能跳出循环(等于n)？ 假设乘的次数设为x，则2x=n，逆推得到执行次数x=log2n 常见时间复杂度排序 O(1) &lt; O(log⁡n) &lt; O(n) &lt; O(nlog⁡n) &lt; O(n2) &lt; O(n3) &lt; O(an) &lt; O(n!) &lt; O(nn) 阶 非正式术语 常见结构 例 O(1) 常数阶 顺序结构、无循环分支结构 x++: O(log n) 对数阶 循环**索引线性增长斜率＞1 ** for(i=1;i&lt;=n; i=2 * i){} O(n) 线性阶 单循环结构 for(){} O(nlog n) nlog n阶 略 略 O(n2) 平方阶 二层内嵌循环结构 for(){for(){} } O(n3) 立方阶 三层内嵌循环 for(){for(){for(){}} } an 指数阶 略 略 空间复杂度 算法空间复杂度是指代码执行过程中需要的辅助空间。不含算法的代码本身与输入输出数据 即，若算法中声明的变量是可确定的，则空间复杂度为O(1)，反之不确定的，动态的，则另行分析 假设我们的算法需要把栈里面的元素逆置，算法中采取开辟一个与该栈同一大小的数组/顺序表暂存，则此时空间复杂度为O(n)，n为栈内元素总和，因为该算法需要的辅助空间是不确定的、动态的 最坏情况与平均情况 最坏情况指一个算法存在的最低执行效率情况 平均运行时间，见名知意就是指通过大量实验测试得出的平均的执行效率 通常，除非特别指定，提及的运行时间都是指最坏情况的运行时间 平均运行时间是所有情况中最有意义的，它属于期望的运行时间 扩展-递归算法时间复杂度分析 2021-07-03 略 线性表 注意，本文所描述线性表的逻辑索引值均从1开始，而底层数组存储从索引0开始 逻辑结构 线性表指n(n≥0)个数据元素类型相同的有限的，序列( a1, a2,… an) 序列中，a1无前驱， an无后继，其他的每个元素仅有一个前驱和后继 ADTADT描述123456789101112ADT ListDataModel 线性表中的数据元素具有相同类型，相邻元素具有前驱和后继关系Operation initList：表的初始化，建一个空表 length：求表的长度 getElement：在表中取序号为 i 的数据元素 locate：在线性表中查找值等于 x 的元素 insert：在表的第 i 个位置处(前)插入一个新元素 x delete：删除表中的第 i 个元素 isEmpty：判断表是否为空endADT Java接口ADT1234567891011public interface ListInterface&lt;T&gt; { void printList(); //遍历线性表 int length(); //球线性表的长度 int locate(T element); //按值查找 T getElement(int i); //按位查找 void add(T element); //顺序添加数据 void insert(int i,T element); //在指定逻辑位置插入 T delete(int i); //删除指定逻辑位元素 boolean isEmpty(); //判断表空 void clear(); //清空表数据} 顺序表 参考代码 概念 顺序表（SequentialList）指用顺序存储结构实现的线性表 第n个数据 1 2 3 … 数组下标 0 1 2 … 数据 10 12 34 … 结构实现一维数组顺序存储属性 一维数组（list）：声明一个用于存储线性表数据的一维数组 数值型参数（length）：记录线性表中实际元素个数 数值型参数（LIST_SIZE）：标识数组最大容量数值 代码实现1234567public class SequentialList&lt;T&gt; implements ListInterface&lt;T&gt; { private static final int LIST_SIZE = 100; //数组最大容量 private T[] list; //一维数组存储 private int length; //记录元素个数，初始化为0 //实现接口的方法...} ADT实现 在顺序表的实现中，核心算法有如下几种 按位获取：直接计算，随机存取，O(1) 插入算法：后挪数据，插入空位，O(n) 删除算法：前挪数据，覆盖删除元素，O(n) 初始化空顺序表123456/** * 创建总容量为LIST_SIZE的空顺序表 */public SequentialList(){ this.list = (T[]) new Object[LIST_SIZE];} 非空顺序表1234567891011121314151617/** * 创建总容量为LIST_SIZE的空顺序表 * 并将initialList的数据作为顺序表的初始化数据 * @param initialList : 初始化数据数组 */public SequentialList(T[] initialList){ int len = initialList.length; if(len &gt; LIST_SIZE){ throw new RuntimeException(\"初始化数组长度越界\"); } this.list = (T[]) new Object[LIST_SIZE]; for(int i = 0;i &lt; len;i++){ list[i] = initialList[i]; } this.length = len;} 查找按位查找 元素存储地址(数组下标)的顺序和元素逻辑位置顺序有对应关系 可以直接计算出逻辑位置对应的存储位置 时间复杂度：O(1) 1234567891011121314151617/** * 返回指定位置i的元素 * @param i 顺序表元素位置索引，从1开始 * @return 返回指定位置的元素 */@Overridepublic T getElement(int i) { if(isEmpty() == true){ throw new RuntimeException(\"表空\"); } if(i &lt; 1 || i &gt; length){ throw new RuntimeException(\"查找位置非法\"); } return list[i -1];} 按值查找 按值查找只能通过遍历数组，返回对应数据的数组下标 时间复杂度：O(n) 1234567891011121314/** * 查找出element在线性表第一次出现的位置 * @param element 待查找值 * @return 第一次出现的位置，找不到返回0 */@Overridepublic int locate(T element) { for (int i = 0; i &lt; list.length; i++) { if(element.equals(list[i])){ return i + 1; } } return 0;} 插入插入原理 插入操作的“插”就是“日常插队”，指插在某个位置之前 顺序表插入一个元素仍需保留原有顺序，因此需后挪插入位置后的所有数据，空出插入位 伪代码 健壮性检查 顺序表是否已满 插入索引是否合法，length + 1是因为允许将元素插入到表尾 后挪数据，空出插入位 将元素插入到待插入空位中 修改当前表长，length++ 示例代码1234567891011121314151617181920212223/** * 在位置i前插入element数据 * @param i 顺序表元素位置索引，从1开始 * @param element 待插入的数据 */@Overridepublic void insert(int i, T element) { if(this.length == LIST_SIZE){ throw new RuntimeException(\"上溢、顺序表已满\"); } //(i &gt; length + 1)，其中\"+1\" 是允许插入到末尾 if(i &lt; 1 || i &gt; length + 1){ throw new RuntimeException(\"插入位置非法\"); } //以后移位置为判别循环编写，以索引值比较为结束 for (int j = length; j &gt;= i; j--) { list[j] = list[j - 1]; } list[i - 1] = element; length++;} 性能分析 时间复杂度：O(n) 删除删除原理 删除数据，需前挪删除位置后的全部数据，并可通过覆盖删除元素 伪代码 健壮性检查 顺序表是否有数据 插入索引是否合法，只允许删除到最后一个元素，索引最大为length 删除数据，需前挪数据 修改当前表长，length– 示例代码1234567891011121314151617181920212223/** * 删除线性表中指定位置的元素 * @param i 顺序表元素位置索引，从1开始 * @return */@Overridepublic T delete(int i) { if(isEmpty()){ throw new RuntimeException(\"表空\"); } if(i &lt; 1 || i &gt; length){ throw new RuntimeException(\"删除位置非法\"); } T temp = list[i - 1]; //注意：length比最大数组索引多出1 for (int j = i; j &lt; length ; j++) { list[j - 1] = list[j]; } length --; return temp;} 性能分析 时间复杂度：O(n); 遍历 以length为界限的for循环数组遍历 时间复杂度：O(n) 12345678910/** * 遍历顺序表 */@Overridepublic void printList() { for (int i = 0; i &lt; length; i++) { System.out.print(list[i] + \",\"); } System.out.println();} 清空 直接把记录元素个数length至0即可 java中可以将所有数据至为null加快GC进行垃圾回收 1234567891011/** * 清空顺序表已有的数据 */@Overridepublic void clear() { //至null促使GC执行资源回收 for (int i = 0; i &lt; length; i++) { list[i] = null; } length = 0;} 链表 链表是通过链式存储结构实现的线性表 链表通过保存前驱或后继元素的引用/指针，将数据元素串成一个线性表 参考代码 链表结构一般链式存储结构都有最基本的如下5个结构： 数据域：存储数据元素信息的域 引用域(指针)：存储直接后继位置的域，其中存储的信息称做指针或链 结点(Node)：数据域和指针域组成数据元素的存储映像，链表就是由多个结点串成 头结点： 在链表的第一个结点前附设的一个空结点，初始状态 next == null，表链表为空 头结点的设置为了后续链表边缘操作的代码统一而设，又称为哨兵 头引用(指针)：只用于指向头结点的引用域称为头引用(指针) 单链表概念 单链表（LinkedList）指链表中的每个元素结点只有一个指向后继元素的引用域的链表 单链表的初始状态为头结点next == null，表示链表为空 结构实现Node结构属性 数据域（data）：存储数据实体 指针域（next）：指向后继结点的引用/指针 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class LinkedNode &lt;T&gt;{ private T data; //数据域 private LinkedNode&lt;T&gt; next; //引用域(指针域) /** * 空结点创建 */ public LinkedNode() { data = null; next = null; } /** * 初始化数据域结点 * @param data */ public LinkedNode(T data){ this.data = data; } /** * 初始化数据域域引用域结点 * @param data * @param next */ public LinkedNode(T data,LinkedNode&lt;T&gt; next){ this.data = data; this.next = next; } public T getData() { return data; } public void setData(T data) { this.data = data; } public LinkedNode&lt;T&gt; getNext() { return next; } public void setNext(LinkedNode&lt;T&gt; next) { this.next = next; }} 链表结构属性 头引用/指针：专门用于指向头结点的引用，为后续方便代码统一而设的头结点 代码实现123456789public class LinkedList&lt;T&gt; implements ListInterface&lt;T&gt; { /** * 头引用(指针) * 头结点是统一代码的结构，任何时都不会被删除，单链表可考虑声明为常量 */ private final LinkedNode&lt;T&gt; first; //实现ADT所定义的ListInterface接口...} ADT实现初始化空单链表 实例化头结点即可：注意头结点是统一代码的结构，任何时都不会被删除 123456/** * 初始化一个空单链表 */public LinkedList(){ first = new LinkedNode&lt;T&gt;();} 多种实现方式分发 本例通过传入一个枚举类型控制底层创建非空单链表的实现方式 LinkedList.java 12345678910111213/** * 非空链表初始化 * @param init 待初始化数据 * @param createModel 创建方式，可选头插法或尾插法 */public LinkedList(T[] init,CreateModel createModel){ this();//由于本例的头引用first定义成常量，因此需在此进行头结点初始化操作 if(CreateModel.CREATE_LIST_HEAD == createModel){ CreateListHead(init); }else { CreateListTail(init); }} enum CreateModel.java 1234567891011public enum CreateModel { /** * 头插法方式创建 */ CREATE_LIST_HEAD, /** * 尾插法方式创建 */ CREATE_LIST_TAIL;} 头插法构建 始终对第1个位置进行头插法，且进行不断链的顺序操作 单链表的增删操作均需要定位到目的操作结点的前一个结点，才能保证操作过程不断链 因此对第1个位置进行头插则需要定位至头结点first 注：本例采用“多种实现方式分发”在重载构造器中已经进行了空链表的初始化this() 12345678910111213/** * 头插法创建单链表 * @param init 待初始化数据 */private void CreateListHead(T[] init){ //first = first = new LinkedNode&lt;T&gt;(); //初始化空链表 LinkedNode&lt;T&gt; node = null; for (int i = 0; i &lt; init.length; i++) { node = new LinkedNode&lt;&gt;(init[i],null); node.setNext(first.getNext()); first.setNext(node); }} 头插法创建单链过程示意图： 尾插法构建 尾插法定义一个尾引用(尾指针)，使其总是指向最后一个结点，用于实现尾插法 尾指针初始化于头指针 让新元素都插在尾指针的next 最后将最新插入的元素的引用作为最新的rear，因为就是最新的最后一个元素 注：由于java实现新建结点的next默认就是null，若C语言记得在for循环结束后将最终的最后一个元素的next值置为null 1234567891011121314/** * 尾插法创建单链表 * @param init 待初始化数据 */private void CreateListTail(T[] init){ //定义一个尾指针，使其总是指向最后一个结点，用于实现尾插法 LinkedNode&lt;T&gt; rear = first; LinkedNode&lt;T&gt; node = null; for (T data : init) { node = new LinkedNode&lt;&gt;(data); rear.setNext(node); rear = node; }} 尾插法构建非空单链表过程示意图 遍历 关键代码：工作引用后移(工作指针后移) 遍历的是实体结点，即不包含头结点，即工作指针p从p = first.getNext()开始 123456789101112/** * 遍历单链表 */@Overridepublic void printList() { LinkedNode&lt;T&gt; p = first.getNext(); while (p != null){ System.out.print(p.getData() + \" \"); p = p.getNext(); //工作引用(指针)后移 } System.out.println();} 按值查找 在遍历代码实现的基础上，添索引计数器并返回 时间复杂度：O(n) 123456789101112131415161718/** * 查找出element在线性表第一次出现的位置 * @param element 待查找值 * @return 第一次出现的位置，找不到返回0 */@Overridepublic int locate(T element) { LinkedNode&lt;T&gt; p = first.getNext(); int count = 1; while (p != null){ if(p.getData() == element || p.getData().equals(element)){ return count; } p = p.getNext(); count++; } return 0;} 按位查找 按位查找是通过位置(用户提供的索引)定位链表对应位置元素的实现基础 通过设置计数器count，同步追踪目标索引值的位置 最后通过判断工作指针的状态来确认位置的合法性，从而决定返回内容 1234567891011121314151617181920212223242526/** * 返回指定位置i的元素 * @param i 顺序表元素位置索引，从1开始 * @return 返回指定位置的元素 */@Overridepublic T getElement(int i) { //健壮性检查 if(i &lt; 1){ throw new RuntimeException(\"查找位置非法\"); } int count = 1; LinkedNode&lt;T&gt; p = first.getNext(); //对于 count != i的终止条件，count &lt; i健壮性更强，表示更明确 while (p != null &amp;&amp; count &lt; i){ p = p.getNext(); count++; } if(p != null){ return p.getData(); }else { throw new RuntimeException(\"查找位置非法\"); }} 插入 链表的插入删除操作均需定位到操作结点的前驱结点，因此需p = first; 基于“按位查找”操作进行错位定位 由于插入操作是支持插入到最后的，插入尾部索引为，length + 1 最后判别条件if(p == null)，是由于即使是插入到最后一项p也是存在的才可插入 最后进行不断链，逆序的插入操作 时间复杂度分析： 插入一个元素时间复杂度：O(n) 连续插入多个元素，除第一个元素外的时间复杂度：O(1) 1234567891011121314151617181920212223242526272829303132/** * 在位置i前插入element数据 * @param i 顺序表元素位置索引，从1开始 * @param element 待插入的数据 */@Overridepublic void insert(int i, T element) { //健壮性检查 if(i &lt; 1){ throw new RuntimeException(\"插入位置非法\"); } //定位操作位置的前驱结点 LinkedNode&lt;T&gt; p = first; int count = 1; //由于初始值p = first，前继结点已相差一个位置，插入末尾索引为链表长度值+1 while (p != null &amp;&amp; count &lt; i){ p = p.getNext(); count++; } //位置不存在，用p作为判断的原因是即使是插入到最后一项p也是存在的 if(p == null){ throw new RuntimeException(\"非法插入索引\"); } //位置存在，此时操作的就是目标插入位置的前驱结点，进行不断链操作(逆序) LinkedNode&lt;T&gt; node = new LinkedNode&lt;&gt;(element); node.setNext(p.getNext()); p.setNext(node);} 单链表插入操作实现过程示意图 删除 链表的插入删除操作均需定位到操作结点的前驱结点，因此需p = first; 基于“按位查找”操作进行错位定位 由于删除操作仅支持删除最后元素，此时删除的索引为，length (比插入少1) 最后判别条件if(p.getNext() == null)，除了最后一个元素之后的位置不可删除外，其他位置都可删除。而最后一个元素之后的位置删除理论上需依靠最后一个元素。因此当元素的next为null时，就是最后一个元素。则为非法操作 最后进行不断链，暂存数据进行返回，逆序的删除操作 1234567891011121314151617181920212223242526272829303132333435363738/** * 删除线性表中指定位置的元素 * @param i 顺序表元素位置索引，从1开始 * @return 返回被删除元素值，若表空返回null */@Overridepublic T delete(int i) { //健壮性检查 if(i &lt; 1){ throw new RuntimeException(\"删除位置非法\"); } if(isEmpty()){ System.out.println(\"表已空\"); return null; } //错位定位 LinkedNode&lt;T&gt; p = first; int count = 1; //由于初始值p = first：且删除最后一个元素的索引为链表长度值，在insert基础上-1 while (p != null &amp;&amp; count &lt; i){ p = p.getNext(); count++; } //非法索引 if(p.getNext() == null){ throw new RuntimeException(\"删除位置非法\"); } //删除操作 LinkedNode&lt;T&gt; temp = p.getNext(); T resultData = temp.getData(); p.setNext(temp.getNext()); return resultData;} 时间复杂度：O(n) 清空 仅对第一个位置的元素不断进行删除操作即可 对第一个位置元素的操作，即定位则始终定位在头结点 1234567891011/** * * 始终对第一个位置进行单链表删除操作 */@Overridepublic void clear() { while (first.getNext() != null){ //内部元素失去引用，GC自动回收，非GC语言需暂存元素进行资源释放 first.setNext(first.getNext().getNext()); }} 双链表概念 双链表（DulLinkedList），在单链表基础上，为元素结点添加一个指向前驱结点的指针prior 结构实现DulNode属性 数据域（data）：存储数据实体 指针域： （prior）：指向前驱结点的引用/指针 （next）：指向后继结点的引用/指针 示例代码12345678910111213141516171819202122public class DulNode&lt;T&gt; { private T data; //数据域 private DulNode&lt;T&gt; prior; //指向前驱结点指针域 private DulNode&lt;T&gt; next; //指向后继结点的指针域 public DulNode(){ } public DulNode(T data){ this.data = data; } public DulNode(T data, DulNode&lt;T&gt; prior, DulNode&lt;T&gt; next) { this.data = data; this.prior = prior; this.next = next; } //省略3个属性的getter和setter方法} 链表 初始状态，实例化头结点即可 ADT实现 由于双链表中表长、按位查找、按值查找、遍历等操作与单链表基本相同 因此下面仅讨论插入和删除操作 插入 node.setPrior(p); node.setNext(p.getNext()); (p.getNext()).setPrior(node); p.setNext(node); 操作过程图示如下： 双链表和单链表类似，插入操作均需定位到操作结点的前驱结点才能进行 注意操作的相对顺序，2、3步均需用到p.getNext();操作，因此第4步均需2、3操作完后进行 删除 (p.getPrior()).setNext(p.getNext()); (p.getNext()).setPrior(p.getPrior()); 操作过程图示如下： 由于双链表可通过前驱指针prior获取前驱结点，因此无需定位到前驱结点，可直接操作删除元素 1、2语句步骤可颠倒，虽然p结点还指向其他结点，但它已不再被双链表感知到了 循环(单)链表 循环链表（CirSinglyLinkedList），也称为循环单链表，在单链表基础上进行首尾相接的链表结构 带头指针的循环单链表：表首定位 O(1)，表尾定位 O(n) 带尾指针的循环单链表：表首表尾定位均为 O(1)，实际应用中多采用尾指针指示的循环单链表 表首元素：(rear.getNext()).getNext(); 表尾元素：rear 循环双链表 循环双链表（CirDulLinkedList），即在双链表基础上进行头尾相连的链表结构 循环双链表的初始状态：prior和next指针均指向头结点first 循环双链表遍历操作：p = first.getNext()、结束条件p != first; 各类型链表对比 小结性能分析 操作 线性表 链表 查找 O(1) O(n) 插/删 O(n) 确定位置后O(1) 空间性能 开销小 开销大 空间限制 事先确定 理论上无限制 代码实现 插入允许插入都表尾，此时最大索引值为 length + 1 删除只允许删除最后一个存在的元素，此时最大索引值为 length 顺序表 前挪位，后挪位 单链表 遍历，实体结点 + 工作指针后移 按值查找，工作指针后移 + 计数器 按位查找，位置定位(工作指针后移 + 计数器追踪 + 判别条件) 插入操作，错位位置定位 + 插入到尾部索引支持 + 不断链操作(逆序操作) 删除操作，错位位置定位 + 仅最后一个元素索引支持 +不断链操作(暂存操作 + 逆序操作) 清空操作，仅对第一个位置的元素不断进行删除操作 扩展与应用静态链表约瑟夫环问题一元多项式求和栈 Java实现源代码 逻辑结构 栈（Stack），是一种”先进后出“（Last In First Out，LIFO）的数据结构 栈顶（Stack Top）：允许插入和删除的一端 栈底：（Stack Bottom）：栈顶的对端 ADTADT描述1234567891011ADT StackDataModel 栈中元素具有相同类型及后进先出特性，相邻元素具有前驱和后继关系Operation initStack：栈的初始化 destroyStack ：栈的销毁 push：入栈 pop：出栈 getTop：取栈顶元素 isEmpty：判空endADT Java接口ADT123456public interface StackInterface&lt;T&gt; { void push(T element); //入栈，在栈顶插入指定数据元素 T pop(); //出栈，删除并返回栈顶元素 T getTop(); //读取当前栈顶元素 boolean isEmpty(); //判断栈释放为空} 顺序栈概念 顺序栈（SequentialStack）指基于顺序存储结构实现的栈结构 参考代码 结构实现属性 栈顶指针（top）：指向当前栈顶元素的指针，空栈时为 -1 一维数组（stack）：顺序存储栈中的数据 栈容量常量（STACK_SIZE）：表明顺序栈的最大容量，即数组长度 代码实现12345678public class SequentialStack&lt;T&gt; implements StackInterface&lt;T&gt;{ private T[] stack; private int top; public static final int STACK_SIZE = 10; //实现Java接口栈ADT的方法...} ADT实现初始化 初始化数组，top空栈时-1 1234567/** * 空栈初始化 */public SequentialStack(){ stack = (T[]) new Object[STACK_SIZE]; top = -1;} 压栈(进栈) 前置++，top指示的就是栈顶元素的位置 1234567891011/** * 将数据压入顺序栈中 * @param element 待压栈数据 */@Overridepublic void push(T element) { if(top + 1 &gt;= STACK_SIZE){ throw new RuntimeException(\"上溢、栈已满\"); } stack[++top] = element;} 弹栈(出栈) 后置–，top指示的就是栈顶元素的位置 1234567891011/** * 将栈顶数据弹出并返回 * @return 栈顶数据 */@Overridepublic T pop() { if(isEmpty()){ throw new RuntimeException(\"下溢、栈已空\"); } return stack[top--];} 返回栈顶元素1234567891011/** * 返回栈顶元素，并不弹出 * @return 栈顶元素 */@Overridepublic T getTop() { if(isEmpty()){ throw new RuntimeException(\"下溢、栈已空\"); } return stack[top];} 遍历12345678910/** * 遍历当前顺序栈 */@Overridepublic void printStack() { for (int i = 0; i &lt;= top; i++) { System.out.print(stack[i] + \" \"); } System.out.println();} 判空12345678/** * 检查当前顺序栈是否为空 * @return 空栈返回true，反之返回false */@Overridepublic boolean isEmpty() { return top == -1 ? true : false;} 链栈概念 链栈（LinekdStack）指基于单链表的链式存储结构，实现的栈结构 链栈的指针top始终指向栈顶元素是（类头结点），且始终为第一个元素，旧数据往后排 参考代码 结构实现Node 单链表的Node属性 数据域：data 指针域：next 栈链 属性：栈顶指针top，空栈时为null 12345public class LinkedStack&lt;T&gt; implements StackInterface&lt;T&gt;{ private LinkedNode&lt;T&gt; top; //实现Java接口栈ADT的方法...} ADT实现初始化 初始状体，top指向null，表示空栈 123456/** * 空链栈初始化 */public LinkedStack(){} 压栈(进栈) 类似头插法 123456@Overridepublic void push(T element) { LinkedNode&lt;T&gt; node = new LinkedNode&lt;&gt;(element); node.setNext(top); top = node;} 弹栈(出栈) 类似单链表删除操作 123456789@Overridepublic T pop() { if(isEmpty()){ throw new RuntimeException(\"下溢、栈链已空\"); } T temp = top.getData(); top = top.getNext(); return temp;} 返回栈顶元素1234567@Overridepublic T getTop() { if(isEmpty()){ throw new RuntimeException(\"下溢、栈链已空\"); } return top.getData();} 遍历123456789@Overridepublic void printStack() { LinkedNode&lt;T&gt; p = top; while (p != null){ System.out.print(p.getData() + \" \"); p = p.getNext(); } System.out.println();} 判空1234@Overridepublic boolean isEmpty() { return top == null ? true : false;} 扩展与应用*两栈共享空间 暂略 括号匹配问题*表达式求值队列逻辑结构 队列（Queue）指数据间具有“先进先出”（First In First Out，FIFO）特性的数据结构 队头（front）：允许删除/出队的一端 队尾（rear）：允许插入/入队的一端 参考代码 ADTADT描述1234567891011ADT StackDataModel 队列中元素具有相同类型及先进先出特性，相邻元素具有前驱和后继关系Operation initQueue：队列的初始化 destroyQueue：队列的销毁 enQueue：入队 deQueue：出队 getHead：取队头元素 isEmpty：判空endADT Java接口ADT12345678public interface QueueInterface&lt;T&gt; { void enQueue(T element); //入队，在队尾插入指定数据元素 T deQueue(); //出队，删除并返回队头元素 T getHead(); //读取当前队头元素 boolean isEmpty(); //判断当前队列是否为空 //void printQueue(); //循环队列结构不可按序遍历 int length(); //获取队列长度} 顺序队列概念 顺序队列（SequentialQueue）指通过顺序存储结构实现的队列 常见的顺序队列为循环队列 队列雏形结构设计为了提高执行效率，定义如下两个活动的指针 队头指针（int front）：规定front指向队头元素，出队时返回front值，后+1 队尾指针（int rear）：规定rear指向队尾元素的后一个元素，入队时放入rear位置，后+1 《数据结构-从概念到xxx实现》采用的是front指向队头的元素前一个位置，rear指向队尾 《大话数据结构》采用的是front指向队头，rear指向队尾的下一个位置(可以直接存储的位置) 两者观念一致，这样归约目的是为了方便运算，例如rear - front就等于队列长度 本人觉得《大话数据结构》的归约更贴切，因此选用 操作过程示意图 假溢出现象 随着队列的入队和出队操作，整个队列向数组高端移动，从而产生了单一的“单向移动性” 在上述的“操作过程示意图”基础上再依次入队a5 当a5数据进入后，rear值已经超出了数组最大索引值，此时外部检查到为队列已满 但实际上，下标0还有空位，这种数组看似用尽、而低端还有空间的现象称为“假溢出”现象 循环队列基本概念 解决假溢出现象最好的方法就是将数组看成头尾相接的循环结构 允许队列从数组中的下标最大位置延续到下标最小位置，使其空间能够充分被利用 队列中这种头尾在逻辑上进行相接的顺序存储结构称为循环队列，是实际应用中的顺序队列 结构实现队空队满判别 假设改装成循环队列后，上述非循环队列“假溢出现象”示意图基础上就可再添加数据(a6) 此时队列真正处于装满状态，rear == front 此时出现问题，就是队列初始状态时也是设置为，rear == front == 0，造成两种状态重叠 解决方案是，浪费一个空间，如上图的(1)a6入队的状态为队满状态，即rear + 1 == front 此时队列可存储数据量为 “ QUEUE_SIZE - 1 ” 循环列索引实现 从设计上rear + 1 == front，但这种等值关系还存在隐性的条件，即rear &lt; front时 但循环队列在头尾连接进行入队出队操作的过程中，会存在rear &gt; front的情况，如下图所示 当rear &gt; front时候，rear + 1 == front将不成立 解决方案是通过取模的方式(循环自增归零)，进行条件判断 即队满时因为：(rear + 1) % QUEUE_SIZE == front 同理，这种实现思路也应用在front与rear进行循环递增的操作 入队：(rear + 1) % QUEUE_SIZE 出队：(front + 1) % QUEUE_SIZE 应用在计算当前队列长度，不考虑循环因素时队列长度为rear - front 考虑循环因素的通用队列长度公式：(rear - front + QueueSize) % QueueSize 取模循环自增原理 无论入队还是出队都用统一的操作，这是一种通用的循环自增归零写法 (变量 + 1) % MAXSIZE 代码实现1234567891011121314151617181920212223242526272829public class CircularQueue&lt;T&gt; implements QueueInterface&lt;T&gt;{ /** * 循环队列，通过浪费一个存储空间来区分队空与队满状体 */ public static final int QUEUE_SIZE = 10 + 1; //队列最大容量 private T[] data; //存放队列的数组 private int front; //指向队头元素 private int rear; //指向队尾元素的下一个元素 /** * 空队列初始化 */ public CircularQueue(){ data = (T[]) new Object[QUEUE_SIZE]; rear = front = 0; } /** * 设置队列初始化容量 * @param initialSize 设置的队列初始化容量 */ public CircularQueue(int initialSize){ data = (T[]) new Object[initialSize + 1]; rear = front = 0; } //实现Java接口ADT} ADT实现 再次强调，本例front指向队头元素，rear指向队尾元素的下一个位置，即可存储位置 初始化 初始化，空队列情况 1234567/** * 空队列初始化 */public CircularQueue(){ data = (T[]) new Object[QUEUE_SIZE]; rear = front = 0;} 入队 rear = (rear + 1) % QUEUE_SIZE; 123456789101112/** * 入队操作 * @param element 待入队元素 */@Overridepublic void enQueue(T element) { if((rear + 1) % QUEUE_SIZE == front){ throw new RuntimeException(\"上溢，队列已满\"); } data[rear] = element; rear = (rear + 1) % QUEUE_SIZE;} 出队 front = (front + 1) % QUEUE_SIZE 1234567891011121314/** * 将队头元素出队 * @return 返回队头元素 */@Overridepublic T deQueue() { if(isEmpty()){ throw new RuntimeException(\"下溢，队列已空\"); } T temp = data[front]; data[front] = null;//促使GC回收 front = (front + 1) % QUEUE_SIZE; return temp;} 获取长度 (rear - front + QUEUE_SIZE % QUEUE_SIZE) 12345678/** * 获取队列长度 * @return 当前队列长度 */@Overridepublic int length() { return (rear - front + QUEUE_SIZE % QUEUE_SIZE);} 判空 rear == front 1234@Overridepublic boolean isEmpty() { return rear == front ? true : false;} 获取队头元素1234567@Overridepublic T getHead() { if (isEmpty()){ throw new RuntimeException(\"下溢，队列已空\"); } return data[front];} 链队列概念 链队列（LinkedQueue）指使用链式存储结构实现的队列，一般使用单链表实现 队头元素存放在链表第一个位置，队列元素从前到后依次排开 此时front欲负责操作队头元素则应充当单链表中指向头结点的头指针地位 rear则始终指向链表的最后一个元素，即队尾，即充当单链表中的尾指针作用 结构实现Node 利用单链表实现，同单链表的Node结构 数据域：data 指针域：next 链队列123456789101112public class LinkedQueue&lt;T&gt; implements QueueInterface&lt;T&gt;{ private LinkedNode&lt;T&gt; front; private LinkedNode&lt;T&gt; rear; /** * 初始化空链队列，实际即初始化单链表的头结点 */ public LinkedQueue(){ front = rear = new LinkedNode&lt;&gt;(); }} ADT实现初始化 初始化空链队列，实际即初始化单链表的头结点，让front和rear一开都指向它 123456/** * 初始化空链队列，实际即初始化单链表的头结点 */public LinkedQueue(){ front = rear = new LinkedNode&lt;&gt;();} 入队 类似单链表的尾插法 12345678910/** * 入队操作，类似尾插法 * @param element 待入队元素 */@Overridepublic void enQueue(T element) { LinkedNode&lt;T&gt; node = new LinkedNode&lt;&gt;(element); rear.setNext(node); rear = node;} 出队 将队头元素出队，相当于对第一个元素进行单链表删除 注意，链队列出队最后一个元素是需手动维护空队列状态 1234567891011121314151617181920/** * 将队头元素出队，相当于对第一个元素进行单链表删除 * 注意，链队列出队最后一个元素是需维护空队列状态 * @return 返回队头元素数据 */@Overridepublic T deQueue() { if(isEmpty()){ throw new RuntimeException(\"下溢，队列已空\"); } LinkedNode&lt;T&gt; temp = front.getNext(); front.setNext(temp.getNext()); //若待删除元素的next是null，则表示这是最后一个元素， //此时需手动维护rear == front，表示队列已空 if(temp.getNext() == null){ rear = front; } return temp.getData();} 获取队头元素1234567891011/** * 返回队头元素 * @return 队头元素 */@Overridepublic T getHead() { if(isEmpty()){ throw new RuntimeException(\"下溢，队列已空\"); } return front.getNext().getData();} 遍历123456789101112/** * 测试输出遍历 * @return */public void printQueue() { LinkedNode&lt;T&gt; p = front.getNext(); while (p != null){ System.out.print(p.getData() + \" \"); p = p.getNext(); } System.out.println();} 判空 队空：front == rear 12345678/** * 链队列判空 * @return 返回true为空队列 */@Overridepublic boolean isEmpty() { return front == rear ? true : false;} 小结性能对比 栈和队列的顺序与链式结构：基本操作的时间复杂度均为 O(1) 若栈和队列元素数量不确定，数量变化大推荐使用链式存储结构 队列代码实现 循环队列 基本归约：front指向队头元素，rear指向队尾元素的下一个元素 队初始：front = rear = 0 队空：front == rear 队满：(rear + 1) % QUEUE_SIZE == front 入队：rear = (rear + 1) % QUEUE_SIZE 出队：front = (front + 1) % QUEUE_SIZE 队列长度：(rear - front + QUEUE_SIZE) % QUEUE_SIZE 链队列： 基本归约： 队头元素存放在第一个位置，后依次从前往后排开 front对队头元素进行操作，充当单链表的头指针first地位 rear始终指向队尾元素，充当单链表中的尾指针地位 出队： 始终对第一个元素进行类单链表删除操作 若是最后一个元素出队需手动维护空链队列状态，手动至rear = front，否则rear会丢失 入队：相当于尾插法 扩展与应用双端队列","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Hexo-Keep主题基于插件实现添加标题序号","slug":"Hexo-Keep主题基于插件实现添加标题序号","date":"2021-07-03T03:40:12.000Z","updated":"2021-08-25T15:27:11.616Z","comments":true,"path":"2021/07/03/Hexo-Keep主题基于插件实现添加标题序号/","link":"","permalink":"http://yoursite.com/2021/07/03/Hexo-Keep%E4%B8%BB%E9%A2%98%E5%9F%BA%E4%BA%8E%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%B7%BB%E5%8A%A0%E6%A0%87%E9%A2%98%E5%BA%8F%E5%8F%B7/","excerpt":"","text":"引言，本人使用的基于Hexo的Keep主题框架的版本默认不会再markdown文章中为标题编号，参考其他博主的文章 Hexo, MWeb 为标题自动添加序号模仿实现了基于hexo-heading-index插件实现的Keep主题markdown文章标题自动编号 文章参考出处：Hexo, MWeb 为标题自动添加序号 编号需求在Hexo的Keep主题中希望在解析MD文档的时候，能自动为标题带上一个序号 123451 xxxxx1.1 xxxx1.1.1 xxxx2. xxxxx 修改主题CSS 找到Keep主题markdown文档样式的css文件 1&#123;hexo根目录&#125;\\themes\\keep\\source\\css\\common\\markdown.styl 打开markdown.styl文件，在.markdown-body &#123;&#125;域中添加如下css代码 123456789101112.markdown-body &#123; counter-reset:section h1&#123;counter-reset:sub-section&#125; h2&#123;counter-reset:composite&#125; h3&#123;counter-reset:detail&#125; h1:before&#123;content:counter(section) &quot; &quot;;counter-increment:section&#125; h2:before&#123;content:counter(section) &quot;.&quot; counter(sub-section) &quot; &quot;;counter-increment:sub-section&#125; h3:before&#123;content:counter(section) &quot;.&quot; counter(sub-section) &quot;.&quot; counter(composite) &quot; &quot;;counter-increment:composite&#125; h4:before&#123;content:counter(section) &quot;.&quot; counter(sub-section) &quot;.&quot; counter(composite) &quot;.&quot; counter(detail) &quot; &quot;;counter-increment:detail&#125; &#125; 添加插件 在hexo安装的根目录中，添加hexo-heading-index插件 1$ npm install hexo-heading-index 在hexo根目录的全局配置文件_config.yml中添加如下配置 1234567heading_index: enable: true index_styles: &quot;&#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125;&quot; connector: &quot;.&quot; global_prefix: &quot;&quot; global_suffix: &quot;. &quot; start_level: 1 执行hexo clean与hexo g命令重新生成hexo数据，最后执行hexo s命令启动博客查看效果 tips：若重新生成数据重新部署都看不到编号，在需要清空部署Hexo的仓库，再部署一次即可 最终效果 最后就可以基于hexo-heading-index实现Hexo的Keep主题自动添加标题序号的功能了","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"Java9,10,11(LTS)新特性基础","slug":"Java9,10,11(LTS)新特性基础","date":"2021-06-30T08:57:56.000Z","updated":"2021-08-25T15:27:11.814Z","comments":true,"path":"2021/06/30/Java9,10,11(LTS)新特性基础/","link":"","permalink":"http://yoursite.com/2021/06/30/Java9,10,11(LTS)%E6%96%B0%E7%89%B9%E6%80%A7%E5%9F%BA%E7%A1%80/","excerpt":"","text":"引言：本文主要介绍orcale公司自JDK9开始改变了JDK版本的更新策略，以及以JDK11(LTS)为一个长期支持版本的时间节点介绍所包含的JDK9，10，11的新特性。含模块化系统、 jShell命令、接口的私有方法、钻石操作符的使用升级、语法改进：try语句、String存储结构变更、便利的集合特性：of() 、 增强的Stream API、 全新的HTTP客户端API 、Deprecated的相关API等等 JDK发展变化 自从 2017 年 9 月 21 日 Java 9 正式发布之时，Oracle 就宣布今后会按照每6个月一次的节奏进行更新 意味着Java的更新从传统的以特性驱动的发布周期，转变为以时间驱动的发布模式。并逐步的将 Oracle JDK 原商业特性进行开源。 针对企业客户的需求，Oracle将以3年为周期发布长期支持版本（long term support），即LTS版 对于非LTS版，如JDK9，10，是不会长期支持维护更新的 如JDK9只有9.04左右，JDK10，10.02左右，如JDK8这种旧的且长期支持的已经8.200多 3年一个周期，即JDK11是一个LTS版，下一个LTS版因为JDK17 Oracle 改变后的理念是，“小步快跑，快速迭代” JDK9概述 Java9 提供了超过150项新功能特性， 含备受期待的模块化系统、可交互 的 REPL 工具(jshell)，JDK 编译工具，Java 公共 API 和私有代码，以及安 全增强、扩展提升、性能管理改善等 可以说Java9是一个庞大的系统工程， 完全做了一个整体改变(以至于连续4次跳票最终才发布出来) JDK&amp;JRE目录结构变更 从JDK9开始，JDK10，11都延用了JDK9变更的目录结构 JDK8目录结构 JDK9目录结构 主要把JDK8的jre目录拆分出来了 核心新特性模块化系统背景谈到 Java 9 大家往往第一个想到的就是Jigsaw 项目。众所周知，Java 已经发展超过 20 年（95 年最初发布），Java 和相关生态在不断丰富的同时也越 来越暴露出一些问题： Java 运行环境的膨胀和臃肿。每次JVM启动的时候，至少会有30～60MB的内存 加载，主要原因是JVM需要加载rt.jar，不管其中的类是否被classloader加载，第 一步整个jar都会被JVM加载到内存当中去（而模块化可以根据模块的需要加载程 序运行需要的class） 当代码库越来越大，创建复杂，盘根错节的“面条式代码”的几率呈指数级的 增长。不同版本的类库交叉依赖导致让人头疼的问题，这些都阻碍了 Java 开发和 运行效率的提升 很难真正地对代码进行封装, 而系统并没有对不同部分（也就是 JAR 文件）之间 的依赖关系有个明确的概念。每一个公共类都可以被类路径之下任何其它的公共类所访问到，这样就会导致无意中使用了并不想被公开访问的API 小结：jar包统一加载、类库关系不明确、jar包的封装性弱 模块化设计 针对种种已经存在的问题：jar包统一加载、类库关系不明确、jar包的封装性弱 jdk9采用的解决方案是，为package层外再裹一层，称为模块(module) 即从传统的eclipse向IDEA使用时，多出module模块结构。 用模块来管理各个package，通过声明某个package 暴露，不声明默认就是隐藏。 因此，模块化使得代码组织上更安全，并能一并实现如下目标功能： 只须必要模块，而非全部jdk模块，减少内存的开销 可简化各种类库和大型应用的开发和维护 改进 Java SE 平台，使其可以适应不同大小的计算设备 改进其安全性，可维护性，提高性能 使用示例tips：下文module模块命名为了学习顺序方便使用了数字开头，实际开发按标准规范命名。 需求想在模块化结构的项目中进行跨模块调用，而且仅暴露指定的允许的类库可供跨模块调用 步骤 在需要暴露指定类库资源的Module的src目录下创建名为，module-info.java的java文件 若出现新建的”module-info.java”选项不可选，或者找不到，请确认IDEA版本是否支持JDK9或以上，确认当前IDEA项目或者该模块，是否使用了JDK9及其以上版本(主要是Source选择了JDK9没有)。 由于本文module模块命名为了学习顺序方便使用了数字开头，如果通过IDEA自动生成后可能或以Module名作为module关键字类的类名，而类名是不允许数字开头，IDEA会报出“Module declaration expected”提示，请注意更改为合法的名字即可。 在需要暴露指定package的module的module-info.java文件中以exports语句声明向外暴露的package 12345678/** * @author yhd * @create 2021-06-29 20:02 */module JDK8_9_10_11&#123; //通过exports语句，以package为单位选择向外暴露的package exports com.company.jdk9;&#125; 在需要引入其他module的module中同样创建module-info.java文件，并通过requires语句以module-info.java中的module关键字名为单位引入。 1234567/** * @author yhd * @create 2021-06-29 20:05 */module JDK9Test&#123; requires JDK8_9_10_11;&#125; 此时12JDK9Test模块(module JDK9Test)可以使用11JDK8_9_10_11模块(module JDK8_9_10_11)中的com.company.jdk9资源了 jshell背景 Python和Scala之类的语言早就有交互式编程环境 REPL (read - evaluate - print - loop)，读、评价、打印、循环。 交互式编程环境指。开发者无需按照严格的代码执行语法流程，只需要输入一些代码， 就可以在编译前直接获得执行结果的程序反馈。实现“即写即得、快速运行”的理念。 有点类似汇编的交互式编程环境，Linux的shell编程环境 之前的Java版本要想执行代码，必须创建文件、声明类、提供测试方法方法或main方法再编写语句才可实现。 jshell简介 Java 9 中终于拥有了REPL工具——jshell.exe程序/命令，让Java可以像脚本语言一样运行 从控制台启动jshell，利用jShell在没有创建类的情况下直接声明变量，计算表达式， 执行语句。 jshell也可以从文件中加载语句或者将语句保存到文件中 jshell也可以是tab键进行自动补全和自动添加分号 jshell使用调出jshell 在cmd环境直接输入jshell命令启用 基本使用 输入tab键，能自动补全代码。类似Linux环境 列出当前session中所有有效代码片段 查看当前session中所有有效代码片段：jshell&gt; /list jshell允许重新定义相同方法名和参 数列表的方法，即为对现有方法的修改（或覆盖） 查看当前session下所有创建过的变量：jshell&gt; /vars 查看与导入包 查看默认已经导入的包：jshell&gt; /imports 导入指定的包：jshell&gt; import java.util.*; 外部代码编辑器来编写 Java 代码 外部代码编辑器来编写 Java 代码：jshell&gt; /edit 获取帮助 获取所有帮助： 1jshell&gt; /help 获取指定命令帮助，如查看list命令的帮助 1jshell&gt; /help list 导入外部jshell文件】 导入外部jshell文件：jshell&gt; /open D:\\code\\HelloWorld.java 退出jshell 退出jshell：jshell&gt; exit 异常隐藏 在jshell环境中，编写有异常抛出的语句，jshell会默认将异常隐藏掉 语法层面接口私有方法 在jdk8中，为接口加入了允许定义default方法和静态方法 在jdk9中，还允许接口里面定义私有方法，即private方法 示例代码 接口示例 12345678910111213141516171819202122232425package com.company.jdk9;/** * @author yhd * @create 2021-06-29 21:35 */public interface InterfaceTest &#123; String INTERFACE_VALUE = &quot;InterfaceValue&quot;; void methodAbstract(); static void methodStatic()&#123; System.out.println(&quot;staticMethod&quot;); &#125; default void methodDefault()&#123; System.out.println(&quot;methodDefault&quot;); privateMethod(); &#125; private void privateMethod()&#123; System.out.println(&quot;privateMethod&quot;); &#125;&#125; 实现类示例 1234567891011121314151617181920212223242526272829303132package com.company.jdk9;/** * @author yhd * @create 2021-06-29 21:38 */public class ImpletmentClass implements InterfaceTest&#123; @Override public void methodAbstract() &#123; System.out.println(&quot;实现类实现抽象方法&quot;); &#125; public static void main(String[] args) &#123; //1、接口的静态属性和静态方法只能由接口调用 String interfaceValue = InterfaceTest.INTERFACE_VALUE; InterfaceTest.methodStatic(); //2、接口的default方法是接口唯一具备类继承特性的结构 //可通过实现类对象调用，但不能够像普通继承父类那样，直接在实现类中调用 ImpletmentClass impletmentClass = new ImpletmentClass(); impletmentClass.methodDefault(); //3、接口的private方法(jdk9)只能在接口内部使用 //InterfaceTest.privateMethod(); //实现类无法直接调用接口的任何结构。 //INTERFACE_VALUE; //staticMethod(); //methodDefault(); //privateMethod(); &#125;&#125; 钻石操作符升级 钻石操作符(diamond operator)就是指泛型中的&lt;&gt;符号 在jdk8中带泛型的匿名实现类是不能够进行类型推断的，即后面不能省略&lt;&gt; 如下操作在jdk8中会报错：编译报错信息Cannot use “&lt;&gt;” with anonymous inner classes. 123456Comparator&lt;Object&gt; com = new Comparator&lt;&gt;()&#123;//不支持类型推断 @Override public int compare(Object o1, Object o2) &#123; return 0; &#125;&#125;; jdk9中则支持在带泛型的匿名实现类进行类型推断 try语句改进背景 jdk9中try语句的改进很大程度是为了优化jdk8已经推出的try()自动资源回收机制 jdk8前资源关闭 jdk8之前资源关闭都是放在finally中 123456789101112131415161718192021222324252627282930313233343536package com.company.jdk9;import java.io.IOException;import java.io.InputStreamReader;/** * @author yhd * @create 2021-06-29 22:14 */public class TryUpdateTest &#123; public static void main(String[] args) &#123; //JDK8之前，集中在finally结构进行资源关闭 InputStreamReader isr = null; try &#123; System.out.print(&quot;请输入内容：&quot;); isr = new InputStreamReader(System.in); int len = -1; char[] data = new char[1024]; if((len = isr.read(data)) != -1)&#123;//只读取一次，供测试使用 String str = new String(data,0,len); System.out.println( str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(isr != null)&#123; try &#123; isr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; jdk8自动资源关闭 jdk8支持自动资源回收，但要求自动关闭的所有资源必须在try()子句中声明及其初始化 由于语法限制严格，局限，因此没有被广泛应用 12345678910111213141516171819202122232425262728package com.company.jdk9;import java.io.IOException;import java.io.InputStreamReader;/** * @author yhd * @create 2021-06-29 22:14 */public class TryUpdateTest &#123; public static void main(String[] args) &#123; //JDK8，增加了try()方式将声明在此内的资源的实现自动资源关闭 //InputStreamReader isr = null; try(InputStreamReader isr = new InputStreamReader(System.in)) &#123; System.out.print(&quot;请输入内容：&quot;); //isr = new InputStreamReader(System.in); int len = -1; char[] data = new char[1024]; if((len = isr.read(data)) != -1)&#123;//只读取一次，供测试使用 String str = new String(data,0,len); System.out.println( str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; jdk9优化的自动资源关闭 jdk9给予jdk8的自动资源回收基础上优化，允许需自动关闭的资源实例化在try()结构外面 try()中只声明需要自动回收的资源变量名 123456789101112131415161718192021222324252627282930package com.company.jdk9;import java.io.IOException;import java.io.InputStreamReader;import java.util.Scanner;/** * @author yhd * @create 2021-06-29 22:14 */public class TryUpdateTest &#123; public static void main(String[] args) &#123; //JDK9进行了优化，支持通过外部声明流资源，try()只声明需自动关闭的资源变量名 InputStreamReader isr = new InputStreamReader(System.in); Scanner scanner = new Scanner(System.in); try(isr;scanner) &#123;//可通过;隔开关闭多个资源 System.out.print(&quot;请输入内容：&quot;); //isr = new InputStreamReader(System.in); int len = -1; char[] data = new char[1024]; if((len = isr.read(data)) != -1)&#123;//只读取一此，供测试使用 String str = new String(data,0,len); System.out.println( str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注：这种资源自动回收的方式仅支持资源变量的使用，而不允许修改资源变量的引用。 API层面String存储结构变更背景 经过大量的数据收集，可以发现String的使用是堆空间的主要组成部分 而且实际开发中大部分的String使用都是拉丁字母字符集范围内的字符，而拉丁字母仅需1byte存储 因此在实际开发中，近似有一半的空间浪费在了堆空间中 JDK9试图将原本String的UTF-8的char[]数组存储结构，改为byte[]数组存储，并且添加一个编码标识字段，使其能够动态地调整字符的存储大小 变更内容 将原本String的UTF-8的char[]数组存储结构，改为byte[]数组存储 并且添加一个编码标识字段，用于标识当前字符集，动态地扩充底层每个字符的存储大小 如当存储中文字符时，底层还是需要扩充到两个字节存储 同样，可变字符序列的StringBuilder和StringBuffer也改为了byte[]数组 + 编码标识字段的方式 集合工厂方法只读集合创建 在实际开发中，常常需要创建一个只读的集合，即只能读取集合数据，不能修改集合数据。 JDK8方式在JDK8及其之前的版本创建一个只读的集合需调用Collections工具类的unmodifiableXxx()方法 List只读集合1 12345678910List&lt;String&gt; namesList = new ArrayList&lt;&gt;();namesList.add(&quot;Joe&quot;);namesList.add(&quot;Bob&quot;);namesList.add(&quot;Bill&quot;);//返回的namesList是一个只读的集合namesList = Collections.unmodifiableList(namesList);namesList.add(&quot;Tom&quot;);//不允许再添加，否则报出异常System.out.println(namesList); List只读集合2 123//通过Arrays.asList()创建的集合也是一个只读集合List&lt;Integer&gt; list = Arrays.asList(1,2,3,4);list.add(6);//报异常，不允许修改 Set只读集合 123Set&lt;String&gt; set = Collections.unmodifiableSet( new HashSet&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))); Map只读集合 12345678Map&lt;String, Integer&gt; map = Collections.unmodifiableMap(new HashMap&lt;&gt;() &#123; &#123; put(&quot;a&quot;, 1); put(&quot;b&quot;, 2); put(&quot;c&quot;, 3); &#125;&#125;);map.forEach((k, v) -&gt; System.out.println(k + &quot;:&quot; + v)); JDK9方式 在JDK9中，创建只读的List、Set、Map集合可有这集合接口定义的静态的重载的方法of()方法实现 12345List&lt;Integer&gt; list = List.of(1, 2, 3, 4, 5);Set&lt;Integer&gt; set = Set.of(1, 2, 3, 4, 5);Map&lt;String, Integer&gt; map1 = Map.of(&quot;Key1&quot;, 1, &quot;Key2&quot;, 2, &quot;Key3&quot;, 3);Map&lt;String, Integer&gt; map2 = Map.ofEntries(Map.entry(&quot;Key1&quot;, 1), Map.entry(&quot;Key1&quot;, 2)); inputStream加强 在JDK9中为InputStream新增了一个transferTo方法 transferTo方法，可将InputStream中的所有数据直接传输到OutputStream中 1234567891011121314151617181920212223242526package com.company.jdk9;import java.io.*;/** * 将src目录下的文件复制一份 * @author yhd * @create 2021-06-30 8:58 */public class InputStreamPlus &#123; public static void main(String[] args) &#123; ClassLoader classLoader = InputStreamPlus.class.getClassLoader(); InputStream is = classLoader.getResourceAsStream(&quot;file.txt&quot;); try &#123; OutputStream os = new FileOutputStream(&quot;dir\\\\file2.txt&quot;); try(is;os)&#123; is.transferTo(os); System.out.println(&quot;执行完毕！！！&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Stream API加强概述 Java的Steam API是java标准库最好的改进之一，让开发者能够快速运算， 从而能够有效的利用数据并行计算。Java 8 提供的 Steam 能够利用多核架构实现声明式的数据处理。 在 Java 9中，Stream API 变得更好，Stream 接口中添加了4 个新的静态方法，takeWhile, dropWhile, ofNullable，还有个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。 takeWhile()Stream&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate)：从头开始返回尽可能多的元素 接收一个Predicate断言型接口来进行选择，从头开始匹配为true结果的元素 一旦遇到不匹配的即刻停止运行，即使后面还有元素匹配都不再运行 12345List&lt;Integer&gt; list = Arrays.asList(33, 2, 22, 32, 77, 35, 1);Stream&lt;Integer&gt; stream = list.stream();stream.takeWhile(t -&gt; t &lt; 40).forEach(System.out::println);//打印结果：2、22、32 dropWhile()Stream&lt;T&gt; dropWhile(Predicate&lt;? super T&gt; predicate)：dropWhile的行为与 takeWhile 相反，返回takeWhile 剩余的那部分元素 接收一个Predicate断言型接口来进行选择，从头开始跳过匹配为true结果的元素 直至遇到第一个不匹配的(包含它)，后的所有数据保留，即保留剩余的。 12345List&lt;Integer&gt; list = Arrays.asList(33, 2, 22, 32, 77, 35, 1);Stream&lt;Integer&gt; stream = list.stream();stream.dropWhile(t -&gt; t &lt; 40).forEach(System.out::println);//打印结果：77、35、1 ofNullable() jdk8情况：Stream初始化元素只有一个时，不允许为null。而多个元素时允许出现null值 可理解Stream的of类似Optional的of，即传入的参数一定不能为null 12345Stream&lt;Integer&gt; stream1 = Stream.of(1, 2, 3,null);//允许情况 Stream&lt;Object&gt; stream2 = Stream.of(null);//不允许情况Stream&lt;Object&gt; stream2 = Stream.of(null,null);//允许情况 jdk9情况：提供了ofNullable(T t)方法，允许初始化元素只有一个时，也允许为null &lt;T&gt; Stream&lt;T&gt; ofNullable(T t)：允许初始化一个null元素，也只有一个形参，非可变形参列表 1Stream&lt;Object&gt; stream = Stream.ofNullable(null);//允许情况 重载的Iterate()方法 jdk9提供了一个重载的新的iterate()方法，可提供一个断言型Predicate函数式接口 通过断言型函数式接口可以为其声明迭代的一个终止条件 其他使用方式与jdk8时的iterate相同 123//打印10以内的偶数Stream&lt;Integer&gt; stream = Stream.iterate(0, x -&gt; x &lt; 10, t -&gt; t + 2);stream.forEach(System.out::println);//0、2、4、6、8 Optional API加强 除了对Stream 本身的扩展，Optional和Stream 之间的结合也得到了改进。 现在可以通过Optional 的新方法 stream() 将一个 Optional 对象转换为一个 (可能是空的) Stream 对象 12345678910public class StreamPlus &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3,4); Optional&lt;List&lt;Integer&gt;&gt; optional = Optional.ofNullable(list); //提供了Optional转换为Stream类型的方法 Stream&lt;List&lt;Integer&gt;&gt; stream = optional.stream(); stream.flatMap(t -&gt; t.stream()).forEach(System.out::println);//1,2,3,4 &#125;&#125; 其他新特性 多版本兼容jar包 javadoc的HTML5支持 JavaScript引擎升级：Nashorn升级 java的动态编译器 全新HTTP客户端API，HttpClient Nashorn引擎 Nashorn 项目在 JDK 9 中得到改进，它为 Java 提供轻量级的 Javascript 运行时。 Nashorn 项目跟随 Netscape 的 Rhino 项目，目的是为了在 Java 中实现一个高 性能但轻量级的 Javascript 运行时。Nashorn 项目使得 Java 应用能够嵌入 Javascript。它在 JDK 8 中为 Java 提供一个 Javascript 引擎。 JDK 9 包含一个用来解析 Nashorn 的 ECMAScript 语法树的 API。这个 API 使得 IDE 和服务端框架不需要依赖 Nashorn 项目的内部实现类，就能够分析 ECMAScript 代码。 注：JDK 11的时候，又弃用了Nashorn引擎 JavaScript三大组成部分 ECMAScript：语法层面内容 DOM：描述网页中的DOM结构，解析读取或修改网页中的数据 BOM：’B’，指”Browser”，即浏览器，与浏览器交互相关的内容 JDK10概述 2018年3月21日，Oracle官方宣布Java10正式发布。 JDK10一共定义了109个新特性，其中包含12个JEP，对应开发者来说就主要了解12个中核心新特性，只有一个，即”局部变量类型推断“。 还有一些新API和JVM规范以及JAVA语言规范 的改动。 JEP：JDK Enhancement Proposal特性加强提议 12个JEP官方文档：http://openjdk.java.net/projects/jdk/10 局部变量类型推断背景 局部变量的前部分的显示类型声明，常常被认为是不必须的，示例如下 场景一：类实例化时 在声明一个变量时，习惯了编写两次变量类型，一次用于声明变量类型，第二次用于构造器。而且往往这两种类型都是一样的。 12LinkedHashSet&lt;Integer&gt; set = new LinkedHashSet&lt;&gt;();//拟优化成：set = new LinkedHashSet&lt;&gt;(); 场景二：返回值类型含复杂泛型结构 12Iterator&lt;Map.Entry&lt;Integer, Student&gt;&gt; iterator = set.iterator();//拟优化成：iterator = set.iterator(); 其实从目前很多IDE中可以对操作的类型结果进行自动生成就能看到，是可以推断出来的，也省略的 即官方也可完成这个局部变量类型推断的操作 优化后存在的好处 减少了啰嗦和形式的代码，避免了信息冗余 对齐了变量名，更容易阅读 更加关注代码的右侧部分，也是关键部分 类型推断示例基本数据类型 原生方式 1int num = 10; 类型推断 1var num = 10; 带泛型 原生方式 1List&lt;String&gt; list = new ArrayList&lt;&gt;(); 类型推断 1var list = new ArrayList&lt;String&gt;(); 遍历操作普通for循环 原生方式 123for(int i = 0;i &lt; 100;i++)&#123; System.out.println(i);&#125; 类型推断 123for(var i = 0;i &lt; 100;i++)&#123; System.out.println(i);&#125; 增强for循环 原生方式 1234List&lt;String&gt; list = new ArrayList&lt;&gt;();for(String str : list)&#123; System.out.println(str);&#125; 类型推断 1234var list = new ArrayList&lt;String&gt;();for(var str : list)&#123; System.out.println(str);&#125; 不支持类型推断变量声明操作 由于类型推断依靠参数值来进行推断的，因此没有赋值的声明操作无法使用 12int num2;//正确var num1;//错误 Lambda表达式 由于Lambda表达式已经是最简化式的函数式接口类型推断了 若把接口类型都省略成var，则Lambda表达式无法推断出接口 12Supplier&lt;Double&gt; sup = () -&gt; Math.random();//正确var sup = () -&gt; Math.random();//错误 数组静态初始化1234int[] ary1 = new int[]&#123;1,2,3&#125;;//正确var ary2 = new int[]&#123;1,2,3&#125;;//正确var ary2 = &#123;1,2,3&#125;;//错误 方法返回类型 推断逻辑反转错误，变成了由方法的调用者控制方法的返回类型 1234//错误方式public var method()&#123; return 0;&#125; 形参列表 如方法、构造器、catch()等的形参列表均不允许使用 1234//错误方式public void method(var num)&#123; &#125; 工作原理 在处理var时，编译器先是查看表达式右边部分，并根据右边变量值的类型进行推断 推断后的类型作为左边变量的类型，然后将该类型写入字节码当中 将源文件的所有var，都会被类型推断后在字节码文件中(.class)将其类型填充完整后再加载到JVM 如下是使用IntelliJ（实际上为Fernflower的反编译器）反编译器反编译出的代码 var其他概述var不是关键字 var不是关键字，作为顶替类型名的合法标识符 除了不能用它作为类名，其他的都可以， 但极少会用它作为类名 与JavaScript的区别 首要说明的是，var并不会改变Java是一门静态类型语言的事实 从代码来看，就好像之前已经声明了这些类型一样。事实上，这一特性只发生在编译阶段，与运行时无关，所以对运行时的性能不会产生任何影响。这不是 JavaScript。 编译器只负责推断出类型，并把结类型完整写入字节码文件，就好像是开发人员自己敲入类型一样 只读集合创建copyOf() 自jdk9开始，Jdk 里面为集合（List / Set / Map）都添加了 of()方法 而jdk10又新增了copyOf()，均可用来创建不可变，即只读的集合 of()与copyOf()方法两者之间的区别 copyOf()可以理解为比of()多一个检测功能 当传入集合变量调用copyOf()方法时，copyOf()先判断传入的集合是否为可变集合 若为可变集合，则转换为不可变(只读)集合 若已经为只读集合，则不操作，仅返回只读集合的引用(旧的集合)。 而of()方法没有先检测的步骤，而是任何类型的集合调用of()方法后都是返回一个新的不可变集合 123456789101112public static void main(String[] args)&#123; //示例1： var list1 = List.of(&quot;Java&quot;, &quot;Python&quot;, &quot;C&quot;); var copy1 = List.copyOf(list1); System.out.println(list1 == copy1); // true //示例2： var list2 = new ArrayList&lt;String&gt;(); list2.add(&quot;aaa&quot;); var copy2 = List.copyOf(list2); System.out.println(list2 == copy2); // false&#125; 小结：总的来说，copyOf()方法比of()好，因此对于采用新特性创建不可变集合，推荐使用jdk10提供的copyOf()方法。 JDK11概述 北京时间 2018年9月26日， Oracle 官方宣布 Java 11 正式发布。是一个长期支持版本(LST)， Java11 将带来两种GC机制(Epsilon与 ZGC)、 HttpClient等重要特性，一共包含17 个 JEP 字符串处理API JDK11，新增的字符串处理API Method Descriptions Example boolean isBlank() 判断字符串是否为空白 “ “.isBlank(); // true String strip() 去除首尾空白 “ Javastack “.strip(); // “Javastack” String stripLeading() 去除尾部空格 “ Javastack “.stripTrailing(); // “ Javastack” String repeat(int count) 复制len遍字符串 “Java”.repeat(3); // “JavaJavaJava” Stream&lt;String&gt; lines() 按行分割封装成Stream对象 可结合Stream的count()终止操作统计行数 “A\\nB\\nC”.lines().count(); // 3 …… Optional API增强 Method Descriptions Version boolean isEmpty() 判断value是否为空 JDK 11 T orElseThrow() value非空，返回value；否则抛异常 NoSuchElementException JDK 10 ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction) value非空，执行参数1功能；如果value 为空，执行参数2功能 JDK 9 Optional&lt;T&gt; or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier) value非空，返回对应的Optional； value为空，返回Supplier形参封装的Optional JDK 9 Stream&lt;T&gt; stream() value非空，返回仅包含此value的 Stream；否则，返回一个空的Stream JDK 9 …… 类型推断升级 在var上添加注解的语法格式，在jdk10中是不能实现的。在JDK11中加入了这样的语法 123456//错误的形式: 必须要有类型, 可以加上var//Consumer&lt;String&gt; con1 = (@Deprecated t) -&gt; System.out.println(t.toUpperCase());//正确的形式://使用var的好处是在使用lambda表达式时给参数加上注解。Consumer&lt;String&gt; con2 = (@Deprecated var t) -&gt; System.out.println(t.toUpperCase()); HttpClient概述 HttpClient用于替换HttpURLConnection，早在JDK9时已引入 由于JDK11又对其HttpClient进行整改，因此以JDK11版本学习为主 HTTP Client API，该 API支持同步和异步，提供对WebSocket和HTTP/2的支持。用于替代仅适用于 blocking 模式的 HttpURLConnection HttpURLConnection是在HTTP 1.0的时代创建的，并使用了协议无关的 方法 示例代码引入结构 HttpClient是一个内部结构，若使用需要先进行模块化导入 123module Xxxx&#123; requires java.net.http;&#125; 同步方式1234567HttpClient client = HttpClient.newHttpClient();HttpRequest request = HttpRequest.newBuilder(URI.create(&quot;http://127.0.0.1:8080/test/&quot;)).build();BodyHandler&lt;String&gt; responseBodyHandler = BodyHandlers.ofString();HttpResponse&lt;String&gt; response = client.send(request, responseBodyHandler);String body = response.body();System.out.println(body); 异步方式1234567HttpClient client = HttpClient.newHttpClient();HttpRequest request = HttpRequest.newBuilder(URI.create(&quot;http://127.0.0.1:8080/test/&quot;)).build();BodyHandler&lt;String&gt; responseBodyHandler = BodyHandlers.ofString();CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; sendAsync = client.sendAsync(request, responseBodyHandler);sendAsync.thenApply(t -&gt; t.body()).thenAccept(System.out::println); ZGC GC是java主要优势之一。 然而, 当GC停顿太长, 就会开始影响应用的响应时间。消除或者减少GC停顿时长, java将对更广泛的应用场景是一个更有吸引力 的平台。此外, 现代系统中可用内存不断增长,用户和程序员希望JVM能够以高 效的方式充分利用这些内存, 并且无需长时间的GC暂停时间。 ZGC, A Scalable Low-Latency Garbage Collector(Experimental) ZGC, 这应该是JDK11最为瞩目的特性, 没有之一。 但是后面带了Experimental, 说明这还不建议用到生产环境，还处于实验阶段。 ZGC是一个并发，基于region, 压缩型的垃圾收集器, 只有root扫描阶段会STW(stop the world)，因此GC停顿时间不会随着堆的增长和存活对象的增长而变长。 优势： GC暂停时间不会超过10ms 既能处理几百兆的小堆,，也能处理几个T的大堆(OMG) 和G1相比, 应用吞吐能力不会下降超过15% 为未来的GC功能和利用colord指针以及Load barriers优化奠定基础 初始只支持64位系统 ZGC的设计目标是：支持TB级内存容量，暂停时间低（&lt;10ms），对整个程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存）， 或压缩堆。 其他新特性 简化了编译运行命令 废弃了Nashorn引擎 Unicode 10 Deprecate the Pack200 Tools and API 新的Epsilon垃圾收集器 完全支持Linux容器（包括Docker） 支持G1上的并行完全垃圾收集 最新的HTTPS安全协议TLS 1.3 Java Flight Recorder：java的飞行记录仪，类似飞机的黑匣子 核心新特性小结 JDK9： 目录变更、模糊化系统、jshell 接口私有方法、加强泛型类型推断、try语句改进 String存储结构变更、of()只读集合创建方法、Inputstream API增强、Stream API增强 JDK10： 局部变量类型推断 copyOf()只读集合创建方法 JDK11： 两大垃圾回收器更新， Epsilon与 ZGC HttpClient、String API增强、Optional API 增强 展望 原生的JSON API支持 原生的货币API支持 选择比努力更重要","categories":[],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/tags/JavaSE/"}]},{"title":"Java8(LTS)其他新特性基础","slug":"Java8(LTS)其他新特性基础","date":"2021-06-29T08:57:56.000Z","updated":"2021-08-25T15:27:11.749Z","comments":true,"path":"2021/06/29/Java8(LTS)其他新特性基础/","link":"","permalink":"http://yoursite.com/2021/06/29/Java8(LTS)%E5%85%B6%E4%BB%96%E6%96%B0%E7%89%B9%E6%80%A7%E5%9F%BA%E7%A1%80/","excerpt":"","text":"引言：本文主要介绍一些现今开始常用的JDK8其他新特性，其中涉及了JDK8中Lambda表达式、函数式接口，方法引用和构造器引用，强大的StreamAPI，Optional类。 JDK8概论概论 Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。 于2014年3月发布 自Java 5以来最具革命性的版本 Java 8为Java语言、编译器、类库、开发 工具与JVM带来了大量新特性 速度更快 代码更少，增加了新的语法，Lambda 表达式 强大的Stream API 便于并行 最大化减少空指针异常：Optional（给空指针预设实例对象） Nashorn引擎，允许在JVM上运行JS应用（jjs.exe命令，可执行js程序） 以前JDK6也有js引擎，只是对比Google V8引擎太慢了，JDK8更新成为Nashorn引擎 小结：JDK8表面上最明显的更新就是，Lambda表达式(函数式编程)、Stream API、Optinal API的更新 新特性导图 JDK8新特性思维导图 常用新特性回顾 接口：新增了允许interface，声明default默认方法和静态方法 新日期时间API：Instant、LocalDate、LocalTime、localDateTime、DateTimeFromat… 注解：类型注解，重复注解… 集合： 目标类型推断，即可省略后部分的泛型类型声明：List&lt;String&gt; list = new ArrayList&lt;&gt;(); ArrayList和HashMap都初始化都从饿汉式预先初始化到懒汉式的懒加载初始化 HashMap底层结构加入了红黑树，提高了查找效率 …. …. 外在最显著的新特性是，Lambda 表达式和Stream API Lambda表达式基本概念Lambda表示数学符号”λ”，计算机领域中的λ代表”λ演算”，表达了计算机中最基本的概念：”调用”和”置换”概念 Lambda是一个匿名函数 可以把 Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递） 实用Lambda表达式可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升 Lambda表达式不是Java特有的特性，而是在编程技术发展中出现的表达式。Java对此也表示支持，因此更新了Lambda表达式的实用支持。 Lambda表达式的引用其实很大程度是，当接口中只有一个抽象方法时，反正实现类实现该接口都一定必须只有实现这个方法，因此我们可以考虑将其方法名、方法体语法格式等等语法层面的结构都省略掉，只留下表示方法体范围的部分的语法。这样能在不改变编程逻辑的情况下，大量缩短编码的内容。 初体验 示例1 1234567891011121314151617181920package com.company.jdk8;public class LambdaTest &#123; public static void main(String[] args) &#123; //当接口只有一个抽象方法时，如实现Runnable接口(自调用run只是为了方便测试) //1、原生方式 Runnable runnable1 = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;多线程代码1...&quot;); &#125; &#125;; runnable1.run();//单线程调用测试：多线程代码1... //2、Lambda表达式：无形参抽象方法的Lambda表达式使用 Runnable runnable2 = () -&gt; System.out.println(&quot;多线程代码2...&quot;); runnable2.run();//单线程调用测试：多线程代码2... &#125;&#125; 示例2 123456789101112131415161718192021222324252627282930313233package com.company.jdk8;import java.util.Comparator;/** * @author yhd * @create 2021-06-28 14:46 */public class LambdaTest &#123; public static void main(String[] args) &#123; //当接口只有一个抽象方法时，如实现Comparator接口 //1、原生方式 Comparator&lt;Integer&gt; comparator1 = new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return Integer.compare(o1,o2); &#125; &#125;; int compare1 = comparator1.compare(12, 33); System.out.println(&quot;compare1 = &quot; + compare1);//-1 //2、Lambda表达式 Comparator&lt;Integer&gt; comparator2 = (o1,o2) -&gt; Integer.compare(o1,o2); int compare2 = comparator2.compare(33, 12); System.out.println(&quot;compare2 = &quot; + compare2);//1 //2.1、在Lambda表达式中使用方法的引用 Comparator&lt;Integer&gt; comparator3 = Integer :: compare; int compare3 = comparator3.compare(12, 33); System.out.println(&quot;compare3 = &quot; + compare3);//1 &#125;&#125; 语法格式基础语法格式举例： (o1,o2) -&gt; &#123;Integer.compare(o1,o2)&#125;; -&gt;：Lambda操作符或箭头操作符 -&gt;左边：Lambda形参列表 （其实就是接口中的抽象方法的形参列表） -&gt;右边：Lambda体 （其实就是重写的抽象方法的方法体） Lambda表达式本质：作为只有一个抽象方法的接口(函数式接口)的实例 这里说的本质指Java层面的Lambda表达式本质，其他语言的Lambda表达式可能是一个类或者其他 格式变形 根据不同的使用情况，Lambda表达式在基础语法格式的可以有多种格式上的变形。 无参,无返回值 接口的抽象方法，无形参，无返回值 1Runnable r1 = () -&gt; &#123;System.out.println(&quot;Hello Lambda!&quot;);&#125;; 有参,无返回值 接口的抽象方法，有一个形参，无返回值 1Consumer&lt;String&gt; con = (String str) -&gt; &#123;System.out.println(str);&#125;; 省略数据类型 接口存在泛型时，泛型所决定的数据类型，可由编译器推断得出，称为“类型推断” 1Consumer&lt;String&gt; con = (str) -&gt; &#123;System.out.println(str);&#125;; 类型推断：上述 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序 的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于 上下文环境，是由编译器推断出来的。这就是所谓的“类型推断”。 一个形参,省略括号 当接口只有一个参数时，参数的小括号可以省略 1Consumer&lt;String&gt; con = str -&gt; &#123;System.out.println(str);&#125;; 多参,多语句,返回值 当接口需要两个或以上的参数，多条执行语句，并且可以有返回值 1234Comparator&lt;Integer&gt; com = (x，y)-&gt;&#123; System.out.println(&quot;实现函数式接口方法！&quot;); return Integer.compare(x，y);&#125;; 一条语句 当接口的实现方法体只有一条语句时，return、大括号若存在则都可省略 1Comparator&lt;Integer&gt; com = (o1,o2) -&gt; Integer.compare(o1,o2); 小结 Lambda表达式本质作为只有一个抽象方法的接口(函数式接口)的实例 -&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也可以省略 -&gt;右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一对{}和return关键字 函数式接口引言 当接口中只有一个抽象方法时，反正实现类实现该接口都一定必须只有实现这个方法，因此我们可以考虑将其方法名、方法体语法格式等等语法层面的结构都省略掉，只留下表示方法体范围的部分的语法。这样能在不改变编程逻辑的情况下，大量缩短不必要的编码的内容。 Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP) 编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不 得不做出调整以便支持更加广泛的技术要求，也即java不但可以支持OOP还 可以支持OOF（面向函数编程） 在其他支持Lambda表达式的语言中，Lambda表达式常以函数的身份定义，而java中不同，java把Lambda表达式作为接口的实现类对象来看待 以前用匿名实现类表示的现在都可以用Lambda表达式来写 基础概念 若一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口 如Java的Runnable接口，**@FunctionalInterface以标识作用**显式表明就是一个函数式接口 123456package java.lang;@FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125; 若自定义一个函数式接口，则建议都加上@FunctionalInterface注解 使其编译器能够自动帮我们进行校验，规避不必要的错误。如一个函数式接口中定义超过一个的接口。 同时javadoc也会被解析为其接口添加函数式接口的标识 官方函数式接口 定义这些已有的不同类型的函数式接口的目的在于，为用户提供从原生代码编写方式转变为Lambda表达式编写方式提供了已有的桥梁 而定义一系列不同类型规范化的函数式接口的目的在于，免去用户为将原生代码转变Lambda表达式而进行自定义函数式接口的编码操作，同时规范化接口功能、命名。是一种基于API层面基于用户的编码规范。 即给定用户已有的不同业务逻辑函数式接口，让用户更方便地将原生代码转变为Lambda表达式的写法。即函数式编程。 在Stream API 中，为了大量地支持函数式编程，即Lambda表达式的使用，许多终止操作都是提供函数式接口。 使Stream API支持函数式编程是其中的一个用意。从侧面也能反映出函数式编程的内涵，或者说是函数式编程的需求背景，即希望在支持方法调用链的API中尽量缩短每一个调用链的代码长度。 在具有承上启下的连续操作(如Stream API)，或单纯同类型的重复操作(StringBuilder/StringBuffer)中常会出现方法链调用的支持 注：不是任何代码都可以改造成函数式编程的方式，只有在用到接口实现类，且仅有一个抽象方法的场景，即属于函数式接口时才可考虑改装成功函数式编程。 核心接口 核心函数式接口 Consumer 概念：Consumer&lt;T&gt;：消费型接口，提供一个泛型参数用于消费，用于提供他人仅传入方法体的操作。即无返回值，仅传入方法体消费泛型参数。内置抽象方法定义为void accept(T t); 用例：Stream API 中终止方法forEach(Consumer&lt;T&gt; action)所提供的函数式接口就是消费型的，仅传入方法体去操作forEach，即遍历的过程中的动作。 Supplier 概念：Supplier&lt;T&gt;是一个供给型接口，正好与消费型接口相反。无泛型参数，提供具有返回值的方法体操作。 用例： Function 概念：Fuction&lt;T&gt;是一个函数型接口，提供一个类型T可供对象操作，并返回任意类型结果R，即操作后的类型可以变。包含方法：boolean test(T t) 用例：如Stream API中map(Fuction&lt;T&gt; f)方法，可以提供T类型对象，再返回T对象中某个属性类型 Predicate 概念：Predicate&lt;T&gt;是一个断定型接口，可以返回值只能为Boolean类型的函数型接口。用于对类型为T的对象进行操作，传入作为判定操作的方法体。方法：R apply(T t) 用例： 示例代码： 例如编写一个可供别人定制化使用(多态的使用场景)的过滤字符串添加的函数时 过滤规则可以抽取出来作为一个接口的实现类传入。 通过实现该接口编写过滤规则，此时该接口的功能就属于判定式接口，若符合规则返回true，否则返回false 1234567891011121314151617181920212223242526272829303132333435363738394041package com.company.jdk8;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.function.Predicate;/** * @author yhd * @create 2021-06-28 14:46 */public class LambdaTest &#123; //对list字符串以符合pre接口的true标准过滤 public static List&lt;String&gt; filterString(List&lt;String&gt; list, Predicate&lt;String&gt; pre)&#123; List&lt;String&gt; filterList = new ArrayList&lt;&gt;(); for (String str : list) &#123; if(pre.test(str))&#123; filterList.add(str); &#125; &#125; return filterList; &#125; //测试 public static void main(String[] args) &#123; List&lt;String&gt; list = Arrays.asList(&quot;北京&quot;,&quot;天津&quot;,&quot;南京&quot;); //1、原始方式 Predicate&lt;String&gt; stringPredicate = new Predicate&lt;String&gt;() &#123; @Override public boolean test(String s) &#123; return s.contains(&quot;京&quot;); &#125; &#125;; List&lt;String&gt; filterList1 = filterString(list, stringPredicate); System.out.println(filterList1);//[北京, 南京] //2、Lambda表达式方式 List&lt;String&gt; filterList2 = filterString(list, str -&gt; str.contains(&quot;京&quot;)); System.out.println(filterList2);//[北京, 南京] &#125;&#125; 其他接口 其他接口都是核心的函数式接口基础上的变形 BiXxx == Binary：表示二元 Unary：一元 方法,构造器引用方法引用概念 方法引用(Method References) ：当要传递给Lambda体的操作，已经有实现的方法时，可以使用方法引用 方法引用可以看做是Lambda表达式深层次的表达 即方法引用就是Lambda表达式，也是函数式接口的一个实例 语法规则 前提：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的一致 格式：使用操作符 “**::**” 将类(或对象) 与方法名分隔开来，以下各种调用方法的方式。 对象 :: 实例方法名：普通方法(非静态方法)调用 类 :: 静态方法名：静态方法调用 类 :: 实例方法名：第一个形参作为调用方法的对象 此时取走第一个形参作为引用方法的调用者，用参数所属的类表示 剩余的参数作为抽象方法的实参传入 若取走第一个形参后没有参数了，即抽象方法形参数只有一个，则等价于无参方法调用 类::实例方法分析 情况1：抽象方法形参有两个或以上。所构成的方法调用 如(x,y)-&gt;x.equals(y);，则使用方法引用则需要String::equals; 这种情况下，系统默认讲第一个参数作为方法的调用者，即x.equals(); 剩下的第二个参数，则作为实参传入，即x.equals(y); 情况2：抽象方法形参只有一个，等价与第一个形参的空参方法调用 Function的apply(T t)抽象方法体 1R apply(T t); 测试代码，抽象方法只有一个形参，则t取走作为了调用方法的对象，剩下就没有参数作为实参传入调用的方法中，因此等于t调用了一个空参的方法。 1234567public static void main(String[] args) &#123; Employee employee = new Employee(1001, &quot;Jerry&quot;, 23, 6000); //两者同样是，调用了抽象方法形参1的getName()方法， Function&lt;Employee,String&gt; func1 = e -&gt; e.getName(); Function&lt;Employee,String&gt; func2 = Employee::getName;&#125; 示例代码非静态方法 Lambda表达式 1Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x); 等价的方法引用方式的Lambda表达式 1Consumer&lt;String&gt; con = System.out::println; 静态方法 Lambda表达式 1Comparator&lt;Integer&gt; com =(x,y) -&gt; Integer.compare(x,y); 等价的方法引用方式的Lambda表达式 12Comparator&lt;Integer&gt; com = Integer::compare;int value = com.compare(12,32); 自调用方法 情况1：参数作为调用者的带参方法调用 Lambda表达式 1BiPredicate&lt;String,String&gt; bp = (x,y) -&gt; x.equals(y); 等价的方法引用方式的Lambda表达式 12BiPredicate&lt;String,String&gt; bp = String::equals;//自动把第一个参数作为方法的调用者boolean flag = bp.test(&quot;hello&quot;,&quot;hi&quot;); 情况2：抽象方法只有一个形参，参数作为调用者的无参方法调用 Function的apply(T t)抽象方法体 1R apply(T t); 测试代码 12345Employee employee = new Employee(1001, &quot;Jerry&quot;, 23, 6000);//两者同样是，调用了抽象方法形参1,即t调用了getName()方法，Function&lt;Employee,String&gt; func1 = e -&gt; e.getName();Function&lt;Employee,String&gt; func2 = Employee::getName; 构造器引用语法规则 前提： 要求构造器参数列表要与接口中抽象方法的参数列表一致！ 方法的返回值即为构造器对应类的对象 格式：ClassName::new 若抽象方法带形参，则全部作为构造器实参进行传入 tips：方法引用或者构造器引用，都不用写形参列表，都是自动代入。 示例代码12Function&lt;Integer,MyClass&gt; fun = (n) -&gt; new Myclass(n);Function&lt;Integer,MyClass&gt; fun = Myclass::new; 数组引用语法规则 格式： type[] :: new 可以近似地将数组的new 看作一个特殊的类，写法与构造器引用类似 示例代码12Function&lt;Integer,Integer[]&gt; fun = (n) -&gt; new Integer[n];Function&lt;Integer,Integer[]&gt; fun = Integer[]::new; Stream API概论基础概念 Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。 Stream 是 Java8 中处理集合的关键抽象概念，它可以对指定的集合进行非常复杂的查找、过滤和映射数据等操作。 Stream的出现很大程度是加入对数据分析与数据挖掘的支持，使其在后端进行大量的数据处理操作，如筛选、切片、求值…，可以说Java生命力强在于不断的进行符合潮流的更新迭代… 使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询(排序、过滤、筛选) 也可使用 Stream API 来并行执行操作 简言之，Stream API 提供了一种高效且易于使用的处理数据的方式 Stream与Collection区别 Collection是一种静态的内存数据结构，是用存储数据的集合，主要面向内存 Stream是操作集合的工具，是用于相关计算的(过滤，映射，计算最大/最小)，主要面向与CPU Stream是数据渠道，是用于操作数据源（集合、数组等）所生成的元素序列 “集合讲的是数据，Stream讲的是计算！ 串行与并行流 串行流：Stream对数据源进行操作时。数据扫描采用单线程顺序扫描，操作的结果与源数据本来的顺序有关 并行流：数据扫描或操作采用多线程，对于非排序操作(数据加载)，操作的结果与原有数据的顺序无关。 Stream原理 Stream 自身不会存储元素 Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream Stream 操作是延迟执行的，意味着必须执行了终止操作，中间操作才会开始执行 操作原理 创建Stream：准备一个数据源(集合、数组)，通过数据源获取Stream对象实例，或用无限流创建。 中间操作：一个中间操作链，对数据源的数据进行一个或多个处理操作(limt、max等) 终止操作(终端操作) ： 一旦执行终止操作，就会执行中间操作链，并产生结果。 随后，作为结果描述的Stream对象不能再被使用 Stream实例化Stream对象的实例化有4种方式 Collection方式：JDK8对Collection接口扩充了两个default方法，提供获取串行Stream和并行Stream对象 Arrays方式：对于数组类型的数据源，可以使用Arrays工具类提供静态的static stream()方法 Stream方式：Stream类本身也提供静态方法of(T… values)，通过可变形参的方式提供数据源 创建无限流：可直接在Stream上创建无限个数据源对应的Stream实例 迭代方法：iterate，传入一元函数型接口对种子数据seed进行迭代操作去生成数据无限量的数据 生成方法：generate，直接通过供给型函数式接口，生成无限量数据 Collection方式 JDK8对Collection接口扩充了两个default方法，提供获取串行Stream和并行Stream对象 123456789public static void main(String[] args) &#123; List&lt;Person&gt; list = new ArrayList&lt;&gt;(); list.add(new Person(&quot;Priscilla&quot;,23)); list.add(new Person(&quot;Deny&quot;,25)); //获取Stream实例 Stream&lt;Person&gt; stream = list.stream(); Stream&lt;Person&gt; personStream = list.parallelStream();&#125; Arrays方式 对于数组类型的数据源，可以使用Arrays工具类提供静态的static stream()方法 12345678910public static void main(String[] args) &#123; Person p1 = new Person(&quot;Priscilla&quot;,23); Person p2 = new Person(&quot;Deny&quot;,25); Person[] array = new Person[]&#123;p1,p2&#125;; int[] intArray = new int[]&#123;1,2,3,4,5&#125;; //获取Stream实例 Stream&lt;Person&gt; stream = Arrays.stream(array); IntStream stream1 = Arrays.stream(intArray);//基本数据类型有对应的Stream对象&#125; Stream.of()方式 Stream类本身也提供静态方法of(T… values)，通过可变形参的方式提供数据源 1234public static void main(String[] args) &#123; //貌似不能传入array和collection类型 Stream&lt;Integer&gt; stream2 = Stream.of(1,2,3,4);&#125; 创建无限流创建无限流：可直接在Stream上创建无限个数据源对应的Stream实例 迭代方法：iterate，传入一元函数型接口，通过对种子数据seed进行迭代操作去生成数据无限量的数据 一元函式接口指，UnaryOperator&lt;T&gt;(Function&lt;T&gt;的子接口) 生成方法：generate，直接通过供给型函数式接口，生成无限量数据 示例代码：由于不加以限制性的中间操作和终止操作，是会无限输出数据，和看不到数据效果 123456789public static void main(String[] args) &#123; //1、通过迭代的方式生成10个偶数 //种子数据，也可理解为初始数据 int seed = 0; Stream.iterate(seed,t -&gt; t + 2).limit(10).forEach(System.out::println); //2、通过生成的方式，直接生成10个随机数 Stream.generate(Math::random).limit(10).forEach(System.out::println);&#125; Stream中间操作 中间操作是对数据源进行数据处理的操作 多个中间操作可以连接起来形成一个流水线，即支持方法链调用 其次，中间操作只有在触发终止操作后，才会一次性全部处理，也称为“惰性求值” 中间操作可划分为几种类型 筛选与切片 映射 排序 筛选与切片API Method Descriptions filter(Predicate&lt;T&gt; p) 过滤、提供判定型函数式接口， 从流中排除判定为false的元素 limit(long maxSize) 截断流，使其元素不超过给定数量 skip(long n) 跳过元素，返回一个跳过了前 n 个元素的流。若流中元素不足 n 个，则返回一 个空流。与 limit(n) 互补 distinct() 筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素 …… 用例数据 Employee.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Employee &#123; private int id; private String name; private int age; private double salary; /* 此处省略getter和setter方法 */ public Employee() &#123; System.out.println(&quot;Employee().....&quot;); &#125; public Employee(int id) &#123; this.id = id; System.out.println(&quot;Employee(int id).....&quot;); &#125; public Employee(int id, String name) &#123; this.id = id; this.name = name; &#125; public Employee(int id, String name, int age, double salary) &#123; this.id = id; this.name = name; this.age = age; this.salary = salary; &#125; @Override public String toString() &#123; return &quot;Employee&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, salary=&quot; + salary + &#x27;&#125;&#x27;; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Employee employee = (Employee) o; if (id != employee.id) return false; if (age != employee.age) return false; if (Double.compare(employee.salary, salary) != 0) return false; return name != null ? name.equals(employee.name) : employee.name == null; &#125; @Override public int hashCode() &#123; int result; long temp; result = id; result = 31 * result + (name != null ? name.hashCode() : 0); result = 31 * result + age; temp = Double.doubleToLongBits(salary); result = 31 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32)); return result; &#125;&#125; EmployeeData：用于测试使用的数据 1234567891011121314151617public class EmployeeData &#123; public static List&lt;Employee&gt; getEmployees()&#123; List&lt;Employee&gt; list = new ArrayList&lt;&gt;(); list.add(new Employee(1001, &quot;马化腾&quot;, 34, 6000.38)); list.add(new Employee(1002, &quot;马云&quot;, 12, 9876.12)); list.add(new Employee(1003, &quot;刘强东&quot;, 33, 3000.82)); list.add(new Employee(1004, &quot;雷军&quot;, 26, 7657.37)); list.add(new Employee(1005, &quot;李彦宏&quot;, 65, 5555.32)); list.add(new Employee(1006, &quot;比尔盖茨&quot;, 42, 9500.43)); list.add(new Employee(1007, &quot;任正非&quot;, 26, 4333.32)); list.add(new Employee(1008, &quot;扎克伯格&quot;, 35, 2500.32)); return list; &#125;&#125; filter 过滤出薪资 &gt; 7000的员工 123456public static void main(String[] args) &#123; List&lt;Employee&gt; employees = EmployeeData.getEmployees(); Stream&lt;Employee&gt; stream = employees.stream(); stream.filter(t -&gt; t.getSalary() &gt; 7000).forEach(System.out::println);&#125; limit 取出前两项数据 123456public static void main(String[] args) &#123; List&lt;Employee&gt; employees = EmployeeData.getEmployees(); Stream&lt;Employee&gt; stream = employees.stream(); stream.limit(2).forEach(System.out::println);&#125; skip 跳过前三项数据 123456public static void main(String[] args) &#123; List&lt;Employee&gt; employees = EmployeeData.getEmployees(); Stream&lt;Employee&gt; stream = employees.stream(); stream.skip(3).forEach(System.out::println);&#125; distinct 执行过滤掉重复数据的操作 123456789101112public static void main(String[] args) &#123; List&lt;Employee&gt; employees = EmployeeData.getEmployees(); employees.add(new Employee(33,&quot;priscilla&quot;,23,666)); employees.add(new Employee(33,&quot;priscilla&quot;,23,666)); Stream&lt;Employee&gt; stream = employees.stream(); stream.forEach(System.out::println); System.out.println(); employees.stream().distinct().forEach(System.out::println);&#125; 映射映射的操作含义在于：数据源 ——&gt; [遍历 —&gt; map(Functio&lt;T&gt; t) —&gt;处理后] ——&gt;加工后的数据 API Method Descriptions map(Function&lt;T&gt; f) 接收一个函数型接口作为参数，该函数会被应用到每个元素上(自带遍历)，并将其映射成一个新的元素。 mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 DoubleStream。 mapToInt(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 IntStream。 mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 LongStream。 flatMap(Function&lt;T&gt; f) 接收一个函数型接口作为参数，若Function&lt;T&gt; 返回的也是一个Stream类型，则将该流中的每个值都换成另一个流，然后把所有流连接成一个流的结果。有点像list中addAll()和add的区别 ……. map 示例1：将集合的所有字符转换为大写 123456789public static void main(String[] args) &#123; List&lt;String&gt; list = Arrays.asList(&quot;aa&quot;,&quot;bb&quot;,&quot;CC&quot;,&quot;dd&quot;); //普通Lambda表达式 list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println); //使用方法引用方式更简短 list.stream().map(String::toUpperCase).forEach(System.out::println);&#125; 示例2：综合使用，获取员工姓名长度大于3的员工的姓名 12345678public static void main(String[] args) &#123; List&lt;Employee&gt; employees = EmployeeData.getEmployees(); Stream&lt;Employee&gt; stream = employees.stream(); stream.filter(t -&gt; t.getName().length() &gt; 3) .map(t -&gt; t.getName())//也可方法引用.map(Employee::getName) .forEach(System.out::println);&#125; flatMap 辅助测试方法：准备一个将字符的每个字符转换为Stream实例的方法 12345678public static Stream&lt;Character&gt; fromStringToStream(String str)&#123; ArrayList&lt;Character&gt; list = new ArrayList&lt;&gt;(); for(Character c : str.toCharArray())&#123; list.add(c); &#125; return list.stream();&#125; map()测试，直接整体当做一个Stream中的Stream元素了 1234public static void main(String[] args) &#123; Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(str -&gt; fromStringToStream(str));&#125; flatMap()测试，将Function&lt;T&gt;返回的Stream类型拆开，并全部链接成一个流 1234public static void main(String[] args) &#123; Stream&lt;Character&gt; characterStream = list.stream().flatMap(str -&gt; fromStringToStream(str));&#125; 排序API Method Descriptions sorted() 产生一个新流，其中按自然顺序排序 sorted(Comparator com) 产生一个新流，其中按比较器顺序排序 …… 自然排序 自然排序，从小到大 1234public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(12,33,4,11,25,3); list.stream().sorted().forEach(System.out::println);&#125; 定制排序 逆序排序，从大到小 12345public static void main(String[] args) &#123;List&lt;Integer&gt; list = Arrays.asList(12,33,4,11,25,3); list.stream().sorted((e1,e2) -&gt; -Integer.compare(e1,e2)).forEach(System.out::println);&#125; Stream终止操作 执行终止操作后的Stream对象间会被关闭，不能够再次使用，只能作为结果输出。 终止操作也具有多种类型划分 检查与查找 归约 收集 检查与查找API Method Descriptions boolean allMatch(Predicate p) 检查是否匹配所有元素 boolean anyMatch(Predicate p) 检查是否至少匹配一个元素 boolean noneMatch(Predicate p) 检查是否没有匹配所有元素 Optional findFirst() 返回第一个元素 Optional findAny() 返回当前流中的任意元素 long count() 返回流中元素总数 Optional max(Comparator c) 返回流中最大值 Optional min(Comparator c) 返回流中最小值 forEach(Consumer c) 内部迭代使用 Collection 接口需要用户去做迭代， 称为外部迭代相反，Stream API 使用内部迭代——它帮你把迭代做了) …… 归约 归约，在Java代码层面表现出的操作即， 将Stream中两个元素进行特定运算后返回其结果到原Stream集合中 反复进行该操作，是最终的Stream只剩下一个结果（规约） API 进行reduce归约操作前，一般先进行map操作，先取出reduce想操作的数据属性 这样进行reduce操作时，可以直接对数据元素进行操作。更加方便 map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。 Method Descriptions T reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 TT iden：初始值，作为Stream其中一个元素参与到操作中BinaryOperator b：二元函数型接口，将T t1与T t2进行操作返回T类型数据 Optional reduce(BinaryOperator b) 类同reduce(T iden, BinaryOperator b)可以将流中元素反复结合起来，返回Optional类型结果 …… reduce 示例1：计算1-10的自然数和结果 12345public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10); Integer reduce = list.stream().reduce(0, Integer::sum); System.out.println(&quot;reduce = &quot; + reduce);//55&#125; 示例2：计算公司所有员工工资的综合 先进行map操作，提取出目的归约数据，更方便地直接进行reduce操作 12345678public static void main(String[] args) &#123; List&lt;Employee&gt; employees = EmployeeData.getEmployees(); Optional&lt;Double&gt; reduce = employees.stream() .map(e -&gt; e.getSalary()) //或使用方法引用，Employee::getSalary .reduce(Double::sum); System.out.println(&quot;reduce = &quot; + reduce);&#125; 收集 若Stream操作中数据过多，或者需要暂存回内存中(Collection中)，可进行收集操作。 即也可以理解为，Stream转换为Collection方法的一种操作 API使用逻辑： 调用collect方法的前提需要传入Collector接口的实例 Collector接口的实例可以通过Collectors工具类提供的静态方法获得 最终绝对Stream转换为什么类型的集合(Collection、Map)取决于Collector接口的实例 Method Descriptions collect(Collector c) 将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总 的方法 Collectors-API 获取表明转换结果为List、Set的Collector实例 Static Method Descriptions toList() 返回一个 Collector ，它将输入元素到一个新的List toSet() 返回一个 Collector ，它将输入元素到一个新的Set toCollection() 返回一个 Collector ，它将输入元素到一个新的Collection中 toMap() 返回一个 Collector ，它将输入元素到一个新的Map中 …… 示例代码1：转换为List 12345public static void main(String[] args) &#123; List&lt;Employee&gt; collect = stream.collect(Collectors.toList()); collect.forEach(System.out::println);&#125; 示例代码2：转换为Set 12345public static void main(String[] args) &#123; Set&lt;Employee&gt; collect = stream.collect(Collectors.toSet()); collect.forEach(System.out::println);&#125; 其他工具类操作API方法 Static Method Descriptions Long counting() 计算流中元素的个数 Integer summingInt() 对流中元素的整数属性求和 Double averagingInt() 计算流中元素Integer属性的平均值 IntSummaryStatistics summarizingInt() 收集流中Integer属性的统计值。如：平均值 String joining() 连接流中每个字符串 Optional&lt;T&gt; maxBy() 根据比较器选择最大值 归约产生的类型 reducing() 从一个作为累加器的初始值开始， 利用BinaryOperator与流中元素逐个结合，归约成单个值 转换函数返回的类型 collectingAndThen() 包裹另一个收集器，对其结果转 换函数 Map&lt;K,List&lt;T&gt;&gt; groupingBy() 根据true或false进行分区 Map&lt;Boolean,List&lt;T&gt;&gt; partitioningBy() 根据true或false进行分区 …… Optional类引言 到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。 以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类， Guava通过使用检查空值的方式来防止空指针异常，代码污染，它鼓励程序员写更干净的代码 受到Google Guava的启发，Optional类已经成为Java 8类库的一部分 基本概念 Optional&lt;T&gt; 类(java.util.Optional) 是一个容器类，它可以保存任意类型T的值，甚至null值 原生代码是用null表示一个值不存在的 如今Optional通过一系列机制、标准、方法去更好的表达空值概念，使其避免空指针异常的出现 Optional提供很多有用的方法，这样我们就不用显式进行空值检测 APIOptional实例化 Optional对象的实例化是使用Optional容器的开始 如下提供三种实例化的方式，按场景需求选用合适的实例化方式对数据进行包装 若传入的形参不允许为空，为空就报错处理，则可选用of()方式，或者采用原生方式 若传入的参数允许为空，后续会进行Optional空值判断后可进一步对null值情况赋予默认值，如配合orElse(T other)方法使用，则选用ofNullable()方式对传入数据进行包装 Static Method Descriptions Optional.of(T t) 创建一个Optional 实例，t必须非空，否则报异常 Optional.ofNullable(T t) t允许为null Optional.empty() 创建一个空的Optional实例，内部value == null ……. Optional容器空值判断 Static Method Descriptions boolean isPresent() 判断是否包含对象，存在返回true void ifPresent(Consumer&lt;? super T&gt; consumer) 如果有值，就执行Consumer 接口的实现代码，并且该值会作为参数传给它 ….. Optional容器数据获取 Static Method Descriptions T get() 直接获取方式，Optional值必须存在，否则抛异常 T orElse(T other) 带默认值获取，即如果有值则将其返回，否则返回指定的other对象 T orElseGet(Supplier&lt;? extends T&gt; other) 如果有值则将其返回，否则返回由 Supplier接口实现提供的对象 T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) 如果有值则将其返 回，否则抛出由Supplier接口实现提供的异常 …… 示例代码Girl.java12345678910111213141516171819202122232425262728package com.company.jdk8;/** * @author yhd * @create 2021-06-29 15:15 */public class Girl &#123; private String name; private int age; public Girl(String name,int age)&#123; this.age = age; this.name = name; &#125; public String getName() &#123; return name; &#125; @Override public String toString() &#123; return &quot;Girl&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; Boy.java1234567891011121314151617181920212223242526272829303132package com.company.jdk8;/** * @author yhd * @create 2021-06-29 15:15 */public class Boy &#123; private String name; private Girl girlFriend; public Boy()&#123; &#125; public Boy(String name, Girl girlFriend) &#123; this.name = name; this.girlFriend = girlFriend; &#125; public Girl getGirlFriend() &#123; return girlFriend; &#125; @Override public String toString() &#123; return &quot;Boy&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, girlFriend=&quot; + girlFriend + &#x27;&#125;&#x27;; &#125;&#125; 原生null值过滤12345678910//原生null值过滤写法public static String getGirlFriendName1(Boy boy)&#123; if(boy != null)&#123; Girl girlFriend = boy.getGirlFriend(); if(girlFriend != null)&#123; return girlFriend.getName(); &#125; &#125; return null;&#125; Optional方式null值过滤1234567891011121314//Optional包装，方法判断过滤写法public static String getGirlFriendName2(Boy boy)&#123; //这里设计成允许boy为null情况，若为null后续给予默认情况 Optional&lt;Boy&gt; opBoy = Optional.ofNullable(boy); //若boy为null，拟返回的girlFriend肯定也为空，因此需一同给予默认的初始化 boy = opBoy.orElse(new Boy(&quot;Tom&quot;,new Girl(&quot;Priscilla&quot;,23))); Girl girlFriend = boy.getGirlFriend(); //同样这样也可设计成允许girlFriend为null情况，若为null后续给予默认情况 Optional&lt;Girl&gt; opGirl = Optional.ofNullable(girlFriend); girlFriend = opGirl.orElse(new Girl(&quot;Sally&quot;, 25)); return girlFriend.getName();&#125; 代码测试12345678910//测试public static void main(String[] args) &#123; Boy boy1 = null; String girlFriendName1 = getGirlFriendName2(boy1); System.out.println(girlFriendName1);//Priscilla Boy boy2 = new Boy(); String girlFriendName2 = getGirlFriendName2(boy2); System.out.println(girlFriendName2);//Sally&#125;","categories":[],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/tags/JavaSE/"}]},{"title":"Java反射机制","slug":"Java反射机制","date":"2021-06-28T01:20:34.000Z","updated":"2021-08-25T15:27:11.564Z","comments":true,"path":"2021/06/28/Java反射机制/","link":"","permalink":"http://yoursite.com/2021/06/28/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/","excerpt":"","text":"引言：本章主要说明Java反射相关的知识。其中包含Java反射机制概述、Class类及其获取实例操作、类的加载与ClassLoader的理解、创建运行时类的对象、获取运行时类的完整结构、调用运行时类的指定结构以及反射常见应用，动态代理。 反射的概述基本概念 Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看 到类的结构，所以，我们形象的称之为：反射。 反射其动态性在于，进行编译时不确定的类的相关操作 反射提供功能tips：强调“任意一个”主要突出私有的结构都可以被反射使用 在运行时判断任意一个对象所属的类 在运行时创建任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时获取泛型信息 在运行时调用任意一个对象的成员变量和方法 在运行时处理注解 生成动态代理 ……. 反射相关API java.lang.Class：代表一个类 java.lang.reflect.Method：代表类的方法 java.lang.reflect.Field：代表类的成员变量 java.lang.reflect.Constructor：代表类的构造器 …… 反射动态性体现 反射其动态性在于，进行编译时不确定的类的相关操作 如下示例代码，在编译使其是无法确认最终加载的类是什么，这就是反射的动态性 12345678910111213141516171819202122232425262728293031323334//体会反射的动态性@Testpublic void test()&#123; for(int i = 0;i &lt; 100;i++)&#123; int num = new Random().nextInt(3);//0,1,2 String classPath = &quot;&quot;; switch(num)&#123; case 0: classPath = &quot;java.util.Date&quot;; break; case 1: classPath = &quot;java.lang.Object&quot;; break; case 2: classPath = &quot;com.atguigu.java.Person&quot;; break; &#125; try &#123; Object obj = getInstance(classPath); System.out.println(obj); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/* 创建一个指定类的对象。 classPath:指定类的全类名*/public Object getInstance(String classPath) throws Exception &#123; Class clazz = Class.forName(classPath); return clazz.newInstance();&#125; 动态与静态语言动态语言 在运行时代码可以根据某些条件改变自身结构。 主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang 静态语言 静态语言与动态语言相对应的，运行时结构不可变的语言就是静态语言 如：Java、C、 C++ Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。 Java的动态性让编程的时候更加灵活！ Class类概述 Class类是描述类的结构的类，用与封装某一个类的结构，因此每一个类只对应一个Class实例 如果需要得知这个类的结构/类的类型，即传入一个Class类对象即可 如封装和记录指定类有什么属性、方法、构造器及其权限、泛型信息、注解信息等等一切关于类的信息。 在Java反射机制API中将类的每一个结构，如属性、方法、构造器都有对应的一个封装类进行描述和操作 如用于描述和操作构造器的Constructor封装类，得到该对象后可以通过调用newInstance()方法进行构造器的对象实例化。 属性对应的描述封装类就是Field，可以进行设置操作，也可以进行读取操作 Class类提供获取类所有结构对应的封装类对象实例的方法，如getConstructor()方法返回Constructor实例 Class类还是一个泛型类，通过指定泛型，可以更加明确要操作的类的类型，强烈建议使用。 获取Class实例获取运行时类Class实例的4种方式 调用运行时类对应的类的class静态属性获取 1Class&lt;Person&gt; clazz = Person.class; 通过运行时类对应的类的实例对象调用getClass()方法获取 12Person person = new Person(&quot;Priscilla&quot;,23);Class&lt;? extends Person&gt; clazz = person.getClass(); 最常用：调用Class类的静态方法forName(String className)，传入全类名进行获取 1Class&lt;?&gt; clazz3 = Class.forName(&quot;com.website.java.Person&quot;); 能更好体现反射的动态性 获取类加载器ClassLoader(一般使用当前操作所在类的类加载器)，的loadClass(String className)方法，显式地加载某一个类，使其返回运行时类的Class实例。 12ClassLoader classLoader = ClassTest.class.getClassLoader();Class&lt;?&gt; clazz4 = classLoader.loadClass(&quot;com.website.java.Person&quot;); 示例代码123456789101112131415161718192021222324252627282930313233package com.website.java;/** * @author yhd * @create 2021-06-19 11:08 */public class ClassTest &#123; public static void main(String[] args) throws ClassNotFoundException &#123; //方式1：类.class静态属性 Class&lt;Person&gt; clazz1 = Person.class; System.out.println(&quot;clazz1 = &quot; + clazz1);//class com.website.java.Person //方式2：类的对象.getClass() Person person = new Person(&quot;Priscilla&quot;,23); Class&lt;? extends Person&gt; clazz2 = person.getClass(); System.out.println(&quot;clazz2 = &quot; + clazz2);//class com.website.java.Person //方式3：Class.forName(String classAllName); 静态方法 Class&lt;?&gt; clazz3 = Class.forName(&quot;com.website.java.Person&quot;); System.out.println(&quot;clazz3 = &quot; + clazz3);//class com.website.java.Person //方式4：任意获取一个类加载器，通过该加载器加载一遍指定类，获取其运行时类 //为了能顺利获取到类加载器，一般使用当前代码执行所在类去获取其加载器 ClassLoader classLoader = ClassTest.class.getClassLoader(); Class&lt;?&gt; clazz4 = classLoader.loadClass(&quot;com.website.java.Person&quot;); System.out.println(&quot;clazz4 = &quot; + clazz4);//class com.website.java.Person //最后验证某一个类在JVM中只会加载一份运行时类，即Class实例 System.out.println(clazz1 == clazz2);//true System.out.println(clazz2 == clazz3);//true System.out.println(clazz3 == clazz4);//true &#125;&#125; Class实例类型以下类型都看作一种结构，编译运行后都具有自己对应的Class实例，封装这些结构的信息 class： 广义上的累，如外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类 interface：接口 **[]**：数组 enum：枚举 annotation：注解@interface primitive type：基本数据类型 void：无返回值类型 示例代码1234567891011121314151617181920@Testpublic void test()&#123; Class c1 = Object.class;//普通类 Class c2 = Comparable.class;//接口 Class c3 = String[].class;//数组 Class c4 = int[][].class;//二维数组 Class c5 = ElementType.class;//枚举类 Class c6 = Override.class;//注解 Class c7 = int.class;//基本数据类型 Class c8 = void.class;//无返回值类型 Class c9 = Class.class;//Class本身 //问题：c10和c11的Class实例是否一致 int[] a = new int[10]; int[] b = new int[100]; Class c10 = a.getClass(); Class c11 = b.getClass(); //答：只要元素类型与维度一样，就是同一个Class System.out.println(c10 == c11);//true&#125; Class类常用API 常用API Method Descriptions static Class forName(String name) 返回指定类名 name 的 Class 对象 Object newInstance() 调用默认空参构造函数，返回该Class对象的一个实例 String getName() 返回此Class对象所表示的实体（类、接口、数组类、基本类型 或void）名称 Class getSuperClass() 返回当前Class对象的父类的Class对象 Class [] getInterfaces() 获取当前Class对象的接口 ClassLoader getClassLoader() 返回该类的类加载器 Class getSuperclass() 返回表示此Class所表示的实体的超类的Class Constructor[] getConstructors() 返回一个包含某些Constructor对象的数组 Field[] getDeclaredFields() 获取当前运行时类自己定义的属性 Method getMethod(String name,Class … paramTypes) 返回一个Method对象，此对象的形参类型为paramType ……. 反射使用逻辑 定位反射操作对应的结构封装类 通过Class对象方法，获取相关反射操作对应的负责的封装类对象 通过类结构的某个封装类对象的方法进行相关结构的反射操作 获取反射操作的类的Class对象，无论什么反射操作，只要涉及反射就必须先获取Class对象 如Class&lt;Person&gt; clazz = Person.class; 确定反射操作的对应的结构封装类，并通过Class实例的getXxxx()方法获取该结构的封装类 如想通过反射创建对象，则创建对象的操作对应的结构主要由构造器负责 因此获取构造器结构对应的封装类，即Constructor对象实例，通过getConstructor()方法对应获取 1Constructor&lt;Person&gt; constructor = clazz1.getConstructor(String.class, int.class); 通过反射操作对应负责的结构对象实例，调用操作对应的方法进行反射操作 如还是实例化对象的反射操作 12Person person = constructor.newInstance(&quot;Tom&quot;, 123);System.out.println(person);//Person&#123;name=&#x27;Tom&#x27;, age=123&#125; 类加载过程 反射学习阶段了解简述即可 详解可供补充学习 加载过程简述 程序经过javac.exe命令编译以后，会生成一个或多个字节码文件(.class结尾) 接下来使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中,此过程就称为类的加载 加载到内存中的类(不是类的对象)，我们就称为运行时类，此运行时类对应一个Class实例 加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类 小结：一个类只有一个运行时类的Class对象(封装了该类信息的对象)，即Class的实例 详解当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过 如下三个步骤来对该类进行初始化 类的加载类的加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时 数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问 入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的 过程需要类加载器参与。 类的链接将Java类的二进制代码合并到JVM的运行状态之中的过程。 验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题 准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存 都将在方法区中进行分配。 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。 类的初始化 执行类构造器&lt;clinit&gt;()方法的过程。类构造器&lt;clinit&gt;()方法是由编译期自动收集类中所有类变量的赋值(static)动作和静态代码块中的语句合并产生的。（类构造器是构造类信 息的，不是构造该类对象的构造器）。 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 虚拟机会保证一个类的()方法在多线程环境中被正确加锁和同步。 类加载器ClassLoader译为，类加载器/装载器，主要用于把类加载进入内存中 作用 将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构， 在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。 类缓存标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间，且只存在一份，不过JVM垃圾回收机制可以回收这些Class对象。 ClassLoader类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的类的加载器。 引导类加载器：加载核心库，无法获取 扩展类加载器：加载jre/lib/ext目录下的jar包，可获取 系统类加载器：最常用，负责加载java -classpath下的类或jar包，即平常自定义类。可获取 获取类加载器 获取系统类加载器、扩展类加载器、以及尝试获取引导类加载器 1234567891011121314151617181920212223242526272829package com.website.java;/** * @author yhd * @create 2021-06-23 17:07 */public class ClassLoaderTest &#123; public static void main(String[] args) &#123; //1、获取系统类加载器，通过任意自定义类的运行时类Class对象获取 ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); System.out.println(&quot;系统类加载器：&quot; + classLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2 //类加载器只有一个，所有自定义类都是共用一个系统类加载器 ClassLoader classLoader2 = Person.class.getClassLoader(); System.out.println(classLoader == classLoader2);//true //2、获取扩展类加载器 ClassLoader parent = classLoader.getParent(); System.out.println(&quot;扩展类加载器：&quot; + parent);//sun.misc.Launcher$ExtClassLoader@4554617c //3、尝试获取引导类加载器，用于加载Java核心库 ClassLoader parent1 = parent.getParent(); System.out.println(&quot;尝试获取引导类加载器：&quot; + parent1);//null //尝试获取引导类加载器等价于获取String(核心类库)的类加载器 ClassLoader classLoader1 = String.class.getClassLoader(); System.out.println(&quot;尝试获取String类加载器(引导类加载器)&quot; + classLoader1);//null &#125;&#125; 类加载器读取文件 类加载器的getResourceAsStream(String path)方法，默认相对路径于src目录下 IDEA中@Test单元测试下File操作默认相对路径于module根目录下 IDEA中main方法下File操作默认相对路径于Project根目录下 tips：无论是File方式还是类加载器方式，建议配置文件都放入src下，module/project根目录下的其他文件在部署到tomcat服务器时是不会被加载的。 123456789101112131415161718@Testpublic void test() throws Exception &#123; Properties pros = new Properties(); //此时的文件默认在当前的module下。 //读取配置文件的方式一： // FileInputStream fis = new FileInputStream(&quot;jdbc.properties&quot;); // FileInputStream fis = new FileInputStream(&quot;src\\\\jdbc.properties&quot;); // pros.load(fis); //配置文件默认识别为：当前module的src下 ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); InputStream is = classLoader.getResourceAsStream(&quot;jdbc.properties&quot;); pros.load(is); String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); System.out.println(&quot;user = &quot; + user + &quot;,password = &quot; + password);&#125; 创建运行时类对象反射创建运行类对象实例的方式有两种： 最常用，执行目标创建对象的类的Class实例的clazz.newInstance()方法(空参构造器) 少用，兼容性不够强，通过构造器结构的封装类对象constructor.newInstance()方法 newInstance()通过newInstance()创建运行时类对象前提 运行时类必须提供空参构造器 空参构造器的权限必须足够访问，一般为public 注：newInstance()是最常用反射创建对象的方法，框架底层都使用该方式，兼容性更强。为了便与通过反射创建运行时类的对象，及其继承关系的类都能一并调用，一般Java类都设置一个public空参构造器。 123Class&lt;Person&gt; clazz = Person.class;Person person = clazz.newInstance();System.out.println(person);//Person&#123;name=&#x27;null&#x27;, age=0&#125; 获取运行时类结构获取运行时类的结构，如常见的类结构：属性名、方法名、构造器、注解、包名、泛型、权限修饰符…. 样例 测试自定义父类Creature，父类含接口实现 1234567891011121314import java.io.Serializable;public class Creature&lt;T&gt; implements Serializable &#123; private char gender; public double weight; private void breath()&#123; System.out.println(&quot;生物呼吸&quot;); &#125; public void eat()&#123; System.out.println(&quot;生物吃东西&quot;); &#125;&#125; 测试自定义注解MyAnnotation 1234567891011import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import static java.lang.annotation.ElementType.*;@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123; String value() default &quot;hello&quot;;&#125; 测试自定义接口MyInterface 123public interface MyInterface &#123; void info();&#125; 测试普通Java类，Person 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@MyAnnotation(value=&quot;hi&quot;)public class Person extends Creature&lt;String&gt; implements Comparable&lt;String&gt;,MyInterface&#123; private String name; int age; public int id; public Person()&#123;&#125; @MyAnnotation(value=&quot;abc&quot;) private Person(String name)&#123; this.name = name; &#125; Person(String name,int age)&#123; this.name = name; this.age = age; &#125; @MyAnnotation private String show(String nation)&#123; System.out.println(&quot;我的国籍是：&quot; + nation); return nation; &#125; public String display(String interests,int age) throws NullPointerException,ClassCastException&#123; return interests + age; &#125; @Override public void info() &#123; System.out.println(&quot;我是一个人&quot;); &#125; @Override public int compareTo(String o) &#123; return 0; &#125; private static void showDesc()&#123; System.out.println(&quot;我是一个可爱的人&quot;); &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, id=&quot; + id + &#x27;&#125;&#x27;; &#125;&#125; Field获取所有属性 API tips：Declared，表声明之意 Methods Descriptions Field[] fields getFields() 获取当前运行时类及其父类中public权限的属性Field数组 Field getField(String name) 给定属性名返回当前运行时类及其父类中public权限的属性Field Field[] getDeclaredFields() 获取当前运行时类中声明的所有属性(无权限要求，不包含父类) Field getDeclaredField(String name) 在getDeclaredFields()方法基础上获取指定属性名 示例代码 1234567891011121314151617181920212223242526package com.website.java;import java.lang.reflect.Field;/** * @author yhd * @create 2021-06-23 22:33 */public class GetFieldTest &#123; public static void main(String[] args) throws NoSuchFieldException &#123; Class&lt;Person&gt; clazz = Person.class; System.out.println(clazz.getField(&quot;name&quot;)); System.out.println(clazz.getDeclaredField(&quot;name&quot;)); Field[] fields = clazz.getFields(); for (Field field : fields) &#123; System.out.println(&quot;field = &quot; + field); &#125; Field[] declaredFields = clazz.getDeclaredFields(); for (Field declaredField : declaredFields) &#123; System.out.println(&quot;declaredField = &quot; + declaredField); &#125; &#125;&#125; 获取属性结构 获取的属性返回是一个Field类型，每一个Field结构封装了一个属性包含的所有结构 如属性的权限修饰符、数据类型、变量名、被修饰的注解等等.. Field属性 Field的属性封装类一个属性所包含的所有结构 若想获取或设置这些结构的值，则通过对应属性的getter和setter方法操作即可 123456789101112131415public finalclass Field extends AccessibleObject implements Member &#123; private Class&lt;?&gt; clazz; private int slot; private String name;//属性名 private Class&lt;?&gt; type;//属性的数据类型 private int modifiers;//属性的权限修饰符 private transient String signature; private transient FieldRepository genericInfo; private byte[] annotations;//注解 private FieldAccessor fieldAccessor; private FieldAccessor overrideFieldAccessor; private Field root; //....&#125; 示例代码 getModifiers()返回的全新修饰是整型常量 java.lang.reflect.Modifier定义了这些常量的含义 可以调用其静态的toString(int mod)方法返回这些常量的含义 12345678910111213141516171819202122package com.website.java;import java.lang.reflect.Field;import java.lang.reflect.Modifier;/** * @author yhd * @create 2021-06-23 22:33 */public class FieldTest &#123; public static void main(String[] args) &#123; Class&lt;Person&gt; clazz = Person.class; Field[] declaredFields = clazz.getDeclaredFields(); for (Field field : declaredFields) &#123; System.out.print(field.getModifiers() + &quot;\\t&quot;); System.out.print(Modifier.toString(field.getModifiers()) + &quot;\\t&quot;); System.out.print(field.getType() + &quot;\\t&quot;); System.out.print(field.getName() + &quot;\\t&quot;); System.out.println(); &#125; &#125;&#125; Method API Methods Descriptions Method[] getMethods() 获取当前运行时类及其父类中public权限的所有方法，返回Method数组 Method getMethod(String name, Class&lt;?&gt;… parameterTypes) 给定方法名及其方法的参数类型(重载)，获取当前运行时类及其父类中public权限的Method数组 Method[] getDeclaredMethods() 获取当前运行时类中声明的所有方法(无权限要求，不包含父类) Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 在getDeclaredMethods()方法基础上获取指定方法名和形成列表的Method对象 获取所有方法 类获取所有属性 获取方法的结构Method属性 同Field属性使用，getter和setter方法使用 12345678910111213141516public final class Method extends Executable &#123; private Class&lt;?&gt; clazz; private int slot; private String name;//方法名 private Class&lt;?&gt; returnType;//返回类型 private Class&lt;?&gt;[] parameterTypes;//参数列表 private Class&lt;?&gt;[] exceptionTypes;//异常类型(抛出的异常) private int modifiers;//权限修饰 private transient String signature; private transient MethodRepository genericInfo; private byte[] annotations;//注解 private byte[] parameterAnnotations; private byte[] annotationDefault; private volatile MethodAccessor methodAccessor; private Method root;&#125; Constructor 类获取Field和Method，都是常规四个方法，一种声明的，一种非声明的。分别有指定的和全部的。 以下取获取全部的说明区别 1234567891011121314151617@Testpublic void test()&#123; Class clazz = Person.class; //getConstructors():获取当前运行时类中声明为public的构造器(不包含父类) Constructor[] constructors = clazz.getConstructors(); for(Constructor c : constructors)&#123; System.out.println(c); &#125; System.out.println(); //getDeclaredConstructors():获取当前运行时类中声明的所有的构造器(不包含父类) Constructor[] declaredConstructors = clazz.getDeclaredConstructors(); for(Constructor c : declaredConstructors)&#123; System.out.println(c); &#125;&#125; Superclass普通父类 获取父类，或者如果父类是带泛型的，可以调用获取带泛型的父类 1234567@Testpublic void test2()&#123; Class clazz = Person.class; Class superclass = clazz.getSuperclass(); System.out.println(superclass);&#125; 带泛型信息父类1234567@Testpublic void test3()&#123; Class clazz = Person.class; Type genericSuperclass = clazz.getGenericSuperclass(); System.out.println(genericSuperclass);&#125; 泛型父类的泛型类型应用场景 原生业务XxxxxDAO继承DAO&lt;T&gt;时，需要获取父类的泛型类型(全类名)来通过反射创建一个对象。再将查询结果的数据通过反射写入对象中。即DAO&lt;T&gt;中的T类型。 注意，泛型T是不能够调用任何方法的，不存在T.class() 泛型在此的作用只是返回类型时是明确的指定的类型，免去了强制类型转换的步骤，但不能为反射提供任何信息。 注：除获取父类泛型类型外，更加简单的反射目标类型提供方法是传入Class&lt;T&gt;类型参数，如DBUtils.jar的方法的方式 Type Type是一个接口，是Java编程语言中所有类型的通用超级接口，Class也实现了Type接口。因此若获得的实现类对象是Class类型，可以将Type类型强制向下转型成Class类型使用。 ParameterizedType ParameterizedType也是一个接口，并继承了Type接口。用于描述一个参数化类型(即带泛型描述的类型) 声明类型中带有“&lt;&gt;”的都是参数化类型 如Collection &lt;String&gt;这个整体表示一个参数化类型。 对象获取：clazz.getGenericSuperclass();方法返回的实际是ParameterizedType接口的实现类 ParameterizedType接口常用的方法 Methods Descriptions Type[] getActualTypeArguments() 返回实际的参数类型，即泛型类型数组。即“&lt;&gt;”里的参数，比如Map&lt;String,Integer&gt;中的String、Integer Tpye getRawType() 返回原始类型，即得到“&lt;&gt;”前面的类型，比如List&lt;String&gt;中的List Type getOwnerType() O&lt;T&gt;.I&lt;S&gt;类型变量调用时会返回O&lt;T&gt;，比如Map.Entry&lt;Long,Short&gt; …… 代码示例12345678910111213141516171819202122232425262728293031323334353637383940package com.website.java;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;/** * @author yhd * @create 2021-06-24 16:32 */public class GenericTest &#123; public static void main(String[] args) &#123; Class&lt;Person&gt; clazz = Person.class; //class Person extends GenericClass&lt;Date,String&gt; //获取父类类型(带泛型参数) Type genericSuperclass = clazz.getGenericSuperclass(); ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass; //获取父类类型 Type rawType = parameterizedType.getRawType(); System.out.println(&quot;rawType = &quot; + rawType);//com.website.java.GenericClass //获取父类的泛型类型 System.out.println(&quot;-----------------&quot;); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments) &#123; System.out.println(&quot;actualTypeArgument = &quot; + actualTypeArgument.getTypeName()); //java.util.Date //java.lang.String &#125; System.out.println(&quot;-----------------&quot;); //从Type的打印的信息中可以看到，class java.util.Date其实现类就是Class //有必要的话，也可向下强制转换为Class类型， Class argument = (Class) actualTypeArguments[0]; System.out.println(argument.getName());//java.util.Date Type ownerType = parameterizedType.getOwnerType(); System.out.println(&quot;ownerType = &quot; + ownerType);// null &#125;&#125; Interface 获取运行时类接口 123456789@Testpublic void test5()&#123; Class clazz = Person.class; Class[] interfaces = clazz.getInterfaces(); for(Class c : interfaces)&#123; System.out.println(c); &#125;&#125; Package 获取运行时类所在的包 1234567@Testpublic void test6()&#123; Class clazz = Person.class; Package pack = clazz.getPackage(); System.out.println(pack);&#125; Annotation 获取运行时类的注解 123456789@Testpublic void test7()&#123; Class clazz = Person.class; Annotation[] annotations = clazz.getAnnotations(); for(Annotation annos : annotations)&#123; System.out.println(annos); &#125;&#125; 调用指定结构Field非静态属性步骤 获取需要修改的属性封装结构Field实例，一般使用getDeclaredField(String fieldName) 对于操作非静态属性，需创建需要修改该属性的对象 调用Field的提供的方法 set()方法，传入修改属性的对象和属性值 get()方法，传入指定对象，获取该对象的Field属性值 注：IllegalAccessException，通过getDeclaredField(String fieldName)获取的非public属性Field封装类，在调用set()方法时还是不具备修改权限的。需要在set()操作之前，将非public权限的属性调用setAccessible(true)方法，使其允许被修改。 示例代码123456789101112131415161718192021222324252627282930package com.website.java;import java.lang.reflect.Field;/** * @author yhd * @create 2021-06-23 22:33 */public class FieldTest &#123; public static void main(String[] args) throws Exception&#123; //1、获取拟操作属性的封装结构实例，即Field实例 Class&lt;Person&gt; clazz = Person.class; Field ageField = clazz.getDeclaredField(&quot;age&quot;); //2、对于非public权限的值，即使getDeclaredField能获取到Field实例 //但还不具备属性修改权限，需设置使其属性能够被访问 ageField.setAccessible(true); //3、设置ageField属性值(指定被修改属性的对象，修改的属性值) //3.1、准备被修改Field属性的对象 Person person = new Person(); System.out.println(person);//Person&#123;name=&#x27;null&#x27;, age=0&#125; //3.2、修改age属性值(指定被修改属性的对象，修改的属性值) ageField.set(person,9999); //4、获取ageField属性值(指定被获取属性值的对象) System.out.println(ageField.get(person));//9999 &#125;&#125; 静态属性 静态属性操作步骤和非静态类似， 主要区别在于，调用set(Object obj, Objec val)方法时，第一个形参Object obj,可以写任意参数，一般写反射类的Class对象，或者直接写null即可。 Method 操作运行时类中的指定方法 非静态方法步骤 获取需要调用的方法封装结构Method实例，一般使用getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes); String name：指定的方法名 Class&lt;?&gt;… parameterTypes：可变形参类型列表，即对应方法的形参列表。因为方法具有重载特性，因此需指定方法名和参数列表才能唯一确定一个方法。 对于操作非静态方法，需创建调用该方法的对象 调用Method的提供的invoke(Object obj, Object… args)方法，即“调用”含义 Object obj：方法调用的对象 Object…args：调用方法传入的实参列表 注：IllegalAccessException，同理属性的非public修饰符缺少修改权限。需在调用非public方法前调用setAccessible(true)方法，使其方法允许被调用。 示例代码 Person 12345678public class Person extends GenericClass&lt;Date,String&gt;&#123; //... private String show(String name)&#123; System.out.println(&quot;Method show ：&quot; + name); return name; &#125; //...&#125; 反射示例代码 12345678910111213141516171819202122232425262728package com.website.java;import java.lang.reflect.Method;/** * @author yhd * @create 2021-06-27 8:46 */public class MethodTest &#123; public static void main(String[] args) throws Exception &#123; //1、获取Class类型 Class&lt;Person&gt; clazz = Person.class; //2、获取指定调用方法的Method封装类实例 Method showMethod = clazz.getDeclaredMethod(&quot;show&quot;, String.class); //3、非静态方法调用，需提供调用对象 Person person = new Person(); //4、非public权限的方法，在调用之前需设置可调用权限 showMethod.setAccessible(true); //5、通过invoke()调用方法，invoke本身具备的返回值就是调用的方法的返回值 Object returnValue = showMethod.invoke(person,&quot;Tom&quot;);//Method show ：Tom System.out.println(&quot;returnValue = &quot; + returnValue);//returnValue = Tom &#125;&#125; 静态方法 静态方法调用步骤和非静态类似， 主要区别在于，调用invoke(Object obj, Object… args)方法时，第一个形参Object obj,可以写任意参数，一般写反射类的Class对象，或者直接写null即可。 Constructor 调用运行时类中的构造器，不常用。一般99%使用newinstance()方法 步骤 获取需要调用的方法封装结构Method实例，一般使用getDeclaredConstructor(Class&lt;?&gt;… parameterTypes); Class&lt;?&gt;… parameterTypes：可变形参类型列表，即对应构造器的形参列表。因为构造器也具有重载特性，因此需指定参数列表才能唯一确定一个构造器 调用Constructor的提供的newInstance(Object… args)方法，创建构造器 Object…args：调用构造器传入的实参列表 注：IllegalAccessException，同理属性和方法的非public修饰符缺少修改权限。需在调用非public方法前调用setAccessible(true)方法，使其方法允许被调用。 示例代码1234567891011121314151617181920package com.website.java;import java.lang.reflect.Constructor;/** * @author yhd * @create 2021-06-27 9:17 */public class ConstructorTest &#123; public static void main(String[] args) throws Exception &#123; Class&lt;Person&gt; clazz = Person.class; Constructor&lt;Person&gt; constructor = clazz.getDeclaredConstructor(String.class, int.class); constructor.setAccessible(true); Person person = constructor.newInstance(&quot;Tom&quot;, 23); System.out.println(&quot;person = &quot; + person);//person = Person&#123;name=&#x27;Tom&#x27;, age=23&#125; &#125;&#125; 反射的应用动态代理基本概念 代理设计模式的原理: 使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原 始对象上。 例如，你想去买房，通过销售或其他中间商买，则就是销售和中间级作为代理替你完成了买房的操作，即代理类。而你自己就是被代理类。 静态代理实现原理实现静态代理/一般代理，需要两个类(代理类、被代理类)和共同的一个接口构成一个三角关系 拥有一个被代理类，并选取需要代理执行的方法。 创建一个被代理类和代理类都需共同实现的一个代理方法接口，并把需要代理的方法声明在接口中 创建被代理类， 声明一个被代理对象的属性：由于某些方法代理类是无法直接完成的，考内部调用被代理类实现 通过代理类构造器实例化这个被代理类对象的引用 代理类和被代理类同时实现代理方法接口，并各自实现里面的方法。 被代理类按正常情况实现方法 代理类根据实际功能范围，去辅助被代理类完成功能 实例化时，通过构造器传入被代理类对象，实例化代理类。后续方法调用均通过代理类进行调用。 特征 静态代理，特征是代理类和目标 对象的类都是在编译期间确定下来。 即，一个/类被代理类需要对应一个代理，即代理类中的被代理类引用类型定义是编译时期固定下来了。 而且在实现接口时，需要实现同一个提前定义好的接口。 示例代码例如：一个歌星(被代理类)，需要一个代理(代理类)，辅助完成经纪人订票操作。而且代理地实现唱歌操作。 如RealStar.java是真是的明星类，选取，bookTicket()，sing()方法作为被代理方法。 123456789101112131415161718192021//被代理类class RealStart implements Star&#123; public void eat ()&#123; System.out.println(&quot;明星吃饭...&quot;); &#125; public void run()&#123; System.out.println(&quot;明星跑&quot;); &#125; @Override public void bookTicket() &#123; System.out.println(&quot;明星亲自去订票&quot;); &#125; @Override public void sing() &#123; System.out.println(&quot;明星唱歌&quot;); &#125;&#125; 创建一个代理方法接口Star.java，把需要代理的方法bookTicket()，sing()声明在接口处 12345//代理方法接口interface Star&#123; void bookTicket(); void sing();&#125; 创建代理类StarProxy 1234567891011121314151617181920212223//代理类class StarProxy implements Star&#123; private RealStart realStart; public StarProxy(RealStart realStart)&#123; this.realStart = realStart; &#125; @Override public void bookTicket() &#123; System.out.println(&quot;由代理去完成订票操作&quot;); System.out.println(&quot;----------------&quot;); &#125; @Override public void sing() &#123; //代理无法代理地完成唱歌操作，不过可以在前在后辅助被代理类sing()方法 System.out.println(&quot;代理在明星唱歌前的一些辅助工作&quot;); realStart.sing(); System.out.println(&quot;代理在明星唱完歌后进行一些善后工作&quot;); System.out.println(&quot;----------------&quot;); &#125;&#125; 通过代理类StarProxy进行代理方法调用 1234567891011public class StaticProxy &#123; //测试 public static void main(String[] args) &#123; RealStart realStart = new RealStart(); StarProxy proxy = new StarProxy(realStart); //代理方法调用 proxy.bookTicket(); proxy.sing(); &#125;&#125; 实际应用 其实Runnable接口方式创建多线程就是一个静态代理 12345678Class MyThread implements Runnable&#123;&#125; //相当于被代理类Class Thread implements Runnable&#123;&#125; //相当于代理类main()&#123; MyThread t = new MyThread(); Thread thread = new Thread(t); thread.start();//启动线程；调用线程的run()&#125; 动态代理引言 静态代理，特征是代理类和目标 对象的类都是在编译期间确定下来，不利于程序的扩展。 即，一个/类被代理类需要对应一个代理，即代理类中的被代理类引用类型定义是编译时期固定下来了。 而且在实现接口时，需要实现同一个提前定义好的接口。 因此每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。最 好可以通过一个代理类完成全部的代理功能。 Spring中的IOC，和AOP，其中AOP的原理就是动态代理。 实现原理在静态代理的基础上，使其代理类成为通用的类 根据加载到内存中的被代理类，动态创建一个代理类的示例作为被代理类的引用 获取被代理类实现的接口，并使代理类 示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*要想实现动态代理，需要解决的问题？问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。 */class ProxyFactory&#123; //调用此方法，返回一个代理类的对象。解决问题一 public static Object getProxyInstance(Object obj)&#123;//obj:被代理类的对象 MyInvocationHandler handler = new MyInvocationHandler(); handler.bind(obj); return Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler); &#125;&#125;class MyInvocationHandler implements InvocationHandler&#123; private Object obj;//需要使用被代理类的对象进行赋值 public void bind(Object obj)&#123; this.obj = obj; &#125; //当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke() //将被代理类要执行的方法a的功能就声明在invoke()中 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; HumanUtil util = new HumanUtil(); util.method1(); //method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法 //obj:被代理类的对象 Object returnValue = method.invoke(obj,args); util.method2(); //上述方法的返回值就作为当前类中的invoke()的返回值。 return returnValue; &#125;&#125;public class ProxyTest &#123; public static void main(String[] args) &#123; SuperMan superMan = new SuperMan(); //proxyInstance:代理类的对象 Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan); //当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法 String belief = proxyInstance.getBelief(); System.out.println(belief); proxyInstance.eat(&quot;四川麻辣烫&quot;); System.out.println(&quot;*****************************&quot;); &#125;&#125; AOP原理概述 AOP代理里的方法可以在执行目标方法之前、之后插入一些通用处理 面向切面编程，类似面向“插入”编程，是一种非硬编码方式实现的代码复用设计模式。 硬编码代码复用：就是平时抽取相同部分的代码封装成方法从而实现代码复用的方式 即自定义的代码是通过“软编码”的方式插入一些通用的代码的操作。","categories":[],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/tags/JavaSE/"}]},{"title":"Java网络编程基础","slug":"Java网络编程基础","date":"2021-06-19T01:36:22.000Z","updated":"2021-08-25T15:27:11.581Z","comments":true,"path":"2021/06/19/Java网络编程基础/","link":"","permalink":"http://yoursite.com/2021/06/19/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/","excerpt":"","text":"引言：本文主要含网络编程概述，网络通信的要素，介绍IP和端口号的概念，以及部分网络协议。了解InetAddress封装类编写基于Java实现的基础的TCP网络程序、UDP网络程序以及URL编程。网络编程概述 InetAddress基本概念 Java通过InetAddress封装了IP信息 InetAddress了私有化构造器 静态方法返回IntetAddress对象实体，常用getByName() 可以直觉输入IP，也可以输入域名(内部自动DNS请求) 获取本地IP地址方法，getLocalHost() 获取本地IP地址：InetAddress.getLocalHost(); InetAddress对象常用方法 获取域名：getHostName() 获取Ip地址：getHostAddress() 示例代码123456789101112131415161718192021222324252627package com.website.addr;import java.net.InetAddress;import java.net.UnknownHostException;/** * @author yhd * @create 2021-06-18 20:46 */public class InetAddressTest &#123; public static void main(String[] args) throws UnknownHostException &#123; //InetAddress 私有化了构造器 //通过调用静态方法实例化InetAddress对象，getByName(String IpOrDomain) InetAddress address1 = InetAddress.getByName(&quot;192.168.9.10&quot;); System.out.println(&quot;address1 = &quot; + address1);//192.168.9.10 InetAddress address2 = InetAddress.getByName(&quot;www.baidu.com&quot;); System.out.println(&quot;address2 = &quot; + address2);//www.baidu.com/14.215.177.39 System.out.println(address2.getHostName());//获取域名,www.baidu.com System.out.println(address2.getHostAddress());//获取ip,14.215.177.39 //获取当前主机IP地址 InetAddress localHost = InetAddress.getLocalHost(); System.out.println(localHost);//DESKTOP-P5ISHNE/169.254.204.1 &#125;&#125; Socket构造器 Socket socket = new Socket(String ip,int port) Socket socket = new Socket(InetAddress address,int port) TCP网络编程示例代码一句话通信Client123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.website.tcp;import java.io.IOException;import java.io.OutputStream;import java.net.InetAddress;import java.net.Socket;/** * @author yhd * @create 2021-06-18 21:39 */public class TcpClient &#123; public static void main(String[] args) &#123; Socket client = null; OutputStream outputStream = null; try &#123; //1、准备好服务器的Ip和端口号信息 InetAddress serverAddr = InetAddress.getByName(&quot;127.0.0.1&quot;); int serverPort = 8533; //2、创建客户端Socket，指明需要连接的服务器Ip和端口号 client = new Socket(serverAddr,serverPort); //3、获得输出流对象进行数据发送 outputStream = client.getOutputStream(); outputStream.write(&quot;你好，我是客户端，发送AAA信息给服务器&quot;.getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(outputStream != null)&#123; try &#123; outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(client != null)&#123; try &#123; client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; Server1 方式1：转换流+缓冲流以行的方式读取 + StringBuilder累加存储，完整数据终端显示 tips：建议使用Server2，的数组节点流方式累存数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.website.tcp;import java.io.*;import java.net.ServerSocket;import java.net.Socket;/** * @author yhd * @create 2021-06-18 21:49 */public class TcpServer &#123; public static void main(String[] args) &#123; ServerSocket server = null; Socket accpetSocket = null; InputStream inputStream = null; InputStreamReader isr = null; BufferedReader br = null; try &#123; //1、创建服务器(监听)Socket，声明监听端口号即可 server = new ServerSocket(8533); System.out.println(&quot;服务器正在监听....&quot;); //2、调用accept()方法，创建与客户端通信的Socket实例 accpetSocket = server.accept(); //3、获取输入流对象准备获取客户端发送过来的数据 inputStream = accpetSocket.getInputStream(); //若想在完整地接收客户端发送的字符数据，并在终端输出，或存在如下问题 //可变长的字符编码，如果边接收边输出，则可能存在字符编码的字节截断， //为什么之前没有过这些问题呢，因为之前读取数据的同时进行了写入数据的操作 //两者就是在配合部分传送，实现Cpoy效果，而且没输出在终端，而看不出来， //如单纯只是读取数据在终端上显示，则需要考虑获取完整字符数据的问题 // //方式：1可以考虑转换流+缓冲流以行的方式读取 + StringBuilder累加存储 isr = new InputStreamReader(inputStream); br = new BufferedReader(isr); StringBuilder builder = new StringBuilder(); String data = null; while ((data = br.readLine()) != null)&#123; builder.append(data); &#125; String clientIp = accpetSocket.getInetAddress().getHostAddress(); System.out.println(&quot;来自客户的&quot; + clientIp + &quot;的数据：&quot;); System.out.println(builder.toString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(br != null)&#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(isr != null)&#123; try &#123; isr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(inputStream != null)&#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(accpetSocket != null)&#123; try &#123; accpetSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(server != null)&#123; try &#123; server.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; Server2 使用数组节点流累积存储客户端数据，并一同终端显示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.website.tcp;import java.io.*;import java.net.ServerSocket;import java.net.Socket;/** * @author yhd * @create 2021-06-18 21:49 */public class TcpServer &#123; public static void main(String[] args) &#123; ServerSocket server = null; Socket accpetSocket = null; InputStream is = null; ByteArrayOutputStream bos = null; try &#123; //1、创建服务器(监听)Socket，声明监听端口号即可 server = new ServerSocket(8533); System.out.println(&quot;服务器正在监听....&quot;); //2、调用accept()方法，创建与客户端通信的Socket实例 accpetSocket = server.accept(); //3、获取输入流对象准备获取客户端发送过来的数据 is = accpetSocket.getInputStream(); //通过数组节点流累积存储客户端发送了的字节数据，并在终端一并输出 //数组节点有类似一个List&lt;Byte&gt;，内部数组会暂存数据，也会自动扩容， bos = new ByteArrayOutputStream(); byte[] buff = new byte[1024]; int len = -1; while((len = is.read(buff)) != -1)&#123; bos.write(buff,0,len);//把数据写入ByteArrayOutputStream，相当于一个容器 &#125; String clientIp = accpetSocket.getInetAddress().getHostAddress(); System.out.println(&quot;来自客户的&quot; + clientIp + &quot;的数据：&quot;); System.out.println(bos.toString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(bos != null)&#123; try &#123; bos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(is != null)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(accpetSocket != null)&#123; try &#123; accpetSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(server != null) &#123; try &#123; server.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 简单文件传输 客户端发送本地一个文件给服务器，服务器将其保存在本地 Cilent12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.website.tcp;import java.io.*;import java.net.InetAddress;import java.net.Socket;/** * @author yhd * @create 2021-06-18 22:26 */public class TcpFileClient &#123; public static void main(String[] args) &#123; Socket client = null; InputStream is = null; OutputStream os = null; BufferedOutputStream bos = null; BufferedInputStream bis = null; try &#123; //1、准备Sokcet连接信息 InetAddress serverAddr = InetAddress.getByName(&quot;127.0.0.1&quot;); int serverPort = 8855; client = new Socket(serverAddr,serverPort); //2、准备文件读取与数据输出 is = new FileInputStream(&quot;dir//img.jpg&quot;); os = client.getOutputStream(); bis = new BufferedInputStream(is); bos = new BufferedOutputStream(os); byte[] buff = new byte[1024]; int len = -1; while ((len = bis.read(buff)) != -1)&#123;//读取本地文件数据 bos.write(buff,0,len);//发送数据到服务器 &#125; System.out.println(&quot;数据发送完毕!!!&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(bos != null)&#123; try &#123; bos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(bis != null)&#123; try &#123; bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(is != null)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(os != null)&#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(client != null)&#123; try &#123; client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; Server12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.website.tcp;import java.io.*;import java.net.ServerSocket;import java.net.Socket;/** * @author yhd * @create 2021-06-18 22:42 */public class TcpFileServer &#123; public static void main(String[] args) &#123; InputStream is = null; OutputStream os = null; BufferedOutputStream bos = null; BufferedInputStream bis = null; ServerSocket serverSocket = null; Socket acceptSocket = null; try &#123; serverSocket = new ServerSocket(8855); System.out.println(&quot;服务器已启动，开始监听客户端....&quot;); acceptSocket = serverSocket.accept(); is = acceptSocket.getInputStream(); os = new FileOutputStream(&quot;dir//server//client_img.jpg&quot;); bis = new BufferedInputStream(is); bos = new BufferedOutputStream(os); byte[] buff = new byte[1024]; int len = -1; while ((len = bis.read(buff)) != -1)&#123; bos.write(buff,0,len); &#125; String clientIp = acceptSocket.getInetAddress().getHostAddress(); System.out.println(&quot;已接收完毕来自 &quot; + clientIp + &quot;客户的的数据&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(bos != null)&#123; try &#123; bos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(bis != null)&#123; try &#123; bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(is != null)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(os != null)&#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(acceptSocket != null)&#123; try &#123; acceptSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(serverSocket != null)&#123; try &#123; serverSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 多次交流传输场景描述 客户端发送本地一个文件给服务器 服务器接收完数据后通过Socket回传客户端一句话 客户端把服务器回传的话语接收并打印在终端 问题分析 Socket的InputStream流的读取操作和FileInputStream流的读取有些细节上的不同 FileInputStream在读取到文件末尾时会返回-1 而Socket的客户端和服务器一旦建立连接后，流的建立是一直存在的，不会因为客户端某一次数据传输完毕流就会结束，服务器read读取就返回-1，即read函数会一直阻塞着 想要read停止阻塞、结束read方法读取操作，或者想Socket流read()方法返回-1，有两种方式 客户端或服务器端任意一方断开连接 客户端或服务器端任意一方调用shutdownOutput()方法，此时Socket的输入流读取数据时就会返回-1 注：在Socket通信的流操作中使用缓冲流最后一定记得手动flush，把数据传送完整。同理上面的read无法检查到何时何为客户端数据传送完毕，因此缓冲流对Socket流包装后页无法知道数据什么时候读取结束。若一个数据的大小比缓冲流的缓冲区(默认8K)还小，估计还没装满，又检测不到数据何时结束，而没有发送完全。 Client123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package com.website.tcp;import java.io.*;import java.net.InetAddress;import java.net.Socket;/** * @author yhd * @create 2021-06-18 22:26 */public class TcpFileClient &#123; public static void main(String[] args) &#123; Socket client = null; InputStream is = null; OutputStream os = null; BufferedOutputStream bos = null; BufferedInputStream bis = null; InputStream inputStream = null; ByteArrayOutputStream baos = null; try &#123; //1、准备Sokcet连接信息 InetAddress serverAddr = InetAddress.getByName(&quot;127.0.0.1&quot;); int serverPort = 8855; client = new Socket(serverAddr,serverPort); //2、准备文件读取与数据输出 is = new FileInputStream(&quot;dir//img.jpg&quot;); os = client.getOutputStream(); //在Socket环境使用缓冲流一定要加一个flush，不然有部分数据还没发过去 bis = new BufferedInputStream(is); bos = new BufferedOutputStream(os); byte[] buff = new byte[1024]; int len = -1; while ((len = bis.read(buff)) != -1)&#123;//读取本地文件数据 bos.write(buff,0,len);//发送数据到服务器 &#125; bos.flush();//在Socket环境使用缓冲流一定要加一个flush，不然有部分数据还没发过去 System.out.println(&quot;发送完毕，关闭输出流&quot;); client.shutdownOutput();//传送完数据后，显式地关闭Socket连接的输出流// //使其服务器端的read()方法阻塞终止，返回-1// //发送完数据后接收服务器的收到响应 len = -1; inputStream = client.getInputStream(); baos = new ByteArrayOutputStream(); while ((len = inputStream.read(buff)) != -1)&#123; baos.write(buff,0,len); &#125; System.out.println(&quot;收到服务器的响应信息：&quot; + baos.toString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(bos != null)&#123; try &#123; bos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(bis != null)&#123; try &#123; bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(baos != null)&#123; try &#123; baos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(is != null)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(os != null)&#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(inputStream != null)&#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(client != null)&#123; try &#123; client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; Server123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.website.tcp;import java.io.*;import java.net.ServerSocket;import java.net.Socket;/** * @author yhd * @create 2021-06-18 22:42 */public class TcpFileServer &#123; public static void main(String[] args) &#123; InputStream is = null; OutputStream os = null; BufferedOutputStream bos = null; BufferedInputStream bis = null; ServerSocket serverSocket = null; Socket acceptSocket = null; OutputStream outputStream = null; try &#123; serverSocket = new ServerSocket(8855); System.out.println(&quot;服务器已启动，开始监听客户端....&quot;); acceptSocket = serverSocket.accept(); is = acceptSocket.getInputStream(); os = new FileOutputStream(&quot;dir//server//client_img.jpg&quot;); bis = new BufferedInputStream(is); bos = new BufferedOutputStream(os); byte[] buff = new byte[1024]; int len = -1; while ((len = bis.read(buff)) != -1)&#123; bos.write(buff,0,len); &#125; System.out.println(&quot;图片传输完成&quot;); //接收完文件后，通过Socket回传一句话给客户端 String clientIp = acceptSocket.getInetAddress().getHostAddress(); String mes = &quot;已接收完毕来自 &quot; + clientIp + &quot;客户的的数据&quot;; outputStream = acceptSocket.getOutputStream(); outputStream.write(mes.getBytes());//// //acceptSocket.shutdownOutput();//传送完数据后，显式地关闭Socket连接的输出流// //使其客户端的read()方法阻塞终止，返回-1 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(bos != null)&#123; try &#123; bos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(bis != null)&#123; try &#123; bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(is != null)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(os != null)&#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(outputStream != null)&#123; try &#123; outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(acceptSocket != null)&#123; try &#123; acceptSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(serverSocket != null)&#123; try &#123; serverSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; UDP网络编程示例代码一句话通信Sender 异常需try-catch-finally处理 123456789101112131415161718192021222324252627package com.website.udp;import java.io.IOException;import java.net.*;/** * @author yhd * @create 2021-06-19 8:55 */public class UdpSender &#123; public static void main(String[] args) throws IOException &#123; //数据报发送者 DatagramSocket sender = new DatagramSocket(); //数据报本体 //发送的内容 byte[] bytes = &quot;我是UDP发送端发送过来的数据&quot;.getBytes(); InetAddress ip = InetAddress.getByName(&quot;127.0.0.1&quot;); int port = 8383; DatagramPacket packet = new DatagramPacket(bytes,0,bytes.length,ip,port); //发送数据 sender.send(packet); sender.close();//关闭资源 &#125;&#125; Receiver 异常需try-catch-finally处理 123456789101112131415161718192021222324252627282930package com.website.udp;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;/** * @author yhd * @create 2021-06-19 8:58 */public class UdpReceiver &#123; public static void main(String[] args) throws IOException &#123; //数据报接送者 DatagramSocket receiver = new DatagramSocket(8383); //将接收的数据封装到packed中 //使用指定数组存放接收的数据 byte[] buff = new byte[1024]; DatagramPacket revPacket = new DatagramPacket(buff,0,buff.length); //接收数据 receiver.receive(revPacket); //打印数据，DatagramPacket封装了实际接收的数据长度 //revPacket.getData() == byte[] buff = new byte[1024]; System.out.println(new String(revPacket.getData(),0,revPacket.getLength())); receiver.close();//关闭资源 &#125;&#125; URL编程示例代码URL基本属性123456789101112131415161718192021package com.website.url;import java.net.MalformedURLException;import java.net.URL;/** * @author yhd * @create 2021-06-19 9:18 */public class URLTest &#123; public static void main(String[] args) throws MalformedURLException &#123; String link = &quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png?test=param&quot;; URL url = new URL(link); System.out.println(url.getProtocol());//协议名：https System.out.println(url.getHost());//主机名：www.baidu.com System.out.println(url.getPort());//端口号：-1 System.out.println(url.getPath());//文件路径：/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png System.out.println(url.getFile());//获取文件名：/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png?test=param System.out.println(url.getQuery());//获取查询参数：test=param &#125;&#125; 下载URL资源12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.website.url;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;import java.net.URLConnection;/** * @author yhd * @create 2021-06-19 9:18 */public class URLTest &#123; public static void main(String[] args)&#123; String link = &quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png?test=param&quot;; HttpURLConnection huc = null; FileOutputStream fis = null; InputStream inputStream = null; try &#123; URL url = new URL(link); //获取URL资源输入流，首先获取URL资源连接对象 URLConnection urlConnection = url.openConnection(); //由于该URL使用的是HTTP协议，因此可选择强转其子类HttpURLConnection，以获取更多HTTP相关方法 if(urlConnection instanceof HttpURLConnection)&#123; huc = (HttpURLConnection) urlConnection; &#125; huc.connect();//进行资源连接 fis = new FileOutputStream(&quot;dir//baidu.jpg&quot;); inputStream = huc.getInputStream(); byte[] buff = new byte[1024]; int len = -1; while ((len = inputStream.read(buff)) != -1)&#123; fis.write(buff,0,len); &#125; System.out.println(&quot;下载完毕&quot;); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(fis != null)&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(inputStream != null)&#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(huc != null)&#123; huc.disconnect(); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/tags/JavaSE/"}]},{"title":"Java的File类及IO系统","slug":"Java的File类及IO系统","date":"2021-06-17T02:33:21.000Z","updated":"2021-08-25T15:27:11.780Z","comments":true,"path":"2021/06/17/Java的File类及IO系统/","link":"","permalink":"http://yoursite.com/2021/06/17/Java%E7%9A%84File%E7%B1%BB%E5%8F%8AIO%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"引言：本文主要介绍Java IO流系统的知识，包含File类的使用、IO流原理及流的分类、节点流(文件流)、缓冲流、转换流、标准输入输出流、打印流、对象流、随机存取文件流、NIO中的Path、Paths、Files类的使用。 File类基本概念 java.io.File类：是文件和文件目录(文件夹)的抽象表示形式，与平台无关 File能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。 如果需要访问文件内容本身，则需要使用IO流。 在Java程序中表示一个真实存在的文件或目录，必须有一个与之对应的File对象 但是Java程序中的一个File对象，可能没有一个与之对应的真实存在的文件或目录，如这个路径/文件是即将由Java程序创建的。 File对象可以作为参数传递给IO流的构造器，作为IO操作的节点类型之一(还可以是网络结点) Constructor注：创建File对象只是在内存中创建类这个对象，还没有和文件系统建立关系。因此无论这个文件/目录是否真是存在，都不影响File对象的创建。 Constructor Descriptions public File(String pathname) 以pathname为路径创建File对象，可以是绝对路径或者相对路径，如果相对路径，则默认的当前路径在系统属性user.dir中存储 public File(String parent,String child) 以parent为父路径，child为子路径创建File对象 public File(File parent,String child) 根据一个父File对象和子文件路径创建File对象 public File(URI uri) 将给定的 file:URI转换为抽象路径名来创建新的File实例 示例代码File(String pathname)12345678public static void main(String[] args) &#123; //定义一个目录，File对象 File file1 = new File(&quot;D:\\\\java&quot;); System.out.println(&quot;file1 = &quot; + file1);//D:\\java //定义一个文件，File对象 File file2 = new File(&quot;D:\\\\java\\\\test.txt&quot;); System.out.println(&quot;file2 = &quot; + file2);//D:\\java\\test.txt&#125; File(String parent,String child)12345public static void main(String[] args) &#123; //等价于 D:\\java\\test.txt File file = new File(&quot;D:\\\\java&quot;,&quot;test.txt&quot;); System.out.println(&quot;file = &quot; + file); // D:\\java\\test.txt&#125; File(File parent,String child)123456public static void main(String[] args) &#123; //等价于 D:\\java\\test File parentFile = new File(&quot;D:\\\\java&quot;); File file = new File(parentFile,&quot;test&quot;); System.out.println(&quot;file = &quot; + file); // D:\\java\\test&#125; 文件路径 相对路径：不是以盘符开始的任意路径片断。如 java\\test.txt Java程序中，相对路径的基准为：项目根目录下，与src目录同级。 IDEA： mian方法：project路径下， 单元测试：model下。 eclipse：main和单元测试均是相对于 project下 绝对路径：从文件系统的盘符开始的文件路径。如 D:\\java\\test\\test.txt 路径分隔符不同系统分隔符 路径中的每级目录之间用一个路径分隔符隔开 路径分隔符和系统有关： windows和DOS系统默认使用&#39;\\&#39;(反斜杠-转义符)来表示 UNIX和URL使用&#39;/&#39;(斜杆)来表示 由于Java程序支持跨平台运行，这些路径分隔符表示都支持，但由于\\含转义，因此需双写 示例代码 123456789public class FileTest &#123; public static void main(String[] args) &#123; //1、Windows平台的路径分隔符，需要转意一下 File file1 = new File(&quot;D:\\\\java\\\\test.txt&quot;); //2、UNIX和URL使用的路径分隔符， File file2 = new File(&quot;D:/java/test.txt&quot;); &#125;&#125; 动态分隔符 由于Java程序支持跨平台运行，因此路径分隔符要慎用。 为了解决这个隐患，File类提供了一个常量： public static final String separator 它可根据操作系统，动态地提供系统匹配的分隔符。 示例代码 1234567891011121314//同等功能public class FileTest &#123; public static void main(String[] args) &#123; //1、Windows平台的路径分隔符，需要转意一下 File file1 = new File(&quot;D:\\\\java\\\\test.txt&quot;); //2、UNIX和URL使用的路径分隔符， File file2 = new File(&quot;D:/java/test.txt&quot;); //3、动态路径分隔符，自动匹配系统类型 File file3 = new File(&quot;D:&quot; + File.separator + &quot;java&quot; + File.separator + &quot;test.txt&quot;); &#125;&#125; Methods File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法， 并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。 基础信息 Method Descriptions public String getAbsolutePath() 获取绝对路径 public String getPath() 获取路径 public String getName() 获取名称 public String getParent() 获取上层文件目录路径。若无，返回null public long length() 获取文件大小(单位字节数)，目录不可用 public long lastModified() 获取最后一次的修改时间，单位，毫秒值 public String[] list() 获取指定当前目录下(不含子目录)的所有文件或者文件目录的名称数组，目录不存在返回null，空目录返回0 public File[] listFiles() 获取指定当前目录下(不含子目录)的所有文件或者文件目录的File数组，目录不存在返回null，空目录返回0 String[] list(FilenameFilter filter) 同理list()，满足过滤器FilenameFilter规则下返回 File[] listFiles(FilenameFilter filter) 同理listFiles()，满足过滤器FilenameFilter规则下返回 …… 示例代码1234567891011121314151617181920212223242526272829303132public static void main(String[] args) &#123; File file1 = new File(&quot;test\\\\hello.txt&quot;);//tisp：该文件与目录都不存在 File file2 = new File(&quot;D:\\\\TestFolder\\\\FiletTest\\\\file.txt&quot;);//该文件存在 System.out.println(file1.getAbsoluteFile());// D:\\ProfessionApp\\Source\\IdeaWorkSpace\\JavaSE\\test\\hello.txt System.out.println(file1.getPath());// test\\hello.txt System.out.println(file1.getName());// hello.txt System.out.println(file1.getParent());// test System.out.println(file1.length());// 0 System.out.println(file1.lastModified());// 0 System.out.println(); System.out.println(file2.getAbsoluteFile()); //D:\\TestFolder\\FiletTest\\file.txt System.out.println(file2.getPath()); //D:\\TestFolder\\FiletTest\\file.txt System.out.println(file2.getName()); //file.txt System.out.println(file2.getParent());// D:\\TestFolder\\FiletTest System.out.println(file2.length());// 6 System.out.println(file2.lastModified());// 1623681034684 File file = new File(&quot;D:\\\\TestFolder\\\\FiletTest&quot;);//必须是存在的目录 String[] list1 = file.list(); for (String fileAndDir : list1) &#123; System.out.println(&quot;fileAndDir = &quot; + fileAndDir); &#125; File[] files = file.listFiles(); for (File file1 : files) &#123; System.out.println(&quot;file1 = &quot; + file1); &#125;&#125; 当硬盘中真是存在文件和目录时创建File对象时，各个属性会显式赋值，不存在时则按默认值赋值 重命名 Method Descriptions public boolean renameTo(File dest) 只能操作文件，若传入目录则操作结果为无后缀文件把文件重命名为指定的File文件路径，返回操作结果相当于修改调用者File对象的文件路径，类剪切操作但若像保证修改成功，还需满足如下两个条件1. 调用renameTo的File对象必须真实存在2. 重命名的目的File dest必须不存在小结：该方法类似目标位置不能含同名文件的剪切操作 …… 示例代码123456public static void main(String[] args) &#123; File file = new File(&quot;test.txt&quot;);//该文件必须存在 File dest = new File(&quot;dir\\\\rename.txt&quot;);//该文件必须不存在 boolean result = file.renameTo(dest); System.out.println(&quot;result = &quot; + result);&#125; 判断 Method Descriptions public boolean exists() 判断是否存在(以下方法都内部都执行exists()) public boolean isDirectory() 判断是否是文件目录 public boolean isFile() 判断是否是文件 public boolean canRead() 判断是否可读 public boolean canWrite() 判断是否可写 public boolean isHidden() 判断是否隐藏 …… 创建与删除 Method Descriptions public boolean createNewFile() 创建文件。若文件存在，则不创建，返回false public boolean mkdir() 创建文件目录。如果此文件目录存在，就不创建了 如果此文件目录的上层目录不存在，也不创建 public boolean mkdirs() 创建文件目录树。如果上层文件目录不存在，一并创建 public boolean delete() 删除文件或者文件夹(不能包含内容，删除所有只能写递归) …… 注： 如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目路径下 Java中的删除不走回收站。 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录 示例代码 12345678910public static void main(String[] args) throws IOException &#123; File file = new File(&quot;dir\\\\abc.txt&quot;); if(!file.exists())&#123;//不存在则创建 file.createNewFile(); System.out.println(&quot;创建成功&quot;); &#125;else&#123;//不存在则删除 file.delete(); System.out.println(&quot;删除成功&quot;); &#125;&#125; 常见应用指定后缀文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import org.junit.Test;import java.io.File;import java.io.FilenameFilter;/** * 判断指定目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称 */public class FindJPGFileTest &#123; //方式1：String[] fileName + endsWith()判断 @Test public void test1()&#123; File srcFile = new File(&quot;d:\\\\code&quot;); String[] fileNames = srcFile.list(); for(String fileName : fileNames)&#123; if(fileName.endsWith(&quot;.jpg&quot;))&#123; System.out.println(fileName); &#125; &#125; &#125; //方式2： File[] listFiles的fileName + endWith()判断 @Test public void test2()&#123; File srcFile = new File(&quot;d:\\\\code&quot;); File[] listFiles = srcFile.listFiles(); for(File file : listFiles)&#123; if(file.getName().endsWith(&quot;.jpg&quot;))&#123; System.out.println(file.getAbsolutePath()); &#125; &#125; &#125; /* * 方式3：过滤器方式 * File类提供了两个文件过滤器方法 * public String[] list(FilenameFilter filter) * public File[] listFiles(FileFilter filter) */ @Test public void test3()&#123; File srcFile = new File(&quot;d:\\\\code&quot;); //设置过滤器 File[] subFiles = srcFile.listFiles(new FilenameFilter() &#123; @Override public boolean accept(File dir, String name) &#123; return name.endsWith(&quot;.jpg&quot;); &#125; &#125;); //打印 for(File file : subFiles)&#123; System.out.println(file.getAbsolutePath()); &#125; &#125; &#125; 打印所有文件先循环后分类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.website.file;import java.io.File;import java.io.FileNotFoundException;import java.util.ArrayList;import java.util.List;/** * @author yhd * @create 2021-06-14 21:42 */public class FileTest &#123; public static void main(String[] args) throws Exception &#123; File dir = new File(&quot;D:\\\\TestFolder\\\\FiletTest\\\\&quot;); //存储所有文件 List&lt;File&gt; fileList = new ArrayList&lt;&gt;(); //也可选择调用没有异常处理的printSubAllFileImp()方法 printSubAllFile(dir,fileList); //打印指定目录下的所有文件 for (File file : fileList) &#123; System.out.println(&quot;file = &quot; + file); &#125; &#125; /** * 核心实现方法：递归方式 * 打印指定文件路径(目录)下的所有文件，含子目录 * @param dir */ public static void printSubAllFileImp(File dir, List&lt;File&gt; fileList)&#123; File[] files = dir.listFiles(); for (File file : files) &#123; if(file.isDirectory())&#123; printSubAllFileImp(file,fileList); &#125;else&#123; fileList.add(file); &#125; &#125; &#125; /*** * 递归实现的健壮性包装 * @param dir * @param fileList * @throws NullPointerException * @throws FileNotFoundException * @throws RuntimeException */ public static void printSubAllFile(File dir, List&lt;File&gt; fileList) throws NullPointerException,FileNotFoundException,RuntimeException &#123; if(fileList == null) throw new NullPointerException(&quot;fileList空指针异常，为实例化对象&quot;); if(dir.isFile()) throw new RuntimeException(dir + &quot;不是文件目录&quot;); if(!dir.exists()) throw new FileNotFoundException(dir + &quot;不存在&quot;); printSubAllFileImp(dir,fileList); &#125;&#125; 先分类后循环123456789101112131415//递归方式2： 先分类后循环：//列出file目录的下级，如果它的下级还是目录，接着列出下级的下级，依次类推// 建议使用File类的File[] listFiles()public void listAllSubFiles(File file) &#123; if (file.isFile()) &#123; System.out.println(file); &#125; else &#123; File[] all = file.listFiles(); // 如果all[i]是文件，直接打印 // 如果all[i]是目录，接着再获取它的下一级 for (File f : all) &#123; listAllSubFiles(f);// 递归调用：自己调用自己就叫递归 &#125; &#125;&#125; 删除目录先循环后分类 不推荐 12345678910111213141516public static void deleteDirectoryContent(File dir)&#123; File[] files = dir.listFiles(); for (File file : files) &#123; if(file.isFile())&#123; file.delete();//若是文件直接删除 &#125;else&#123;//若是文件夹 File[] dirFiles = file.listFiles(); for (File dirFile : dirFiles) &#123; deleteDirectoryContent(dirFile); dirFile.delete(); &#125; &#125; file.delete();//删除父级目录 &#125; dir.delete();//删除顶级目录，自身目录&#125; 先分类后循环 推荐 123456789101112131415//删除指定的目录将其所有内容//递归方式：先分类，后循环，public static void deleteDirectory(File file) &#123; // 如果file是文件，直接delete // 如果file是目录，先把它的下一级干掉，然后删除自己 if (file.isDirectory()) &#123; File[] all = file.listFiles(); // 循环删除的是file的下一级 for (File f : all) &#123;// f代表file的每一个下级 deleteDirectory(f); &#125; &#125; // 删除自己 file.delete();&#125; 计算目录大小先分类后循环 采用返回值存储记录递归值参数 1234567891011121314151617/** * 获取指定目录的大小 * @param file * @return */public static long getDirectorySize(File file)&#123; long size = 0; if(file.isFile())&#123;//文件 size+=file.length(); &#125;else &#123;//文件夹 File[] files = file.listFiles(); for (File file1 : files) &#123; size+=getDirectorySize(file1);//返回值记录 &#125; &#125; return size;&#125; IO流概述基本概念 I/O是Input/Output的缩写， I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等。 Java程序中，对于数据的输入/输出操作以“流(stream)” 的 方式进行。 Java.io包下提供了各种“流”类和接口，用以获取不同种类的 数据，并通过标准的方法输入或输出数据。 分类 总体分离示意图 输入输出流 按数据流的流向不同分为：输入流，输出流 “输入输出”概念是基于内存/程序/CPU角度而命名的 input输入：读取磁盘中的文件，读取URL的数据 out输出：把数据写入到磁盘中，响应客户端的请求 字节字符流按操作数据单位不同分为：字节流(8 bit)，字符流(16 bit-java是Unicode编码) 字符流 字符流：传输最小单位为一个字符(2byte)，仅能处理任意文本数据(.txt，.java，.c，.cpp…) 兼容任意字符集原理 为什么字符流能保证任何编码集字符在程序中或内存中(JVM)都不会出现乱码情况？ 原因是：字符流内部操作时，含编码，解码过程，而且Java使用Unicode字符集使其兼容世界上任何一种字符。 字符流按字符读数据：将文本文件的每个字符转换成Unicode字符，即返回这2个字节所对应的字符的int型数值，此时无论任何字符集都可被Unicode兼容(真正在程序中兼容任何字符集的原因) 写入文件时：把内存中的每一个Unicode字符(char-2个字节)的内容，再按写入文件系统的编码格式进行译码，使其兼容目的操作的文件系统。 版权声明：本文为CSDN博主「山淼」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_43229056/article/details/106137920 简单来说：字符流是面向字符的(超出字符码表的二进制是不认的)，即把原始文件中的二进制数据以字符形式读出，再将字符以二进制形式写入，所以得到的文件以字符方式存储。 不兼容非文本类型原理 字符流仅能处理文本数据，而不能传输处理非文本数据(图片、视频)的原因是 ? 原因：字符流是面向字符的，字符流操作过程自带编码，解码，非文本文件二进制数据存在超出字符集码表的可能性，即乱码。使其经过编码和解码操作后，原有的二进制数据发送改变。 此时一个非文本文件的二进制数据什么组合或者什么大小的可能性都存在的 当非文本文件的一个或多个字节的二进制数据，按字符传输时，首先会对文件进行编码 编码的过程中由于是非文本文件，二进制的内容是任意情况的。存在超出字符集的码表范围的二进制组合，即找不到与之对应的字符，此时就会转为其他字符乱码 注意，这个乱码是没有一一对应关系(如果有，就属于是字符集编码范围了)，即某个匹配不到码表的数据A1，转换为某个乱码S后。这个乱码S再经过解码得出的数据A2，是和A1存在不一样的可能性。 因此经过这样一个“ 二进制——&gt; 乱码编码 ——&gt; 乱码解码 ——&gt; 二进制‘ ”过程，二进制数据已经发生了改变。 而图片的数据是按字节存储的，所以打开图片时解码出错了 与字节流对比，字节流传输数据是面向字节的(比特)，不存在编码、解码过程，直接的传输原始的二进制数据。因此字节流在传输非文本文件类型的数据时不会导致原有的二进制数据发生改变。 版权声明：可以用字符流复制一张图片文件吗？ - 不将就！ 原文链接：博客园 https://www.cnblogs.com/byron0918/p/4898526.html 字节流 字节流：传输最小单位是1byte(等同于bit)，可以处理任意类型的文件 字节流按字节读取：两节点之间直接进行字节传送/比特流传送。(没有编码解码过程) 字节流也可以处理字符文本(复制黏贴)，但一般不支持在终端，程序，内存中直接输出中文(cmd终端默认会以GBK编码输出)，会因为字符集不对应而输出乱码。(此时可以考虑使用转换流) 但字节流是可以对文本文件进行传输，这是不影响的。文本文件归根到底也是比特流。 兼容任意文件类型原因 在计算机中任何数据类型底层存储的都是二进制数据 字节流是面向字节读取的，可以说就是面向二进制/比特流直接操作 与字符流对比没有编码和解码的过程。因此可以传输任意文件类型 节点流与处理流按流的角色的不同分为：节点流，处理流 节点流：直接作用在两传输节点上，进行数据传输的流，如inputStream和outputStream 处理流：作用在节点流之上，对节点流进行包裹作用以实现特定的辅助功能的流 API体系 Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个 抽象基类派生的 顶层抽象基类： 字节流：InputStream、OutputStream 字符流：Reader、Writer 由这四个类派生出来的子类名称都是以其父类名作为子类名后缀 抽线类是不能够实例化的，因此实际使用都是多态与这些抽象类，或者直接使用其子类 IO流API体系结构图 缓冲区设置 无论输出流还是输入流都要基于一个存储数据的缓冲数组，一般设置为1024的整数倍 现代操作系统的内存管理都具有分页机制，而内存页的大小都是1024的整数倍，定义1024整数倍大小的缓冲区在分配内存时将不会形成碎片。 编码基础知识字符集兼容 其实文本的不同编码字符集之间都是尽量使其能互相兼容 而兼容性最强的便是最早出现的ASCII码，可以说现如今的任何一种字符集都是兼容ASCII编码 字符编码转换 注意定长字符集，并不代表编码转换的过程也是定长的， 编码转换的过程是专门的编码转换器完成的，如UTF-8/ASCII转Uniconde编码， 此时两个字符集每个字符占用的字节数不一致，且UTF-8本身就是变长的。 因此转换的过程肯定也是变长处理的，只是由于转换的目的字符集是定长的而已。 定长字符集 Unicode是无论什么字符，每一个字符都使用2个字节进行编码，是一种定长编码方式。 虽然unicode编码能做到将不同国家的字符进行统一，使得乱码问题得以解决，但是如果内容全是英文unicode编码比ASCII编码需要多一倍的存储空间 因此一种可变长的编码“utf-8”就应运而生了，把英文变长1个字节，汉字3个字节，特别生僻的变成4-6个字节，如果传输大量的英文，utf8的作用就很明显了 为什么转换成汉字时，一个字符编码所需的字节数比Unicode定长编码所需的字节数还要大呢？ 这是由于可变长编码是一种哈夫曼编码，这种编码要保证不能有重复的前缀后缀，简单来说即需要完全兼容一个字节的原生ASCII码，因此需要在识别上增加字节数目。 变长编码字符集 实际文本字符使用某个字符集进行编码时，有些字符集为了节省内存可变长编码的，如UTF-8 如UTF-8中一个中文是占据3个byte，而UTF-8所兼容的ASCII码还是一个ASCII码只占1byte 如使用UTF-8编码的test.txt文本内容为：ABC中国 该test.txt的实际二进制以十六进制方式呈现的内容是：41 42 43 E4 B8 AD E6 96 87 其中”ABC”字符共占据3个byte：41 42 43 而”中国”两字符共占6个byte：E4 B8 AD E6 96 87 因此实际编码时是非等长编码的 UTF-8编码示例：当确定字符集后，每次键盘输入时就判断输入字符是属于兼容字符集还是本体字符集 如以此键盘输入ABC中国字符时，可以识别ABC属于ASCII码范畴，因此采用ASCII码一个字节编码 而当识别到中文字符中国时采用UTF-8本体的字符编码规则，一个中文采用三个字节编码 因此最终编码的结果为：41 42 43 E4 B8 AD E6 96 87 UTF-8解码示例： 由于字符集编码时是采用非等长方式编码，同理，解码也需非等长方式解码。 具体实现可以通过比较兼容字符集的二进制大小来区分转换译码 如41 42 43 E4 B8 AD E6 96 87，已知使用UTF-8字符集编码，则解码时 由于ASCII编码一个字节最大值为7F， 因此译码时可以以每一个字节遍历，当一个字节大小小于7F时表示该字节就是使用ASCII码编码，则当前这一个字节就表示一个字符，将其一个字符按照字符对照表转换为ASCII字符。 当遍历到的字节大小 &gt; 7F 时，则证明非ASCII字符，则从当前字节开始共3字节构成一个UTF8字符，将三个字节的组合按字符对照表进行转换，转换为对应的UTF8字符 节点流文件流 示例代码可从文件字符流看起，相对较为详细 字节流FileInputStream JDK-1.8-API：FileInputStream是InputStream的主要实现类 Constructors 注：读取文件操作前提，文件必须存在。否则报FileNotException异常！！！ Constructor Descriptions FileInputStream(File file) 给定File对象实例化FileInputStream对象文件不存在，报FileNotException FileInputStream(String name) 给定文件路径对象实例化FileInputStream对象文件不存在，报FileNotException FileInputStream(FileDescriptor fdObj) 给定FileDescriptor对象实例化FileInputStream对象文件不存在，报FileNotException Methods Method Descriptions int read() 从该输入流读取一个字节的数据，文件结尾返回 -1 int read(byte[] buff) 从该输入流读取buff.length个字节的数据，到buff字节数组中返回实际读取到的字节个数，文件结尾返回 -1 int read(byte[] b, int off, int len) 从该输入流读取最多len个字节的数据，到buff数组从off索引开始位置中 int available() 返回从此输入流中可以读取（或跳过）的剩余字节数的估计值，而不会被下一次调用此输入流的方法阻塞。 long skip(long n) 跳过并从输入流中丢弃 n字节的数据。 void finalize() 确保当这个文件输入流的 close方法没有更多的引用时被调用。 void close() 关闭此文件输入流并释放与流相关联的任何系统资源。 FileChannel getChannel() 返回与此文件输入流相关联的唯一的FileChannel对象 FileDescriptor getFD() 返回表示与此 FileInputStream正在使用的文件系统中实际文件的连接的 FileDescriptor对象。 FileOutputStream JDK-1.8-API：FileOutputStream是OutputStream的主要实现类 Constructors 注：写入文件操作，文件不一定存在，若不存在则自动创建，不会报FileNotException Constructor Descriptions FileOutputStream(File file) 给定File对象实例化FileOutputStream对象 FileOutputStream(File file, boolean append) 给定File对象实例化FileOutputStream对象append指明写入操作是否追加到文件末尾true为追加，false为覆盖(write默认覆盖) FileOutputStream(String name) 给定文件路径实例化FileOutputStream对象 FileOutputStream(String name, boolean append) 给定文件路径实例化FileOutputStream对象append指明写入操作是否追加到文件末尾true为追加，false为覆盖(write默认覆盖) FileOutputStream(FileDescriptor fdObj) 创建文件输出流以写入指定的文件描述符表示与文件系统中实际文件的现有连接。 Methods write()系列的方法若文件不存在，则自动创建，若文件存在，则覆盖该文件。 追加数据操作需使用append()系列的方法，或new FileOutputStream(file,ture)，true表明追加数据标识。 Method Descriptions void write(int b) 将指定的字节写入此文件输出流 void write(byte[] b) 将 b.length个字节从指定的字节数组写入此文件输出流 void write(byte[] b, int off, int len) 将len字节从位于偏移量off开始的指定字节数组写入此文件输出流 void close() 关闭此文件输出流并释放与此流相关联的任何系统资源。 void finalize() 清理与文件的连接，并确保当没有更多的引用此流时，将调用此文件输出流的 close方法。 FileChannel getChannel() 返回与此文件输出流相关联的唯一的FileChannel对象。 FileDescriptor getFD() 返回与此流相关联的文件描述符。 void flush() OutputStream的方法，将缓冲区的内容强制输出的输出流 图片Copy示例 能操作任意文件类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.website.io.node;import java.io.*;/** * @author yhd * @create 2021-06-15 17:30 */public class FileTest &#123; public static void main(String[] args) &#123; File srcFile = new File(&quot;dir//img.jpg&quot;); File destFile = new File(&quot;dir//test&quot;,srcFile.getName()); FileInputStream fis = null; FileOutputStream fos = null; try &#123; fis = new FileInputStream(srcFile); fos = new FileOutputStream(destFile); int len = -1; byte[] buff = new byte[1024]; while((len = fis.read(buff)) != -1)&#123;//读取 fos.write(buff,0,len);//写入 &#125; &#125;catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(fis != null)&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fos != null)&#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 字符流 字符型文件流：FileReader、FileWriter FileReader JDK-1.8-API：FileReader是Reader主要实现类 Constructors 注：读取文件操作前提，文件必须存在。否则报FileNotException异常！！！ Constructor Descriptions FileReader(File file) 给定File对象创建一个FileReader实例文件不存在，报FileNotException FileReader(FileDescriptor fd) 给定FileDescriptor创建一个FileReader实例文件不存在，报FileNotException FileReader(String fileName) 给定文件路径创建一个FileReader实例文件不存在，报FileNotException Methods Method Descriptions int read() 每次读取一个字符，返回值为字符Unicode编码读取到文件末尾返回-1 int read(char[] cbuf) 每次读取一个cbuf长度的字符，并存入cbuf数组返回值为每次已读取的字符个数返回每次实际读取到字符个数，文件末尾返回-1 int read(char[] cbuf, int off, int len) 每次读取len长度的字符数，并从cbuf的off索引开始存入read(char[] cbuf,0,cbuf.length) 等价read(char[] cbuf)返回每次实际读取到字符个数，文件末尾返回-1 int read(CharBuffer target) 试图将字符读入指定的字符缓冲区。 boolean ready() 判断是否准备读取此流 void close() 关闭该流并释放与之关联的所有资源 void mark(int readAheadLimit) 标记流中的当前位置 boolean markSupported() 判断此流是否支持 mark() 操作 void reset() 重置该流。 long skip(long n) 跳过字符 FileWriter JDK-1.8-API：FileWriter是Writer主要实现类，等同Writer的API Constructors 注：写入文件操作，文件不一定存在，若不存在则自动创建，不会报FileNotException Constructor Descriptions FileWriter(File file) 传入一个File对象构造一个FileWriter对象。 FileWriter(File file, boolean append) 传入一个File对象构造一个FileWriter对象，append指明write方法是否为追加数据操作，true为追加数据，false覆盖操作 FileWriter(FileDescriptor fd) 构造与文件描述符关联的FileWriter对象 FileWriter(String fileName) 构造一个给定文件名的FileWriter对象。 FileWriter(String fileName, boolean append) 构造一个FileWriter对象，给出一个带有布尔值的文件名表示是否附加写入的数据 Methods write()系列的方法若文件不存在，则自动创建，若文件存在，则覆盖该文件。 追加数据操作需使用append()系列的方法，或new FileWriter(file,ture)，true表明追加数据标识 Method Descriptions void write(char[] cbuf) 写入一个字符数组。 void write(char[] cbuf, int off, int len) 每次从cbuf数组的off索引开始取len长度的数据写入文件中 void write(int c) 写一个字符 void write(String str) 写一个字符串 void write(String str, int off, int len) 写一个字符串的一部分 Writer append(char c) 将指定的字符附加到此文化末尾。 Writer append(CharSequence csq) 将指定的字符序列附加到文件末尾。 Writer append(CharSequence csq, int start, int end) 将指定字符序列的子序列附加到此作者。 void flush() 刷新缓冲流，将缓冲区的数据强行输出到输出流中属于Writer的方法定义 void close() 关闭流，先刷新。 读取文本文件read() 核心代码 123456789101112//方式一编写，一般使用int data;while((data = fr.read()) != -1)&#123; System.out.print((char)data);//asdasgar123&#125;//方式二编写int data = fr.read();while(data != -1)&#123; System.out.print((char)data); data = fr.read();&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536package com.website.io.node;import java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;/** * @author yhd * @create 2021-06-15 17:30 */public class FileTest &#123; public static void main(String[] args) &#123; File file = new File(&quot;dir\\\\abc.txt&quot;);//asdasgar123 FileReader fr = null; try &#123; fr = new FileReader(file);//若文件不存FileNotException int data; while((data = fr.read()) != -1)&#123;//每次读取一个字符 System.out.print((char)data);//asdasgar123 &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(fr != null)&#123; try &#123; fr.close();//关闭资源 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; read(char[] cbuf) 核心代码 12345678910111213int len = -1;char[] cbuf = new char[1024];while((len = fr.read(cbuf)) != -1)&#123; //方式1：打印每次读取到的数据.注意遍历长度是len for (int i = 0; i &lt; len; i++) &#123; System.out.print(cbuf[i]); &#125; System.out.println(); //方式2：使用指定数组索引String的构造器 String str = new String(cbuf,0,len); System.out.println(str);&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.website.io.node;import java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;/** * @author yhd * @create 2021-06-15 17:30 */public class FileTest &#123; public static void main(String[] args) &#123; File file = new File(&quot;dir//abc.txt&quot;); FileReader fr = null; try &#123; fr = new FileReader(file); int len = -1; char[] cbuf = new char[1024]; while((len = fr.read(cbuf)) != -1)&#123; //方式1：打印每次读取到的数据.注意遍历长度是len for (int i = 0; i &lt; len; i++) &#123; System.out.print(cbuf[i]); &#125; System.out.println(); //方式2：使用指定数组索引String的构造器 //String str = new String(cbuf,0,len); //System.out.println(str); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(fr != null)&#123; try &#123; fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 写入文本文件write(String str) 核心代码 123fw = new FileWriter(file);fw.write(&quot;Hello Java IO\\n&quot;);fw.write(&quot;Writer String Data&quot;); 完整代码 1234567891011121314151617181920212223242526272829package com.website.io.node;import java.io.*;/** * @author yhd * @create 2021-06-15 17:30 */public class FileTest &#123; public static void main(String[] args) &#123; File file = new File(&quot;dir//cde.txt&quot;); FileWriter fw = null; try &#123; fw = new FileWriter(file); fw.write(&quot;Hello Java IO\\n&quot;); fw.write(&quot;Writer String Data&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(fw != null)&#123; try &#123; fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 文本Copy示例 将一个已经存在的文本文件复制到指定目录下(默认覆盖) 仅适用与文本文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.website.io.node;import java.io.*;/** * @author yhd * @create 2021-06-15 17:30 */public class FileTest &#123; public static void main(String[] args) &#123; File srcFile = new File(&quot;dir//abc.txt&quot;); File destFile = new File(&quot;dir//test&quot;,srcFile.getName()); FileReader fr = null; FileWriter fw = null; try &#123; fr = new FileReader(srcFile); fw = new FileWriter(destFile); int len = -1; char[] cbuf = new char[1024]; while((len = fr.read(cbuf)) != -1)&#123;//读取 fw.write(cbuf,0,len);//写入 &#125; &#125;catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(fr != null)&#123; try &#123; fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fw != null)&#123; try &#123; fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 数组流 备份了解， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.BufferedReader;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;import org.junit.Test;public class ByteArrayOutputStreamTest &#123; @Test public void test1() throws Exception &#123; FileInputStream fis = new FileInputStream(&quot;abc.txt&quot;); String info = readStringFromInputStream(fis); System.out.println(info); &#125; private String readStringFromInputStream(FileInputStream fis) throws IOException &#123; // 方式一：可能出现乱码 // String content = &quot;&quot;; // byte[] buffer = new byte[1024]; // int len; // while((len = fis.read(buffer)) != -1)&#123; // content += new String(buffer); // &#125; // return content; // 方式二：BufferedReader BufferedReader reader = new BufferedReader(new InputStreamReader(fis)); char[] buf = new char[10]; int len; String str = &quot;&quot;; while ((len = reader.read(buf)) != -1) &#123; str += new String(buf, 0, len); &#125; return str; // 方式三：避免出现乱码 // ByteArrayOutputStream baos = new ByteArrayOutputStream(); // byte[] buffer = new byte[10]; // int len; // while ((len = fis.read(buffer)) != -1) &#123; // baos.write(buffer, 0, len); // &#125; // // return baos.toString(); &#125;&#125; 处理流 回收资源时，先关闭外层的处理流，再关闭内层的节点流。 实际操作中，仅需关闭外层的缓冲流即可，会自动关闭内层的节点流。 缓冲流基本概念 通过对节点流进行”包裹“，提高流的读取写入速度。 原理 为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类 时，会创建一个内部缓冲区数组，默认使用8192个字节(8Kb)的缓冲区 当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区 当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了(或文件内容结束)，才重新从文件中读取下一个8192个字节数组。 向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满， BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。 使用方法flush()可以强制将缓冲区的内容全部写入输出流 小结：缓冲流的原理就是，内部再使用一个数组来存储读写的数据，而且每次都是一次性读满或写满后才进行下一步操作，加快用户的数据操作，与减少和文件系统的交互次数。 字节流BufferedInputStream Constructor Constructor Descriptions BufferedInputStream(InputStream in) 给定InputStream对象创建一个BufferedInputStream对象 BufferedInputStream(InputStream in, int size) 给定InputStream对象创建一个BufferedInputStream对象size用于指定缓冲区大小 Methods 继承FileInputStream并重写部分方法，类同FileInputStream的API BufferedOutputStream Constructor Constructor Description BufferedOutputStream(OutputStream out) 给定一个OutputStream 对象创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 BufferedOutputStream(OutputStream out, int size) 。 给定一个OutputStream 对象，创建一个新的缓冲输出流，以便以指定的缓冲区大小将数据写入指定的底层输出流 Methods 继承FileOutputStream并重写了部分方法，同FileOutputStream的API 新增的API Method Descriptions void flush() 刷新(清空)缓冲流的缓冲区，并将内容输出。write()方法,内部有自动调用 Copy示例 通过缓存流实现文件字节流的Copy操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.website.io.node;import java.io.*;/** * @author yhd * @create 2021-06-15 17:30 */public class BufferTest &#123; public static void main(String[] args) &#123; File srcFile = new File(&quot;dir//img.jpg&quot;); File destFile = new File(&quot;dir//test&quot;,srcFile.getName()); BufferedInputStream bis = null; BufferedOutputStream bos = null; try &#123; FileInputStream fis = new FileInputStream(srcFile); FileOutputStream fos = new FileOutputStream(destFile); //包装节点流 bis = new BufferedInputStream(fis); bos = new BufferedOutputStream(fos); int len = -1; byte[] buff = new byte[1024]; while((len = bis.read(buff)) != -1)&#123;//读取 bos.write(buff,0,len);//写入 &#125; &#125;catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(bis != null)&#123; try &#123; bis.close();//自动关闭内部节点流 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(bos != null)&#123; try &#123; bos.close();//自动关闭内部节点流 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 字符流BufferedReader Constructors Constructor Descriptions BufferedReader(Reader in) 给定Reader对象创建使用默认大小的输入缓冲区的缓冲字符输入流 BufferedReader(Reader in, int sz) 给定Reader对象创建使用指定sz大小的输入缓冲区的缓冲字符输入流。 Methods 基本继承Reader方法，以下是新增的API New Method Descriptions Stream&lt;String&gt; lines() 返回一个 Stream ，其元素是从这个 BufferedReader读取的行 String readLine() 读取一行文字，返回的一行数据不包含换行符读取到文件末尾返回null BufferedWriter Constructors Constructor Descriptions BufferedWriter(Writer out) 创建使用默认大小的输出缓冲区的缓冲字符输出流。 BufferedWriter(Writer out, int sz) 创建一个新的缓冲字符输出流，使用给定大小的输出缓冲区。 Methods 基本继承Writer，Writer又被FileWrtier继承实现，可以参照FileWriter的API，以下是新增的API New Method Descriptions vodi flush() 刷新流，将缓冲区数据强制输出到输出流中write()方法,内部有自动调用 void newLine() 输出一个换行符，一般配合readLine()使用(不包含换行) void write(String s, int off, int len) 写一个字符串的一部分 Copy示例 采用BufferedReader和BufferedWriter新API 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.website.io.node;import java.io.*;/** * @author yhd * @create 2021-06-15 17:30 */public class FileTest &#123; public static void main(String[] args) &#123; File srcFile = new File(&quot;dir//abc.txt&quot;); File destFile = new File(&quot;dir//test&quot;,srcFile.getName()); BufferedReader br = null; BufferedWriter bw = null; try &#123; FileReader fr = new FileReader(srcFile); FileWriter fw = new FileWriter(destFile); br = new BufferedReader(fr); bw = new BufferedWriter(fw); //新方式 String str = null; while((str = br.readLine()) != null)&#123;//一行行读取,不包含换行符 bw.write(str); bw.newLine();//补充换行符 &#125; //旧方式// int len = -1;// char[] cbuf = new char[1024];// while((len = br.read(cbuf)) != -1)&#123;//读取// bw.write(cbuf,0,len);//写入// &#125; &#125;catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(br != null)&#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(bw != null)&#123; try &#123; bw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 转换流基本概念 转换流提供了在字节流和字符流之间的转换 Java API提供了两个转换流：从类型上均属于字符流(看后缀) InputStreamReader：将InputStream转换为Reader OutputStreamWriter：将Writer转换为OutputStream InputStreamReader 将InputStream转换为Reader Construcors tips：下列构造器指示的字符集属于解码字符集，但最终目的转换的字符集固定为Unicode(Java) 指示解码字符集的作用只是表明将二进制数据以指定字符集方式转换Unicode编码，如： 指定解码字符集为GBK，则底层转码过程为：二进制 —GBK解析—&gt; Unicode 指定解码字符集为UTF-8，则底层转码过程为：二进制 —UTF-8解析—&gt; Unicode Constructor Descriptions InputStreamReader(InputStream in) 创建一个使用默认字符集的InputStreamReader，该字符集指解码字符集，即程序设置的字符集，非文件所在文件系统的字符集。 InputStreamReader(InputStream in, String charsetName) 创建一个使用指定字符集的InputStreamReadertips：指定的是解码字符集，建议基于文件存储时使用的编码字符集而定。 InputStreamReader(InputStream in, Charset cs) 创建一个使用给定字符集创建InputStreamReader。 InputStreamReader(InputStream in, CharsetDecoder dec) 创建一个使用给定字符集解码器的InputStreamReader Methods 转后后的字符流继承Reader，因此方法的API类似FileReader OutputStreamWriter 将Writer转换为OutputStream 应用场景字节流不乱码 转换流可以弥补字节流在终端、Java程序中、内存中直接显示某些字符(中文**)乱码**的情况 即将通过字节流读取的文本文件，转换为字符流后在程序中进行输出，则解决了乱码 示例代码：通过字节流读取一个UTF-8编码的文本文件(含中文)，并通过转换流成功输出到控制台 123456789101112131415161718192021222324252627282930313233343536373839package com.website.io.deal;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStreamReader;/** * 字节流读取一个UTF-8编码的文本文件(含中文)，并通过转换流成功输出到控制台 * @author yhd * @create 2021-06-16 21:15 */public class InputStreamReaderTest &#123; public static void main(String[] args) &#123; InputStreamReader isr = null; try &#123; FileInputStream fis = new FileInputStream(&quot;dir\\\\dbcp.txt&quot;); isr = new InputStreamReader(fis,&quot;UTF-8&quot;); char[] cbuf = new char[1024]; int len = -1; while((len = isr.read(cbuf)) != -1)&#123; System.out.println(new String(cbuf,0,len)); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(isr != null)&#123; try &#123; isr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 字符集转换功能 转换流可以对文本文件自定义地进行指定字符集的解码和编码操作 如下图时是通过字节流读取的UTF-8编码文件转换为GBK编码文件后再通过字节流传输出去过程： 示例代码：将从字节流获取的UTF-8编码转码成GBK编码后再通过字节流送出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.website.io.deal;import java.io.*;/** * * @author yhd * @create 2021-06-16 21:51 */public class TranscoderTest &#123; public static void main(String[] args) &#123; InputStreamReader isr = null; OutputStreamWriter osw = null; try &#123; FileInputStream fis = new FileInputStream(&quot;dir//dbcp.txt&quot;); FileOutputStream fos = new FileOutputStream(&quot;dir//test//dbcp_gbk.txt&quot;); isr = new InputStreamReader(fis,&quot;UTF-8&quot;);//解码字符集 osw = new OutputStreamWriter(fos,&quot;GBK&quot;);//编码字符集 int len = -1; char[] cbuf = new char[1024]; while((len = isr.read(cbuf)) != -1)&#123; osw.write(cbuf,0,len); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(isr != null)&#123; try &#123; isr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(osw != null)&#123; try &#123; osw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 标准输入输出流 System封装了系统级的很多属性和控制方法，其中含三个静态属性属于流对象 静态属性 描述 static PrintStream out “标准”输出流 static InputStream in “标准”输入流 static PrintStream err “标准”错误输出流 默认输入设备是：键盘，输出设备是：显示器 System.in的类型是InputStream System.out的类型是PrintStream(打印流)，其是OutputStream的子类 FilterOutputStream 的子类 重定向：通过System类的setIn()，setOut()方法对输入输出得默认设备进行改变。 public static void setIn(InputStream in) public static void setOut(PrintStream out) 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.website.io.system;import java.io.*;import java.util.Locale;/** * 从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续 * 进行输入操作，直至当输入“e”或者“exit”时，退出程序。 * @author yhd * @create 2021-06-16 22:25 */public class SystemIOTest &#123; public static void main(String[] args) &#123; InputStream is = System.in; InputStreamReader isr = new InputStreamReader(is); BufferedReader br = new BufferedReader(isr); String str = null; try &#123; while (true)&#123; System.out.println(&quot;请输入一行字符,回车后输出大写&quot;); str = br.readLine(); if(&quot;e&quot;.equalsIgnoreCase(str) || &quot;exit&quot;.equalsIgnoreCase(str))&#123; System.out.println(&quot;退出程序...&quot;); break; &#125; System.out.println(str.toUpperCase(Locale.ROOT)); &#125; &#125;catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(br != null)&#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 打印流 实现将基本数据类型的数据格式转化为字符串输出 打印流：PrintStream和PrintWriter 提供了一系列重载的print()和println()方法，用于多种数据类型的输出 PrintStream和PrintWriter的输出不会抛出IOException异常 PrintStream和PrintWriter有自动flush功能 PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。 在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。 System.out返回的就是是PrintStream的实例 示例代码：创建打印流，并设置System.out.print()的输出重定向到该打印流中。 即将控制台的输出内容不在控制台输出，而是存储到指定文件中。 123456789101112131415161718192021222324252627@Testpublic void test2() &#123; PrintStream ps = null; try &#123; FileOutputStream fos = new FileOutputStream(new File(&quot;D:\\\\IO\\\\text.txt&quot;)); // 创建打印输出流,设置为自动刷新模式(写入换行符或字节 &#x27;\\n&#x27; 时都会刷新输出缓冲区) ps = new PrintStream(fos, true); if (ps != null) &#123; System.setOut(ps); // 把标准输出流(控制台输出)重定向到指定输出流(指定文件) &#125; //打印0~255数字的字符，每50个字符换行一次 for (int i = 0; i &lt;= 255; i++) &#123; // 输出ASCII字符 System.out.print((char) i); if (i % 50 == 0) &#123; // 每50个数据一行 System.out.println(); // 换行 &#125; &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ps != null) &#123; ps.close(); &#125; &#125;&#125; 数据流 基本概念 数据流：DataInputStream 和 DataOutputStream 构造器时使用时套接对应的InputStream和OutputStream 作用： 用于读取或写出基本数据类型的变量或字符串 即用于Java内存中的基本数据类型和字符串类型数据的持久化操作。 示例代码 注意：处理异常的话，仍然应该使用try-catch-finally. 1234567891011121314151617181920212223242526272829303132333435/* 练习：将内存中的字符串、基本数据类型的变量写出到文件中。 注意：处理异常的话，仍然应该使用try-catch-finally.*/@Testpublic void test3() throws IOException &#123; DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;data.txt&quot;)); dos.writeUTF(&quot;刘建辰&quot;); dos.flush();//刷新操作，将内存中的数据写入文件 dos.writeInt(23); dos.flush(); dos.writeBoolean(true); dos.flush(); dos.close();&#125;/* 将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。 注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！*/@Testpublic void test4() throws IOException &#123; DataInputStream dis = new DataInputStream(new FileInputStream(&quot;data.txt&quot;)); String name = dis.readUTF(); int age = dis.readInt(); boolean isMale = dis.readBoolean(); System.out.println(&quot;name = &quot; + name); System.out.println(&quot;age = &quot; + age); System.out.println(&quot;isMale = &quot; + isMale); dis.close();&#125; 对象流基本概念 对象流：ObjectInputStream和OjbectOutputSteam 构造器时使用时套接对应的InputStream和OutputStream 用于存储和读取基本数据类型数据或Java对象的处理流。 它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。 序列化：用ObjectOutputStream类保存基本类型数据或对象的机制 反序列化：用ObjectInputStream类读取基本类型数据或对象的机制 ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量 对象的序列化序列化的实现 对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从 而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。 当其它程序获取了这种二进制流，就可以恢复成原 来的Java对象。 序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据， 使其在保存和传输时可被还原 序列化是 RMI（Remote Method Invoke – 远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是 JavaEE 平台的基础 如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的， 为了让某个类是可序列化的，需要两步： 注：以下操作包含其类及其内部所有属性都必须实现这两步! ! ! 该类必须实现如下两个接口之一。 否则，会抛出NotSerializableException异常 Serializable：标识接口，没有任何方法需要实现 Externalizable 添加public static final long serialVersionUID，并且给定一个值，可以随便写 serialVersionUID 凡是实现Serializable接口的类都有一个表示序列化的类的版本标识符的静态变量： private static final long serialVersionUID; serialVersionUID用来表明类的不同版本间的兼容性。 简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。 如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的结构做了修改(如增加了属性、方法…修改了方法名，类名等)，自动生成的serialVersionUID 可能发生变化，此时再进行反序列化时，JVM就识别不是同一个类版本，报出异常。故建议， 显式声明。 简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的 serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化类的版本不一致的异常。(InvalidCastException) 小结：简单来说就是保证用于序列化的Person类的结构，(如通过网络传输给另一个系统)是和反序列化时是同一个Person结构 示例代码可序列化类 示例代码：为其自定义类及其所有属性实现Serializable接口与添加serialVersionUID属性 Person.java 123456789101112131415161718192021222324252627282930313233package com.website.io.other;import java.io.Serializable;/** * @author yhd * @create 2021-06-17 8:29 */public class Person implements Serializable &#123; //声明该类的序列化版本ID public static final long serialVersionUID = 888123L; //内部已实现了Serializable和定义了serialVersionUID private String name; private int age; private Account account;//还需序列化基础设置 public Person(String name, int age, Account account) &#123; this.name = name; this.age = age; this.account = account; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, account=&quot; + account + &#x27;&#125;&#x27;; &#125;&#125; Account.java 12345678910111213141516171819202122232425package com.website.io.other;import java.io.Serializable;/** * @author yhd * @create 2021-06-17 8:32 */public class Account implements Serializable &#123; //声明该类的序列化版本ID public static final long serialVersionUID = 999123L; private double balance; public Account(double balance) &#123; this.balance = balance; &#125; @Override public String toString() &#123; return &quot;Account&#123;&quot; + &quot;balance=&quot; + balance + &#x27;&#125;&#x27;; &#125;&#125; 序列化与反序列化 示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.website.io.other;import java.io.*;/** * @author yhd * @create 2021-06-17 8:01 */public class ObjectOutputStreamTest &#123; public static void main(String[] args) &#123; serialize(); deSerialize(); &#125; //序列化操作 public static void serialize()&#123; ObjectOutputStream oos = null; try &#123; FileOutputStream fos = new FileOutputStream(&quot;dir//Person.bat&quot;); oos = new ObjectOutputStream(fos); Person person = new Person(&quot;Priscilla&quot;, 23, new Account(88.8)); oos.writeObject(person);//可以进行多次操作,对应反序列化时也需按序操作，类数据流使用原则 oos.writeObject(new String(&quot;testString&quot;)); oos.flush();//刷新缓冲区，即讲所有数据一次性写出。 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(oos != null)&#123; try &#123; oos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //反序列化操作 public static void deSerialize()&#123; ObjectInputStream ois = null; try &#123; FileInputStream fis = new FileInputStream(&quot;dir//Person.bat&quot;); ois = new ObjectInputStream(fis); Person person = (Person) ois.readObject();//按序列化数据顺序反序列化 String str = (String) ois.readObject(); System.out.println(&quot;person = &quot; + person); System.out.println(&quot;str = &quot; + str); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if(ois != null)&#123; try &#123; ois.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 随机存取文件流基本概念 RandomAccessFile 声明在java.io包下，但直接继承于java.lang.Object类。并且它实现了DataInput、DataOutput这两个接口(非对象流)，也就意味着这个类既可以读也可以写。 RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方进行读写操作 支持只访问文件的部分内容 可以向已存在的文件后追加内容 RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。 RandomAccessFile 类对象可以自由移动记录指针： long getFilePointer()：获取文件记录指针的当前位置 void seek(long pos)：将文件记录指针定位到 pos 位置 tips：有点像C语言的文件操作结构体 应用场景：可以用RandomAccessFile这个类，来实现一个多线程断点下载的功能， 用过下载工具的朋友们都知道，下载前都会建立两个临时文件，一个是与被下载文件大小相同的空文件，另一个是记录文件指针的位置文件，每次 暂停的时候，都会保存上一次的指针，然后断点下载的时候，会继续从上 一次的地方下载，从而实现断点下载或上传的功能。 API Constructors Constructor Descriptions public RandomAccessFile(File file, String mode) 通过mode指明访问模式，并给定File对象创建实例 public RandomAccessFile(String name, String mode) 通过mode指明访问模式，并给定文件路径创建实例 Field - String mode Mode Descriptions r 以只读方式打开，不存在则会出现异常 rw 打开以便读取和写入，文件不存在则会去创建文件，如果存在则不会将整个文件全部覆盖，而是把数据从文件指针位置开始覆盖写入内容，写多少覆盖多少(指针默认文件开头) rwd 打开以便读取和写入；同步文件内容的更新 rws 打开以便读取和写入；同步文件内容和元数据的更新 注：JDK 1.6上面写的每次write数据时，“rw”模式，数据不会立即写到硬盘中；而rwd”，数据会被立即写入硬盘。如果写数据过程发生异常，“rwd“模式中已被write的数据被保存到硬盘，而”rw“则全部丢失。 Methods RandomAccessFile主要继承了数据流DataInput和DataOutput，数据流也实现这些接口，因此含数据流的API RandomAccessFile自定义和实现了，类InputStream和OutputStream的read()writer()方法 以下再补充RandomAccessFile特有的常用的新API Method Descriptions long getFilePointer() 获取文件记录指针的当前位置 void seek(long pos) 将文件记录指针定位到pos 位置，单位为字节，位置从0开始计算tips：定位到末尾可以使用seek(file.length) ……. 示例代码Copy 示例代码 如果只在一个文件中进行读写操作，则一个RandomAccessFile对象即刻完成 如果是复制，移动到其他路径下的操作，则需要多一个RandomAccessFile指明目标文件路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.website.io.other;import java.io.FileNotFoundException;import java.io.IOException;import java.io.RandomAccessFile;/** * @author yhd * @create 2021-06-17 9:04 */public class RandomAccessTest &#123; public static void main(String[] args) &#123; RandomAccessFile raf1 = null; RandomAccessFile raf2 = null; try &#123; raf1 = new RandomAccessFile(&quot;dir//img.jpg&quot;,&quot;r&quot;); raf2 = new RandomAccessFile(&quot;dir//test//raf_img.jpg&quot;,&quot;rw&quot;); byte[] buff = new byte[1024]; int len = -1; while((len = raf1.read(buff)) != -1)&#123;//数据读取 raf2.write(buff,0,len);//数据写入 &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(raf1 != null)&#123; try &#123; raf1.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(raf2 != null)&#123; try &#123; raf2.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 数据插入 由于直接插入回对原有数据进行部分或全部覆盖 因此插入前，需把插入位置后的所有数据先保存下来(文件指针已在末尾) 把插入的数据和插入位置后的所有数据一并插入到指定位置。实现传统意义上的数据插入 示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.website.io.other;import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;import java.io.RandomAccessFile;/** * 在文件abc.txt中的abcghijk123，第3个位置插入def * 插入数据后的效果为：abcdefghijk123 * @author yhd * @create 2021-06-17 9:04 */public class RandomAccessTest &#123; public static void main(String[] args) &#123; RandomAccessFile raf = null; try &#123; File file = new File(&quot;dir//abc.txt&quot;); raf = new RandomAccessFile(file,&quot;rw&quot;);//abcghijk123 byte[] buff = new byte[1024]; int len = -1; //也可以使用数组流代替 StringBuilder sb = new StringBuilder((int) file.length());//提高效率 //暂存插入位置后的所有数据 raf.seek(3); while((len = raf.read(buff)) != -1)&#123;//此时文件指针已至末尾 sb.append(new String(buff,0,len)); &#125; //插入新增的数据 raf.seek(3);//重置文件指针到插入位置 byte[] insert = &quot;def&quot;.getBytes(); raf.write(insert);//在插入位置写入数据 raf.write(sb.toString().getBytes());//补充插入位置原有的数据 &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(raf != null)&#123; try &#123; raf.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; NIO.2基本概念NIO概述 Java NIO (New IO，Non-Blocking IO/非阻塞IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的Java IO API。 NIO与原来的IO有同样的作用和目的，但是实现方式完全不同，NIO支持面向缓冲区的基于通道的IO操作(IO是面向流的)。 NIO将以更加高效的方式进行文件的读写操作。 Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。 java.nio.channels.Channel 处理本地文件NIO FileChannel：处理本地文件 网络编程NIO SocketChannel：TCP网络编程的客户端的Channel ServerSocketChannel：TCP网络编程的服务器端的Channel DatagramChannel：UDP网络编程中发送端和接收端的Channe NIO.2的出现 由于NIO的初始版本并不好用，以至于没有被大力推广。 随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对 文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。 因为 NIO 提供的一些功能，NIO已经成为文件处理中越来越重要 的部分。 Path基本概念 早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息（如renameTo()方法）。 NIO. 2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。Path可以看成是File类的升级版本，实际引用的资源也可以不存在。 在以前IO操作都是这样写的: 123import java.io.File;File file = new File(&quot;index.html&quot;); 但在Java7中，我们可以这样写： 1234import java.nio.file.Path;import java.nio.file.Paths;Path path = Paths.get(&quot;index.html&quot;) 常用API 部分常用API，具体查询官方API String toString() ： 返回调用 Path 对象的字符串表示形式 boolean startsWith(String path) : 判断是否以 path 路径开始 boolean endsWith(String path) : 判断是否以 path 路径结束 boolean isAbsolute() : 判断是否是绝对路径 Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径 Path getRoot() ：返回调用 Path 对象的根路径 Path getFileName() : 返回与调用 Path 对象关联的文件名 int getNameCount() : 返回Path 根目录后面元素的数量 Path getName(int idx) : 返回指定索引位置 idx 的路径名称 Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象 Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象 File toFile(): 将Path转化为File类的对象 Paths&amp;Files Paths和Files都是工具类，由NIO.2在java.nio.file包提供。 Paths-API 部分常用API，具体查询官方API 如Paths 类提供的静态 get() 方法用来获取 Path 对象： static Path get(String first, String … more) : 用于将多个字符串串连成路径 static Path get(URI uri): 返回指定uri对应的Path路径 Files-API 部分常用API，具体查询官方API Path copy(Path src, Path dest, CopyOption … how) : 文件的复制 Path createDirectory(Path path, FileAttribute … attr) : 创建一个目录 Path createFile(Path path, FileAttribute … arr) : 创建一个文件 void delete(Path path) : 删除一个文件/目录，如果不存在，执行报错 void deleteIfExists(Path path) : Path对应的文件/目录如果存在，执行删除 Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置 long size(Path path) : 返回 path 指定文件的大小 用于判断 boolean exists(Path path, LinkOption … opts) : 判断文件是否存在 boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录 boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件 boolean isHidden(Path path) : 判断是否是隐藏文件 boolean isReadable(Path path) : 判断文件是否可读 boolean isWritable(Path path) : 判断文件是否可写 boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在 用于操作内容 SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连 接，how 指定打开方式。 DirectoryStream newDirectoryStream(Path path) : 打开 path 指定的目录 InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象 OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象 第三方IO库apache-commons-io概述Apache Commons IO是Apache基金会创建并维护的Java函数库。它提供了许多类使得开发者的常见任务变得简单，同时减少重复（boiler-plate）代码，这些代码可能遍布于每个独立的项目中，你却不得不重复的编写。这些类由经验丰富的开发者维护，对各种问题的边界条件考虑周到，并持续修复相关bug。 示例代码 FileUtils工具类使用实例代码：复制一个文件操作 1234567891011121314151617import org.apache.commons.io.FileUtils;import java.io.File;import java.io.IOException;public class FileUtilsTest &#123; public static void main(String[] args) &#123; File srcFile = new File(&quot;img.jpg&quot;); File destFile = new File(&quot;dir\\\\img.jpg&quot;); try &#123; FileUtils.copyFile(srcFile,destFile); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/tags/JavaSE/"}]},{"title":"Java集合","slug":"Java集合","date":"2021-06-13T14:03:12.000Z","updated":"2021-08-25T15:27:11.766Z","comments":true,"path":"2021/06/13/Java集合/","link":"","permalink":"http://yoursite.com/2021/06/13/Java%E9%9B%86%E5%90%88/","excerpt":"","text":"引言：本文主要包含的内容有集合框架概述、Collection接口常用方法、及其子接口List、Set，及其实现类ArrayList、LinkList原理。iterator迭代器原理与使用，Map接口及其实现类、HashMap、TreeMap原理，以及工具类Collections常用的方法。 集合框架概述背景 编程中，经常需要将多个对象进行进行存储操作。使用传统的Array存储对象方面具有一些弊端： 数组初始化以后，长度就不可变了，不便于扩展 数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。 同时无法直接获取实际存储元素的个数(length属性是数组长度，是固定的) 存储数据的特点单一：数组存储的数据只能是有序的、且允许可以重复的 数组声明的类型，就决定了进行元素初始化时的类型 …. Java集合如同数据结构中的线性表，集合这样的数据结构 Java 集合类可以用于存储数量不等的多个对象(List&amp;Set)，还可用于保存具有映射关系的关联数组(Map) Java 集合就像一种容器，可以动态地把多个对象的引用放入容器中 概念体系 Java集合总的来说可分为Collection和Map两种系，均为接口，用于规范操作。 Collection Collection接口：译为“集合”，单列数据，定义存储一组对象的方法的集合，包含子接口如下： List子接口：译为“线性表”，指有序、可重复的集合。同数据结构线性表定义。 实现类：ArrayList、LinkedList、Vector… Set子接口：译为“集合”，指无序、不可重复的集合，同数学上集合的定义(无序、互斥、确定)。 实现类：HashSet、LinkedHashSet、TreeSet… …… Map Map接口：译为“映射”，双列数据，保存具有映射关系“key-value对”的集合，同数学函数 y=f(x) 实现类：HashMap、LinkedHashMap、TreeMap、Hashtable、Properties…. 概念示意图 API体系 Collection Collection是一个接口，List和Set都是继承与该接口的子接口，对应衍生出去的实现类也众多。它们都会具备Collection的特性，因此首当其冲学习Collection接口。 由于接口的数学都是全局静态属性，没有什么可以展开说明，因此忽略。 主要掌握Collection的方法，以Collection声明其子类的多态方式就可以只测试Collection方法了 Collection testMethod = new ArrayList(); AbstractMethods JDK 8.0 - API Abstract Method Description boolean add(E e) 将指定元素添加到集合内 boolean addAll(Collection&lt;? extends E&gt; c) 将指定集合中的所有元素添加到此集合 void clear() 从此集合中删除所有元素 boolean contains(Object o) 如果此集合包含指定的元素，则返回 true boolean containsAll(Collection&lt;?&gt; c) 如果此集合包含指定集合中的所有元素，则返回true boolean equals(Object o) 将指定的对象/集合(对象)与此集合进行比较以获得相等性 int hashCode() 返回此集合的哈希码值 boolean isEmpty() 如果此集合为空，则返回 true Iterator&lt;E&gt; iterator() 返回此集合中的元素的迭代器。 boolean remove(Object o) 从该集合中删除指定元素的单个实例 boolean removeAll(Collection&lt;?&gt; c) 删除指定集合中包含的此集合的元素(删除交集=this的差集) boolean retainAll(Collection&lt;?&gt; c) 仅保留此集合中包含在指定集合中元素(删差集=算交集) int size() 返回此集合中的元素数。 Object[] toArray() 返回一个包含此集合中所有元素的数组。逆操作常用Arrays.asList(T…a);方法 &lt;T&gt; T[] toArray(T[] a) 返回包含此集合中所有元素的数组; 返回的数组的运行时类型是指定数组的运行时类型。 contain&amp;removecontain与``containAll方法还是remove或removeAll`方法，都是调用equals方法 判断依据均是：调用传入对象的equals()方法与集合元素逐一比较。 一般调用equals方法有两种情况： 重写了equals方法：则调用对象重写的equals方法，一般比较属性内容 没有重写equals方法：调用”终极父类“Object的equals方法，此时比较地址值 结论：一般使用集合的contain方法时都先重写对象的equals方法。 示例代码以contain方法测试为例说明 测试类：Person.java，没有重写equals方法 1234567891011package com.website.collectiontest;public class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 测试代码1： 1234567891011121314151617181920package com.website.collectiontest;import org.junit.Test;import java.util.ArrayList;import java.util.Collection;public class CollectionTest &#123; @Test public void test1()&#123; Collection&lt;Object&gt; coll = new ArrayList&lt;&gt;(); coll.add(new String(&quot;str123&quot;)); coll.add(new Person(&quot;Tom&quot;,10)); //由于String重写了equals方法 System.out.println(coll.contains(new String(&quot;str123&quot;)));//true System.out.println(coll.contains(new Person(&quot;Tom&quot;,10)));//false &#125;&#125; 重写Person类equals方法 1234567891011121314151617181920package com.website.collectiontest;public class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; if (age != person.age) return false; return name.equals(person.name); &#125;&#125; 重新测试： 12System.out.println(coll.contains(new String(&quot;str123&quot;)));//trueSystem.out.println(coll.contains(new Person(&quot;Tom&quot;,10)));//true equals 这里指的equals方法指Collection接口的equals方法 Collection的equals方法集合与对象比较，对象也可以是集合，因此即可比较单个对象，也可以比较集合。 无论是集合比较单一对象，还是集合比较集合。内部还是调用对象的equals方法 重点：当调用Collection的equals方法比较两个集合的时候，但由于接口方法的功能细节取决于实现类，对于不同的实现类，相等的要求也不一致，常见两种要求如下： List：不仅元素对象从equals层面要相等，对象在集合中的顺序也要一致 Set：仅元素对象从equals层面相等即可，无顺序要求 DefaultMethodsAPI Default Method Description default Stream&lt;E&gt; parallelStream() 返回可能并行的Stream与此集合作为其来源 default boolean removeIf(Predicate&lt;? super E&gt; filter) 删除满足给定谓词的此集合的所有元素 default Spliterator&lt;E&gt; spliterator() 创建一个Spliterator在这个集合中的元素 default Stream&lt;E&gt; stream() 返回以此集合作为源的顺序 Stream Iteratoriterator译为”迭代器“，是一个接口，本质是一种设计模式。 概念 迭代器模式，拟提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。 Collection接口继承了java.lang.Iterable接口，该Iterable接口有一个iterator()方法 因此所有Collection接口实现类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。 Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建 Iterator 对象，则必须有一个被迭代的集合。 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前 迭代器设计模式理念 不同底层存储原理的集合，定位下一个元素的原理是不一样的 顺序存储结构的ArrayList，底层用数组存储，下一个元素的定位 = (数组下标索引值+1) 链式存储结构的LinkedList，底层用元素对象链接存储，下一个元素的定位 = (当前元素next引用) 迭代器的设计就在于，把”下一个元素的定位“实现的操作封装起来(next()方法) 用户通过直接调用一个封装好的”下一个元素的定位“方法 next()，即可返回当前元素的下一个元素。 想完整地对数据集合进行遍历操作，仅有”返回下一个元素“的操作还不能完全实现 因为数据遍历操作是有边界的，同样不同的存储结构，对数据边界的判断也不一致 如顺序存储结构，数据的边界就是元素的个数，即索引值 而链式存储结构，则是判断next的引用是否为null 同理，迭代器就把对数据边界判断也封装成了一个hashNext()方法，为用户遍历提供边界检查。 这就是迭代器中所描述的”屏蔽内部细节“而实现用户统一遍历操作的设计原理。 APIJDK 8.0 - API Abstract &amp; Default Method Description boolean hasNext() 如果迭代下一个元素存在，则返回 true E next() 返回迭代中的下一个元素。 default void remove() 通过迭代器方式，删除当前游标位置的元素 default void forEachRemaining(Consumer&lt;? super E&gt; action) 对每个剩余元素执行给定的操作，直到所有元素都被处理或动作引发异常。 迭代器遍历 游标概念相当于头指针/引用，它的初始位置是在第一个元素之前 next()：方法是，先将指针后移一位，再返回当前指针指向的元素，(即返回下一个元素) 由于游标初始值在第一个元素之前，因此next()可等价为返回当前位置的元素 若next调用超出数据的边界，会报NoSuchElementException异常。 hashNext()：该方法用于提供遍历数据边界检查的函数，若下一个元素存在则返回true，不对指向进行操作 因此next和hashNext方法的结合就如同数组遍历中的for(;i &lt; arr.length;i++) 示例代码1234567891011121314@Testpublic void test1()&#123; Collection&lt;Object&gt; coll = new ArrayList&lt;&gt;(); coll.add(new String(&quot;str123&quot;)); coll.add(123); coll.add(&quot;str&quot;); //迭代器方式遍历 Iterator&lt;Object&gt; iterator = coll.iterator(); while(iterator.hasNext())&#123; Object obj = iterator.next(); System.out.print(obj + &quot; , &quot;);//str123 , 123 , str , &#125;&#125; 错误示例 错误迭代器示例代码1：null判断无效，及重复调用next null判断无效：是先指针下移，再取值，因此下移后发现没有数据是先抛NoSuchElementException异常，因此null判断无效 重复调用next：每一次遍历进行了两次指针移动和数据获取，即跳着遍历 1234//错误代码while(iterator.next() != null)&#123; System.out.println(iterator.next());&#125; 错误迭代器示例代码2：匿名迭代器错误遍历 匿名迭代器：由于迭代器每次新创建时，游标都是默认第一个元素之前，因此无论怎么遍历都是第一个元素，死循环 1234//错误代码while(coll.iterator().hasNext())&#123; System.out.print(coll.iterator().next());&#125; 增强for循环原理 JDK 5.0新增了一个增强for循环，底层用迭代器底层实现，可用于遍历集合、数组 格式：for(集合元素的类型 局部变量 : 集合对象)&#123;&#125; 执行原理： 先从集合对象中取出一个元素 把取出的元素赋值给局部变量 循环体中使用局部变量 注意：局部变量原理！！！ 基本数据类型：只能获取不能修改(赋值操作) 引用数据类型：不能修改引用本身(赋值操作)，只能修改引用指向的内容 原理还是无返回值函数方法调用原理，即内核原理是局部变量原理 示例代码 示例代码 1234567891011@Testpublic void test1()&#123; Collection&lt;Object&gt; coll = new ArrayList&lt;&gt;(); coll.add(new String(&quot;str123&quot;)); coll.add(123); coll.add(&quot;str&quot;); for (Object obj : coll)&#123; System.out.print(obj + &quot; ,&quot;);//str123 ,123 ,str &#125;&#125; remove Iterator接口还定义了default类型的remove方法，可删除当前游标的集合中的元素。 不能在游标起始位置或同一个游标位置已经进行了两次的remove操作，否则报IllegalStateException异常。 123456789101112131415161718192021@Testpublic void test1()&#123; Collection&lt;Object&gt; coll = new ArrayList&lt;&gt;(); coll.add(new String(&quot;str123&quot;)); coll.add(123); coll.add(&quot;str&quot;); Iterator&lt;Object&gt; iterator = coll.iterator(); while (iterator.hasNext())&#123; Object obj = iterator.next(); if(&quot;str123&quot;.equals(obj))&#123; iterator.remove(); &#125; &#125; //注意此时迭代器iterator的游标已在末尾，若想重新遍历应获取新的iterator iterator = coll.iterator(); while (iterator.hasNext())&#123; System.out.print(iterator.next() + &quot; , &quot;);//123 , str &#125;&#125; Iterable Collection还继承了一个Iterable父接口 API Method Descriptions default void forEach(Consumer&lt;? super T&gt; action) 对Iterable的每个元素执行给定的操作，直到所有元素都被处理或动作引发异常。 Iterator&lt;T&gt; iterator() 返回类型为 T元素的迭代器。 default Spliterator&lt;T&gt; spliterator() 在Iterable描述的元素上创建一个Iterable 。 forEach遍历 forEach方法遍历集合 123456789@Testpublic void test1()&#123; Collection&lt;Object&gt; coll = new ArrayList&lt;&gt;(); coll.add(new String(&quot;str123&quot;)); coll.add(123); coll.add(&quot;str&quot;); coll.forEach(System.out::println);//Consumer接口,可以使用方法引入代替,JDK8新特性&#125; List API体系 概述基本概念 List译为“线性表”，指有序、可重复的集合， List也称为”动态数组“，因为List与数组的表面特性区别就只有动态的可扩展性 实现类概述 List常用实现类：ArrayList、LinkedList、Vector 继承体系 以ArrayList继承实现关系为例： 1234|--java.lang.Object |----java.util.AbstractCollection&lt;E&gt;//实现Collection接口，并重写toString方法|------java.util.AbstractList&lt;E&gt;|---------java.util.ArrayList&lt;E&gt;//实现Lsit接口 其中：AbstractCollection重写了toString()方法，使其直接打印除集合中元素(迭代器) 实现类比较 相同点：都实现了List接口存储特点相同，有序，可重复 不同点： 指标\\实现类 ArrayList LinkedList TreeSet 背景 JDK 1.2，List主要实现类 JDK 1.2 JDK 1.0 ，已弃用实现类 底层实现 Object数组 双向链表 Object数组 线程安全 线程不安全 线程不安全 线程安全 效率 高 高 低 使用场景 多数存储与查询操作 频繁修改操作 线程安全 API体系结构 List接口继承于Collection接口，默认包含Collection接口定义的所有抽象方法(默认方法) 注意：子接口List即使继承Collection接口，也几乎把父类的抽象方法重写了一遍(除若干个default方法外) 由于List也是接口，接口继承接口，重写父接口的抽象方法还是抽象方法，即相当于重定义了一遍Collection接口的抽象方法而已，并没有做出实质编码。 为什么List接口要将从Collection父接口继承下来的抽象方法在”白重写“一遍呢？ List接口”白重写“Collection父接口的方法是”在于意，而不在于形！“ 如Collection以集合角度定义的抽象方法add(E e)，的API含义并没有什么其他说明，就是”把一个元素加入到集合中“而已，没强调顺序、也没强调是否可重复。 但在List中，基于List独有的存储特性，同样一个add(E e)方法，意义确是”将元素顺序添加到有序集合中“，且允许元素重复。 因此表面上是同一个接口中的抽象方法，但从设计上已经不是同一个层面的意义了。 也有可能是自己 一时猜想，毕竟Collection接口定义的方法已经足够抽象化、兼容化了。除了add(E e)方法，其他方法的含义均通用于任何类型的集合。 API文档 新增方法： 带索引操作方法 排序方法sort，(非Object类型才可排序，即排序的前提要同一数据类型) 新迭代器方法 部分重写父接口 索引要求 索引从0开始 索引合法值：0 &lt;= index &lt;= size-1 凡是带索引值方法，都需保证索引合法性，否则报IndexOutOfBoundsException异常 JDK 8.0 - List - API Abstract &amp; Default Method Description Collection abstract methods… 重定义了一遍Collection父接口的抽象方法 void add(int index, E element); 将元素插入此列表中的index位置之前 boolean addAll(int index, Collection&lt;? extends E&gt; c); 将指定集合中的所有元素插入到此列表中的index位置之前 E get(int index); 获取指定index位置的元素，不存在返回 E set(int index, E element); 设置指定index位置的元素为element E remove(int index); 移除指定index位置的元素，并返回此元素 int indexOf(Object obj); 返回obj在集合中首次出现的位置，不存在返回-1 int lastIndexOf(Object obj); 返回obj在当前集合中末次出现的位置，不存在返回-1 List&lt;E&gt; subList(int fromIndex, int toIndex); 返回从[ fromIndex,toIndex )左闭右开位置的子集合 ListIterator&lt;E&gt; listIterator(); 返回列表迭代器 ListIterator&lt;E&gt; listIterator(int index); 返回从指定位置开始的列表迭代器 default void replaceAll(UnaryOperator&lt;E&gt; operator) default void sort(Comparator&lt;? super E&gt; c) 基于Comparator接口实现从小到大排序 @Override default Spliterator&lt;E&gt; spliterator() 小结 增：add(Object obj) 删：remove(int index) / remove(Object obj) 改：set(int index,Object ele) 查：get(int index) 插：add(int index,Object ele) 长度：siez() 遍历：Iterator/增强for循环、listIterator、普通循环(由于含索引方法) remove remove测试代码： 123456789101112@Testpublic void testListRemove() &#123; List list = new ArrayList(); list.add(1); list.add(2); list.add(3); updateList(list); System.out.println(list);//&#125;private static void updateList(List list) &#123; list.remove(2);&#125; 解释 add只有一个方法add(Object obj)，Object类型需自动装箱成Integer类型传入，其实无关 list.remove(2)，List含两个remove方法，remove(Object obj)与remove(int i)类型 此时传入的2为int类型，应优先匹配remove(int i)，方法因此操作的是索引而不是类型 答案：12 若此时想删除对象为2的元素，则应list.remove(new Integer(2));调用 ArrayList ArrayList：List主要实现类、基于Object数组实现、线程不安全，效率高 ArrayList底层实现，JDK7.0和JDK8.0并不一致，因此需区分说明，先以JDK 7.0底层实现说起 API ArrayList的自身独有的API很少且几乎是一些接口default方法的重写，不常用 List接口方法已经囊概ArrayList百分之99的使用场景需要的方法，由此称为List主要实现类 结论：可以通过多态的方式定义ArrayList，从而提高代码的兼容性 List&lt;T&gt; arrayList = new ArrayList&lt;&gt;(); 新增 Method Descriptions void trimToSize() 修改这个ArrayList实例的容量是当前元素数量(手动置满) void ensureCapacity(int minCapacity) 手动请求(拟添加后总量数)，主动扩容 重写default方法迭代器 default void forEach(Consumer&lt;? super T&gt; action)方法 public void forEach(Consumer&lt;? super E&gt; action) default void forEachRemaining(Consumer&lt;? super E&gt; action) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) List default Spliterator&lt;E&gt; spliterator() public Spliterator&lt;E&gt; spliterator() default void replaceAll(UnaryOperator&lt;E&gt; operator) public void replaceAll(UnaryOperator&lt;E&gt; operator) default void sort(Comparator&lt;? super E&gt; c) public void sort(Comparator&lt;? super E&gt; c) Collection default boolean removeIf(Predicate&lt;? super E&gt; filter) public boolean removeIf(Predicate&lt;? super E&gt; filter) JDK7源码分析 jdk1.7 ArrayList源码 属性 private transient Object[] elementData：ArrayList集合存储元素的底层Objcet数组 private int size：记录集合中实际存储的元素个数 ArrayList.java 123456public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; private transient Object[] elementData; private int size;&#125; 构造器ArrayList(); 空参构造器申请容量默认为：10 this(10)，调用ArrayList(int initialCapacity)构造器实现 new ArrayList()源码 123public ArrayList() &#123; this(10);&#125; ArrayList(int initialCapacity) initialCapacity参数为传入的自定义初始化容量值 initialCapacity &lt; 0 非法输入抛出异常 否则直接创建initialCapacity长度的Object类型数组，返回其引用给elementData new ArrayList(int initialCapacity) 1234567public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); this.elementData = new Object[initialCapacity];&#125; 方法add(E e) 先确认当前容量是否足够，调用ensureCapacityI(size + 1)方法检测 将元素通过元素数量size作为数组下标索引的方式添加到elementData数组中 源码类似与StringBuffer/StringBuilder的源码逻辑 add(E e) 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; ensureCapacityInternal(int minCapacity) modCount++，用于”快速失败机制“，暂且忽略 判断是否需要调用grow(int minCapacity)方法进行扩容 ensureCapacityInternal(int minCapacity) 123456private void ensureCapacityInternal(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; grow(int minCapacity) 将旧数组容量，扩容至原来的1.5倍 == 旧容量 + 旧容量/2(右移1位) 若还不够，则使用当前需求的容量为最终容量 若还不够，则直接扩容至MAX_ARRAY_SIZE的容量(Integer.MAX_VALUE - 8) 若还不够，则直接调用hugeCapacity方法获取最大扩容量 通过调用Arrays.copyOf(T [] t，newLength)，将原有数据复制到长度为扩容容量的新数组中 数学上几倍就是乘以几，一倍乘1，二倍乘2。一倍和两倍结果是有区别的 口语是没有太多规范的，1倍也是2倍，但准确应该是，什么比什么多倍倍 == 什么的2倍 grow(int minCapacity) 1234567891011private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; hugeCapacity(int minCapacity) 若传入容量为负数，则表示已经出现Integer类型溢出异常(可能存在由多线程操作导致，否则单线程代码不可能出现这样的问题)，报出OutOfMemoryError异常。 若传入容量为正数 &lt; MAX_ARRAY_SIZE返回MAX_ARRAY_SIZE作为最终扩容量，否则以Integer.MAX_VALUE，为最终扩容量。 hugeCapacity(int minCapacity) 1234567private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; JDK8源码分析属性JDK8中的ArrayList属性在JDK7的基础上增加了三个全局静态常量属性 static final int DEFAULT_CAPACITY = 10：默认的容量常量 static final Object[] EMPTY_ELEMENTDATA = {}：实例化了一个长度为0的全局静态EMPTY_ELEMENTDATA数组 static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}：实例化了一个长度为0的全局静态DEFAULTCAPACITY_EMPTY_ELEMENTDATA数组 transient Object[] elementData：ArrayList集合存储元素的底层Objcet数组 int size：记录集合中实际存储的元素个数 ArrayList.java 12345678910111213141516public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; private static final int DEFAULT_CAPACITY = 10; private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; transient Object[] elementData; // non-private to simplify nested class access private int size; //......&#125; 构造器ArrayList() 调用空参构造器，直接返回了全局静态常量的DEFAULTCAPACITY_EMPTY_ELEMENTDATA数组的引用 DEFAULTCAPACITY_EMPTY_ELEMENTDATA使一个长度为0的Object数组的引用 new ArrayList() 123public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 方法add(E e) 同jdk7.0的ArrayList源码的add(E e)方法调用逻辑 ensureCapacityInternal(int minCapacity) 初始状体处理：若当前elementData的引用还是初始状态的引用则取拟申请总容量数和默认容量数(10)最大值 若符合这个初始化状态进一步调用ensureExplicitCapacity方法时肯定需要扩容 因为初始状体的容量就是0，那怕添加一个元素，都需要进入grow函数进行扩容 即首次添加就需要调用扩容函数，扩容至DEFAULT_CAPACITY = 10的长度 扩容判断：调用ensureExplicitCapacity()，确定当前总数据申请量是否需要扩容 ensureCapacityInternal(int minCapacity) 1234567private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125; grow(int minCapacity) 代码逻辑和JDK 7.0一致 初始状态调用grow时，由于oldCapacity为0，第一次拟扩容量newCapacity也为0 因此最终初始状态的扩容直接拿minCapacity作为扩容量，即DEFAULT_CAPACITY的值=10 源码分析小结源码对比 指标\\ArrayList JDK1.7/7源码 JDK1.8/8 new ArrayList() 实例化并创建容量为10的Object[]数组 仅实例化(长度为0) 初始化时机 new ArrayList()时已经初始化容量为10 首次进行add方法调用：添加数据量L &lt; 10：扩容至 **10**添加数据量L &gt; 10：扩容至 L add方法扩容 尝试扩容为原来的容量的，1.5倍 不够，扩容至需求数据容量数(装满)不够，扩容至MAX_ARRAY_SIZE 不够，扩容至Integer.MAX_VALUE 不够，OutOfMemoryError异常 同JDK1.7/7扩容机制 小结 类似单例的饿汉式在调用空参构造器时候已初始化对比JDK8.0方式，一定程度上浪费内存 类似单例的懒汉式在首次进行添加操作时才初始化延迟了数组创建时间，节省了内存 指导意义 无论是哪个版本的ArrayList，底层原理(数组)和扩容机制与StirngBuilder/StringBuffer类似。 其指导意义在于，开发中尽量让其少扩容。 建议开发中预先估计业务中需要的存储的对象数量 初始化定义时使用带参的构造器：ArrayList list = new ArrayList(int capacity)，使其开发中尽量减少扩容的次数。 LinkedList LinkedList：基于链式存储结构，双向链表实现、线程不安全，对于频繁修改操作效率高 LinkedList的源码比较稳定，一直没有改变，因此以JDK 8.0版本为基准说明 API LinkedList独特的API部分并不像ArrayList的API那样”没用” LinkedList有很多实用的新增API，若当需要实用这些新增API时，则不能以多态方式创建LinkedList。而是通过对象实例直接创建LinkedList实例，依次获得LinkedList独有的API 直接创建/获取更多方法：LinkedList&lt;T&gt; linkedList = new LinkedList&lt;&gt;(); 同理，当开发中用不到这些新增API时，也应像ArrayList一样，为提高代码兼容性而使用多态方式实例化 多态方式/提高兼容性：List linkedList = new LinkedList&lt;&gt;(); 新增的首尾操作-API Method Descriptions void addFirst(Object obj) 把obj元素添加到列表的首部 void addLast(Object obj) 把obj元素添加到列表的末尾 Object getFirst() 获取列表首位置元素 Object getLast() 获取列表末尾元素 Object removeFirst() 删除列表首位置元素 Object removeLast() 删除列表末尾元素 源码分析属性 int size = 0：记录当前元素的个数 Node&lt;E&gt; first：双向链表的头指针 Node&lt;E&gt; last：双向链表的尾指针 static class Node&lt;E&gt;：内部类Note，由于只有LinkedList使用，因此定义为内部类 LinkedList.java 12345678910111213public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; transient int size = 0; transient Node&lt;E&gt; first; transient Node&lt;E&gt; last; private static class Node&lt;E&gt; &#123;/*...*/&#125; //....&#125; Node 链表是有每一个Node存储单位通过引用链接起来的数据结构 双向链表的Node结构定义如下 1234567891011private static class Node&lt;E&gt; &#123; E item;//数据域 Node&lt;E&gt; next;//前指指针域， Node&lt;E&gt; prev;//后指指针域 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 构造器LinkedList() 空操作，仅代表创建了LinkedList实例 first和last引用初始化值均为null LinkedList 12public LinkedList() &#123;&#125; 方法add(E e) 调用linkLast方法， 直接返回true linkLast(E e) 原理是数据结构中双向链表采取了尾插法 创建新的Note结点，传入前置指针为当前的last引用，后置指针为null last引用等于null，则为当前链表为空情况，直接把新节点(第一个结点)赋值为first引用 否则常规尾插法操作 linkLst(E e)源代码 1234567891011void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; Vector Vector：基于顺序存储结构实现，即Object[]数组实现、线程安全，但效率低 API相关 Vector的源码比较稳定，一直没有改变，因此以JDK 8.0版本为基准说明 Vector源码的扩容机制与ArrayList扩容机制不同 注意：Vector已经是一个倍被官方弃用，套题的类。如今保留它只是为了兼容性问题。集合List框架中也不会因为Vector具有线程安全特性而独树一帜。现如今想获取线程安全的List实现类，只需要调用Collections的synchronizedList方法，将线程不安全的List实现类传入，返回的便是一个线程安全的List实现类。因此Vector纯属一个被淘汰的类。 API由于Vector已经是一个倍被官方弃用，因此不研究Vector的API。 源码分析 Vector代码逻辑如JDK 7.0的ArrayList，饿汉式容量创建 Vector源码的扩容机制与ArrayList扩容机制不同 Vector首次拟扩容量为，扩容至原来的1倍，即乘2 后续扩容机制同ArrayList扩容机制 其次Vector大部分操作的方法都使用了synchronized修饰为同步方法，因此线程安全。 Stack Vector还有一个子类，Stack栈 实际开发 List接口API，可作为所有List实现类的，顶层API参照结构 首先List接口继承与Collection父接口，并重定义了所有Collection方法。 虽然常用的List实现类并不是直接实现List接口，如下所示。但最终都间接地实现了List接口 ArrayList—继承—&gt;AbstractList(实现List)—继承—&gt;AbstractCollection(实现Collection) ArrayList再定义的API极少使用，因此开发常以多态方式实例化 常以多态方式实例化：List&lt;T&gt; arrayList = new ArrayList&lt;&gt;(); LinkedList若需使用特有的API方法(首尾操作)，则直接实例化，否则也建议使用多态方式实例化 使用特有API：LinkedList&lt;T&gt; linkedList = new LinkedList&lt;&gt;(); 不使用特有API：List linkedList = new LinkedList&lt;&gt;(); 以接口多态的方式实例化对象的好处：提高代码兼容性 因为对于一个声明List接口的方法形参，即可传入ArrayList，也可传入LinkedList实现。 Set API体系 概述基本概念 Set接口：译为“集合”，指无序、不可重复的集合 特性解析不可重复性原理 除去哈希表本身的综合性能而言，若想通过线性表(顺序表或链表)，如何保证添加元素的唯一性？ 唯一的实现方式：每添加一个元素都需要和当前集合中的所有元素对比一次。 因此线性表这种存储结构实现这样的功能的效率是非常低的。 哈希表这样的存储结构，对于实现唯一性的功能，天然有着更高效率的处理方式 我也不确定哈希表的发明是基于更理想的查找速度，还是更高效率地实现唯一性的功能而诞生的 tips：以下查找过程是基础定义式哈希表的查找过程。实际HashSet即底层HashMap有两层冲突判断 以HashSet为例，如何保证添加的元素不可重复？ 哈希值： Object中，hashCode()默认返回的是对象存储的地址 HashSet中将hashCode()重写了，返回的哈希值是以该对象所有属性值计算的 此时若所有属性都一样，哈希值也肯定是一样，但由于计算哈希值的散列函数的特性，极少机率会出现不同两个对象，计算出的哈希值也一样的现象，这种现象称为冲突，或者碰撞。存储时就会产生堆积现象。 但是注意，这种生成哈希值的散列函数本身存在的冲突现象不是一般数据结构讲的散列查找技术中的冲突现象，这种是数学上的冲突，而数据结构中冲突是转化为数组下标时存在的冲突。可以说是两种独立的冲突。 以哈希值作为存储元素的数组的下标值。 添加一个新元素之前，先计算该元素的hash值，后分两步判断是否重复元素 定位到该hash的存储位置，若该位置没有数据，则肯定不存在重复，直接存储即可 若hash值定位的位置存在数据，也不能立即证明元素重复了(存在冲突现象)，此时需调用equals方法判断两者是否为同一元素，若都不同则存储( 将同义词记录，存储在开散列表中，当然若开散列表中也有逐一对比 )，若相同的则为重复元素，不添加。 判断依据 HashSet &amp; LinkedHashSet：重写hashCode()和equals()方法 若都不重写，默认Object，hashCode打印地址值，equals比较地址值 TreeSet：由于存储结构不一样，TreeSet判别标准是实现Comparable或Comparator接口 示例代码 HashSet存储逻辑终极测试经典题 123456789101112131415161718@Testpublic void test()&#123; HashSet set = new HashSet(); Person p1 = new Person(1001,&quot;AA&quot;); Person p2 = new Person(1002,&quot;BB&quot;); set.add(p1); set.add(p2); p1.name = &quot;CC&quot;; set.remove(p1); System.out.println(set); set.add(new Person(1001,&quot;CC&quot;)); System.out.println(set); set.add(new Person(1001,&quot;AA&quot;)); System.out.println(set);&#125; 计算的hash值和修改后在计算出的hash值已经不一样了 hash值就算一样了，equals方法有不一样了 答案： 1001,”CC”、1002,”BB” (hash值不一样) 1001,”CC”、1002,”BB”、1001,”CC” (hash值不一样) 1001,”CC”、1002,”BB”、1001,”CC”、1001,”AA” (equals不一样) 无序性 无序性可以说是因为不可重复性使用的数据结构而导致的一种无序性。 即无序性强调存储的无序性，即并非根据索引下标顺序存储的，而是根据哈希表存储的 无序性不等于随机性。 hashCode重写重写 hashCode() 方法的基本原则：”相等的对象(equals)必须具有相等的散列码！“ 在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值。 当两个对象的 equals() 方法比较返回 true 时，这两个对象的hashCode()方法的返回值也应相等。 对象中用作 equals() 方法比较的 Field，都应该参与hashCode值的计算 扩展：数字31，Eclipse/IDEA为例，在自定义类中可以调用工具自动重写equals和hashCode。 问题：为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？ 选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的 “冲突”就越少，查找起来效率也会提高。（减少冲突） 并且31只占用5bit，相乘造成数据溢出的概率较小。 31可以 由i*31== (i&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化，可移位操作得出的数据效率高。(且重要还是一个最小的素数) 31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结 果只能被素数本身和被乘数还有1来整除！(减少冲突) 结论以HashSet为例，使用Set集合的实现类 不仅需要重写equals方法，还需要重写hashCode()方法 判断唯一性步骤是，先检查hashCode是否有数据，有再调用equals方法逐一排查 实现类概述实现类：HashSet、LinkedHashSet、TreeSet… API体系 以HashSet继承实现关系为例 12345|--java.lang.Object|----java.util.AbstractCollection&lt;E&gt;//实现Collection，并重写toString方法|------java.util.AbstractSet&lt;E&gt;|--------java.util.HashSet&lt;E&gt;//实现了Set接口|-----------java.util.LinkedHashSet&lt;E&gt;//LinkedHashSet是HashSet的子类 其中：AbstractCollection重写了toString()方法，使其直接打印除集合中元素(迭代器) LinkedHashSet是HashSet的子类 实现类比较 相同点：都实现了Set接口存储特点相同，无序，不可重复 不同点： 指标\\实现类 HashSet LinkedHashSet TreeSet 背景 Set主要实现类 HashSet子类 实现SortedMap 底层实现 哈希表(哈希地址+数组) 带双向索引的哈希表 红黑树 线程安全 线程不安全 线程不安全 线程安全 使用场景 一般场景 频繁的遍历操作 支持自动排序 元素类型 无限制(存储null值) 无限制 仅同一类型 API Set接口继承与Collection父接口 Set接口仅重定义了一遍Collection的所有方法，并没有提供额外的方法，等同于Collection HashSet HashSet：Set主要实现类、基于哈希表实现、 HashSet底层实现，JDK7.0和JDK8.0并不一致，因此需区分说明，先以JDK 7.0底层实现说起 API HashSet也仅间接实现了Set的所有方法，并没有自身的API，因此拥有的方法等同于Collection 源码分析 HashSet底层是用HashMap实现的，因此分析HashSet的源码就是分析HashMap的源码 创建HashSet在底层实际创建了一个HashMap，添加一个元素到HashSet实际添加到了HashMap中 原理 HashSet(LinkedHahsSet)的整个体系都是基于HashMap实现的 HashSet在进行put(E e)操作时实际把想存储的数据作为Key存储到了HashMap中 value总统一指向一个Object静态常量，避免空指针 put(E e) 123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; PRESENT常量 1private static final Object PRESENT = new Object(); LinkedHashSet LinkedHashSet基于LinkedHashMap实现，底层存储同是哈希表(数组)，本质还是存储的无序性。 只是在添加操作时，为每个元素额外添加了双向索引来维护其添加的顺序。 因此LinkedHashSet在遍历时，就可以选择通过索引的方式来遍历，因此能得到添加时顺序 优点：对于频繁得遍历操作，LinkedHashSet效率高于HashSet。(因为不用判断操作，直接索引) API LinkedHashSet仅对HashSet进行了继承操作，本身并没有声明新的方法或重写。因此等价于HashSet的API。 而HashSet又等价与Set，Set又等价与Collection的API 这里引发出一个问题，既然LinkedHashSet仅对HashSet进行了继承操作，并没有进行任何重写操作，那么这个双向索引在什么时候添加上去的？ 源码分析 由于LinkedHashSet底层使基于LinkedHahsMap实现的，LinkedHashMap有继承与HashMap。 TreeSet TreeSet由于有许多自我实现的特点，因此建议和HashSet与LinkedHashSet区分学习。 TreeSet底层是由红黑树实现，最大的特点是支持自动排序。 红黑树是一种自平衡的平衡二叉数，平衡二叉树即最高性能的二叉排序树 因为支持排序，因此TreeSet要求传入的元素必须是同一类型，不同类型元素在添加使其就会报错。 注：实际开发中使用泛型即可避免类型错误 TreeSet&lt;String&gt; treeSet = new TreeSet&lt;&gt;(); 自动排序 TreeSet在添加元素的过程中就会自动给元素进行排序。 因此对于未进行排序接口实现的数据元素，连添加元素操作都无法进行，报出异常。 同Java比较器实现排序原理一致，都需要待排序对象首先实现自然排序或定制排序接口。 示例代码 Person.java：没有进行任何排序接口的实现操作 123456789101112package com.website.tree;public class Person&#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 测试代码：添加自定义类数据元素 1234567891011121314151617package com.website.tree;import org.junit.Test;import java.util.TreeSet;public class TreeSetTest &#123; @Test public void test1()&#123; TreeSet&lt;Person&gt; treeSet = new TreeSet&lt;&gt;(); treeSet.add(new Person(&quot;Priscilla&quot;,18)); treeSet.add(new Person(&quot;Jack&quot;,28)); /* 添加操作都无法进行：报出如下异常 java.lang.ClassCastException: com.website.tree.Person cannot be cast to java.lang.Comparable */ &#125;&#125; 自然排序TressSet自然排序实现步骤： 使用TreeSet空参构造器：TreeSet&lt;T&gt; treeSet = new TreeSet&lt;&gt;(); 数据元素实现Comparable接口 示例代码 Person：实现Comparable接口，重写compareTo()方法 设置比较规则：以name属性从小到大排序 123456789101112131415161718192021222324252627282930313233package com.website.tree;public class Person implements Comparable&lt;Person&gt;&#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public int compareTo(Person o) &#123; return this.getName().compareTo(o.getName()); &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 测试代码 12345678910111213141516171819202122232425package com.website.tree;import org.junit.Test;import java.util.Iterator;import java.util.TreeSet;public class TreeSetTest &#123; @Test public void test1()&#123; TreeSet&lt;Person&gt; treeSet = new TreeSet&lt;&gt;(); treeSet.add(new Person(&quot;Priscilla&quot;,18)); treeSet.add(new Person(&quot;Jack&quot;,28)); treeSet.add(new Person(&quot;Acer&quot;,33)); Iterator&lt;Person&gt; iterator = treeSet.iterator(); while(iterator.hasNext())&#123; System.out.print(iterator.next()); &#125; //遍历结果 //Person&#123;name=&#x27;Acer&#x27;, age=33&#125; //Person&#123;name=&#x27;Jack&#x27;, age=28&#125; //Person&#123;name=&#x27;Priscilla&#x27;, age=18&#125; &#125;&#125; 不可重复性判断 TreeSet判断两个元素是否相同的依据：是自然排序的compareTo()方法，不是equals和hashCode 测试代码1： 以上述”自然排序“规则的Person类为基础，进行如下元素添加 排序规则：以name属性从小到大排序 由于排序规则只涉及name属性，因此age属性的差异不作为元素相同判断标准。 1234567891011121314151617181920212223242526272829package com.website.tree;import org.junit.Test;import java.util.Iterator;import java.util.TreeSet;public class TreeSetTest &#123; @Test public void test1()&#123; TreeSet&lt;Person&gt; treeSet = new TreeSet&lt;&gt;(); treeSet.add(new Person(&quot;Priscilla&quot;,18)); treeSet.add(new Person(&quot;Jack&quot;,28)); treeSet.add(new Person(&quot;Acer&quot;,33)); //再添加一个name相同age不同的元素 treeSet.add(new Person(&quot;Acer&quot;,20));//未能被添加进TreeSet集合中 System.out.println(&quot;size = &quot; + treeSet.size());//3 Iterator&lt;Person&gt; iterator = treeSet.iterator(); while(iterator.hasNext())&#123; System.out.print(iterator.next()); &#125; //遍历结果 //Person&#123;name=&#x27;Acer&#x27;, age=33&#125; //Person&#123;name=&#x27;Jack&#x27;, age=28&#125; //Person&#123;name=&#x27;Priscilla&#x27;, age=18&#125; &#125;&#125; 测试代码2： 使new Person(&quot;Acer&quot;,20);元素添加进去，则需把age属性也参与compareTo()中 修改compareTo()方法：使其name属性相同时，以age从小到大排序 123456789@Overridepublic int compareTo(Person o) &#123; int result = this.getName().compareTo(o.getName()); if(result == 0)&#123;//二级排序条件 return Integer.compare(this.getAge(),o.getAge());//age从小到大 &#125;else&#123; return result; &#125;&#125; 打印结果 123454Person&#123;name&#x3D;&#39;Acer&#39;, age&#x3D;20&#125;Person&#123;name&#x3D;&#39;Acer&#39;, age&#x3D;33&#125;Person&#123;name&#x3D;&#39;Jack&#39;, age&#x3D;28&#125;Person&#123;name&#x3D;&#39;Priscilla&#39;, age&#x3D;18&#125; 定制排序TressSet定制排序实现步骤： 创建实现Comparator接口的实现类，作为参数传入TreeSet构造器中 使用TreeSet带Comparator参数构造器：new TreeSet(Comparator&lt;? super E&gt; comparator); 示例代码 Person：不实现任何比较器接口 12345678910111213141516171819202122232425262728package com.website.tree;public class Person&#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 采用定制化比较器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.website.tree;import org.junit.Test;import java.util.Comparator;import java.util.Iterator;import java.util.TreeSet;public class TreeSetTest &#123; @Test public void test1()&#123; //定制排序，比较器(采用匿名方式创建实现类对象) Comparator comparator = new Comparator&lt;Person&gt;() &#123; @Override public int compare(Person o1, Person o2) &#123; int result = -(o1.getName().compareTo(o2.getName()));//取反，逆序 if(result == 0)&#123;//二级排序条件 return Integer.compare(o1.getAge(),o2.getAge()); &#125;else&#123; return result; &#125; &#125; &#125; //定制化排序，在构造器中传入比较器接口 TreeSet&lt;Person&gt; treeSet = new TreeSet&lt;&gt;(comparator); treeSet.add(new Person(&quot;Priscilla&quot;,18)); treeSet.add(new Person(&quot;Jack&quot;,28)); treeSet.add(new Person(&quot;Acer&quot;,33)); treeSet.add(new Person(&quot;Acer&quot;,20));//再添加一个name相同age不同的元素 System.out.println(&quot;size = &quot; + treeSet.size());//4 Iterator&lt;Person&gt; iterator = treeSet.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; //遍历结果 //size = 4 //Person&#123;name=&#x27;Priscilla&#x27;, age=18&#125; //Person&#123;name=&#x27;Jack&#x27;, age=28&#125; //Person&#123;name=&#x27;Acer&#x27;, age=20&#125; //Person&#123;name=&#x27;Acer&#x27;, age=33&#125; &#125;&#125; 不可重复性判断 此时TreeSet判断两个元素是否相同的依据：是定制排序的compare()方法 API源码分析 TreeSet底层实现也是TreeMap Map API体系 概述基本概念 Map接口，是和Collection并列的接口 Map也译为“映射”，双列数据，保存具有映射关系“key-value对”的集合，同数学函数 y=f(x) x自变量相当于key，y因变量相当于value Map中的key是不可重复的，value可重复 实现类概述API体系 以HashMap继承实现关系为例 1234|--java.lang.Object |-----java.util.AbstractMap&lt;K,V&gt; |--------java.util.HashMap&lt;K,V&gt;//实现Map|-----------java.util.LinkedHashMap 实现类比较 相同点：都实现了Map接口存储特点相同，有序，可重复 不同点： 指标\\实现类 HashMap LinkedHashMap TreeMap Hahstable 背景 Map主要实现类 HashMap子类 实现SortedMap 已弃用 底层实现 jdk7：哈希表(哈希地址+数组)jdk8：哈希表 + 红黑树 带双向索引的哈希表(同理jdk7，8不一样) 红黑树 哈希表 线程安全 线程不安全 线程不安全 线程不安全 线程安全 效率 高 高 高 低 使用场景 一般场景 频繁遍历操作 支持排序(key) 线程安全 元素类型 可存储null值(key与value) 不可存储null值 其他实现类补充 Properties Properties：Properties是Hashtable的子类，常用于处理属性(配置)文件 Properties的key和value都是String类型 CurrentHashMap：高并发场景使用 API Map接口是和Collection接口并列的独立的两个接口 JDK 1.8 - MAP Map使用需要重写hashCode和equals方法，详情查看“Map存储原理” 增删改 AbstractMethod Descriptions V put(K key,V value) 将指定key-value添加到(或修改)当前map对象中，返回旧value指 void putAll(Map m) 将m中的所有key-value对存放到当前map中 V remove(Object key) 移除指定key的key-value对，并返回value void clear() 清空当前map中的所有数据 元素查询 AbstractMethod Descriptions V get(Object key) 获取指定key对应的value boolean containsKey(Object key) 是否包含指定的key boolean containsValue(Object value) 是否包含指定的value int size() 返回map中key-value对的个数 boolean isEmpty() 判断当前map是否为空 boolean equals(Object obj) 判断当前map和参数对象obj是否相等 元视图操作 AbstractMethod Descriptions Set&lt;K&gt; keySet() 返回所有key构成的Set集合，遍历key Collection&lt;V&gt; values() 返回所有value构成的Collection集合，遍历values Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回所有key-value对构成的Set集合，遍历key-value(entry) 在hashmap中add添加相同得key起到修改功能Map存储原理 遍历 Map中的遍历操作使用元视图API实现，调用任意一个方法都可以返回一个Collection或其子接口Set 只要是Collection，遍历就可以使用：迭代器(增强for循环) 遍历key Set&lt;K&gt; keySet() 123456789101112131415161718192021222324252627282930package com.website.map;import java.util.*;/** * @author yhd * @create 2021-06-12 11:17 */public class MapTest &#123; public static void main(String[] args) &#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;ABC&quot;,23); map.put(&quot;DE&quot;,new Double(3.2)); map.put(&quot;SDSD&quot;,&quot;SD&quot;); //方式1：原生迭代器 Set&lt;String&gt; keys = map.keySet(); Iterator&lt;String&gt; iterator = keys.iterator(); while(iterator.hasNext())&#123; System.out.print(iterator.next() + &quot; , &quot;); &#125; System.out.println(); //方式2：增强for循环迭代器 for(String key : map.keySet())&#123; System.out.print(key + &quot; , &quot;); &#125; &#125;&#125; 遍历value Collection&lt;V&gt; values() 123456789101112131415161718192021222324252627282930313233package com.website.map;import java.util.Collection;import java.util.HashMap;import java.util.Iterator;import java.util.Map;/** * @author yhd * @create 2021-06-12 11:17 */public class MapTest &#123; public static void main(String[] args) &#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;ABC&quot;,23); map.put(&quot;DE&quot;,new Double(3.2)); map.put(&quot;SDSD&quot;,&quot;SD&quot;); //方式1：原生迭代器 Collection&lt;Object&gt; values = map.values(); Iterator&lt;Object&gt; iterator = values.iterator(); while(iterator.hasNext())&#123; System.out.print(iterator.next() + &quot; , &quot;); &#125; System.out.println(); //方式2：增强for循环迭代器 for(Object obj : map.values())&#123; System.out.print(obj + &quot; , &quot;); &#125; &#125;&#125; 注：values()返回的Collection接口实现类是java.util.HashMap$Values ，也是无序的，不能强转为List或Set这些子接口，不是一个体系。不能看到Collection就以为可以强转。 测试代码 123456789101112131415@Testpublic void test()&#123; Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;abc&quot;,123); map.put(&quot;cde&quot;,112323); map.put(&quot;afasf&quot;,323); Collection&lt;Integer&gt; values = map.values(); //java.util.HashMap$Values System.out.println(&quot;values.getClass() = &quot; + values.getClass()); List list = (List) values;//报异常：java.lang.ClassCastException: // java.util.HashMap$Values cannot be cast to java.util.List&#125; 遍历Entry Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 123456789101112131415161718192021222324252627282930313233package com.website.map;import java.util.*;/** * @author yhd * @create 2021-06-12 11:17 */public class MapTest &#123; public static void main(String[] args) &#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;ABC&quot;,23); map.put(&quot;DE&quot;,new Double(3.2)); map.put(&quot;SDSD&quot;,&quot;SD&quot;); //方式1：原生迭代器 Set&lt;Map.Entry&lt;String, Object&gt;&gt; entries = map.entrySet(); Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iterator = entries.iterator(); while(iterator.hasNext())&#123; Map.Entry&lt;String, Object&gt; entry = iterator.next(); System.out.print(entry.getKey() + &quot; : &quot;); System.out.print(entry.getValue() + &quot; , &quot;); &#125; System.out.println(); //方式2：增强for循环迭代器 for(Map.Entry&lt;String, Object&gt; entry : map.entrySet())&#123; System.out.print(entry.getKey() + &quot; : &quot;); System.out.print(entry.getValue() + &quot; , &quot;); &#125; &#125;&#125; Map存储原理四元组key-value特性 存储特性 Map中每一个key对应一个value，可以创建一个数据结构将key与value进行绑定 JDK1.7中每个Map元素用一个Entry结构存储，JDK1.8中声明为Node，但功能一样 由于Map中的key是不可重复的，value是可重复，而且两者都是无序的 因此每一个Entry结构表现出来是不可重复、且无序的 数据结构 存储特性数据结构 不可重复性：解决存储不可重复元素的存储的数据结构优先哈希表结构，再采用拉链法解决冲突。 hash：存储用于指定存储数组索引的哈希值 next：用于通过拉链法解决冲突问题时形成链表结构 无序性：哈希表存储数据本身就是无序性 非存储特性数据结构 T key：存储key值本身 T value：存储key值对应的数据本身 小结：通过哈希表，拉链法解决冲突的HashMap，每一个数据结点Entry需4个属性，hash、nextkey、value。 这正是JDK1.7之前HashMap的存储原理，示意图如下 Entry源代码 Entry部分源代码 1234567891011121314151617static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; //.......忽略&#125; JDK1.8版本 相较于jdk1.7版本的HashMap使用的数据结构，jdk1.8新加入红黑树优化开散列表的查询效率 当数组的开散列表元素个数 &gt; 8，且数组长度 &gt; 64时，将此时的开散列表转为红黑树存储 唯一影响哈希表查询效率的就是冲突现象引发的数据堆积现象 一旦出现冲突，无论是开闭散列表都将退化为线性的顺序查找O(n) 由于红黑树在查找效率要比线性表查找效率高，因此当堆积现象频繁出现时，将其转存为红黑树结构能很大程度上减缓查询效率的减低。 可以说哈希表存储(拉链法)和红黑树是绝配 除加入红黑树外，Entry结点名改为Node，但属性数量和意义与1.7版本一致 jdk1.8版HashMap存储结构示意图： HashMap查找过程基本概念 哈希值： Object中，hashCode()默认返回的是对象存储的地址 HashSet中将hashCode()重写了，返回的哈希值是**以该对象所有属性值计算的 此时若所有属性都一样，哈希值也肯定是一样，但由于计算哈希值的散列函数的特性，极少机率会出现不同两个对象，计算出的哈希值也一样的现象，这种现象称为冲突，或者碰撞。存储时就会产生堆积现象 散列表查找技术以哈希值作为存储元素的数组的下标值，不发生冲突时候查找效率为O(1) 查找过程以jdk1.7，纯哈希表(拉链法解决冲突)为例： 添加一个新元素之前，先计算key对象的hash值 将hash值再经过indexFor计算后，得出一个散列表数组得下标值 注意这里有个关键的点，hash值—indexFor算法—&gt;下标值，这个过程中也会引发出新的一种冲突 即存在两个不同的hash值计算出同一个下标值 如两个不同的对象，计算出两个不同的hash值，300213，311213 这些庞大的hash值是不能够直接作为有限数组下标存储的(如数组初始容量为16) 处理的方式就是将hash值和散列表长度值(16)取模，如 300231 % 16 = [0 ~ 15] 如 源码底层实现这种取模运算更高效的算法就是：hash &amp; (length - 1) 与运算是所有布尔运算中计算机底层效率最高的 此时加上hash值本身存在的冲突，再加上转换为数组下标时存在的冲突，一共有两次冲突可能 通过下标定位到存储位置后，若该位置没有数据，则肯定不存在重复，直接存储Entry即可 若定位有数据，则有存在冲突的可能性，也可能是同一key数据添加而已 若hash值不同则存在数组下标转换冲突 若hash值相同，则判断hash计算冲突 若两者(遍历全部)key的equals不同，则存在hash值计算冲突 若两者(遍历全部)key的equals相同，则不属于冲突情况，属于同一key值被添加了 一直以希望它是重复数据，而不是冲突数据的角度去排除判断的 不可重复性 HahsMap &amp; LinekdHashMap 由于每一个Entry/Node采用了哈希表存储，且Map规定key值是不可重复的。 因此在Map中判断key是否重复的依据是：equals() 和 hashCode() TreeMap HashMapAPI HahsMap几乎增加新的API，如ArrayList一样，几乎完全实现与父接口。 即HashMao是Map接口的主要实现类 因此一般使用多态的方式声明Map&lt;T&gt; map = new HashMap&lt;&gt;(); 扩容指标分析 HashMao底层的散列表也是由数组实现的，集合中涉及数组实现则肯定避免不了扩容机制 但由于哈希表存储与线性表底层的存储结构差异性较大，扩容机制完全不同于上文提及的StringBuffer/StringBuilder、ArrayList这些扩容机制，仅仅大于数组长度时就除法扩容。 首先，哈希表扩容的判断标准就不一样，不像线性表存储，容量为16，当第17个元素到来时即扩容的时机，由于存储数据是无序的，因为存在冲突现象，还设置了开闭散列表。即有可能散列表数组容量是16，可存储的数据不止16。因为有可能部分数据发生了冲突存储在了开散列表中，还会出现散列表中某些位置无论存多少个数据都一直没被使用，甚至出现这个散列表一直没被存满，这些情况都存在的，因此简单以散列表数组长度 &lt; 拟存储数据量，去决定扩容指标是不可取的 首先散列表也是静态数组，容量有限。而由于存储数据是无序的，因此哈希算法尽量使不同的元素计算出的哈希值能均匀地分布在散列表中。因此减少冲突现象发生的机率 但随着数据量的增多，散列表长度不变的情况下，冲突的机率将会越来越大 此时应该设定一个标准(非数组长度)，一旦达到这个标准，就要开始扩充散列表的长度，以此将冲突机率降低下来，达到一个相对稳定的过程。 结论 因此哈希表存储不同于线性表，仅判断大于数组长度就扩容。而是需要通过一定算法计算出一个临界值比例，若比这个临界值大才扩容。 虽说添加数据量不能直接作为哈希表存储结构判断扩容的标准，但添加操作本身肯定是作为任意数据结构判断扩容机制的时机。 而这个标准就是实现中的临界值，而临界值如何计算，如何设计，又是另一个问题了 重要常量与属性 在研究HashMap之前，无论是jdk7还是jdk8版本的源码，具备如下重要常量和属性 全局常量 DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16 MAXIMUM_CAPACITY ： HashMap的最大支持容量，2^30 DEFAULT_LOAD_FACTOR：HashMap的默认加载因子，0.75 TREEIFY_THRESHOLD：开散列表Bucket中链表长度大于该默认值8，转化为红黑树 UNTREEIFY_THRESHOLD：Bucket中红黑树存储的Node小于该默认值，转化为链表 MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量。（当桶中Node的 数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行 resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4 倍。） 重要属性 table：存储元素的底层散列表数组，总是2^n次幂(需匹配哈希值算法) entrySet：存储具体元素的集 size：HashMap中存储的键值对的数量 modCount：HashMap扩容和结构改变的次数。 threshold：扩容的临界值，=容量*填充因子 loadFactor：填充因子 加载因子加载因子又称为负载因子 负载因子的大小决定了HashMap的数据密度。 负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长, 造成查询或插入时的比较次数增多，性能会下降。 负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的 几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。 按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数。 JDK7源码分析 jdk1.7/7 HashMap源码 构造器HashMap() 传入DEFAULT_INITIAL_CAPACITY(默认容量=16)，DEFAULT_LOAD_FACTOR(默认加载因子=0.75) 调用重载构造器HashMap(int initialCapacity, float loadFactor)进一步处理 HashMap() 123public HashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);&#125; HashMap(int initialCapacity, float loadFactor) 前面三个if均是对两个传入参数的合法性检查 初始化状态调用直接到int capacity = 1开始，下述代码是保证传入的初始化容量是2的整数倍 如当传入的initialCapacity==15时，最终capacity将以16的结果退出循环，后续初始化使用的变量是capacity不是传入的initialCapacity 123int capacity = 1;while(capacity &lt; initialCapacity); capacity &lt;&lt; 1; 得到2的整数倍初始化容量capacity后，记录传入的加载因子，并计算出临界值threshold 以capacity(初始状态为16)的大小初始化散列表数组，Entry[capacity] sun.misc.VM.isBooted暂且忽略 init()是一个空方法，给子类LinkedHahsMap重写用的，旨在初始化双向链表 HashMap(int initialCapacity, float loadFactor) 12345678910111213141516171819202122public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); // Find a power of 2 &gt;= initialCapacity int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; this.loadFactor = loadFactor; threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); table = new Entry[capacity]; useAltHashing = sun.misc.VM.isBooted() &amp;&amp; (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD); init();&#125; 方法put(K key, V value)put(K key, V value)方法90%的代码都在过滤真正重复的key(要进行修改value操作)，而不是冲突现象。 null判断，若为null，调用专属的null值存储方法，putForNullKey(忽略) 计算key值得hash值(除调用key对象得hashCode还进行了加工计算) 通过indexFor方法计算出hash值对应的数组下标索引位置 实质是取模运算，通过与运算实现，从哈希值中取数组索引范围的比特位，h &amp; (length -1)，int会转换位二进制位，因此能取到 注意：此时存在两个不同的hash值计算出同一个下标值的转换冲突现象 加上hash值计算本身存在的冲突，再加上转换为数组下标时存在的冲突，一共有两次冲突可能 若此时若下标位置没有元素，e == null，则不存在重复更加不存在冲突，跳出for循环，直接调用addEntry方法 若有元素，则进入if判断，if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) 因为开散列表存在多个元素(链表)，因此需要逐一遍历,即在for循环内，尝试去找到那个真正重复的key而不是冲突造成的key。 首先判断数组下标转换冲突，此时下标值已一致， 若hash值却不一致则存在数组下标转换冲突现象， 如hash值一致，则属于正常现象，理应就是一致的hash值得出一致的数组下标 若不存在数组下标转换冲突，则继续判断hash计算冲突，此时hash值已经一致 若key内容本身不一致，即equals方法，则存在hash计算冲突 若key内容本身一致，则可以确定就是重复的key被添加进来了，新的value值替换原有的value值，并返回旧的value值 其实if一直以希望它是重复数据，不是冲突数据的角度去编写的 像下标相同有数据了，则如果hash值相同则下标相同也正常(希望它是重复数据)， hash值相同了，又希望它key数据本身也相同equals(也希望它是重复数据) 最后，或许跳出for循环的不重复情况，或者不满足if其中一个条件，都肯定存在冲突情况，或者for循环之后也找不到重复数据的冲突情况，这三种情况可归纳成两种：不重复数据现象和冲突现象 最终这两种现象都交给，addEntry函数处理。put(E e)函数旨在找到那个可能重复的key put(K key, V value) 1234567891011121314public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; addEntry(int hash, K key, V value, int bucketIndex)tips：addEntry被调用时存在key还处于不重复数据和冲突数据的两种现象的可能性 虽说添加数据量不能直接作为哈希表存储结构判断扩容的标准，但添加操作本身肯定是作为任意数据结构判断扩容机制的时机。而且该addEntry()90%代码也是扩容机制的判断处理，if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) 进行扩容指标判断：当判断当前数据容量 ≥ 扩容临界值，且添加的数据属于冲突现象的数据，则进行扩容。即使≥扩容临界值，若添加数据不属于重复数据则也不扩容，直接存储在空的索引位置。 调用resize函数，将数组扩容到原来的2倍(table.length * 2)，并将所有元素重新计算下标值并重新存放。包括传入进来的拟添加的元素的下标值 由于addEntry被调用的场景包括，数组下标没有数值(不重复也不冲突)，以及冲突的两种情况， 因此add内部还要把这两种情况判断区分一下 无论扩容与否，数据重复还是数据冲突，最后统一进行createEntry()操作 123456789void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex);&#125; createEntry(int hash, K key, V value, int bucketIndex)tips：addEntry被调用时存在key还处于不重复数据和冲突数据的两种现象的可能性 createEntry主要用于实现真正的数据添加操作，且实现了不重复数据(直接存储)，和冲突数据的统一代码处理化。 统一添加代码原理：博主将这种在哈希表拉链法统一处理不重复数据，及冲突现象数据的添加操作的代码称为为“积木撞击”添加方法 源码分析 先将索引位置原有的数据暂存起来 创建Entry同时设置关键参数next的引用索引位置上原有的值(构成链表) 将新加入的Entry放入索引位置，并将容量参数size自增1 void createEntry(int hash, K key, V value, int bucketIndex) 12345void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125; Entry(int h, K k, V v, Entry&lt;K,V&gt; n) 123456Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h;&#125; JDK8源码分析构造器HashMap 仅初始化了loadFactor(加载因子)的初始化值，并没有调用重载构造器，更没有实例化底层数组 HashMap 123public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125; 方法put(K key, V value) 计算key的hash值并调用putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)方法 传入的末尾两个false和true参数暂且忽略 put(K key, V value) 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)以首次添加的情景引入源码分析 初始化声明底层Node数组引用tab，与Node结点 第一个 if 将table属性(底层数组引用)，赋值给tab引用暂存，并间接判断table是否为null，若部位null随便把当前table的长度计算并返回到具备变量n 若首次添加，table肯定没有进行初始化，则为null，调用resize()方法进行扩容或初始化 第二个 if ，通过hash值计算数组下标并取下标元素为p且判断是否为null，为null不存在重复和冲突直接存储到底层数组 elase：即下标位置有数据，声明一个Node局部变量e，p为数组下标原有数据 第一个 if ：若当前数组下标数据p就是和添加的数据key完全一致，则用e暂存数据下标。 若数组下标第一个数据p不能判断重复，则还需往下找，往下找就有两种情况，开散列表和红黑树 第二个 else if ：若p这个头指针是红黑树 第三个 else：若p这个头指针不属于红黑树类型，则需要进行开散列表的遍历 先看第二个 if ：常规的二重冲突判断找重复数据，若找得到，则从第二个if中break跳出循环，并暂存这个重复key的引用 若第二个if整个遍历过程中都没有break，则会遍历到开散列表的末尾，此时就证明肯定存在冲突了 此时第一个if中的if(e = p.next) == null就会符合要求，把要添加的冲突数据封装成一个新的Node，因为此时p已遍历到末尾是开散列表最后一个元素，通过尾插法的形式把添加的数据添加到末尾。 检测到冲突现象了，还会判断一下是否需要将其开散列表转化为红黑树，即当开散列表的长度 &gt; 8时，(-1 是因为binCount数值关系，实际意义为8)，调用treeifyBin(tab,hash)方法 最后，从上属逻辑中可知e是专门用来暂存重复元素引用的，如果e不为空，则存在重复元素逻辑执行过，则将新的value替换旧的value，并返回旧的value putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) 12345678910111213141516171819202122232425262728293031323334353637383940414243final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; //以下逻辑代码暂且忽略 ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; Node&lt;K,V&gt;[] resize()同样以table底层数组未初始化首次调用resize情景引入 分配为table、threshold属性通过局部变量oldTab、oldThr暂存。并初始化oldCap局部变量 (oldTab = table) == null (oldThr = threshold) == 0 ，threshold在没被初始化 oldCap == 0 初始状态的oldTab、oldThr、oldCap分别为null、0、0，直至最后的else分支，初始化容量和计算临界值 newCap设置为默认初始容量DEFAULT_INITIAL_CAPACITY，16 newThr计算临界值，16 * 默认加载因子(0.75) = 12 若newThr == 0，情况暂时忽略 实例化一个长度为newCap名为newTab的Node[]数组，并将其引用返回给table Node&lt;K,V&gt;[] resize() 12345678910111213141516171819202122232425262728293031323334353637final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; /* 暂且忽略以下代码 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; */&#125; treeifyBin(Node&lt;K,V&gt;[] tab, int hash) if 此时若tab数组不为null而且当前散列表数组长度还小于MIN_TREEIFY_CAPACITY(64)，则调用resize()方法进行扩容操作，而不进行树转化。 else if反之，当散列表数组长度大于MIN_TREEIFY_CAPACITY(64)，则将当前开散列表转化为红黑树存储 treeifyBin(Node&lt;K,V&gt;[] tab, int hash) 1234567891011121314151617181920final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); &#125;&#125; 源码分析小结 HashMap从jdk1.7到1.8的变化类似ArrayList从1.7到1.8的变化，即也是从饿汉式初始化到懒加载。 源码对比 指标\\HashMap JDK1.7/7源码 JDK1.8/8 new HahsMap() 实例化并创建容量为16的Entry[]数组 仅初始化了加载因子threshold 初始化时机 new HashMap()时已经初始化容量为16 首次进行put方法调用：创建长度为16的Node[]数组 put方法扩容 添加数据为冲突现象 &amp;&amp; 开散列表 &gt; 临界值16 * 0.75=12 &amp;&amp;散列表扩容为原来的2倍，即可*2 添加数据为冲突现象 &amp;&amp; 开散列表 &gt; 8 &amp;&amp;if : 散列表数组 &lt; 64，散列表扩容else：将开散列表转存为红黑树 冲突添加数据 头插法 尾插法 小结 类似单例的饿汉式在调用空参构造器时候已初始化对比JDK8.0方式，一定程度上浪费内存 类似单例的懒汉式在首次进行添加操作时才初始化延迟了数组创建时间，节省了内存 将开散列表所有的数据改为红黑树存储，因为红黑树查找效率要比线性表查找效率高 指导意义 懒加载： 红黑树比线性查找牛多了，红黑树简直和哈希表(拉链法)天生一对 位运算指导意义：n % mod == n &amp;(mod -1) 回顾HashSet HashSet(LinkedHahsSet)的整个体系都是基于HashMap实现的 HashSet在进行put(E e)操作时实际把想存储的数据作为Key存储到了HashMap中 value总统一指向一个Object静态常量，避免空指针 put(E e) 123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; PRESENT常量 1private static final Object PRESENT = new Object(); LinkedHashMapAPI 仅对HashMap进行了继承操作，本身并没有声明新的方法或重写。因此等价于Map的API。 源码分析只分析JDK1.8版本 LinkedHashMap完全基于父类实现，只对在HashMap中的某些方法对应需要增加、删除、修改双向链表操作时候进行方法的重写操作 如putVal方法，重写了newNode()方法，使用LinkedHashMap.Entry(继承与HashMap.Node)进行存储。 Entry 在继承与HashMap.Node结构的基础上，增加了before和after的双向索引 123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; 因此在遍历的过程中可以按添加的顺序遍历(有双向链表追踪)，而不是直接按遍历散列表进行遍历 Hashtale 已弃用，忽略 Properties Properties是Hashtable的子类，常用于处理属性(配置)文件 Properties的key和value都是String类型 使用步骤 创建.properties后缀文件(为方便演示，IDEA可在Project(根路径)右键新建，非Model) 一行一条数据，以键值对方式存储(默认均字符串格式)， 等号”=”连接key和value，且等号两旁不能有空格 12username=adminpassword=12345 创建Properties对象 获取配置文件的输入流对象 调用Properties对象的load方法进行输入流的加载 调用Properties对象的setProperty(String key,String value)方法和 getProperty(String key)方法，存取数据时 注：若出现中文乱码请在IDE中设置.properties创建和编码使用UTF-8编码，且需删除原有文件重新新建。 示例代码12345678910111213141516171819202122232425262728293031323334353637383940package com.website.map;import java.io.FileInputStream;import java.io.IOException;import java.util.Properties;/** * @author yhd * @create 2021-06-12 11:17 */public class MapTest &#123; public static void main(String[] args) &#123; Properties properties = new Properties(); FileInputStream fis = null; try &#123; fis = new FileInputStream(&quot;test.properties&quot;); properties.load(fis); String username = properties.getProperty(&quot;username&quot;); String password = properties.getProperty(&quot;password&quot;); System.out.println(&quot;username = &quot; + username);//username = admin System.out.println(&quot;password = &quot; + password);//password = 12345 properties.setProperty(&quot;password&quot;,&quot;abcde&quot;); System.out.println(properties.getProperty(&quot;password&quot;));//abcde &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; if(fis != null)&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; TreeMap TreeMap有别于HashMap与Hashtable，除了间接实现Map接口还实现了，SortedMap接口 向TreeMap添加key-value数据，要求key必须是同一个类型的数据(用泛型可以保证) TreeMap的排序是只对key进行自然排序、定制排序 操作与TreeSet一致，详情可查看”TreeSet”操作 Collections Collections 是一个操作 Set、List 和 Map 等集合的工具类 Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作， 还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。 排序API Static Method Descriptions reverse(List&lt;?&gt; list) 反转List 中元素的顺序 shuffle(List&lt;?&gt; list) 对 List 集合元素进行随机排序 sort(List&lt;?&gt; list) 根据元素的自然排序对指定 List 集合元素按升序排序 sort(List&lt;?&gt; list，Comparator&lt;? super T&gt; c) 根据指定的Comparator顺序对 List 集合元素进行排序 ……. 查找、替换API Static Method Descriptions Object max(Collection) 根据元素的自然排序，返回给定集合中的最大元素 Object max(Collection，Comparator) 根据 Comparator 指定的顺序，返回 给定集合中的最大元素 Object min(Collection) 同理max Object min(Collection，Comparator) 同理max int frequency(Collection，Object) 返回指定集合中指定元素的出现次数 void copy(List dest,List src) 将src中的内容复制到dest中 boolean replaceAll(List list，Object oldVal，Object newVal) 使用新值替换 List 对象的所有旧值 swap(List&lt;?&gt; list，int， int) 将指定 list 集合中的 i 处元素和 j 处元素进行交换 ……. copycopy(List dest,List src) 调用copy方法易错，copy内部代码要先保证dest.size &gt; src.size否则就会抛出异常 因此不能直接新建一个空的List作为dest，而是要建一个有src.size长度的dest 123456public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123; int srcSize = src.size(); if (srcSize &gt; dest.size()) throw new IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;); //....省略代码..&#125; 示例代码123456789101112131415161718192021222324252627282930package com.website.collections;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;/** * @author yhd * @create 2021-06-13 20:37 */public class CollectionsTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(&quot;sbccd&quot;); arrayList.add(&quot;23&quot;); arrayList.add(&quot;adfa&quot;); //正确写法 List&lt;String&gt; dest = Arrays.asList(new String[arrayList.size()]); Collections.copy(dest,arrayList); System.out.println(&quot;dest = &quot; + dest);//dest = [sbccd, 23, adfa] //错误写法 //List&lt;String&gt; dest = new ArrayList&lt;&gt;(); //java.lang.IndexOutOfBoundsException: Source does not fit in dest //Collections.copy(dest,arrayList); &#125;&#125; 同步控制API Collections 类中提供了多个 synchronizedXxx() 方法 该方法可使将指定集合对象包装成线程同步的集合对象 从而可以解决多线程并发访问集合时的线程安全问题 Static Method Descriptions synchronizedCollection(Collection&lt;T&gt; c) 返回由指定Collection支持的同步（线程安全）集合 synchronizedList(List&lt;T&gt; list) 返回由指定List支持的同步（线程安全）列表。 synchronizedMap(Map&lt;K,V&gt; m) 返回由指定Map支持的同步（线程安全）映射。 synchronizedSet(Set&lt;T&gt; s) 返回由指定Set支持的同步（线程安全）集 synchronizedSortedMap(SortedMap&lt;K,V&gt; m) 返回由指定的SortedMap支持的同步（线程安全）SortedMap synchronizedSortedSet(SortedSet&lt;T&gt; s) 返回由指定的SortedSet支持的同步（线程安全）SortedSet …… 小结基本特性 Collection：”集合“，单列数据 List：“线性表”，指有序、可重复 Set子接口：译为“集合”，指无序、不可重复 Map：”映射“，双列数据，无序，key不可重复，value可重复 比较标准 Collection List：重写equals方(ArrayList、LinkedList、Vector) Set： HashSet(子类LinkedHashSet，基于Map实现)：重写hashCode()与equals()方法 TreeSet：实现自然排序或定制排序接口 Map HashMap(子类LinkedHashMap)、Hashtable(子类Properties)：重写hashCode()与equals()方法 TreeMap：实现自然排序或定制排序接口 实现类比较List 指标\\实现类 ArrayList LinkedList TreeSet 背景 JDK 1.2，List主要实现类 JDK 1.2 JDK 1.0 ，已弃用实现类 底层实现 Object数组 双向链表 Object数组 线程安全 线程不安全 线程不安全 线程安全 效率 高 高 低 使用场景 多数存储与查询操作 频繁修改操作 线程安全 Set 指标\\实现类 HashSet LinkedHashSet TreeSet 背景 Set主要实现类 HashSet子类 实现SortedMap 底层实现 哈希表(哈希地址+数组) 带双向索引的哈希表 红黑树 线程安全 线程不安全 线程不安全 线程安全 使用场景 一般场景 频繁的遍历操作 支持自动排序 元素类型 无限制(存储null值) 无限制 仅同一类型 Map 指标\\实现类 HashMap LinkedHashMap TreeMap Hahstable 背景 Map主要实现类 HashMap子类 实现SortedMap 已弃用 底层实现 jdk7-哈希表(拉链法)jdk8-哈希表 + 红黑树 带双向索引的哈希表(同理jdk7，8不一样) 红黑树 哈希表 线程安全 线程不安全 线程不安全 线程不安全 线程安全 效率 高 高 高 低 使用场景 一般场景 频繁遍历操作 支持排序(key) 线程安全 元素类型 可存储null值(key与value) 无限制 同一类型 不可存储null值","categories":[],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/tags/JavaSE/"}]},{"title":"Java枚举,注解及泛型","slug":"Java枚举,注解及泛型","date":"2021-06-10T01:47:51.000Z","updated":"2021-08-25T15:27:11.612Z","comments":true,"path":"2021/06/10/Java枚举,注解及泛型/","link":"","permalink":"http://yoursite.com/2021/06/10/Java%E6%9E%9A%E4%B8%BE,%E6%B3%A8%E8%A7%A3%E5%8F%8A%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"引言：主要包含了JDK 5.0新增枚举类与注解。其中包括枚举类的定义、enum关键字的使用、主要方法、实现接口的枚举类。以及注解的原理、使用、实现操作，含常见注解、java四大元注解、JDK注解新特性，可重复注解、类型注解，以及Java泛型操作。 枚举类概念 枚举类核心：类的对象只有有限个，且确定(常量)的。 如星期数据的星期一到星期天，性别的男女，一年四季，线程的状态…… 枚举类的核心若枚举类中只有一个对象，可以作为一种单例模式的实现方式. 当需要定义一组常量时，强烈建议使用枚举类。提高代码的健壮性 源于《深入浅出面向对象分析与设计》 定义枚举类定义枚举类的方式有两种，分别以JDK 5.0 为分水岭 JDK 5.0之前的自定义枚举类 JDK 5.0之后使用enum关键字定义枚举类 自实现枚举类以枚举类的核心定义为实现基准，—— “类的对象只有有限个，且确定(常量)的 对象是有限个：或者说是数量可控的，则不能让外界自由地创建对象， 结论：私有化构造器，提供共有方法获取有限个对象实例 对象是确定的：即对象是常量，创建后不可变。 结论：将枚举类本身及其属性均定义为常量，且不向外提供任何修改属性的方法，但允许获取相关属性) 示例代码：以一年四季实现自定义枚举类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.website.enumtest;/** * 自定义枚举类，四季枚举类 * @author yhd * @create 2021-06-09 20:56 */public class Season&#123; //枚举类定义指南 //1、对象是有限个的：私有化构造器，静态方法获取实例 //2、对象是确定的，不变的：常量实例对象及其属性 //一般定义一些描述性属性，让枚举对象包含一些信息，使其更加形象与丰富 private final String name; private final String describe; private Season(String name,String describe)&#123; this.name = name; this.describe = describe; &#125; //定义确定的，不变的，有限的实例对象 public final static Season SPRING = new Season(&quot;春天&quot;,&quot;3～5月为春季&quot;); public final static Season SUMMER = new Season(&quot;夏天&quot;,&quot;6～8月为夏季&quot;); public final static Season AUTUMN = new Season(&quot;秋天&quot;,&quot;9～11月为秋季&quot;); public final static Season WINTER = new Season(&quot;冬天&quot;,&quot;12～2月为冬季&quot;); //给属性提供get方法 public String getName() &#123; return name; &#125; public String getDescribe() &#123; return describe; &#125; @Override public String toString() &#123; return &quot;Season&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, describe=&#x27;&quot; + describe + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 代码测试： 1234567public class SeasonTest &#123; public static void main(String[] args) &#123; Season spring = Season.SPRING; System.out.println(&quot;spring = &quot; + spring); //spring = Season&#123;name=&#x27;春天&#x27;, describe=&#x27;3～5月为春季&#x27;&#125; &#125;&#125; enum定义 如同JDK 8 之前定义接口的属性都需要显式地声明为public static final xxx，由于格式是固定的，因此JDK 8之后interface关键字下的类属性就不用显式地声明全局静态常量了默认是这样的类型。这样就省去了很多代码的编写，而且更加直观简洁。 同样自实现的枚举类，对象实例化的时候也是均需要public static final加以修饰，这些其实同时固定的。因此JDK 5.0之后可以通过enum关键字，进行枚举类的直接修饰。 使用与规范 枚举类只需enum关键字修饰，不需要class关键字：enum Season&#123;&#125; 枚举类的首部必须是有限个的枚举对象实例 枚举类实例对象，以 对象名(新参列表), 的格式创建，且多个对象之间用,逗号相隔，最后一个分号用; 若枚举类不存在需要带参构造器进行某些属性的初始化操作，则枚举实例知需要对象名, 其他细节： enum关键字定义的枚举类不继承于Object类型，而是继承与java.lang.Enum Enum默认重写了toString()方法：输出当前枚举类实例的名称 示例代码基于自实现修改 基于自实现代码加以注释，突出enum关键字省去的内容 123456789101112131415161718192021222324252627282930313233343536373839package com.website.enumtest;/** * 基于自定义枚举类注释的enum关键字枚举类：四季枚举类 * @author yhd * @create 2021-06-09 20:56 */public enum /* class */ Season&#123; /* public final static Season */ SPRING /* = new Season */ (&quot;春天&quot;,&quot;3～5月为春季&quot;),//; /* public final static Season */ SUMMER /* = new Season */ (&quot;夏天&quot;,&quot;6～8月为夏季&quot;),//; /* public final static Season */ AUTUMN /* = new Season */ (&quot;秋天&quot;,&quot;9～11月为秋季&quot;),//; /* public final static Season */ WINTER /* = new Season */ (&quot;冬天&quot;,&quot;12～2月为冬季&quot;); private final String name; private final String describe; /* private */ Season(String name,String describe)&#123; this.name = name; this.describe = describe; &#125; public String getName() &#123; return name; &#125; public String getDescribe() &#123; return describe; &#125; //Enum父类默认重写了toString()，输出枚举实例对象名。也可以选择自定义重写// @Override// public String toString() &#123;// return &quot;Season&#123;&quot; +// &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +// &quot;, describe=&#x27;&quot; + describe + &#x27;\\&#x27;&#x27; +// &#x27;&#125;&#x27;;// &#125;&#125; 测试代码 123456789101112package com.website.enumtest;/** * @author yhd * @create 2021-06-09 21:08 */public class SeasonTest &#123; public static void main(String[] args) &#123; Season autumn = Season.AUTUMN; System.out.println(&quot;autumn = &quot; + autumn);//autumn = AUTUMN &#125;&#125; enum枚举实例 enum定义枚举类的实例 12345678910111213141516171819202122232425262728package com.website.enumtest;/** * enum关键字定义枚举类，四季枚举类 * @author yhd * @create 2021-06-09 20:56 */public enum Season&#123; SPRING(&quot;春天&quot;,&quot;3～5月为春季&quot;), SUMMER (&quot;夏天&quot;,&quot;6～8月为夏季&quot;), AUTUMN(&quot;秋天&quot;,&quot;9～11月为秋季&quot;), WINTER(&quot;冬天&quot;,&quot;12～2月为冬季&quot;); private final String name; private final String describe; Season(String name,String describe)&#123; this.name = name; this.describe = describe; &#125; public String getName() &#123; return name; &#125; public String getDescribe() &#123; return describe; &#125;&#125; 测试代码 123456789101112package com.website.enumtest;/** * @author yhd * @create 2021-06-09 21:08 */public class SeasonTest &#123; public static void main(String[] args) &#123; Season autumn = Season.AUTUMN; System.out.println(&quot;autumn = &quot; + autumn);//autumn = AUTUMN &#125;&#125; Enum常用方法 API 方法 描述 toString() 返回当前枚举类对象常量的名称 values() 返回枚举类型的对象数组，该方法可以很方便地遍历所有的枚举值 valueOf(String str) 可以把一个枚举类对象的“名字”的字符串转化为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。否则报llegalArgumentException异常 …… 枚举类实现接口当枚举类需要实现某个接口时，实现接口的方式有两种不同方式： 统一实现方式：若以整个枚举类为单位，统一实现一次接口的方法。则每个枚举类对象调用重写方法都是一样的代码。(一样代码) 逐一实现方式：若以每个枚举类对象为单位，逐一实现各自的接口的方法。则可以实现每个枚举实例调用自己重写的代码。(各自代码) 统一实现方式 统一实现接口方法的枚举类 123456789101112131415161718192021222324package com.website.enumtest;//测试实现接口interface Info&#123; void show();&#125;/** * enum关键字定义枚举类，四季枚举类 * @author yhd * @create 2021-06-09 20:56 */public enum Season implements Info&#123; SPRING, SUMMER, AUTUMN, WINTER; //以枚举类为单位，统一实现一次接口方法 //所有枚举实例均调用一份代码 @Override public void show() &#123; System.out.println(&quot;我是四季&quot;); &#125;&#125; 测试代码 1234567891011121314package com.website.enumtest;/** * @author yhd * @create 2021-06-09 21:08 */public class SeasonTest &#123; public static void main(String[] args) &#123; Season spring = Season.SPRING; Season autumn = Season.AUTUMN; spring.show();//我是四季 autumn.show();//我是四季 &#125;&#125; 逐一实现方式 逐一实现接口方法的枚举类 1234567891011121314151617181920212223242526272829303132333435363738package com.website.enumtest;//测试实现接口interface Info&#123; void show();&#125;/** * enum关键字定义枚举类，四季枚举类 * @author yhd * @create 2021-06-09 20:56 */public enum Season implements Info&#123; //各自枚举实例实现各自的接口方法代码 SPRING&#123; @Override public void show() &#123; System.out.println(&quot;我是春天&quot;); &#125; &#125;, SUMMER&#123; @Override public void show() &#123; System.out.println(&quot;我是夏天&quot;); &#125; &#125;, AUTUMN&#123; @Override public void show() &#123; System.out.println(&quot;我是秋天&quot;); &#125; &#125;, WINTER&#123; @Override public void show() &#123; System.out.println(&quot;我是冬天&quot;); &#125; &#125;;&#125; 测试方法 1234567891011121314package com.website.enumtest;/** * @author yhd * @create 2021-06-09 21:08 */public class SeasonTest &#123; public static void main(String[] args) &#123; Season spring = Season.SPRING; Season autumn = Season.AUTUMN; spring.show();//我是春天 autumn.show();//我是秋天 &#125;&#125; 分支语句中要点 switch方法中，switch代码内不需要通过枚举类点取枚举类实例进行判断，直接写枚举类实例名即可 注解概述功能Annotation，译为“注解” 从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解) Annotation 其实就是代码里的特殊标记,，这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。 Annotation可以像关键字修饰符一样被使用，如同static，final等关键字一样会对代码做出实质的影响，而且可自定义 java注解，可用于修饰包,类, 构造器, 方 法, 成员变量, 参数, 局部变量的声明, 这些信息被保存在Annotation 的 “name=value” 对中。 应用领域 通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。 如代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署操作。 在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。 小结：未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以 上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的 Struts2有一部分也是基于注解的了，注解是一种趋势， 一定程度上可以说：框架 = 注解 + 反射 + 设计模式 常见注解示例使用Annotation时要在其前面增加@符号 文档相关注解注解描述 @author：标明开发该类模块的作者，多个作者之间使用逗号,分割 @version：标明该类模块的版本 @see：参考转向，也就是相关主题 @since：从哪个版本开始增加的 @param：对方法中某参数的说明，如果没有参数就不能写 @return：对方法返回值的说明，如果方法的返回值类型是void就不能写 @exception：对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写其中 相关使用细节 @param @return 和 @exception 这三个标记都是只用于方法 @param的格式要求：@param 形参名 形参类型 形参说明 @return 的格式要求：@return 返回值类型 返回值说明 @exception的格式要求：@exception 异常类型 异常说明 @param和@exception可以并列多个 示例代码1234567891011/** * * @param req * @param resp * @throws ServletException * @throws IOException */@Overrideprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;&#125; 功能说明这些注解声明在代码头部后，在执行javadoc.exe命令时，可以通过注解获取对应的描述信息。给javadoc.exe程序进行一个文档的信息注入提供基础。 编译相关注解注解描述如在IDE开发软件中，编写的代码在编译阶段就会指向一些注解的操作，如： @Override: 限定重写父类方法, 该注解只能用于方法 @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为 所修饰的结构危险或存在更好的选择 @SuppressWarnings: 抑制编译器警告 示例代码 如java.util.Date中多种已经废弃使用的构造器 1234@Deprecatedpublic Date(int year, int month, int date) &#123; this(year, month, date, 0, 0, 0);&#125; 功能说明 如@Override注解，一旦加入@Override注解的方法，就会在编译器/IDE在编译阶段，主动检查这个方法是否真的是重写父类或实现接口的方法，若不是，则主动报错，将提示信息反馈给程序员。 @Override注解一定程度上对方法的所属进行了标识，使方法功能更明确，减少对方法重名，方法名与重写方法名不对应(因为不对应的方法也可以调用，只是已经不是重写的方法了)，减少导致方法功能不明确的情况。 同理@deprecated，表示已弃用。别加以该注解的方法，会再编译时期被编译器警告提示。 @SuppressWarnings: 抑制编译器警告，可忽略一切编译器警告提示 跟踪代码依赖性 跟踪代码依赖性，实现替代配置文件功能 Servlet3.0提供了注解(annotation),使得不再需要在web.xml文件中进行Servlet的部署 还有spring框架中的事务管理等操作 自定义注解定义说明参照@SuppressWarnings定义 创建注解实现类，用@interface修饰类，如 @interface SuppressWarnings &#123;&#125; tips：自定义注解自动继承了java.lang.annotation.Annotation接口 注解的属性以方法的形式定义，返回值表示属性类型，方法名表示属性名 如果只有一个参数成员，建议使用参数名为value，否则在某些功能使用过程中可能存在报错!!! 如：想声明String value;属性，则对应应声明为String value(); 声明了成员变量的注解在使用时需对应填入参数，否则报错。 或者可通过在属性定义后追加default关键字来定义其默认值。此时调用时不传入参数则使用默认值。 如：String value() default &quot;hello&quot;; 包含成员变量的注解称为元数据注解，没有成员定义的注解，称之为标记，只用于标识作用，如@Override 创建注解类后就可以使用注解了，注解参数传入格式为： 标准键值对格式：@注解类名(属性名 = &quot;属性值&quot;) 数组类型数据格式：@注解类名(属性名 = &#123;&quot;属性值1&quot;,&quot;属性值2&quot;,...&#125;) 若注解只有一个成员变量时，也可以省略成员变量名： 普通类型：@注解类名(&quot;属性值&quot;) 数组类型：@注解类名(&#123;&quot;属性值1&quot;,&quot;属性值2&quot;,...&#125;) 编写注解功能：通过b使用了注解的类、方法、包….的注解的参数。获取参数后进行定制化的功能操作。 tips：自定义注解自动继承了java.lang.annotation.Annotation接口 示例代码 注解实现类 12345678910package com.website.annotationtest;/** * @author yhd * @create 2021-06-10 8:06 */@interface MyAnnotation &#123; String value() default &quot;hello&quot;; String url();&#125; 测试代码 123456789101112package com.website.annotationtest;/** * @author yhd * @create 2021-06-10 8:06 */public class AnnotationTest &#123; @MyAnnotation(value = &quot;test&quot;,url = &quot;abc&quot;) public static void main(String[] args) &#123; System.out.println(&quot;hello annotation~&quot;); &#125;&#125; 元注解基础概念 JDK 的元注解是用于修饰其他注解定义的注解 JDK5.0提供了4个标准的元注解(meta-annotation)类型，分别是： @Retention @Target @Documented @Inherited (扩展理解)元数据的理解： 对现有数据的修饰数据就叫元数据 如：String name = “data”;，数据本身是“data”，对数据修饰则(元数据)是String name 一般自定义注解时都会使用@Retention与@Target元注解进行加以修饰。 @Retention功能说明 @Retention只能用于修饰一个注解的定义(如注解类、属性..)，用于指定该注解定义中的生命周期 @Rentention包含一个RetentionPolicy枚举类型的成员变量，内置了许多描述生命周期状态的枚举实例对象。 使用Rentention注解时通过该枚举类选择参数值传递给@Rentention注解设定生命周期 RetentionPolicy.SOURCE：在源文件中有效，即源文件保留注解，编译后不保留 RetentionPolicy.CLASS：在class文件中有效，class保留注解 ， 运行时, JVM忽略(不加载到内存)，这也是注解的默认行为。 RetentionPolicy.RUNTIME：在运行时有效，运行时保留注解，当运时, JVM保留注解。程序可以通过反射获取该注释。 使用 @Rentention 时必须为该value 成员变量指定值 注解生命周期 代码示例 使用元注解@Retention修饰注解定义的生命周期为Runtime 1234567891011121314package com.website.annotationtest;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;/** * @author yhd * @create 2021-06-10 8:06 */@Retention(RetentionPolicy.RUNTIME)//设置该枚举在运行期间保留，可通过反射进行操作@interface MyAnnotation &#123; String value() default &quot;hello&quot;; String url();&#125; 此时使用注解的方法，可以被反射获取到注解信息 123456public class AnnotationTest &#123; @MyAnnotation(value = &quot;test&quot;,url = &quot;abc&quot;) public static void main(String[] args) &#123; System.out.println(&quot;hello annotation~&quot;); &#125;&#125; @Target功能说明 @Target用于修饰注解的定义,，指定被修饰的注解能用于修饰哪些程序元素(如，包、类、方法…) 当注解使用在不包含的修饰结构范围上时，编译器就会报错。 @Target 也包含一个名为 ElementType[] value的成员变量，因此可传入多种类型 ElementType是一个枚举类，封装了各种枚举类修饰元素类型的实例对象 TYPE：类、接口、或枚举类 FIELD：属性 METHOD：方法 PARAMETER：参数 CONSTRUCTOR：构造器 LOCAL_VARIABLE：局部变量 ANNOTATION_TYPE：注解类型 PACKAGE：包 TYPE_PARAMETER：类型参数，表示该注解能写在类型变量的声明语句中 TYPE_USE：类型使用 示例代码 为自定义注解指定可修饰的结构：方法、构造器 123456@Target(&#123;ElementType.METHOD,ElementType.CONSTRUCTOR&#125;)//只允许修饰方法和构造器@Retention(RetentionPolicy.RUNTIME)//设置该枚举在运行期间保留，可通过反射进行操作@interface MyAnnotation &#123; String value() default &quot;hello&quot;; String url();&#125; @Documented功能说明 @Documented用于指定被修饰的注解类能被javadoc 工具提取成文档。 默认情况下，javadoc是不包括注解的。 定义为@Documented的注解必须设置Retention值为RUNTIME 示例代码 使自定义注解能被javadoc工具提取成为文档 1234567@Documented //标识该注解能被提取成为文档@Target(&#123;ElementType.METHOD,ElementType.CONSTRUCTOR&#125;)@Retention(RetentionPolicy.RUNTIME)//设置该枚举在运行期间保留，可通过反射进行操作@interface MyAnnotation &#123; String value() default &quot;hello&quot;; String url();&#125; @Inherited功能说明 @Inherited: 被它修饰的注解将具有继承性 即如果某个类使用了被 @Inherited 修饰的注解，则其该类的子类将自动也具有该注解 开发中比较少用 示例代码 示例代码：将自定义枚举类定义为具有继承性 12345678@Inherited@Documented@Target(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.CONSTRUCTOR&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation &#123; String value() default &quot;hello&quot;; String url();&#125; 测试代码：子类可以通过反射读取到注解 12345678910111213141516171819202122232425package com.website.annotationtest;import java.lang.annotation.Annotation;/** * @author yhd * @create 2021-06-10 8:06 */public class AnnotationTest &#123; @MyAnnotation(value=&quot;test&quot;,url=&quot;test&quot;) class Person&#123;&#125; //默认自动含有@MyAnnotation(value=&quot;test&quot;,url=&quot;test&quot;)注解 class Student extends Person&#123;&#125; public static void main(String[] args) &#123; Class clazz = Student.class;//子类通过反射可以读取到注解 Annotation[] annotation = clazz.getAnnotations(); for (Annotation an : annotation) &#123; System.out.println(&quot;annotation = &quot; + an); //annotation = @com.website.annotationtest.MyAnnotation(value=test, url=test) &#125; &#125;&#125; 反射获取注解 注解的使用并不是单单的自定义注解 关键在于，通过反射扫描出使用注解的元素，及其元素使用的注解名、以及其注解属性的内容 然后根据这些信息，为使用注解的元素实现一些自动化的服务（设置，装配…） 一句话来说，注解的效能需要通过反射获取注解的相关信息再而进行对应的操作才能体现出来 案例过程，暂且忽略… JDK8注解新特性可重复注解概述 即将同一个注解在同一个位置重复使用多次 注意：这种需求是存在的，如Spring 的注解 @PropertySource常需要一个地方引用多个文件 示例代码：注意以下代码在没有新特性设置前是错误代码格式，只是为了表示用意 123456789public class AnnotationTest &#123; //重复注解了 @MyAnnotation(url=&quot;abc.html&quot;) @MyAnnotation(url=&quot;cde.css&quot;) public static void main(String[] args) &#123; System.out.println(); &#125;&#125; 实现步骤JDK8前方式 由于目的是使用多个同类型的注解A 可选择定义个新的注解B，B注解的成员变量就是拟重复定义注解A的数组的成员变量 在想重复定义注解A时就选择定义注解B，传入多个注解A的变量即可 拟重复定义注解：MyAnnotation 1234567891011package com.website.annotationtest;import java.lang.annotation.*;@Inherited@Documented@Target(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.CONSTRUCTOR&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation &#123; String url();&#125; 创建新注解MyAnnotations，定义以重复定义注解为类型的数组类型成员变量 12345package com.website.annotationtest;@interface MyAnnotations &#123; MyAnnotation[] value();&#125; 重复注解代码测试 12345678public class AnnotationTest &#123; //@MyAnnotation(value=&quot;test&quot;,url=&quot;abc.html&quot;) //@MyAnnotation(value=&quot;test&quot;,url=&quot;cde.css&quot;) @MyAnnotations(value = &#123;@MyAnnotation(url = &quot;abc.html&quot;), @MyAnnotation(url = &quot;cde.css&quot;)&#125;) public static void main(String[] args) &#123; System.out.println(); &#125;&#125; 新特性方式 注意：在上述的JDK 8之前方式的基础上继续实现：MyAnnotiation(注解A)，MyAnnotaitions(注解B) 在拟重复定义注解上添加用于修饰的注解@Repeatable(Class clazz) 将以拟重复定义的注解为数组类型的注解(注解B)，的Class类型传入@Repeatable中作为注解参数 统一注解A与注解B的@Retention()与@Target()元注解要一致。 代码示例：在拟重复定义注解上添加@Repeatable注解修饰，并传入拟重复定义注解为数组的成员变量的注解(MyAnnotations，注解B) 12345678910111213141516package com.website.annotationtest;import java.lang.annotation.*;/** * @author yhd * @create 2021-06-10 8:06 */@Inherited@Documented@Repeatable(value = MyAnnotations.class)//注意传入的不是当前拟重复定义注解类@Target(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.CONSTRUCTOR&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation &#123; String url() default &quot;test&quot;;&#125; MyAnnotations注解 注意，该注解的参数名必须是value，否则会报错！！！ 12345678910111213package com.website.annotationtest;import java.lang.annotation.*;/** * @author yhd * @create 2021-06-10 9:11 */@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.CONSTRUCTOR&#125;)@interface MyAnnotations &#123; MyAnnotation[] value();&#125; 新特性方式重复注解操作：设置后以下行为为合法行为 1234567public class AnnotationTest &#123; @MyAnnotation(url=&quot;abc.html&quot;) @MyAnnotation(url=&quot;cde.css&quot;) public static void main(String[] args) &#123; System.out.println(); &#125;&#125; 类型注解概述 JDK1.8之后，元注解@Target的参数类型ElementType枚举值多了两个TYPE_PARAMETER，TYPE_USE。 TYPE_PARAMETER，TYPE_USE就是涉及新特性类型注解的枚举类型。 在Java 8之前，注解只能是在声明的地方所使用，Java8开始，注解可以应用在任何地方 示例代码 ElementType.TYPE_PARAMETER：表示该注解能写在类型变量的声明语句中（如：泛型声明） class Generic&lt;@MyAnnotation T&gt;&#123;&#125; ElementType.TYPE_USE：表示该注解能写在使用类型的任何语句中。 123456class Generic&lt;T&gt;&#123; public void show() throws @MyAnnotation&#123; ArrayList&lt;@MyAnnotation String&gt; list = new ArrayList&lt;&gt;(); int num = (@MyAnnotation int) 10L; &#125;&#125; 泛型背景 集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object。 JDK1.5之后提出”类型参数化“使用泛型(Generic)来解决。此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection&lt;E&gt;，List&lt;E&gt;，ArrayList&lt;E&gt; E 就是类型参数，即泛型。 如List&lt;String&gt; arrayList = new ArrayLst&lt;&gt;();声明只能存放String类型 泛型类似容器的标签，如垃圾分类上的字(标签)，中药抽屉的上的标签。 集合中使用 集合接口或集合类在jdk5.0时都修改为带泛型的结构。 在实例化集合类时，可以指明具体的泛型类型 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。 比如：add(E e) —&gt;实例化以后：add(Integer e) 注意：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换 如果实例化时，没有指明泛型的类型。默认类型为java.lang.Object类型。 示例代码12List&lt;String&gt; arrayList = new ArrayLst&lt;&gt;();Map&lt;String,Person&gt; hashMap = new HashMap&lt;&gt;(); 自定义泛型结构基础语法 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如，&lt;E1,E2,E3&gt; 泛型类的构造器如下： 正确：如非泛型类的构造器，public GenericClass()&#123;&#125; 错误：public GenericClass\\&lt;E\\&gt;()&#123;&#125; 泛型不同的引用不能相互赋值，原因在于这样会扰乱泛型的使用，使类型不受控制。 1234567public static void main(String[] args) &#123; List&lt;Object&gt; arrayList1 = null; List&lt;Integer&gt; arrayList2 = new ArrayList&lt;&gt;(); //错误代码：泛型不同的引用不能相互赋值 //arrayList1 = arrayList2;&#125; 泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价 于Object。 经验：泛型要使用一路都用。要不用，一路都不要用。 jdk1.7，泛型的简化操作，称为”类型推断，即构造器方法的&lt;&gt;可以省略泛型定义 ArrayList flist = new ArrayList&lt;&gt;(); 泛型的指定中不能使用基本数据类型，可以使用包装类替换。 不能以new T[1O];这种方式声明带泛型的数组，而是先创建Object类型数组然后再强转为泛型数组 错误写法：T[] arr = new T[10]; 正确写法：T[] arr = (T[]) new Object[10];， 其含义相当于创建Object类型后自动帮其强制转换为指定泛型类型数组 泛型类及接口定义步骤 在接口名或类名后追加&lt;T&gt;符号，表示是一个泛型类/接口。(常用符号T、E、K、V) 此时类的内部结构(属性、方法、构造器…)就可以使用类定义的泛型符号作为一个可变数据类型 tips：其实真正定义泛型的操作是第一步，第二步都属于使用泛型符号而已，当其是一个数据类型，按日常处理即可 示例代码 GenericClassTest.java 1234567891011121314151617181920212223package com.website.java;/** * @author yhd * @create 2021-06-14 8:38 */public class GenericClassTest&lt;T&gt; &#123; private int id; private String name; private T order;//泛型在属性上使用 public GenericClassTest(int id, String name, T order) &#123;//泛型在局部变量上使用 this.id = id; this.name = name; this.order = order; &#125; public T getOrder() &#123;//泛型在方法返回值上使用 return order; &#125;&#125; 使用 不使用泛型：默认传入的泛型类型为Object，不建议！！！ 使用泛型：则实例化时传入数据类型到泛型符号中，建议！！！ 示例代码 测试代码 123456789101112131415161718package com.website.java;/** * @author yhd * @create 2021-06-14 8:41 */public class GenericTest &#123; public static void main(String[] args) &#123; //不使用泛型：默认传入的泛型类型为Object，不建议！！！ GenericClassTest genericObj = new GenericClassTest(3,&quot;a&quot;,&quot;Object&quot;); Object orderObj = genericObj.getOrder(); //使用泛型：则实例化时传入数据类型到泛型符号中，建议！！！ GenericClassTest&lt;Integer&gt; genericClassTest = new GenericClassTest&lt;&gt;(4,&quot;b&quot;,11101); Integer order = genericClassTest.getOrder(); System.out.println(&quot;order = &quot; + order);//order = 11101 &#125;&#125; 继承中使用 当一个非泛型子类继承一个泛型父类时，子类与父类的泛型定义是独立的。 只要子类不自己进行泛型定义，子类本身是不会因继承而变成泛型类的 当子类继承泛型父类时，可以传入两种类型的泛型数据：泛型类型、子类的泛型定义 继承时传入泛型类型(或不指明默认传入Object类型)：子类不属于泛型类 显式子传入泛型类型： 1234//继承时已指明泛型为Integer，此时SubGeneric不是泛型类class SubGeneric extends GenericClassTest&lt;Integer&gt;&#123; &#125; 隐式传入泛型类型(Object)： 1234//继承时不指明泛型(默认泛型Object)，此时SubGeneric不是泛型类class SubGeneric extends GenericClassTest&#123; &#125; 先把子类定义成泛型类，继承时传入子类的泛型定义。相当于保留了父类的泛型功能！！！ 此时由于是自己把子类定义成泛型类，因此子类肯定属于泛型类 只是此时父类共用了子类定义的泛型类型而已 1234//此时是主动将子类定义为泛型类，而且定义字符为E，因此传入泛型定义是Eclass SubGeneric&lt;E&gt; extends GenericClassTest&lt;E&gt;&#123; &#125; 注：需强调当一个子类继承一个泛型父类时，子类与父类的泛型定义是独立的 您甚至可以把子类定义成一个泛型，而又不向父类传入子类的泛型定义，而是指明了泛型类型。 123class SubGeneric&lt;E&gt; extends GenericClassTest&lt;Integer&gt;&#123;&#125; 示例情况1 示例情况2 注意事项 测试代码 1234567891011121314151617181920212223242526272829303132333435363738394041public class GenericTest &#123; /* 泛型在继承方面的体现 1、虽然类A是类B的父类，但是G&lt;A&gt; 和G&lt;B&gt;二者不具备子父类关系，二者是并列关系。 2、若类A是类B的父类，A&lt;G&gt; 是 B&lt;G&gt; 的父类 可以总结为：不同泛型类型的引用是不能相互赋值的 */ @Test public void test1()&#123; //多态现象-------------- Object obj = null; String str = null; obj = str; Object[] arr1 = null; String[] arr2 = null; arr1 = arr2; //多态现象-------------- //编译不通过 //Date date = new Date(); //str = date; //同理此时的list1和list2的类型不具有子父类关系 //List&lt;Object&gt; list1 = null; //List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); //编译不通过 // list1 = list2; /* 反证法： 假设list1 = list2; list1.add(123);导致混入非String的数据。出错。 */ List&lt;String&gt; list1 = null; ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;(); list1 = list2;//允许 &#125;&#125; 注意事项 泛型类中静态资源不能使用泛型：在类/接口上声明的泛型，在静态属性或方法中不能使用类的泛型。 由于泛型的指定只有在创建对象，即new时才能指定，而static修饰的内容在类加载的时候就创建了。 12345678910class SubGeneric&lt;E&gt; extends GenericClassTest&lt;Integer&gt;&#123; //静态属性中不能使用泛型// private static E name; //静态方法中不能使用泛型// public static void getData(E data)&#123;// System.out.println(&quot;data = &quot; + data);// &#125;&#125; 异常类不能是使用泛型，如自定义异常时，不能用泛型去继承Exception 泛型方法概念 泛型方法指该方法本身去定义了泛型，而不是说当前方法使用了泛型。 泛型方法定义的泛型和所属类是否属于泛型，继承父类是否属于泛型等等通通无关 1234567891011121314public class GenericMethod&lt;T&gt; &#123; private T data;//使用泛型类的泛型 //非泛型方法，使用泛型类的泛型而已 public void setData(T data)&#123; this.data = data; &#125; //泛型方法 public &lt;E&gt; E getDataE(E dataE) &#123; return dataE; &#125;&#125; 定义 在方法的权限修饰符后定义泛型 &lt;E&gt; 此时方法定义的泛型仅供该泛型方法的结构所使用：返回值类型，形参，方法体 123456public class GenericMethod&lt;T&gt; &#123; //泛型方法 public &lt;E&gt; E getDataE(E dataE) &#123;//这里有三处使用了泛型，返回值E，形参dataE，方法体dataE return dataE; &#125;&#125; 注：泛型方法定义泛型后，不一定要全部方法结构(返回值类型、形参、方法体)都使用。可选择性使用 示例代码 1234567public class GenericMethod&lt;T&gt; &#123; //泛型方法 public &lt;E&gt; Integer getDataE(E dataE) &#123; System.out.println(dataE); return 123; &#125;&#125; 使用 在使用泛型方法时，无需像使用创建泛型类这样有&lt;Class&gt;让其填入指定数据类型 而是直接往泛型方法的结构传入类型即可，泛型方法就会自动识别 示例代码 泛型方法定义代码 123456public class GenericMethod&lt;T&gt; &#123; //泛型方法 public &lt;E&gt; E getDataE(E dataE) &#123;//这里有三处使用了泛型，返回值E，形参dataE，方法体dataE return dataE; &#125;&#125; 测试代码 123456789101112131415package com.website.java;/** * @author yhd * @create 2021-06-14 15:15 */public class GenericMethodTest&lt;T&gt; &#123; public static void main(String[] args) &#123; GenericMethod&lt;String&gt; genericMethod = new GenericMethod&lt;&gt;(); Integer integer = new Integer(123); Integer dataE = genericMethod.getDataE(integer); System.out.println(&quot;dataE = &quot; + dataE); &#125;&#125; 注意事项 有别于泛型类，泛型方法可以被static修饰，由于静态泛型方法在调用时就可以指定泛型类型。因此静态方法也可以使用泛型。 通配符背景 有上述可知不同泛型类型的引用(即便存在子父类关系)，也是不能相互赋值的 即失去了子父类关系，在一定程度上失去了多态的特性，这样会造成很多重载的方法。 123456789101112131415161718192021222324252627282930package com.website.java;import java.util.List;/** * @author yhd * @create 2021-06-14 15:15 */public class GenericMethod&lt;T&gt; &#123; public static void main(String[] args) &#123; List&lt;Object&gt; list1 = null; List&lt;String&gt; list2 = null; //list1 = list2;//错误代码，两者之间已不存在子父类关系 //printDataForObject(list2);//错误代码，两者之间已不存在子父类关系 //失去多态性，使用多个重载的方法 printDataForObject(list1); printDataForString(list2); &#125; //失去子父类特性，失去多态特性，需多个重载方法--------------------- public static void printDataForObject(List&lt;Object&gt; list)&#123; System.out.println(&quot;list = &quot; + list); &#125; public static void printDataForString(List&lt;String&gt; list)&#123; System.out.println(&quot;list = &quot; + list); &#125; //----------------------------------------------------------&#125; 此时若能够使其List&lt;Object&gt; list1 与List&lt;String&gt; list2这两个整体结构统一去继承某个父类结构(通配符 ? )，则又能建立一个新的子父类关系，此时又具备多态性的特点使用。减少重载方法的定义 注：可以说通配符的出现，是为了不违背基本泛型使用的语法规则情况下，又还原给用户原有的继承多态特性 使用 通配符的意义：泛型中的通配符?可以使 ”虽然类A是类B的父类，但是G&lt;A&gt; 和G&lt;B&gt;二者失去父类关系“的情况重新以新的字符类关系建立起来，就是使G&lt;A&gt;和G&lt;B&gt;都继承&lt;?&gt; 通配符的定义：List&lt;?&gt; listAll = new ArrayList&lt;&gt;(); 通配符的使用：当使用通配符&lt;?&gt;中定义的数据类型时，默认就是Object类型 示例代码 123456789101112131415161718192021222324252627282930313233package com.website.java;import java.util.Iterator;import java.util.List;/** * @author yhd * @create 2021-06-14 15:15 */public class GenericMethod&lt;T&gt; &#123; public static void main(String[] args) &#123; List&lt;Object&gt; list1 = null; List&lt;String&gt; list2 = null; //list1 = list2;//错误代码，两者之间已不存在子父类关系 //printDataForObject(list2);//错误代码，两者之间已不存在子父类关系 List&lt;?&gt; list3 = null; list3 = list1;//均继承于List&lt;?&gt; list3 = list2;//均继承于List&lt;?&gt; //统一继承与List&lt;?&gt;,存在多态性，避免使用多个重载的方法 printDataForAll(list1); printDataForAll(list2); &#125; //List&lt;Object&gt;与List&lt;String&gt;共同继承与List &lt;?&gt; 这个整体结构 public static void printDataForAll(List&lt;?&gt; list)&#123; Iterator&lt;?&gt; iterator = list.iterator(); while (iterator.hasNext())&#123; Object next = iterator.next();//&lt;?&gt;转换出来即根父类Object类型(兼容全部) System.out.println(&quot;next = &quot; + next); &#125; &#125;&#125; 注意事项 可以说通配符的出现，是为了不违背基本泛型使用的语法规则情况下，又还原给用户原有的继承多态特性。 而这个还原给用户的泛型的继承多态的特性，可不是没限制的，如果没限制则不又回到了原有的问题，还是破坏了泛型的语法体系，这样通配符机制的引入则变成无用操作了 限制就是：使用通配符的泛型变量只能读取数据(返回Object类型)，而不能写入数据。(保护泛型语法体系) 唯一的可写入例外的是null，它是所有类型的成员 可以说，通配符就是重新在方法调用层面上还原了继承与多态特性 示例代码 12345678910111213141516171819202122232425package com.website.java;import java.util.List;/** * @author yhd * @create 2021-06-14 15:15 */public class GenericMethod&lt;T&gt; &#123; public static void main(String[] args) &#123; List&lt;Object&gt; list1 = null; List&lt;?&gt; list3 = null; list3 = list1; //list3.add(?);//无法操作，非法操作，不允许写入数据 Object obj = list.get(0);//允许读取数据，读取类型为Object printDataForAll(list1); &#125; public static void printDataForAll(List&lt;?&gt; list)&#123; //list3.add(?);//无法操作，非法操作，不允许写入数据 Object obj = list.get(0);//允许读取数据，读取类型为Object &#125;&#125; 有限制通配符对于通配符，还可以设置传入类型的上限和下限制 通配符指定上限：&lt;? extends Class&gt;，非”super“ ，等价于 (subClass Class] 使用时指定的类型必须是继承/实现，某个类/接口或其子类/接口 例如：&lt;? extends Comparable&gt;：只允许泛型为实现Comparable接口的实现类的引用调用 代码示例 12345678910List&lt;? extends Person&gt; list1 = null;List&lt;? super Person&gt; list2 = null;List&lt;Student&gt; list3 = new ArrayList&lt;Student&gt;();List&lt;Person&gt; list4 = new ArrayList&lt;Person&gt;();List&lt;Object&gt; list5 = new ArrayList&lt;Object&gt;();list1 = list3;//Student低于上限Person，允许list1 = list4;//Person等于限Person，允许//list1 = list5;//Object超过上限Person，错误 通配符指定下限：&lt;? super Class&gt; ，，等价于 [Class Object) 使用时指定的类型只能是该类型，或其父类(含间接父类)。 例如：&lt;? super Number&gt;：只允许泛型为Number及Number父类的引用调用 代码示例 1234567891011List&lt;? extends Person&gt; list1 = null;List&lt;? super Person&gt; list2 = null;List&lt;Student&gt; list3 = new ArrayList&lt;Student&gt;();List&lt;Person&gt; list4 = new ArrayList&lt;Person&gt;();List&lt;Object&gt; list5 = new ArrayList&lt;Object&gt;();//list2 = list3;//Student低于下限Person，错误list2 = list4;//Person等于下限Person，允许list2 = list5;//Object高于下限Person，允许 数据读写带限制的数据读写是可以指定一定范围的类型的，只要返回或设置的类型在限制范围内即可。 注意：子类可以强转为父类，但父类不可强转为子类。 &lt;? **extends** Class&gt; 等价 (subClass Class]：仅能读写Class类型 &lt;? **super** Class&gt; 等价 [Class Object) ：Class类型及其Class的所有子类 Class本身可以兼容一切情况可以，则抛开泛型概念，Class的子类也能转换为Class 泛型应用 DAO，一般DAO定义型泛型， DAO&lt;T&gt;泛型定义 12345public class DAO&lt;T&gt;&#123; public void add(T t)&#123;&#125; public T get(int id)&#123;&#125; public T update(T t)&#123;&#125;&#125; 不同的Bean对应DAO可以指明类型： public class CustomerDAO extends DAO&lt;Customer&gt;&#123;&#125; public class StudentDAO extends DAO&lt;Student&gt;&#123;&#125;","categories":[],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/tags/JavaSE/"}]},{"title":"Java常用类","slug":"Java常用类","date":"2021-06-09T12:20:23.000Z","updated":"2021-08-25T15:27:11.610Z","comments":true,"path":"2021/06/09/Java常用类/","link":"","permalink":"http://yoursite.com/2021/06/09/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/","excerpt":"","text":"引言：本文主要基于JDK8介绍JavaSE中常用的java类，含字符串相关类，String及其底层原理、StringBuffer、StringBuilder。JDK 8之前的日期时间API，System静态方法、Date、SimpleDateFormat、Calendar、JDK 8日期的时机API、LocalDate、LocalTime、LocalDateTime、Instant、DateTimeFormatter。以及Java比较器Comparable接口、Comparator接口、System类、Math类、BigInteger与BigDecimal等等……. String不可变特性双final特性 String是一个final类，是一个不可被继承引用类型。 String内部定义 final char value[]中(核心)用于存储字符串数据，因此值在创建之后不能更改，代表”不可变字符序列“。 String实现了Serializable接口：表示字符串是支持序列化的。 String实现了Comparable接口：表示String可以比较大小 部分源码 1234567public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; private final char value[];//字符串存储特性核心：不可变字符序列 private int hash; //.......&#125; 特性的体现错误体现 注意：如下代码不能体现字符串不可变特性。因为以下代码的直接原无关乎字符串的存储特性，而是编程语言中通用引用数据类型无返回值调用原理。 123456789@Testpublic void test2()&#123; String str1 = &quot;abc&quot;; method(str1); System.out.println(&quot;str1 = &quot; + str1);//仍然输出abc&#125;public void method(String str)&#123; str = &quot;hi~~&quot;;&#125; 对于引用数据类型，即使不是String也无法修改。(基本数据类型更加无法修改) 123456789@Testpublic void test2()&#123; Person person = new Person(&quot;Tom&quot;); method(person); System.out.println(person.getName());//仍然输出Tom，不可修改&#125;public void method(Person person)&#123; person = new Person(&quot;Jack&quot;);&#125; Person.java 12345678910111213class Person&#123; private String name; public Person(String name)&#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 正确体现 对于引用数据类型来说，无返回值方法调用，仅能修改引用指向的内容，而不能修改引用本身 123456789@Testpublic void test2()&#123; Person person = new Person(&quot;Tom&quot;); method(person); System.out.println(person.getName());//Jack，可以修改&#125;public void method(Person person)&#123; person.setName(&quot;Jack&quot;);&#125; 但是String作为引用数据类型，连修改引用指向的内容都不行 因为指向的内容是 final char[] values中，是一个常量，一个不可改变的数据。 这才是真正体现”不可变字符序列”特性的代码 总体效果，引用类型的String，调用方法进行操作时，如同退化成了基本数据类型一样，只能通过返回值重新赋值的方式改变String的内容。 123456789@Testpublic void test2()&#123; String str1 = &quot;abc&quot;; method(str1); System.out.println(&quot;str1 = &quot; + str1);//仍然输出abc&#125;public void method(String str)&#123; str.replace(&#x27;a&#x27;,&#x27;1&#x27;);&#125; 存储原理背景 由于字符串在java中大量使用，因此JVM特意开辟一个空间(字符串常量池)专门用于存储字符串。当存在两个相同的字符串时，常量池只存储一个，而让两个引用类型变量都引用它。从而达到节约内存资源的目的。 由于字符串数据存储存储在字符串常量池，且存储机制不一样，因此和常规引用类型的堆栈存储关系不一样，有时候会创建数据、有时候就不创建了。 结论：因此看待字符串的存储结构，要结合字符串常量池存储机制，引用类型堆栈的存储机制。 存储机制核心机制 创建字符串变量时，变量的引用存储在栈空间。 若字符串常量池存在相同(equal)的字符串，则只引用不创建。反之创建一个新的字符串。 测试代码 字符串常量池共用一份数据，与创建新的数据 12345678910@Testpublic void test1()&#123; String str1 = &quot;abc&quot;; String str2 = &quot;abc&quot;; //String是引用数据类型，== 比较的是地址值， System.out.println(str1 == str2);//true，同一份资源 str2 = &quot;abcd&quot;; System.out.println(str1 == str2);//false&#125; 引用数据类型值传递机制与字符串存储机制： 123456789@Testpublic void test2()&#123; String str1 = &quot;abc&quot;; method(str1); System.out.println(&quot;str1 = &quot; + str1);//仍然输出abc&#125;public void method(String str)&#123; str = &quot;hi~~&quot;;&#125; 分析：传递的确实是地址值，也确实创建了”hi~~”字符串 字面量机制 示例代码：String str = &quot;abc&quot;; 存储机制：栈空间的变量直接引用，字符串常量池中的字符串(地址)**进行操作，完全遵循核心机制**。 测试代码 字面量方式创建、拼接、方法调用 123456789101112131415161718@Testpublic void test3()&#123; //字面量创建 String str1 = &quot;abc&quot;; String str2 = &quot;abc&quot;; String str3 = &quot;abc&quot;; System.out.println((str1 == str2) &amp;&amp; (str2 == str3));//true str1 = str1 + &quot;def&quot;; System.out.println(&quot;str1 = &quot; + str1);//abcdef，在常量池新建了一份 System.out.println(&quot;str2 = &quot; + str2);//abc，因此abc在常量池没有被修改 System.out.println(str1 == str2);//false str2 = str2.replace(&#x27;a&#x27;,&#x27;1&#x27;); System.out.println(&quot;str2 = &quot; + str2);//1bc，在常量池新建了一份 System.out.println(&quot;str3 = &quot; + str3);//abc，因此abc在常量池没有被修改 System.out.println(str2 == str3);//false&#125; new+构造器机制 示例代码：String str = new String(&quot;abc&quot;); 存储机制： 不管什么情况，先在堆空间中开辟新的空间，用于存储values的引用数据(地址) 采用核心机制，在字符串常量池中搜寻相同的字符串 若找到则将其引用赋值到堆空间的values中 找不到则先在字符串常量池中创建新的字符串，后将其引用赋值到堆空间的values中 示例： 123//两者的区别？String str1 = &quot;abc&quot;;String str2 = new String(&quot;abc&quot;); 分析： 测试代码 示例代码： 123456789101112@Testpublic void test4()&#123; String s1 = &quot;javaEE&quot;; String s2 = &quot;javaEE&quot;; String s3 = new String(&quot;javaEE&quot;); String s4 = new String(&quot;javaEE&quot;); System.out.println(s1 == s2);//true：常量池地址比较 System.out.println(s1 == s3);//false：常量池地址与堆地址比较 System.out.println(s1 == s4);//false：常量池地址与堆地址比较 System.out.println(s3 == s4);//false：堆地址比较&#125; 分析： 源码赋值原理123456789//本质上this.value = new char[0];String s1 = new String(); //this.value = original.value;String s2 = new String(String original); //this.value = Arrays.copyOf(value, value.length);String s3 = new String(char[] a); String s4 = new String(char[] a,int startIndex,int count); 非静态类属性机制 示例代码 12345678class Person&#123; private String name; private int age; public Person(String name)&#123; this.name = name; &#125;&#125; 存储机制：由于类的非静态资源都是在堆空间开辟的，因此同第三种“new + 构造器字符串”方式 测试代码 示例代码 12345678@Testpublic void test5()&#123;//非静态类属性字符串 Person p1 = new Person(&quot;Tom&quot;); Person p2 = new Person(&quot;Tom&quot;); System.out.println(p1 == p2);//true System.out.println(p1.getName() == p2.getName());//true，最终存储都在常量池中&#125; 分析 字符串操作机制字符串拼接 仅字面量或常量(final Sting)参与操作：操作结果按普通核心机制，先检查字符串常量池是否存在，存在则引用，否则创建。 涉及变量名参与操作：，则属于new的形式创建机制，同样也做二次引用。因此操作结果返回的是堆空间的地址值，因此无论怎么和字符串常量池中的字符串比较(地址)都不会相同。 由于变量的状态是会改变的，JVM是无法时刻判断出结果匹配字符串常量池中不变的字符串 无论什么形式字符串本体都只存储在字符串常量池中，new也是做二次引用而已。 当字符串调用intern()方法时：返回该字符串在字符串常量池中的地址。 测试代码： 12345678910111213141516171819202122@Testpublic void test6()&#123; String s1 = &quot;javaEE&quot;; String s2 = &quot;hadoop&quot;; String s3 = &quot;javaEEhadoop&quot;; String s4 = &quot;javaEE&quot; + &quot;hadoop&quot;; String s5 = s1 + &quot;hadoop&quot;; String s6 = &quot;javaEE&quot; + s2; String s7 = s1 + s2; System.out.println(s3 == s4);//true System.out.println(s3 == s5);//false System.out.println(s3 == s6);//false System.out.println(s3 == s7);//false System.out.println(s5 == s6);//false System.out.println(s5 == s7);//false System.out.println(s6 == s7);//false String s8 = s6.intern();//返回值字符串在字符串常量池中的地址 System.out.println(s3 == s8);//true&#125; 分析 字面量与常量(包含final String) 1234567@Testpublic void test2()&#123; String str = &quot;JavaSEabc&quot;; final String str1 = &quot;JavaSE&quot;; String str2 = str1 + &quot;abc&quot;; System.out.println(str == str2);//true&#125; String方法调用 无论是字面量还是new+String结构 调用String方法返回的结果均为堆空间的地址值，即属于new+构造器类型机制，二次引用 代码测试： 123456789101112@Testpublic void test8()&#123; String s1 = &quot;abc&quot;; String s2 = &quot;1bc&quot;; s2 = s2.replace(&#x27;1&#x27;,&#x27;a&#x27;);//即使替换成一样的字符串 System.out.println(s1 == s2);//false String s3 = new String(&quot;def&quot;); String s4 = new String(&quot;1ef&quot;); s4 = s4.replace(&#x27;1&#x27;,&#x27;d&#x27;);//即使替换成一样的字符串 System.out.println(s3 == s4);//false&#125; 未解决问题 猜测是由于toString是Object的方法，操作之后数据存储在方法区？ 123456789101112131415@Testpublic void test7()&#123;//未解决问题，第二个输出为什么是false？toString的内容存储在哪？ String str = &quot;123&quot;; int i = 123; final char[] ch = &#123;&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;&#125;; System.out.println(str == ch.toString());//false System.out.println(str == (ch.toString()).intern());//false ? System.out.println(str == String.valueOf(ch));//false：变量参与new形式 System.out.println(str == String.valueOf(ch).intern());//true System.out.println(str == String.valueOf(i));//false：变量参与new形式 System.out.println(str == String.valueOf(i).intern());//true&#125; 核心总结 存储机制： 无论是哪种字符串创建机制，通过String方式创建的，字符串的本体都是存储在字符串常量池中，只是构造器的方式在堆空间做了二次引用。 字面量：一次引用(直接引用)，返回字符串常量池的地址 new+构造器：二次引用(间接引用)，返回堆空间的地址 注意：只是String中定义的是 final char [] values，遵循字符串常量池机制。而其他自定义的字符数组变量，是遵循引用类型栈堆开辟空间机制的，即字符数组内容的本体都存储在堆空间中。 操作机制： 仅字面量或常量(final String)参与的操作，一次引用 有变量名参与的操作，二次引用 调用String方法，二次引用 涉及JVM结构部分 JDK 1.6：字符串常量池在方法区(具体实现是：永久代) JDK 1.7：字符串常量池在堆空间中 JDK 1.8：字符串常量池在方法去(具体实现：元空间) JVM官方架构规范，会随JDK版本提升而有所变化， 具体虚拟机实现公司有多个，随JVM规范变化，也会有所变化 Sun公司的HotSpot BEA公司的JRockit IBM公司的J9VM 高频API 由于字符串底层的不可变字符序列特性，final char [] values 字符串任何内置的方法都无法只通过调用方法而不重新赋值来修改字符串的内容 字符串所有内置方法操作后都是返回一个新创建的字符串(堆方式)，原字符串不变。 调用者必须通过返回值重新赋值的方式才能修改字符串的内容(实际修改引用) 由于字符串底层用数组存储，因此涉及索引的操作，均从0开始 字符索引不分中文英文或其他语言字符，只要占一个字符位置，就是一个索引值 凡是涉及字符串匹配操作，搜索，替换，都是区分大小写的 CharSequence是一个字符序列接口，String实现类该接口，因此CharSequence形参可传入String类型 高频API 方法 描述 int length() 返回字符串的长度： return value.length，无字符串结束符概念 char charAt(int index) 返回某索引处的字符：return value[index]，按数组下标从0开始 boolean isEmpty() 判断是否是空字符串：return value.length == 0，不是null String toLowerCase() 使用默认语言环境，将 String中的所有字符转换为小写 String toUpperCase() 使用默认语言环境，将 String 中的所有字符转换为大写 String trim() 去除字符串首尾空格(字符串之间的空格不去) boolean equals(Object obj) 比较字符串的内容是否相同 boolean equalsIgnoreCase(String anotherString) 与equals方法类似，忽略大小写 String concat(String str) 等价于用“+”，将指定字符串连接到此字符串的结尾。 int compareTo(String anotherString) 比较两个字符串的大小，每个字符对应相减(ASCII码)，直至返回0(相同字符串)或返回某个字符相减后不等于0的结果。 String substring(int beginIndex) 它是此字符串的从 beginIndex(包含)开始截取到末尾的字符串索引从0开始，[左闭右开原则) String substring(int beginIndex, int endIndex) 从beginIndex(包含)开始截取到endIndex(不包含)的一个子字符串，索引从0开始，[左闭右开原则) String replace(char oldChar, char newChar) 通过用 newChar 替换此字符串中出现的所有 oldChar得到的 boolean endsWith(String suffix) 测试此字符串是否以指定的后缀结束 boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开始 boolean startsWith(String prefix, int toffset) 测试此字符串从指定索引开始(包含)的 子字符串是否以指定前缀开始 boolean contains(CharSequence s) 当且仅当此字符串包含指定的 char 值序列时，返回 true int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引未找到返回-1 int indexOf(String str, int fromIndex) 返回指定子字符串在此字符串中从指定的索引开始(包含)，第一次出现处的索引，未找到返回-1 int lastIndexOf(String str) 返回指定子字符串在此字符串中反向搜索第一次出现的索引未找到返回-1，区分大小写 int lastIndexOf(String str, int fromIndex)： 返回指定子字符串在此字符串从指定的索引开始反向搜索，第一次出现处的索引(完整匹配字符串的正序第一个字符位置)，未找到返回-1 String replace(CharSequence target, CharSequence replacement) 将字符串中，将所有指定的字符串，替换成指定的字符串target：用于匹配的子串replacement：匹配后替换的字符串 String replaceAll(String regex, String replacement) 同replace方法，不同在于通过regex正则表达式去匹配替换所有 String replaceFirst(String regex, String replacement) 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串 boolean matches(String regex) 告知此字符串是否匹配给定的正则表达式 String[] split(String regex) 根据给定正则表达式的匹配拆分此字符串 String[] split(String regex, int limit) 根据匹配给定的正则表达式来拆分此 字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中 笔记 charAt(int index)，由于String不可变字符序列，我们无法操作字符串中的字符串，也无法获取里面的values，因此只能通过charAt方法获取指定字符 从哪个索引开始start，包含 endIndex，到哪结束，则不包含 size，多少个，则包含 indexOf 和 lastIndexOf返回结果一样 情况1：存在唯一的子串 情况2：不存在该子串 API算法利用返回子串在主串出现次数indexOf(String str) + indexOf(String str,int fromIndex) String类型转换包装类之间 String ——&gt; 基本数据类型、包装类：调用包装类的静态方法，parseXxx(str) 基本数据类型、包装类 —— &gt; String：调用String重载的方法valueOf(xxx) char数组之间 String —— &gt; char[]：toCharArray(); char[] —— &gt;：构造器方式 new String(char[] ch) 因为Java用的是Unicode编码，因此char在Java中占用2Byte，因此任意语言字符都是只占一个字符位置。 byte数组之间 String ——&gt; byte[] ：编码操作(懂——&gt;不懂) getBytes();：使用默认字符集，进行转换。(取决当前.java源文件的编码设置) getBytes(String charsetName);：使用指定编码集转换为字节数组。有可能存在异常，因为有可能用户输入的字符集不存在。 12String str = &quot;abc123中国&quot;;byte[] bytes = str1.getBytes(&quot;gbk&quot;);//中文支持 由于byte数组每个元素只占1个字节，世界上很多字符都不能仅用1个字节能存储，编码类型也众多。因此String转换为byte数组时，受编码类型影响， byte[] ——&gt; String：解码操作(不懂——&gt;懂) new String(char[] chars);：用默认字符集，进行转换。(取决当前.java源文件的编码设置) new String(char[] chars,String charsetName);：使用指定解码集转换为字符串，同上 可变字符序列之间调用各自的构造器 String ——&gt; StringBuffer、StringBuilder：调用StringBuffer、StringBuilder构造器 StringBuffer、StringBuilder —— &gt; String：调用String构造器，或调用StringBuffer、StringBuilder的toString方法 可变字符序列 JDK提供的可变字符串有StringBuffer、StringBuilder两种 StringBuffer从JDK 1.0开始就有，后续因为性能低(线程安全)，在JDK 5.0的时候新增了StringBuilder 基本特性String、StringBuffer、StringBuilder三者的异同？ String：不可变的字符序列；底层使用final char[] value存储 StringBuffer：可变字符序列；线程安全，但效率低；底层使用char[] value存储 StringBuilder：jdk5.0新增的可变的字符序列；线程不安全，效率高；底层使用char[] value存储 可变性原理底层存储 StringBuffer与StringBuilder底层都是使用 char[] value 存储的 与String类型底层存储的字符数组不一样，没有final修饰 因此为可变字符序列的实现提供了可能性。 自动扩容 虽然StringBuffer与StringBuilder底层存储的字符数组没有final修饰 但是对于数组来说，一定声明了，长度就是固定的，再往其添加过多的元素是不可能 因此StringBuffer、StringBuilder底层是存在自动扩容机制的 初始容量 StringBuffer与StringBuilder的空参构造器创建的字符数组容量长度默认为：16 StringBuffer与StringBuilder的**(String str)构造器创建容量长度默认为：str.length() + 16** new StringBuffer() 123public StringBuffer() &#123; super(16);&#125; new StringBuffer(String str) 1234public StringBuffer(String str) &#123; super(str.length() + 16); append(str);&#125; 扩容机制简述假设，原有数据长度 + 拟添加数据长度 = 添加后数据总长度 默认初级拟扩容量为：*(原来容量 * 2) + 2* 若拟扩容量还小于添加后数据总长度，则以添加后总长度为最终扩容长度 特殊情况：拟扩容长度超出int类型等…..，暂时不分析 最后将原有数组中的元素复制到扩容后的新数组中 示例代码： 123456789101112131415161718192021222324@Testpublic void test2()&#123; StringBuilder sb = new StringBuilder();//空参默认容量为16，长度为0 sb.append(&quot;123456789&quot;);//容量为16，长度9 //容量为16，数据长度为9，9 &lt; 16，无需扩容 sb.append(&quot;123456789&quot;);//容量为34，长度18 //原容量：16 //原数据长度：9 //增加数据长度：9 //增加数据后长度：18，18 &gt; 16，需扩容 //计算拟扩容量：16*2+2 = 34，34 &gt; 18，扩容至34 char[] chars = new char[80]; Arrays.fill(chars,&#x27;5&#x27;); sb.append(chars);//容量为98，长度98 //原容量：34 //原数据长度：18 //增加数据长度：80 //增加数据后长度：98，98 &gt; 34，需扩容 //计算拟扩容量：34*2+2 = 70，70 &lt; 98，直接采取98为扩容后的容量 System.out.println(sb);&#125; 源码分析以StringBuffer的append方法为例 StringBuffer的append(String str)方法调用了父类的append(str)方法 12345public synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this;&#125; 父类的AbstractStringBuilder的append方法 首先检查是否传入null，然后获取要添加进来的字符串长度 将当前字符数组数据长度 (count + 要添加进来的字符串长度) 作为参数传入ensureCapacityInternal()方法，检测是否需要扩容。 123456789public AbstractStringBuilder append(String str) &#123; if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this;&#125; AbstractStringBuilder的ensureCapacityInternal方法 添加后总数据量 &gt; 当前字符数组容量，则需要调用newCapacity方法进行扩容 首先将原有容量左移1位，再加2。实际上就是×2+2，移位操作效率更高 若扩容好的容量还不足以存储添加后的数据长度，则直接以添加后的数据长度位扩容长度 还有一些超过int大小溢出负数的情况， 暂且略 最后返回真正扩容的长度 12345678910private int newCapacity(int minCapacity) &#123; // overflow-conscious code int newCapacity = (value.length &lt;&lt; 1) + 2; if (newCapacity - minCapacity &lt; 0) &#123; newCapacity = minCapacity; &#125; return (newCapacity &lt;= 0 || MAX_ARRAY_SIZE - newCapacity &lt; 0) ? hugeCapacity(minCapacity) : newCapacity;&#125; 最后通过copyOf方法把原有数据以返回的扩容的长度创建新数组，并把原有数据复制新字符数组中 1234567private void ensureCapacityInternal(int minimumCapacity) &#123; // overflow-conscious code if (minimumCapacity - value.length &gt; 0) &#123; value = Arrays.copyOf(value, newCapacity(minimumCapacity)); &#125;&#125; 父类实现 StringBuffer与StringBuilder的方法都是直接调用父类AbstractStringBuilder方法实现的。 StringBuffer其实是把StringBuilder的方法全部使用synchronized关键字修饰了一遍，使其线程安全。 因此StringBuffer和StringBuilder其实共用一套代码，因此分析其一源码即可 StringBuffer定义 1234public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence&#123; StringBuilder定义 1234public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence&#123; 指导意义通过源码分析，String、StringBuilder、StringBuffer三种字符串比较，目的在不同场景选择最高效率的使用方式，归结为如下几点： 性能优势：StringBuilder &gt; StringBuffer &gt; String，也是开发优先选择的顺序 由于可变字符序列还存在空间重用，String则每次不同都要创建新的。因此可变字符性能总体 &gt; 不可变字符。 线程安全，要申请锁并且使其多线程变成单线程运行，总体均比线程不安全性能要低。 避免自动扩容次数：使用可变字符串最高境界即，使用过程尽可能避免让其自动扩容 从应用场景中，先预判总的操作字符串范围，如(append次数*每次字符串数量) 使用带容量设置的可变字符构造器，自定义初始化其容量。 如：StringBuffer(int capacity) 或 StringBuillder(int capacity) 目的是在整个使用场景中减少自动扩容的机率 性能测试代码： 123StringBuffer的执行时间：7StringBuilder的执行时间：3String的执行时间：2158 源代码：让三者均从1~20000 进行一个字符拼凑 12345678910111213141516171819202122232425262728293031@Testpublic void test3()&#123; //初始设置 long startTime = 0L; long endTime = 0L; String text = &quot;&quot;; StringBuffer buffer = new StringBuffer(&quot;&quot;); StringBuilder builder = new StringBuilder(&quot;&quot;); //开始对比 startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; buffer.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println(&quot;StringBuffer的执行时间：&quot; + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; builder.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println(&quot;StringBuilder的执行时间：&quot; + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; text = text + i; &#125; endTime = System.currentTimeMillis(); System.out.println(&quot;String的执行时间：&quot; + (endTime - startTime));&#125; 常用API StringBuilder与StringBuffer共用一套代码，因此仅举一例说明 String原有的很多方法StringBuilder与StringBuffer都有 现如今主要说明体现可变字符的一些新增的方法 可变字符char[]作为一个可变数据的属性，大部分(不是全部)方法直接调用即可修改，不用接收返回值 由于底层仍是使用数组存储，因此索引均从0开始 支持方法链方法 方法链原理：方法的返回是调用方法的对象，即返回this，使其能连续调用方法。 append方法示例： 123456@Overridepublic synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this;&#125; 方法链连续调用 123456@Testpublic void test3()&#123; StringBuilder sb = new StringBuilder(); sb.append(&quot;a&quot;).append(&quot;b&quot;).append(&quot;c&quot;); System.out.println(sb);//abc&#125; API：增、删、改、查、插、长度、遍历 方法 描述 StringBuffer append(xxx) 很多重载的append()方法，用于进行字符串拼接 StringBuffer delete(int start,int end) 删除 [start,end) 指定位置的内容 StringBuffer replace(int start, int end, String str) 把[start,end)位置的字符串替换为str public void setCharAt(int n ,char ch) 修改指定索引位置的字符为指定字符 public char charAt(int n ) 返回指定位置的字符 public String substring(int start,int end) 提取并返回 [start,end) 位置的子串(需接收返回值) StringBuffer insert(int offset, Object xxx) 重载方法，在指定位置插入数据。插入，是插在之前 public int length() 返回可变字符当前数据长度(非容量) StringBuffer reverse() 把当前字符序列逆转 public int indexOf(String str) 返回指定字符串在主串中首次出现的位置 …… 日期时间JDK8前API JDK 8前API的结构体系 System System类提供静态方法用来返回当前时间戳 时间戳：即当前时间，与1970年1月1日0时0分0秒之间以毫秒为单位的时间差 方法 描述 public static long currentTimeMillis() 来返回当前时间戳，单位ms Date Java中含有两个Date类，分别为java.util.Date与java.sql.Date java.sql.Date是java.util.Date的子类 Date是用于记录某个时刻的瞬时时间，一旦创建对象，时间就记录下来了。 java.util.Date构造器 构造器 描述 new Date(); 创建当前时刻的Date对象，时间格式默认为，年月日、时分秒、时区信息 new Date(long date) 创建指定时间戳的Date对象 方法 方法 描述 toString() 获取date对象的时间信息，格式为：年月日、时分秒、时区信息 getTime() 返回date对象的时间戳 Date是用于记录某个时刻的瞬时时间，一旦创建对象，时间就记录下来了。 1234567@Testpublic void test1() throws InterruptedException &#123; Date date = new Date(); System.out.println(date.getTime()); Thread.sleep(1000); System.out.println(date.getTime());&#125; 输出：任意时刻调用都是一样 1216231184477361623118447736 java.sql.Date java.sql.Date是对应数据库中日期类型的变量，javaBean与数据库映射的时候使用 java.sql.Date的构造器只有带参的： new Date(long date) java.sql.Date的toString()输出时间格式为：”年月日“ 其余和java.util.Date一致 java.util.Date转换为java.sql.Date的方法 情况一：该java.util.Date本来就就是多态与java.sql.Date 直接强制转换即可 1234//情况一：多态情况(很少出现)，直接强制类型向下转换Date date1 = new java.sql.Date(1623118805527L);java.sql.Date date2 = (java.sql.Date) date1;System.out.println(date2.toString()); 情况二：无多态关系 先获取java.util.Date的时间戳，再作为参数传入java.sql.Date 1234//情况二：无多态关系，通过时间戳作为桥梁创建Date date3 = new Date();java.sql.Date date4 = new java.sql.Date(date3.getTime());System.out.println(date4.toString()); 小结Java中的Date类一般三种用途 记录(获取)瞬时(当前)时间：new Date(); 或者直接用System.获取当前时间戳 任意Date日期与时间戳之间相互转换： Date日期——&gt;时间戳：date.getTime() 时间戳——&gt;Date日期：new Date(long time); 日期数据转换为java.sql.Date的桥梁：桥梁就是利用第2点的转换时间戳功能，作为new java.sql.Date(long time)的桥梁。 tips：若创建一个自定义日期时间的Date，则官方已经不推荐使用new Date(String date)实现了。而是通过SimpleDateFormat定义后，解析返回Date类型 1Date date = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(&quot;1990-01-01&quot;); SimpleDateFormat 由于Date类的API不易于国际化，大部分被废弃了 SimpleDateFormat类译为”简单日期格式化“，是一个不与语言环境有关的方式来格式化和解析日期的类 SimpleDateFormat可以对日期Date类进行格式化和对格式化后的内容进行解析 格式化：日期——&gt;文本 解析：文本——&gt;日期 格式化与解析的指定格式，都是通过构造器设置 格式化格式化方法：SimpleDateFormat对象的format方法 默认格式日期格式化：new SimpleDateFormat(); 1234567891011@Testpublic void test1()&#123; //准备Date时间 Date date = new Date(); System.out.println(&quot;date = &quot; + date);//Tue Jun 08 17:19:52 CST 2021 //默认格式格式化，空参构造器 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(); String format = simpleDateFormat.format(date); System.out.println(&quot;format = &quot; + format);//21-6-8 下午5:19&#125; 指定pattern格式日期格式化：new SimpleDateFormat(String pattern) 1234567891011@Testpublic void test1()&#123; //准备Date时间 Date date = new Date(); System.out.println(&quot;date = &quot; + date);//Tue Jun 08 17:20:58 CST 2021 //默认格式格式化，空参构造器 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy_MM_dd hh:mm:ss&quot;); String format = simpleDateFormat.format(date); System.out.println(&quot;format = &quot; + format);//2021_06_08 05:20:58&#125; pattern 常用格式含义： y：年，常用yyyy M：月，常用MM d：日，常用dd h：小时，常用hh m：分，常用mm s：秒，常用ss API：具体说明查看官方API 官方示例：”给定的日期和时间是2001-07-04 12:08:56当地时间在美国太平洋时间时区” 解析解析方法：SimpleDateFormat对象的parse方法 传入的被解析字符串日期格式是SimpleDateFormat格式化后的字符串，并非Date的日期的字符串。 传入格式必须与解析格式一致，否则抛出异常。 默认格式解析：new SimpleDateFormat(); 123456789101112131415@Testpublic void test1() throws ParseException &#123; //准备Date时间 Date date = new Date(); System.out.println(&quot;date = &quot; + date);//Tue Jun 08 17:33:00 CST 2021 //默认格式格式化，空参构造器 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(); String format = simpleDateFormat.format(date); System.out.println(&quot;format = &quot; + format);//21-6-8 下午5:33 //必须匹配simpleDateFormat定义的解析格式 Date parse = simpleDateFormat.parse(&quot;21-6-8 下午5:33&quot;); System.out.println(&quot;parse = &quot; + parse);//Tue Jun 08 17:33:00 CST 2021&#125; 指定格式解析：new SimpleDateFormat(String pattern) 123456789101112131415@Testpublic void test1() throws ParseException &#123; //准备Date时间 Date date = new Date(); System.out.println(&quot;date = &quot; + date);//Tue Jun 08 17:28:36 CST 2021 //默认格式格式化，空参构造器 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); String format = simpleDateFormat.format(date); System.out.println(&quot;format = &quot; + format);//2021-06-08 //必须匹配simpleDateFormat定义的解析格式 Date parse = simpleDateFormat.parse(&quot;2021-06-08&quot;); System.out.println(&quot;parse = &quot; + parse);//Tue Jun 08 17:28:00 CST 2021&#125; Calendar Calendar是JDK提供的一个封装类日历相关信息操作的抽象类，可以进行一些常用日历相关操作 Calendar可以返回Calendar对象实例化的时间是这一个月的第几天，这一年的第几天等操作… 实例化 Calendar是一个抽象类，实际使用的是其(实现)子类GregorianCalendar类 获取Calendar(GregorianCalendar)实例的方式有两种： Calendar静态方法： 1Calendar.getInstance();//实质也是GregorianCalendar实例 new GregorianCalendar()构造器方式： 1GregorianCalendar gregorianCalendar = new GregorianCalendar(); tips：没经过setTime()设置的Calendar所表示的时间就是Calendar对象实例化时候的时间 常用APIget&amp;set get和set方法可以获取或修改Calendar对象持有的时间，根据field所指定的意义的数量(日/月/年…) int field：传入的是Calendar的静态常量，表示部分常量意义如下，详情查看API Calendar.DAY_OF_MONTH：当前月的第几天 Calendar.DAY_OF_WEEK：当前星期的第几天(星期几) Calendar.WEEK_OF_MONTH：当前月份的第几个星期 … get返回值set设置值意义： DAY_OF_WEE(星期)： 1是周日，2周一，3周二 ， 。。。。7是周六 获取月份：一月是0，二月是1，以此类推，12月是11 由于不同国家，多星期一或星期日是第一天理解不同。其他的Calendar类一些常量还具有很多特殊情况，具体问题请查阅相关资料。 示例代码： 获取当前时间是这个月、或这个星期的第几天，这个月的第几周 1234567891011121314@Testpublic void test1()&#123; Calendar calendar = Calendar.getInstance(); System.out.println(calendar.getTime());//Wed Jun 09 07:39:41 CST 2021 int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK); int dayOfMonth = calendar.get(Calendar.DAY_OF_MONTH); int weekOfMonth = calendar.get(Calendar.WEEK_OF_MONTH); //当前测试时间是：2021年06月09日,星期三 System.out.println(&quot;dayOfWeek = &quot; + dayOfWeek);//4，4表示星期三 System.out.println(&quot;dayOfMonth = &quot; + dayOfMonth);//9 System.out.println(&quot;weekOfMonth = &quot; + weekOfMonth);//2&#125; 修改当前时间是这个星期的第几天 123456789101112131415@Testpublic void test2()&#123; Calendar calendar = Calendar.getInstance(); System.out.println(calendar.getTime());//Wed Jun 09 07:39:41 CST 2021 int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK); System.out.println(&quot;dayOfWeek = &quot; + dayOfWeek);//4,星期三 //修改当前时间是这一周的第几天(星期几) calendar.set(Calendar.DAY_OF_WEEK,3); dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK); //当前测试时间是：2021年06月09日，星期三 System.out.println(&quot;dayOfWeek = &quot; + dayOfWeek);//3，星期二&#125; add add方法可以使Calendar对象时间根据field所指定的意义增加或减少或指定的数量(日/月/年…) 加：传入正数 减：传入负数 示例代码 对当前时间是这个星期的第几天进行加减修改操作 1234567891011121314151617@Testpublic void test3()&#123; Calendar calendar = Calendar.getInstance(); System.out.println(calendar.getTime());//Wed Jun 09 07:39:41 CST 2021 //当前测试时间是：2021年06月09日，星期三 int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK); System.out.println(&quot;dayOfWeek = &quot; + dayOfWeek);//4 //将这一周的第几天数量增加2 calendar.add(Calendar.DAY_OF_WEEK,2);//加两天 System.out.println(calendar.get(Calendar.DAY_OF_WEEK));//6 //将这一周的第几天数量减少2 calendar.add(Calendar.DAY_OF_WEEK,-2);//减两天 System.out.println(calendar.get(Calendar.DAY_OF_WEEK));//4&#125; getTime 返回当前Calendar实例的时间对应的java.util.Date类 示例代码 12Calendar calendar = Calendar.getInstance();Date date = calendar.getTime(); setTime 通过java.util.Date类修改Calendar实例持有的时间 示例代码 123Calendar calendar = Calendar.getInstance();Date date = new Date();calendar.setTime(date); 综合应用字符串日期转sql.Date123456789@Testpublic void test2() throws ParseException &#123; String strDate = &quot;2020-09-08&quot;; //对应日期字符串格式编写对应的pattern SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date utilDate = simpleDateFormat.parse(strDate); java.sql.Date date = new java.sql.Date(utilDate.getTime()); System.out.println(date.getClass() + &quot; = &quot; + date);&#125; 总天数计算例题：计算任意日期从1990-01-01开始的天数 方法1：分别计算起始日期的时间戳与目的日期的时间戳，进行相减后除出天数 方法2：先算整数年份日，再算当年年份如： 1990-01-01—2019-12-31 + 2020-01-01 — 2020-09-08 方法2的Calendar类辅助：如计算2020-01-01 — 2020-09-08，可以设置Calendar为2020-09-08计算 1234567891011//方法1：现在规定是从1990年1月1日开始计算public int getDayCount(java.util.Date date) throws ParseException &#123; long beginTime = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(&quot;1990-01-01&quot;).getTime(); long dateTime = date.getTime(); if(dateTime &lt; beginTime) return 0; long time = dateTime - beginTime; int dayCount = (int)(time / 1000 / 3600 / 24) + 1;//整数除法省去余数需加1 return dayCount;&#125; 扩展例题：有一个渔夫，从1990-01-01日起，开始”三天打渔两天嗮网”，请问日期为 xxxx-xx-xx 时，渔夫是在打渔还是在嗮网？转换来说就是一个求总天数的问题。 总天数 % 5 == 4，5：嗮网 总天数 % 5 == 1，2，3：打渔 JDK8后API背景旧API缺陷 JDK 1.0中包含了 一个java.util.Date类，但它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用。 但Calendar并不比Date好多少…，它们面临的问题总共有如下几个方面： Calendar的可变性：calendar的set方法能任意修改一个星期第几天，理应是不允许做这些修改的 偏移量：通过构造器设置Date时间，实际调用Calendar操作年份+1900偏移，月份从0开始(设置当前年份 - 1990，当前月份 -1)，由于偏移量与月份从0开始的设定，使其不方便，易错 格式化：Date可通过废弃的构造器或者基于simpleDateFormat可进行格式化，被推祟替换Date的Calendar却不支持格式化操作 线程不安全：Date与Calendar均线程不安全 不支持处理闰秒 总结：对日期和时间的操作一直是Java程序员最痛苦的地方之一 新API​ Java 8 吸收了 Joda-Time 的精华(第三方库)，以一个新的开始为 Java 创建优秀的 API。 新的 java.time 中包含了所有关于本地日期（LocalDate）、本地时间 （LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime） 和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法， 用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简 化了日期时间和本地化的管理。 没有偏移量，直接获取或设置 不可变性：JDK8 中如Calendar的类的修改有返回值，但不影响对象原有数据 由于新时间API结构庞大，本文章只介绍部分常用的API，有需求另查API 本地日期时间描述本地日期与时间涉及三个类： 本地日期（LocalDate）：代表IOS格式（yyyy-MM-dd）的日期,可以存储 生日、纪念日等日期 本地时间 （LocalTime）：LocalTime表示一个时间，而不是日期 本地日期时间（LocalDateTime）：LocalDateTime是用来表示日期和时间的，最常用的类之一。 注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法，也就是公历。 实例化 实例化操作均为对应类的静态方法，分别有now()与of(形参)两种方式 now()：空参方法，返回当前时间 of(形参列表)：多个重载构造器，可以直接设置指定的年月日时分秒时间 示例代码 123456789101112131415@Testpublic void test1()&#123; //now()方式，获取当前时间的对应类对象 LocalDate localDate = LocalDate.now(); LocalTime localTime = LocalTime.now(); LocalDateTime localDateTime = LocalDateTime.now(); System.out.println(&quot;localDate = &quot; + localDate);//2021-06-09 System.out.println(&quot;localTime = &quot; + localTime);//08:46:34.606 System.out.println(&quot;localDateTime = &quot; + localDateTime);//2021-06-09T08:46:34.606 //of(形参列表)方式，自定义任意时间创建对应类对象(不存在偏移量，直接设置) LocalDateTime localDateTime1 = LocalDateTime.of(2099, 3, 1, 5, 45, 20, 3); System.out.println(&quot;localDateTime1 = &quot; + localDateTime1);//2099-03-01T05:45:20.000000003&#125; 方法 基于表示内容的范围LocalDateTime涵盖了大部分方法，因此主要以LocalDateTime说明方法 JDK 8后的本地时间日期类都没有偏移量设定，可直接获取与设置 JDK 8后的API将其Calender不同field意义的操作直接封装在每一个对应的方法中 不可变性：withXxx()、plusXxx()、minusXxx()方法 这些方法修改后是有修改后的返回值，本身的日期时间对象不会被修改数据。 Calendar的set()方法，是没返回值，直接修改了对象的数据 getXxx() getXxxx()系列的方法可以如Calendar的get(int field)方法一样获取各种日历意义的参数。 getDayOfMonth()：返回当前月的第几天 getDayOfWeek()：返回当前周的第几天 getMonth()：返回月份信息 … getValue()**：可以返回某个时间日期子对象实际的数值**。 示例代码 1234567891011121314@Testpublic void test2()&#123; LocalDateTime localDateTime = LocalDateTime.now(); System.out.println(&quot;localDateTime = &quot; + localDateTime);//2021-06-09T08:53:20.896 System.out.println(localDateTime.getDayOfMonth());//9 System.out.println(localDateTime.getDayOfWeek());//WEDNESDAY(星期三) System.out.println(localDateTime.getDayOfYear());//160 System.out.println(localDateTime.getMonth());//JUNE(六月) System.out.println(localDateTime.getMonth().getValue());//6 System.out.println(localDateTime.getMinute());//53&#125; withXxx() withXxxx()系列的方法可以如Calendar的set(int field,int i)方法一样设置各种日历意义的参数。 对应getXxx()提供意义的方法，基本对应有withXxx()方法，详情查看API 示例代码 123456789@Testpublic void test3()&#123; LocalDateTime originTime = LocalDateTime.now(); //设置当前时间在一个月中第几天的数据。有新对象，原对象数据不修改 LocalDateTime localDateTime1 = originTime.withDayOfMonth(12); System.out.println(&quot;localDateTime1 = &quot; + localDateTime1.getDayOfMonth());//12 System.out.println(&quot;originTime = &quot; + originTime.getDayOfMonth());//9&#125; plusXxx() plusXxx()系列的方法可以如Calendar的add(int field,int i)方法一样增加各种日历意义的参数。 对应getXxx()提供意义的方法，基本对应有plusXxx()方法，详情查看API 示例代码： 123456789@Testpublic void test3()&#123; LocalDateTime originTime = LocalDateTime.now(); System.out.println(&quot;originTime = &quot; + originTime.getDayOfMonth());//9 //增加基于当前时间的天数。有新对象，原对象数据不修改 LocalDateTime localDateTime1 = originTime.plusDays(1); System.out.println(&quot;localDateTime1 = &quot; + localDateTime1.getDayOfMonth());//10&#125; minusXxx() minusXxx()**系列的方法可以如Calendar的add**(int field,int -i)方法一样减少各种日历意义的参数。 对应getXxx()提供意义的方法，基本对应有minusXxx()方法，详情查看API 示例代码： 123456789@Testpublic void test3()&#123; LocalDateTime originTime = LocalDateTime.now(); System.out.println(&quot;originTime = &quot; + originTime.getDayOfMonth());//9 //增加基于当前时间的天数。有新对象，原对象数据不修改 LocalDateTime localDateTime1 = originTime.minusDays(1); System.out.println(&quot;localDateTime1 = &quot; + localDateTime1.getDayOfMonth());//8&#125; Instant Instant：时间线上的一个瞬时点，即时间戳。面向机器的连续的时间数值量。 为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级(秒-毫秒-微妙-纳秒) 类似于java.util.Date()类 实例化 API 方法 描述 now() 静态方法，返回默认UTC时区的Instant类的对象 atOffset(ZoneOffset offset) 结合即时的偏移来创建一个 OffsetDateTime ofEpochMilli(long epochMilli) 静态方法，通过给定时间戳创建Instant类的对象 注：时区*:*UTC/GMT 0 (零时区) 与北京时差相差8个小时 now()方式 123456789101112@Testpublic void test4()&#123; //当前测试时间为：2021-06-09T09:50:47 //now()：默认获取UTC时间，零时区(本初子午线的标准时间) Instant instant = Instant.now(); System.out.println(&quot;instant = &quot; + instant);//2021-06-09T01:50:47.757Z //由于UTC 零时区与北京东八区相差8小时，可通过偏移量方式设置回去 OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8)); System.out.println(&quot;offsetDateTime = &quot; + offsetDateTime);//2021-06-09T09:50:47.757+08:00&#125; ofEpochMilli(long epochMilli)方式 12345@Testpublic void test5()&#123; Instant instant = Instant.ofEpochMilli(1623203887637L); System.out.println(&quot;instant = &quot; + instant);//2021-06-09T01:58:07.637Z&#125; 常用方法 API 方法 描述 toEpochMilli() 返回instant对象的时间戳，单位毫秒 示例代码 123456@Testpublic void test4()&#123; Instant instant = Instant.now(); long time = instant.toEpochMilli(); System.out.println(&quot;time = &quot; + time);//1623204005225&#125; DateTimeFormat DateTimeFormat用于格式化或解析日期、时间 类似SimpleDateFormat 实例化/格式设置DateTimeFormat提供众多的实例化方式(设置格式化与解析格式)，常用如下三种 预定义的标准格式：如，全局静态常量，ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME 本地化相关格式：如，ofLocalizedDateTime(FormatStyle.LONG) 自定义的格式：如，ofPattern(“yyyy-MM-dd hh:mm:ss”)，最常用！！！ 预定义标准格式 通过DateTimeFormat提供的全局静态常量提供的标准格式，来定义格式并实例化其对象 如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIM 12//采取ISO_DATE_TIME格式DateTimeFormatter formatter = DateTimeFormatter.ISO_DATE_TIME; 本地化相关格式 API：静态方法，DateTimeFormatter.ofLocalizedXxxx(FormatStyle value)， Xxx不同的方法对应，LocalDate、LocalTime、LocalDateTime 如：ofLocalizedDate(FormatStyle value)、ofLocalizedDateTime(FormatStyle value)… FormatStyle：是一个本地内置日期实际格式枚举类，提供多种常用的内置的格式标识 LONG：通用的长格式如，2021年6月9日 MEDIUM：通用的中等格式如，2021-6-9 SHORT：通用的短格式如，21-6-9 FULL：仅适用于ofLocalizedDate()的一种格式如，2021年6月9日 星期三 示例代码 123456789101112@Testpublic void test7()&#123; //ofLocalizedDate 对应 LocalDate DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL); String format = dateTimeFormatter.format(LocalDate.now()); System.out.println(&quot;format = &quot; + format);//2021年6月9日 星期三 //ofLocalizedDateTime 对应 LocalDateTime DateTimeFormatter dateTimeFormatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM); String format1 = dateTimeFormatter1.format(LocalDateTime.now()); System.out.println(&quot;format1 = &quot; + format1);//2021-6-9 10:42:29&#125; 自定义格式 API：静态方法，DateTimeFormatter.ofPattern(String pattern); 一般开发都是自定义格式使用多。 pattern格式与SimpleDateFormat的pattern格式一致 示例代码 123456@Testpublic void test9()&#123; DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy_MM_dd&quot;); String format = dateTimeFormatter.format(LocalDate.now()); System.out.println(&quot;format = &quot; + format);//2021_06_09&#125; 格式化 格式化即通过DateTimeFormat格式定义，将LocalXxx类的时间转换为字符串 API 方法 描述 format(TemporalAccessor t) 格式化一个日期、时间，返回字符串 注：TemporalAccessor对象实际就是LocalDate、LocalTime、LoclDateTime对象。它们多实现Temporal接口，Temporal接口继承于TemporalAccessor。 示例代码 123456789101112@Testpublic void test6()&#123; //采取ISO_DATE_TIME格式 DateTimeFormatter formatter = DateTimeFormatter.ISO_DATE_TIME; LocalDateTime localDateTime = LocalDateTime.now(); System.out.println(&quot;localDateTime = &quot; + localDateTime);//2021-06-09T10:20:09.903 //格式化 String format = formatter.format(localDateTime); System.out.println(&quot;format = &quot; + format);//2021-06-09T10:20:09.903&#125; 解析 解析即通过DateTimeFormat格式定义，将字符串转换为LocalXxx类的时间 同理SimpleDateFormat解析概念，解析的格式要和格式化的格式统一，否则失败 API 方法 描述 parse(CharSequence text) 将指定格式的字符序列解析为一个日期、时间 注：CharSequence字符串格式 示例代码 1234567@Testpublic void test9()&#123; String dateStr = &quot;2021_06_09&quot;; DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy_MM_dd&quot;); TemporalAccessor temporalAccessor = dateTimeFormatter.parse(dateStr); System.out.println(&quot;temporalAccessor = &quot; + temporalAccessor);//&#123;&#125;,ISO resolved to 2021-06-09&#125; Date间转换 其他API ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris ZonedDateTime：一个在ISO-8601日历系统时区的日期时间，如 2007-12- 03T10:15:30+01:00 Europe/Paris。 其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，例如： Asia/Shanghai等 Clock：使用时区提供对当前即时、日期和时间的访问的时钟。 持续时间：Duration，用于计算两个“时间”间隔 日期间隔：Period，用于计算两个“日期”间隔 TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整 到“下一个工作日”等操作 TemporalAdjusters : 该类通过静态方法 (firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用 TemporalAdjuster 的实现。 小结 JDK 8前时间类相关 类似JDK 8时间类相关 Date Instant Calendar LocalDate、LocalTime、localDateTime SimpleDateFormat DateTimeFromat Java比较器基础概念 在Java中经常会涉及到多个对象(数组/集合)的排序问题，那么就涉及到对象之间的比较问题。 Java实现对象排序的方式有两种： 自然排序：java.lang.Comparable 定制排序：java.util.Comparator Comparable与Comparator都是接口，即规范，即定义比较标准的规范 Comparable实现原理 对于对象与对象之间，或者说非数值型数据比较，真正比较的还是得基于某个具体的属性数值比较 一个对象的属性有多种，因此比较之前需要定义比较的基准 这个比较的标准正是通过Comparable接口的待实现方法compareTo()所规范的 compareTo()定义规范如下：public int compareTo(Object obj) 返回正整数：this &gt; obj 返回负整数：obj &gt; this 返回零：this = obj 有了compareTo(Object obj)方法就相当于有了用于比较非数值数据的 “&gt;,&lt;,=“号 此时非数值类型对象也可以像数值类型之间两两进行比较 最后如同编写数值类型的排序算法一样，实现排序即可。 String示例例如：字符串之间的比较，字符串属于非数值型数据。比较之前必须定义一个比较的基准。String本身有去实现Comparable接口，进而也就是实现了描述比较基准的compareTo()方法。 String实现compareTo()源码： 通过浏览源码可知，String的比较基准是一个个字符的Unicode数值进行比较(相减)。 若出现不同字符返回的比较结果就是两者之间的差，负数obj大，正数this大 否则就是相同字符串，长度相等返回0，表示comparaTo()规范中的相等含义 123456789101112131415161718public int compareTo(String anotherString) &#123; int len1 = value.length; int len2 = anotherString.value.length; int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; while (k &lt; lim) &#123; char c1 = v1[k]; char c2 = v2[k]; if (c1 != c2) &#123; return c1 - c2; &#125; k++; &#125; return len1 - len2;&#125; 已实现比较类除原理介绍所说的String类已经实现了Comparable接口外JDK还有很多类已经实现了该接口，可进行排序 String：按照字符串中字符的Unicode值进行比较 Character/char：按照字符的Unicode值来进行比较 数值类型、包装类及BigInteger、BigDecimal：按照它们对应的数值大小进行比较 Boolean：true对应的包装类实例大于 false 对应的包装类实例 Date、Time：后面的日期时间比前面的日期时间大 …. 自定义类排序实现步骤基于Comparable规范完成的一套比较流程如下： 非数值型数据实现Comparable&lt;T&gt;接口，泛型T为该实现排序接口的类 实现compareTo方法，基于compareTo方法规范，编写比较的标准。作为比较用的”&gt;,&lt;,=“符号 返回正整数：this &gt; obj 返回负整数：obj &gt; this 返回零：this == obj 此时非数值型数据的比较可以直接调用compareTo(Object obj)方法进行两两比较(如数值型比较一般) 编写排序算法 此时可以选择自己写一个方法通过调用compareTo()实现对一组对象(数组/集合)进行排序，如同数值型数据写排序算法一般。 也可以选择调用JDK提供号的排序方法sort实现(底层快排实现，默认从小到大)： 数组型：Arrays.sort(Object[] a); 集合型：Collections.sort(List&lt;T&gt; list); new TreeSet() new TreeMap() … 注：最终的排序结果的顺序，取决两个因素： 一是，compareTo()中返回判断是正序还是逆序，(如将返回的数值取反，可颠倒一次顺序) 二是，排序算法是基于从小到大还是从大到小进行排序 补充：compareTo规范原本用意也是从小到大，JDK内置sort排序也是从小到大 示例代码 Goods类： 12345678910111213141516171819202122232425262728293031323334package com.website.compare;/** * @author yhd * @create 2021-06-09 15:32 */public class Goods implements Comparable&lt;Goods&gt;&#123; private String name; private double price; public Goods(String name, double price) &#123; this.name = name; this.price = price; &#125; //省略get、set方法与toString方法... //自编写Goods对象的比较规则：默认价格从低到高排序 @Override public int compareTo(Goods o) &#123; if(this.getPrice() &gt; o.getPrice())&#123; return 1;//this &gt; another &#125;else if(this.getPrice() &lt; o.getPrice())&#123; return -1;//another &gt; this &#125;else &#123; return 0;//this == another //还可以进行二级排序：当价格一样时，比较两商品名 //return this.name.compareTo(another.getName()); &#125; //也可以直接不写上面代码，用内置，实现是一样 //return Double.compare(this.getPrice(),another.getPrice()); &#125;&#125; 测试代码 123456789101112131415@Testpublic void test1()&#123; Goods[] goodses = new Goods[4]; goodses[0] = new Goods(&quot;abc&quot;, 1000); goodses[1] = new Goods(&quot;ttt&quot;, 55); goodses[2] = new Goods(&quot;qaa&quot;, 900); goodses[3] = new Goods(&quot;pris&quot;, 2300); Arrays.sort(goodses); System.out.println(Arrays.toString(goodses)); //[Goods&#123;name=&#x27;ttt&#x27;, price=55.0&#125;, // Goods&#123;name=&#x27;qaa&#x27;, price=900.0&#125;, // Goods&#123;name=&#x27;abc&#x27;, price=1000.0&#125;, // Goods&#123;name=&#x27;pris&#x27;, price=2300.0&#125;]&#125; Comparator使用场景 当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码 或者实现了java.lang.Comparable接口的排序规则不适合当前的操作 此时可以考虑使用Comparator的对象来进行定制化的排序，强行对多个对象进行整体排序的比较 如此时，我希望String字符从大到小排序 原理 由于比较器不是待比较数据类型内置的一个排序规则(即非自然排序) 比较器是一个外置的、定制化的排序。因此接口的实现者自然不是待排序数据类型 但核心的原理是一样，即都是规范化一个比较基准定义方法，int compare(T o1, T o2);，因为这是非数值类型进行比较的一个基础，是通用的一个基底。 相比与Comparable/自然排序，比较器的设计的核心就在于把这种比较基准的规范方法与待比较数据类型的关系分离开来，独立开来。使其外界可进行一个任意定制化的排序，这就是比较器！ 自定义比较器 创建一个定制化排序类，实现Comparator&lt;T&gt;接口及其方法。泛型T指明比较的类型，若是调用JDK排序方法，也可用匿名的方式创建。 实现int compare(T o1, T o2)方法，由于非数值类型比较实现原理是一致的，遵循统一规范 返回正整数：o1 &gt; o2 返回负整数：o2 &gt; o1 返回零：o1 == o2 此时非数值型数据的比较可以创建Comparator实现类对象，调用compare方法进行两两比较(如数值型比较一般) 编写排序算法 此时可以选择自己写一个方法通过传入Comparator实现类对象，与待排序对象集合，调用compare()实现对一组对象(数组/集合)进行排序，如同数值型数据写排序算法一般。 也可以选择调用JDK提供的排序方法带Comparator形参的，sort实现(底层快排实现，默认从小到大)： 数组型：Arrays.sort(T[] a, Comparator&lt;? super T&gt; c) 集合型：Collections.sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) new TreeSet() new TreeMap() … 示例代码定制化String排序 使其String比较按从大到小排序 1234567891011@Testpublic void test1()&#123; String[] strs = new String[]&#123;&quot;FF&quot;,&quot;DD&quot;,&quot;EE&quot;,&quot;AA&quot;,&quot;CC&quot;&#125;; Arrays.sort(strs, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return -o1.compareTo(o2);//将比较结果取反，实现倒序 &#125; &#125;); System.out.println(Arrays.toString(strs));//[FF, EE, DD, CC, AA]&#125; 自定义类 自然排序规则：按价格从低到高排序 12345678910111213141516171819202122232425262728293031323334package com.website.compare;/** * @author yhd * @create 2021-06-09 15:32 */public class Goods implements Comparable&lt;Goods&gt;&#123; private String name; private double price; public Goods(String name, double price) &#123; this.name = name; this.price = price; &#125; //省略get、set方法与toString方法... //自编写Goods对象的比较规则：默认价格从低到高排序 @Override public int compareTo(Goods o) &#123; if(this.getPrice() &gt; o.getPrice())&#123; return 1;//this &gt; another &#125;else if(this.getPrice() &lt; o.getPrice())&#123; return -1;//another &gt; this &#125;else &#123; return 0;//this == another //还可以进行二级排序：当价格一样时，比较两商品名 //return this.name.compareTo(another.getName()); &#125; //也可以直接不写上面代码，用内置，实现是一样 //return Double.compare(this.getPrice(),another.getPrice()); &#125;&#125; 定制化排序规则，先按商品名从小到大排序，再按价格从大到小排序 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.website.compare;import org.junit.Test;import java.util.Arrays;import java.util.Comparator;/** * @author yhd * @create 2021-06-09 16:55 */public class ComparatorTest &#123; @Test public void test2()&#123; Goods[] goodses = new Goods[5]; goodses[0] = new Goods(&quot;bbc&quot;, 1000); goodses[1] = new Goods(&quot;ttt&quot;, 55); goodses[2] = new Goods(&quot;aaq&quot;, 900); goodses[3] = new Goods(&quot;aaq&quot;, 1000); goodses[4] = new Goods(&quot;ccd&quot;, 2300); Arrays.sort(goodses, new Comparator&lt;Goods&gt;() &#123; @Override public int compare(Goods o1, Goods o2) &#123;//可以使用内置函数，也可自己写逻辑 int result = o1.getName().compareTo(o2.getName()); if(result == 0)&#123;//二级排序进入条件 //内部可利用已经写好的自然排序的功能规则，一般是这样使用 return -o1.compareTo(o2);//取反,从大到小 //也可以选择废弃自然排序规则，重新编写全新排序逻辑 //return -Double.compare(o1.getPrice(),o2.getPrice());//取反,从大到小 &#125; return result; &#125; &#125;); System.out.println(Arrays.toString(goodses)); //[Goods&#123;name=&#x27;aaq&#x27;, price=1000.0&#125;, // Goods&#123;name=&#x27;aaq&#x27;, price=900.0&#125;, // Goods&#123;name=&#x27;bbc&#x27;, price=1000.0&#125;, // Goods&#123;name=&#x27;ccd&#x27;, price=2300.0&#125;, // Goods&#123;name=&#x27;ttt&#x27;, price=55.0&#125;] &#125;&#125; 自然与定制排序自然排序概念 自然排序可以理解为一种数据类型默认的、内置的、于其绑定的、天生的一个排序规则。 是有该数据类型该类本身去实现的一种比较规则，也可以说属于该数据类型的属性之一 如数值型的自然排序就是：按数字大小本身排序 其他类型的自然排序就是：该数据类型实现Comparable接口的compareTo()方法排序 两者对比定指排序不是该数据类型的一个默认的排序规则，而是经过定制化的比较器排序后得出的一种任意可能性的序列。 从翻译角度 Comparable译为“可比较”，顾名思义，是一种内置化的比较，即自然排序 Comparator译为“比较器”，顾名思义，是一种外置的比较器。 接口方法定义角度 Comparable抽像方法：public int compareTo(Object obj)，this(本身) 与 obj之间的比较 Comparator抽像方法：public int compare(Object obj1,Object obj2)是独立的两个比较 使用逻辑 自然排序的接口设计是一种高可用，高解耦的程序设计方式，能最大程度地减低对象之间的耦合程度。 《Head First面向对象分析与设计》有感 因此尽可能地使所有排序业务都可以基于自然排序实现，是自然排序规则设计的最高境界。 在此基础上，不能仅由自然排序完成的排序业务再由定制排序一一定制化实现。 System System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。 该类位于java.lang包。 由于该类的构造器是private的，所以无法创建该类的对象，即一般用于调用其静态方法 其内部的成员变量和成员方法都是static的，所以也可以很方便 的进行调用。 属性System的成员属性只有三个，都是流对象 静态属性 描述 static PrintStream out “标准”输出流 static InputStream in “标准”输入流 static PrintStream err “标准”错误输出流 方法基本都是静态方法，当工具类使用 静态方法 描述 native long currentTimeMillis() 返回当前时间戳，单位ms void exit(int status) 该方法的作用是退出程序。其中status的值意义：0：代表正常退出，非0：代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等 void gc() 该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。 String getProperty(String key) 通过属性名key获取系统常见的基本信息“java.version“ ： Java运行时环境版本“java.home“ ：Java安装目录“os.name“ ：操作系统的名称“os.version“：操作系统的版本“user.name“：用户的主目录“user.dir“：用户的当前工作目录….. 示例代码getProperty12345@Testpublic void test()&#123; String property = System.getProperty(&quot;java.version&quot;); System.out.println(&quot;property = &quot; + property);//1.8.0_144&#125; Mathjava.lang.Math提供了一系列静态方法用于数学科学计算。其方法的参数和返回值类型一般为double型 //待补充 属性 Math.PI：返回圆周率 方法 abs 绝对值 acos,asin,atan,cos,sin,tan 三角函数 sqrt 平方根 pow(double a,doble b) a的b次幂 log 自然对数 exp e为底指数 max(double a,double b) min(double a,double b) random() ：返回0.0到1.0的随机数，[0.0,1.0) long round(double a) double型数据a转换为long型（四舍五入） toDegrees(double angrad) 弧度—&gt;角度 toRadians(double angdeg) 角度—&gt;弧度 … BigInteger Integer类作为int的包装类，能存储的最大整型值为2^31-1 Long类也是有限的， 最大为2^63-1。， 如果要表示再大的整数，java.math包的BigInteger可以表示不可变的任意精度的整数 “不可变”含义：即BigInteger的运算不能使用普通的+-*/等运算符直接修改，而是只能通过调用BigInteger提供的数据计算方法进行操作，操作完之后也是一个新的BigInteger对象 “任意精度”含义：理论上BigInteger表示的数无上限，想多少位就多少位 构造器 **BigInteger(String val)**：根据字符串构建BigInteger对象 方法BigInteger 提供 所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。 另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、 位操作以及一些其他操作。 public BigInteger abs()：返回此 BigInteger 的绝对值的 BigInteger。 BigInteger add(BigInteger val) ：返回其值为 (this + val) 的 BigInteger BigInteger subtract(BigInteger val) ：返回其值为 (this - val) 的 BigInteger BigInteger multiply(BigInteger val) ：返回其值为 (this * val) 的 BigInteger BigInteger divide(BigInteger val) ：返回其值为 (this / val) 的 BigInteger。整数 相除只保留整数部分 BigInteger remainder(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。 BigInteger[] divideAndRemainder(BigInteger val)：返回包含 (this / val) 后跟 (this % val) 的两个 BigInteger 的数组。 BigInteger pow(int exponent) ：返回其值为 (thisexponent) 的 BigInteger。 … BigDecimal 一般的Float类和Double类可以用来做科学计算或工程计算， 但在商业计算中， 要求数字精度比较高，故用到java.math.BigDecimal类。 BigDecimal类支持不可变的、任意精度的有符号十进制定点数。 概念类似BigInteger 构造器 public BigDecimal(double val) public BigDecimal(String val) 方法 public BigDecimal add(BigDecimal augend) public BigDecimal subtract(BigDecimal subtrahend) public BigDecimal multiply(BigDecimal multiplicand) public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) 示例代码123456789public void testBigInteger() &#123; BigInteger bi = new BigInteger(&quot;12433241123&quot;); BigDecimal bd = new BigDecimal(&quot;12435.351&quot;); BigDecimal bd2 = new BigDecimal(&quot;11&quot;); System.out.println(bi); // System.out.println(bd.divide(bd2));//报错因为结果除不尽，但又为指明余数操作 System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP));//除法，且四舍五入 System.out.println(bd.divide(bd2, 15, BigDecimal.ROUND_HALF_UP));//除法，且保留15位小数&#125; Arrays//待补充 操作数组的工具类：有封装好的快排，二分排等操作(可查看源码学习) method meaning static &lt;T&gt; List&lt;T&gt; asList(T…a) 返回可变参数列表的List集合对象 static&lt;T&gt; T[]copyOf(T[] original, int newLength) 将original数组复制到指定长度的新数组中并返回新数组的引用 boolean equals(int[] a,int[] b) 判断两个数组是否相等。 String toString(int[] a) 打印数组信息 void fill(int[] a,int val) 将指定值均填充到数组之中 void sort(int[] a) 还有很对重载方法，对数组进行排序 int binarySearch(int[] a,int key) 对排序后的数组进行二分法检索指定的值 …..详细查看API Scanner//待补充 1import java.util.Scanner; JUnitTest JUnitTest单元测试类： 快捷步骤： 直接在想要测试的方法上添加@Test注解，通过eclipse提示导入相关内容 详细步骤与细节 中当前工程 - 右键择：build path - add libraries - JUnit 4 - 下一步 单元测试类要求：public、供公共的无参的构造器 单元测试方法的要求：public、无返回值，无形参 单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test; 左键双击单元测试方法名，右键：run as - JUnit Test 执行结果没任何异常：绿条 执行结果出现异常：红条","categories":[],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/tags/JavaSE/"}]},{"title":"多线程编程基础","slug":"多线程编程基础","date":"2021-06-06T09:15:32.000Z","updated":"2021-08-25T15:27:11.591Z","comments":true,"path":"2021/06/06/多线程编程基础/","link":"","permalink":"http://yoursite.com/2021/06/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/","excerpt":"","text":"引言：本文主要基于JDK8介绍JavaSE中多线程基础使用，包含：多线程概念，线程调度、优先级、生命周期等。包含四种创建线程的方式，Thread、Runnable、Callable、线程池技术。介绍了线程安全、线程通信的基础知识，说明了同步监视器的原理。 基础概念程序​ 程序(programm)：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。(如软件安装的物理位置中的文件) 进程进程(process)：程序的一次执行过程，或是正在运行的一个程序。 进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域。(如软件启动后在任务管理器”进程”看到的状态) 有其自身产生、存在合消亡的过程——生命周期 每一个进程占用内存区域中的方法区与堆结构 线程线程(thread)：进程可进一步细化为线程，是一个程序内部的一条执行路径。 若一个进程同一时间并行执行多个线程，就是支持多线程的 线程作为调度和执行的单位，每个线程拥独立的运行栈和程序计数器(pc)，线程切换的开销小。 一个进程中的多个线程共享相同的内存单元/内存地址空间(堆和方法区)，使得线程间通信更简便、高效。但多个线程操作共享的系统资 源可能就会带来安全的隐患。 重点小结： 每个线程，拥有自己独立的：栈、程序计数器 多个线程，共享同一个进程中的结构：方法区、堆。 线程的分类Java中的线程分为两类：一种是守护线程，一种是用户线程。 守护线程是用来服务用户线程的，用户线程都结束了，守护线程才回结束 通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程。 Java垃圾回收就是一个典型的守护线程 单核与多核CPU 单核CPU：其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。只是CPU主频非常高，在快速切换地执行不同的线程。使其感觉像并行的多线程 多核CPU：若是多核的CPU，才能真正更好的发挥多线程的效率 一个Java应用程序java.exe至少有三个线程：main主线程、GC垃圾回收线程、异常处理线程 并行与并发 并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事 并发：一个CPU(采用时间片)同时执行多个任务。比如：多个人做同一件事 多线程的优势 背景：以单核CPU为例，只使用单个线程先后完成多个任务（调用多个方 法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？ 多线程程序的优点： 提高应用程序的响应。对图形化界面更有意义，可增强用户体验。 提高计算机系统CPU的利用率。 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。 多线程的常见需求场景： 程序需要同时执行两个或多个任务。 程序需要实现一些需要等待的任务时，如用户输入、文件读写 操作、网络操作、搜索等。 需要一些后台运行的程序时。 小结：多线程优势总的来说归纳成两个方向： 刚需：界面程序、等不得不进行一些并行操作的程序。 弯道超车的效率提升：虽然对于程序内单一任务多线程还不如单线程。但多任务中多线程利用了时机并行性，形成了流水线加速，远远超过单线程(顺序等待) Thread线程创建 Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread 类来体现。 JDK5.0之前，最原始创建线程的方式有如下两种。 通过继承Thread类方式实现 实现Runnable接口的方式实现 使用步骤继承Thread实现方式步骤如下： 创建一个基础于Thread类的子类 重写Thread类的run()方法，并将执行的代码写在run方法中 以多态的方式，创建Thread类的子类的对象 调用start()方法启动线程 示例代码 继承Thread创建子线程 123456789101112131415161718192021222324//如下创建一个线程打印100以内的偶数class MyThread extends Thread&#123; @Override public void run() &#123; //多线程代码编写处：打印100以内的偶数 for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 == 0) System.out.println(&quot;MyThread-run()：&quot; + i); &#125; &#125;&#125;public class ThreadTest &#123; public static void main(String[] args) &#123; //多态的方式创建 Thread t1 = new MyThread(); t1.start(); //主线程 main，也打印100以内的偶数，多次尝试运行可以发现两个线程存在交替执行 for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 == 0) System.out.println(&quot;main()：&quot; + i); &#125; &#125;&#125; start&amp;run start()方法的作用： 启动当前线程 让 JVM 去调用当前线程的run()方法 启动一个线程，必须调用start()**，不能调用run()**的方式启动线程。 若直接调用run()方法执行代码。则只是在当前线程调用子类重写父类的一个方法而已，属于单线程。 多个线程创建 每一个Thread对象只允许执行一次start方法 若想再启动一个线程执行同一个任务，是不允许连续调用两次start()方法，否则报出IllegalThreadStateException异常。 因此在必须重新创建一个新的Thread子类的对象，调用此**对象的start()**方法。 1234567891011public class ThreadTest &#123; //多次尝试运行可以发现两个线程存在交替执行 public static void main(String[] args) &#123; Thread t1 = new MyThread(); t1.start(); //t1.start();错误写法 Thread t2 = new MyThread();//正确写法，重新创建 t2.start(); &#125;&#125; 匿名方式创建 若子线程只执行一次后无操作，则可以使用匿名子类方式创建 new Thread().start(); new Thread(){&lt;回车&gt;}.start(); 展开后在{}内重写run方法 123456789101112131415161718192021package com.website.exer;/** * @author yhd * @create 2021-06-05 7:50 */public class ThreadDemo &#123; public static void main(String[] args) &#123; //1、new Thread().start(); //2、new Thread()&#123;&lt;回车&gt;&#125;.start(); //3、展开后在&#123;&#125;内重写run方法 System.out.println(Thread.currentThread().getName() + &quot;主线程&quot;); new Thread()&#123; @Override public void run() &#123; System.out.println(getName() + &quot;创建成功&quot;); &#125; &#125;.start(); &#125;&#125; tips：在继承Thread方式创建线程时，在子类中可以直接调用Thread方法(继承作用)，即在run()方法中Thread.currentThread().getName()等价于getName() Thread-API其实Thread类也是实现Runnable接口的 Constructor 构造器 描述 Thread() 创建新的Thread对象 Thread(String threadname) 创建线程并指定线程实例名 Thread(Runnable target) 指定创建线程的目标对象该对象实现了Runnable接口中的run方法 Thread(Runnable target, String name) 创建新的Thread对象 tips：除Thread()外，其他带参数的Thread构造器都需要使用在子类构造器中通过super(形参)显式调用。 method 方法 描述 start() 启动当前线程，让JVM调用当前线程的run() run() 通常需重写此方法，将创建的线程要执行的操作声明在此方法中 currentThread() 静态方法，返回执行当前代码的线程 getName() 获取当前线程的名字(别名，非唯一标识符) setName() 设置当前线程的名字(别名，非唯一标识符) yield() 手动让出当前cpu的执行权，不是结束线程;且有可能下次分配给的还是调用yield的线程 join() 在线程a中通过线程b调用join()，此时线程a就进入阻塞状态，线程b加入执行，直到线程b完全执行完以后，线程a才结束阻塞状态含异常 sleep(long millitime) 静态方法，让当前线程“睡眠”指定的millitime毫秒在指定的millitime毫秒时间内，当前线程是阻塞状态含异常 isAlive() 判断当前线程是否存活 stop() 已过时，当执行此方法时，强制结束当前线程 部分示例代码 join(); 线程调度策略概念线程调度是指按照特定机制为多个线程分配CPU 的使用权。一般为用户级线程调度，与特定的线程调度调度实现。（Java是由JVM中的线程计数器来实现线程调度） 常见调度策略 时间片轮转法：时间片轮转法在进制调度中常用于分时系统 CPU将执行资源均匀分配为若干个相同的时间间隔，称为时间片q 让处于就绪状态的线程轮流使用一段时间片q(当然存在q时间内还没执行完的线程) 通过这种轮流使用相同cpu平均分配出的资源执行完所有线程。 优先级调度(抢占式-线程)： 有别于进程优先级调度，高优先级的线程只是比低优先级的线程先获得CPU资源的概率要高 但并非一定高优先级线程被调用后，甚至被执行完后低优先级的线程才被调用。 Java调度策略 同优先级：先到先服务 + 时间片轮转法 不同优先级：抢占式优先级调度 线程的优先级java优先级范围1~10，下列三个为Thread静态全局常量： Thread.MAX_PRIORITY：10 （最高优先级10） Thread.MIN _PRIORITY：1 （最低优先级1） Thread.NORM_PRIORITY：5 (normal，通常,默认5，主线程默认就是5) 优先级涉及的方法： getPriority() ：返回线程优先值 setPriority(int newPriority) ：改变线程的优先级 优先级线程调度说明： 线程创建时继承父线程的优先级 高优先级线程要抢占低优先级线程cpu的执行权，但低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用。 Runnable线程创建使用步骤 创建多线程的方式二：实现Runnable接口 创建一个实现了Runnable接口的类 实现类去实现Runnable中的抽象方法：run() 创建实现类的对象 创建Thread类的对象，并将此实现类对象作为参数传递到Thread类的构造器中 通过Thread类的对象调用start() 示例代码 实现Runnable接口创建线程 1234567891011121314151617181920212223242526package com.website.exer;//1、创建一个类实现Runnable接口class MyThread implements Runnable&#123; //2、实现接口中的run方法 @Override public void run() &#123; System.out.println(&quot;子线程：&quot; + Thread.currentThread().getName()); &#125;&#125;/** * 通过实现Runnable接口创建子线程 * @author yhd * @create 2021-06-05 10:09 */public class RunnableDemo &#123; public static void main(String[] args) &#123; //3、创建实现类对象 MyThread myThread = new MyThread(); //4、创建Thread类的对象，并将此实现类对象作为参数传递到Thread类的构造器中 Thread thread = new Thread(myThread); //5、调用Thread对象的start()方法启动线程 thread.start(); &#125;&#125; tips：由于实现Runnable接口方式实现线程创建，当前实现类继承的是Object，是没有Thread方法的，因此，只能通过调用Thread.currentThread()后执行Thread相关方法。 start&amp;run Thread对象是如何调用实现类中的run方法？ 深入Thread源码可以看到，run方法执行前先判断target属性是否为空，若不为空调用target的run方法 123456@Overridepublic void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 从Thread类定义中可知，target属性就是Runnable类型的，target.run调用了Runnable的run 123456789publicclass Thread implements Runnable &#123; //... /* What will be run. */ private Runnable target; //...&#125; 相同线程创建当通过实现Runnable方式为一个实现类创建多个线程执行时： 实现类的对象只有一个，即对应的资源只有一份。 此时多个线程共用,争夺这一个实现类的资源 类似对于多个Thread对象来说，该实现类像是一个static静态资源。 若通过Thread方式创建线程且共享一个类的数据时，共享的数据则需要设置成static 因此实现Runnable方式与生俱来更适合来处理多个线程有共享数据的情况 示例代码： 由于一个Thread只能start()一次 因此需要创建一个新的Thread对象 12345678910111213public class RunnableDemo &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); Thread thread = new Thread(myThread); thread.start(); //再创建两个线程 Thread thread2 = new Thread(myThread); Thread thread3 = new Thread(myThread); thread2.start(); thread3.start(); &#125;&#125; 匿名方式创建若子线程只执行一次后无操作，则可以使用匿名实现类方式创建 new Thread().start(); new Thread( new Runnable() { [&lt;回车&gt;] } ).start(); 展开后在{}内实现run方法 12345678public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;子线程&quot; + Thread.currentThread().getName()); &#125; &#125;).start();&#125; Thread与Runnable比较比较创建线程的两种方式。 开发中，优先选择实现Runnable接口的方式 原因是，实现的方式没有类的单继承性的局限性。即如果需要多线程执行的类，原本就还有自己的一套继承体系，则通过继承Thread是无法实现的。 实现的方式更适合来处理多个线程有共享数据的情况 Runnable与Thread联系： Thread本身也是实现Runnable接口：public class Thread implements Runnable 甚至如run这些方法都是Runnable的，Thread也是其实现者而已 如通过继承Thread重写run或实现Runnable本质都一样 综合所述，结合Runnable是一个接口的特性，也能看出整个线程是被上层机制管理的(JVM) 相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中 线程的生命周期生命周期线程一个完整的生命周期中通常要经历如下的五种状态(类进程状态)： 新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已 具备了运行的条件，只是没分配到CPU资源 运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能 阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态 死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束 线程状态转换 Thread.StateJava语言使用Thread类内部枚举类State来描述Java语言中线程的多种状态： 描述的状态：少了就绪状态(操作系统给予的状态)，多了两个等待状态 1234567891011121314151617181920212223publicclass Thread implements Runnable &#123; public enum State &#123; NEW,//新建状态 RUNNABLE,//运行状体，执行完start方法且获取到cpu资源代码执行中 BLOCKED,//阻塞状态 /** * 等待状态 * 调用如下：wait()、join()或LockSupport#park()时候切换至等待 */ WAITING, /** * 指定时长等待状态 * 调用如带参方法：wait(long)、join(long)或 * LockSupport#parkNanos LockSupport.parkNanos * LockSupport#parkUntil LockSupport.parkUntil */ TIMED_WAITING, TERMINATED;//终止(结束)状态，[ˈtɜːmɪneɪtɪd] &#125;&#125; 线程安全基础概念线程安全在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现共享资源的数据污染等意外情况。 同步与互斥在多线程环境中，线程之间相互影响又各自独立运行，彼此之间具有相互协作(同步)或相互竞争(互斥)的关系。 同步：多个线程协同完成一项任务 互斥：多个线程竞争同一资源而发生相互制约 无论是线程同步，还是互斥，都存在共享资源。对共享资源的操作不造成数据污染，则是线程安全所要做的事情。 一般习惯将安全地解决线程同步与线程互斥关系的机制同一称为“线程同步进制”。 线程安全判断若存在共享数据资源，且为多线程操作，则肯定有可能存在线程安全问题。 卖票模型现有引入一个场景，100张票，开启三个线程去售卖，每一个线程每次售卖一张。 Runnable方式注意： Runnable方式Window对象只有一份，ticket不用设置为static 同一任务多个线程的创建方式，作为将实现类作为Thread()构造器的形参传入创建 示例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.website.exer;/** * @author yhd * @create 2021-06-05 15:38 */public class Window implements Runnable&#123; //提供100张车票售卖 private int ticket = 100; //卖票子线程，当目前票数 &gt; 0，则可以卖出一张票 @Override public void run() &#123; while(true)&#123; if(ticket &gt; 0)&#123; //手动阻塞线程100ms，增加错票机率 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; String threadName = Thread.currentThread().getName(); System.out.println(threadName + &quot;卖出：第&quot; + ticket + &quot;张票&quot;); ticket--; &#125;else &#123; break; &#125; &#125; &#125; //开启卖票 public static void main(String[] args) &#123; //创建一个Window对象 Window window = new Window(); //开启三个售卖窗口，一同卖出100张票 Thread thread1 = new Thread(window); Thread thread2 = new Thread(window); Thread thread3 = new Thread(window); thread1.start(); thread2.start(); thread3.start(); &#125;&#125; Thread方式注意： ticket参数需修改为static类型 多个同一任务线程的方式是多态创建 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.website.java;/** * @author yhd * @create 2021-06-05 15:38 */public class Window extends Thread&#123; //提供100张车票售卖 private static int ticket = 100; //卖票子线程，当目前票数 &gt; 0，则可以卖出一张票 @Override public void run() &#123; while(true) &#123; if (ticket &gt; 0) &#123; //手动阻塞线程100ms，增加错票机率 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; String threadName = Thread.currentThread().getName(); System.out.println(threadName + &quot;卖出：第&quot; + ticket + &quot;张票&quot;); ticket--; &#125; else &#123; break; &#125; &#125; &#125; //开始售票 public static void main(String[] args) &#123; //开启三个售卖窗口，一同卖出100张票 Thread thread1 = new Window(); Thread thread2 = new Window(); Thread thread3 = new Window(); thread1.start(); thread2.start(); thread3.start(); &#125;&#125; 错票输出情况打印结果： 如一开始的三张第100张票，末尾的9，9;6，6;3，3;的重票，0，0的错票情况。都是线程不安全的表现。 12345678910111213141516171819Thread-1卖出：第100张票Thread-0卖出：第100张票Thread-2卖出：第100张票Thread-0卖出：第97张票Thread-2卖出：第96张票Thread-1卖出：第95张票...忽略Thread-2卖出：第10张票Thread-1卖出：第9张票Thread-0卖出：第9张票Thread-2卖出：第7张票Thread-1卖出：第6张票Thread-0卖出：第6张票Thread-2卖出：第4张票Thread-1卖出：第3张票Thread-0卖出：第3张票Thread-2卖出：第1张票Thread-0卖出：第0张票Thread-1卖出：第0张票 问题分析卖票过程中，出现了重票、错票，出现了线程的安全问题 理想状态：售票时一一按序卖出，且同时检测到票数为0不操作 极端错误状态：三个线程依次在最后一张票进入if判断后进入阻塞状态，后执行完毕 问题的原因： 是当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。 其实该卖票程序，纯属一个线程互斥的问题，解决方案自然是对互斥共享资源，加锁。 解决思路： 当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。 即使线程a出现了阻塞，也不仍需要等待a执行完一个操作后再给其他线程操作。 线程同步机制​ Java提供的线程同步机制有许多，JDK5.0之前有同步代码块与同步方法，JDK5.0之后 同步代码块使用说明 功能：同步代码块使其多个线程在任意时刻只能有一个线程进入同步代码块中执行，执行完后其他线程才能再进去，以此类推。 语法：synchronized(v.使同步)[ˈsɪŋkrənaɪzd] 123synchronized(同步监视器)&#123; //需要被同步的代码&#125; 共享数据：多个线程共同操作的变量(类操作系统中的互斥共享资源-临界资源概念)。比如场景引入中卖票程序的ticket就是共享数据。 操作共享数据的代码：即为需要被同步的代码。(类操作系统-临界区概念)， 注意同步代码块不能包含多了代码，也不能少了 包含少了同步数据不完整线程不安全，包含多了，有可能退化成为单线程 能完成功能的前提下，能包含代码越少越好，性能越高 同步监视器：俗称：锁。任何一个类的对象，都可以充当锁。但要求多个线程必须要共用同一把锁 同一把锁的含义：参与该同步进制的所有线程都必须含有该对象，而且是同一个的对象。 检测同一把锁：就看多个线程进入synchronize代码块之前同步监视器是不是同一个对象 其实底层原理是：要保证这些参与同步机制的所有线程都是操作在同一个互斥信号量 Runnable方式 由于实现Runnable接口创建多线程的方式，本身只有一个对象。 因此可以考虑使用this充当同步监视器，或内部属性也可以作为锁。 示例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.website.exer;/** * @author yhd * @create 2021-06-05 15:38 */public class Window implements Runnable&#123; //提供100张车票售卖 private int ticket = 100; //任意对象作为锁，且为同一把锁 //private Object obj = new Object();//正确代码，同一把锁 //卖票子线程，当目前票数 &gt; 0，则可以卖出一张票 @Override public void run() &#123; //Object obj = new Object();//错误代码，不是同一把锁 while(true) &#123; //同步代码块 synchronized(this /* obj */) &#123;//正确代码，this指唯一的window对象 if (ticket &gt; 0) &#123; String threadName = Thread.currentThread().getName(); System.out.println(threadName + &quot;卖出：第&quot; + ticket + &quot;张票&quot;); ticket--; &#125; else &#123; break; &#125; &#125; &#125; &#125; //开始售票 public static void main(String[] args) &#123; Window window = new Window(); //开启三个售卖窗口，一同卖出100张票 Thread thread1 = new Thread(window); Thread thread2 = new Thread(window); Thread thread3 = new Thread(window); thread1.start(); thread2.start(); thread3.start(); &#125;&#125; Thread方式 在Thread方式中，由于创建的实现类对象是多份的，则需慎用、甚至不用this做为同步监视器。 一般使用实现类.class(推荐)、或static资源的对象，或保证多个线程操作同一对象的其他对象。 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.website.java;/** * @author yhd * @create 2021-06-05 15:38 */public class Window extends Thread&#123; //提供100张车票售卖 private static int ticket = 100; //任意对象作为锁，且为同一把锁 //private static Object obj = new Object();//正确代码，static同一把锁 //卖票子线程，当目前票数 &gt; 0，则可以卖出一张票 @Override public void run() &#123; //Object obj = new Object();//错误代码，不是同一把锁 while(true) &#123; synchronized(Window.class /* obj */) &#123;//正确代码，Window.class只会加载一次 if (ticket &gt; 0) &#123; String threadName = Thread.currentThread().getName(); System.out.println(threadName + &quot;卖出：第&quot; + ticket + &quot;张票&quot;); ticket--; &#125; else &#123; break; &#125; &#125; &#125; &#125; //开始售票 public static void main(String[] args) &#123; //开启三个售卖窗口，一同卖出100张票 Thread thread1 = new Window(); Thread thread2 = new Window(); Thread thread3 = new Window(); thread1.start(); thread2.start(); thread3.start(); &#125;&#125; 小结 Runnable方式天生具备共享资源特性，属性资源不用static修饰也是一份的 Thread方式共享资源则需要添加static关键字 Runnable常用this作为同步监视器 Thread常用实现类.class作为同步监视器 因此通用的同步监视器应为，实现类.class 同步方法如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。 使用说明 功能：多个线程在任意时刻只能有一个线程进入同步方法中执行 语法：在方法返回值前加入synchronized关键字，使其整个方法声明为同步的 隐式同步监视器： 普通方法：系统默认使用的同步监视器为this 静态方法：系统默认使用的同步监视器为方法所在类.class 1public synchronized void method()&#123;&#125; Runnable方式 由于实现Runnable接口创建多线程的方式，本身只有一个对象。 因此synchronized可以修饰到普通方法上， 由于普通方法，系统默认使用this充当同步监视器，此时的this也正好是唯一的 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940package com.website.exer;/** * @author yhd * @create 2021-06-05 15:38 */public class Window implements Runnable&#123; //提供100张车票售卖 private int ticket = 100; //卖票子线程，当目前票数 &gt; 0，则可以卖出一张票 @Override public void run() &#123; while(true) &#123; method(); &#125; &#125; //将售票操作抽取出为一个方法，并加上synchronized关键字 private synchronized void method()&#123;//系统自动使用this作为同步监视器 if(ticket &gt; 0) &#123; String threadName = Thread.currentThread().getName(); System.out.println(threadName + &quot;卖出：第&quot; + ticket + &quot;张票&quot;); ticket--; &#125; &#125; //开始售票 public static void main(String[] args) &#123; Window window = new Window(); //开启三个售卖窗口，一同卖出100张票 Thread thread1 = new Thread(window); Thread thread2 = new Thread(window); Thread thread3 = new Thread(window); thread1.start(); thread2.start(); thread3.start(); &#125;&#125; Thread方式 在Thread方式中，由于创建的实现类对象是多份的 不能修饰到普通方法上使用，因为this此时不是唯一的 因此synchronized可以只能修饰到静态普通方法上， 由于静态方法，系统默认使用该方法所在类.class充当同步监视器，此时的同步监视器是唯一的 12345678910111213141516171819202122232425262728293031323334353637383940package com.website.java;/** * @author yhd * @create 2021-06-05 15:38 */public class Window extends Thread&#123; //提供100张车票售卖 private static int ticket = 100; //卖票子线程，当目前票数 &gt; 0，则可以卖出一张票 @Override public void run() &#123; while(true) &#123; method(); &#125; &#125; //将售票操作抽取出为一个方法，并加上synchronized关键字 public static synchronized void method()&#123;//正确代码：加静态修饰，同步监视器为Window.class，唯一 //public synchronized void method()&#123;//错误代码：普通方法，同步监视器为this，当前不唯一 if (ticket &gt; 0) &#123; String threadName = Thread.currentThread().getName(); System.out.println(threadName + &quot;卖出：第&quot; + ticket + &quot;张票&quot;); ticket--; &#125; &#125; //开始售票 public static void main(String[] args) &#123; //开启三个售卖窗口，一同卖出100张票 Thread thread1 = new Window(); Thread thread2 = new Window(); Thread thread3 = new Window(); thread1.start(); thread2.start(); thread3.start(); &#125;&#125; 小结 对于Runnable方式，synchronized修饰在普通方法和静态方法都可以实现同步 对于Thread方式，只能修饰在静态方法中才能实现同步 反过来：在静态方法上使用synchronized一定能实现同步 在非静态方法上使用synchronized不一定能实现同步 懒汉式改装原始代码 存在线程安全的懒汉式代码：有可能多个线程挤入(if == null)里 12345678910111213141516171819202122232425package com.website.java;/** * 存在线程安全的懒汉式单例模式 * @author yhd * @create 2021-06-05 21:05 */public class BankTest &#123; //1、私有化构造器 private BankTest()&#123;&#125;; //2、懒汉式，需要才创建，因此先声明不而创建 private static Bank instance; //3、提供外部方法进行实例创建 public static Bank getInstance()&#123; if(instance == null)&#123; instance = new Bank(); &#125; return instance; &#125;&#125;class Bank&#123;&#125; 同步方法改装 由于getInstance()方法刚好是静态方法 因此可兼容Runnable方式和Thread方式的多线程 12345678910111213public class BankTest &#123; private BankTest()&#123;&#125;; private static Bank instance; public static synchronized Bank getInstance()&#123; if(instance == null)&#123; instance = new Bank(); &#125; return instance; &#125;&#125;class Bank&#123;&#125; 同步代码块改装 虽然能解决问题，但是性能低，存在优化空间 123456789101112131415public class BankTest &#123; private BankTest()&#123;&#125;; private static Bank instance; public static Bank getInstance()&#123; synchronized (BankTest.class) &#123; if(instance == null)&#123; instance = new Bank(); &#125; return instance; &#125; &#125;&#125;class Bank&#123;&#125; 高性能同步代码块改装 其实当第一个在线程在线程安全情况下进入到instance==null判断中，实例化了单例后，其他线程不需要再参与到整个进程同步代码块内再执行判断instance == null。 完全可以放开资源几乎并行地获取到单例。 以多人等待实体店开门抢一台首发手机时为场景 初级的同步代码块改装：所有人任意一时刻只允许一个人进入大门，看到有手机时拿走，没手机时从后门离去。 高性能同步代码块改装：所有人任意一时刻只允许一个人进入大门，第一个看到有手机拿走后，门口树立一个牌子，上面写着“已经售空”。其他等待的人不用进入大门也知道要离开了。 代码实现 12345678910111213141516171819public class BankTest &#123; private BankTest()&#123;&#125;; private static Bank instance; public static Bank getInstance()&#123; if(instance == null) &#123; synchronized (BankTest.class) &#123; if (instance == null) &#123; instance = new Bank(); &#125; &#125; &#125; return instance; &#125;&#125;class Bank&#123;&#125; 同步监视器原理同步代码块和同步方法原理一致 synchronized(同步监视器)：其实底层原理是一个互斥信号量(mutex=1)，俗称锁 当线程进入synchronized(同步监视器)的操作：等价于P操作，上锁操作。 当synchronized所包含的代码执行完毕时：等价自定执行V操作，释放锁操作。 使用synchronized(同步监视器)时，不是一定要保证是同一个同步监视器。 上述强调要同一个同步监视器只是解决互斥共享资源只有一个的情况，保证操作的是同一个互斥信号量。 实际开发中，常常出现需要同时上多个不同的锁(同步监视器) 死锁基础概念 死锁：指不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于 阻塞状态，无法继续执行完毕。 死锁的避免与解决方法： 专门的算法、原则 尽量减少同步资源的定义 尽量避免同步资源嵌套 示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.website.java;/** * 死锁演示demo * @author yhd * @create 2021-06-05 22:29 */public class DeadLockDemo &#123; public static void main(String[] args) &#123; StringBuffer sb1 = new StringBuffer(); StringBuffer sb2 = new StringBuffer(); //启动一个子线程，先申请sb1、再申请sb2锁资源 new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized(sb1)&#123;//向sb1锁申请资源 sb1.append(&quot;a&quot;); sb2.append(&quot;1&quot;); //增加发生死锁的概率 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (sb2) &#123;//向sb2锁申请资源 sb1.append(&quot;b&quot;); sb2.append(&quot;2&quot;); System.out.println(&quot;线程1_sb1：&quot; + sb1); System.out.println(&quot;线程1_sb2：&quot; + sb2); &#125; &#125; &#125; &#125;).start(); //再启动一个子线程，先申请sb2、再申请sb1锁资源 new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized(sb2)&#123;//向sb2锁申请资源 sb1.append(&quot;c&quot;); sb2.append(&quot;3&quot;); //增加发生死锁的概率 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (sb1) &#123;//向sb1锁申请资源 sb1.append(&quot;d&quot;); sb2.append(&quot;4&quot;); System.out.println(&quot;线程2_sb1：&quot; + sb1); System.out.println(&quot;线程2_sb2：&quot; + sb2); &#125; &#125; &#125; &#125;).start(); &#125;&#125; 死锁效果：没有任何输出，代码无法执行完毕，一直卡着。 Lock概念 从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。 java.util.concurrent.locks.Lock是一个接口，是控制多个线程对共享资源进行访问的工具。通常我们使用的使其实现类，常用的有ReentrantLock[riːˈɛntrənt]，可以手动加锁、释放锁。它拥有与 synchronized 相同的并发性和内存语义。 锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。 使用说明注意：Lock没有同步监视器，但按使用理解可以把对象本身就作为同步监视器概念理解 创建Lock实现类ReentrantLock对象 ReentrantLock()：空参构造器 ReentrantLock(boolean fair)：当fair = true，公平锁先来先服务，否则按实际竞争 为了防止任何情况下(异常)都能执行释放锁操作，先将要同步的代码用try-finally方式包裹 在try内需要需要同步的代码开始处调用Lock对象的lock()方法 在finally处使用Lock对象调用unlock()方法，释放锁资源 Runnable方式 示例代码： 由于同样以卖票模型为例，因此还要保证Lock是同一把锁。 由于Runnable特性，作为类属性就是同一把锁，不用static修饰 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.website.exer;import java.util.concurrent.locks.ReentrantLock;/** * @author yhd * @create 2021-06-05 15:38 */public class Window implements Runnable&#123; //提供100张车票售卖 private int ticket = 100; //1、创建Lock实现类对象，这里使用ReentrantLock实现类 //且由于Runnable特性，此lock对象为同一把锁 private ReentrantLock lock = new ReentrantLock(); //卖票子线程，当目前票数 &gt; 0，则可以卖出一张票 @Override public void run() &#123; while(true) &#123; try &#123; lock.lock();//2、申请锁资源 if (ticket &gt; 0) &#123; String threadName = Thread.currentThread().getName(); System.out.println(threadName + &quot;卖出：第&quot; + ticket + &quot;张票&quot;); ticket--; &#125; else &#123; break; &#125; &#125; finally &#123; lock.unlock();//3、释放锁资源 &#125; &#125; &#125; //开始售票 public static void main(String[] args) &#123; Window window = new Window(); //开启三个售卖窗口，一同卖出100张票 Thread thread1 = new Thread(window); Thread thread2 = new Thread(window); Thread thread3 = new Thread(window); thread1.start(); thread2.start(); thread3.start(); &#125;&#125; Thread方式 由于同样以卖票模型为例，因此还要保证Lock是同一把锁。 由于Thread特性，作为类属性就不是是同一把锁，需要用static修饰 Lock与synchronized异同synchronized 与 Lock的异同？ 相同点： 二者都可以解决线程安全问题 不同点： 自动管理同步资源监视器：进程进入synchronized机制时自动申请同步监视器(上锁)，在执行完相应的同步代码以后，自动的释放同步监视器(释放锁)。 手动管理同步资源监视器：Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()），因此Lock操作比synchronized方式更加灵活 synchronized含有同步监视器、Lock没有同步监视器 小结同步机制特点 优势：有效解决线程安全问题 劣势：效率低，且有可能造成死锁 操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，因此效率低 不同机制比较 两种同步机制 synchronized：同步代码块、同步方法，JDK5.0之前 Lock：JDK5.0之后 同步机制的性能 原理： 同步代码块包含代码少了线程不安全，包含多了，有可能退化成为单线程 能完成功能的前提下，能包含代码越少越好，性能越高 推荐使用同步机制顺序： Lock ——&gt; 同步代码块 ——&gt; 同步方法 同步监视器 不同机制的同步监视器 同步代码块：显式自定义，推荐Thread用类.class、Runnable使用this 同步方法：static方法，默认使用类.class，非static使用this Lock：Lock对象本身就是同步监视器，若需保证同步监视器唯一性，则就是要保证Lock对象的唯一性 同步监视器原理 底层原理是一个互斥信号量(mutex=1)，俗称锁 当线程进入synchronized(同步监视器)的操作：等价于P操作，上锁操作。 当synchronized所包含的代码执行完毕时：等价自定执行V操作，释放锁操作。 使用synchronized(同步监视器)时，不是一定要保证是同一个同步监视器 只有在操作互斥共享资源数为1个时，才需保证只操作同一个同步监视器 同步方法修饰 对于Runnable方式，synchronized修饰在普通方法和静态方法都可以实现同步 对于Thread方式，只能修饰在静态方法中才能实现同步 反过来：在静态方法上使用synchronized一定能实现同步 在非静态方法上使用synchronized不一定能实现同步 共享资源唯一性 多线程操作与共享资源在同一个类时 Runnable方式天生具备共享资源特性，属性资源不用static修饰也是一份的 Thread方式共享资源则需要添加static关键字 多线程操作与共享资源不是同一个类时 可以在多线程操作类中将共享资源类作为类属性并通过构造器引入 线程通信基础概念这里通过借鉴“进程的通信”一概念来阐述“线程的通信”。 线程通信：当多个线程协调一致完成一个作业时，常需要交换一定数量的信息(状态、数值等) 协调工作： 线程协调工作：如如两个线程交替执行，先后执行，等待执行等等…. 线程同步是指通过修改线程信号量，可向另一个线程资源表明临界资源是否可用，本身就是一种简单的通信方式 交换数据： 信号量机制作为同步工具是卓有成效的，但作为通信工具则不够理想，因为其效率低，称为低级通信方式。 此时线程通信更强调与多线程的各种协调工作。 synchronized线程通信使用说明如下方法使用说明： 均定义在java.lang.Object类中 均只能在synchronized范围内使用，即同步代码块或同步方法内使用 以下方法的调用对象默认均是当前synchronized的同步监视器对象 若当前的同步监视器和调用如下方法的对象不是同一个对象，则会报出IllegalMonitorStateException非法监视器异常。因此建议同步监视器定义如下： 在java中，方法调用没有显式写出调用对象，则默认普通方法为this，静态方法为定义类.class 一般定义同步监视器时，配合上述的调用方法默认机制设置同步监视器。调用时就不用写调用对象 同步代码块： 显式定义：Thread建议继承类.class，Runnable建议this 同步方法： 系统隐式定义：同，同步代码块的显示定义 API 方法 描述 wait() 使其调用wati()方法的线程阻塞并释放该线程的所有同步监视器(锁) notify() 会唤醒处于阻塞状态的一个线程如果有多个线程被wait，则唤醒优先级高的那个 notifyAll() 唤醒所有处于阻塞状态的线程 交替打印 两个线程交替打印0~100数字 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.website.java;/** * 线程通信案例：两个线程交替打印：1~100 * 前提是在线程安全的情况下 * @author yhd * @create 2021-06-06 9:31 */class Number implements Runnable&#123; private int number = 1; //任意对象充当锁 //当使用obj作为同步监视器时，wait、notify、notifyAll均需用obj对象调用 //private Object obj = new Object(); @Override public void run() &#123; while (true)&#123; synchronized (this /*obj*/)&#123; //2、线程获取到锁进入后首先尝试唤醒另一个阻塞状态的线程 //若不存在阻塞状态的其他线程，则相当于空操作 notify();//obj.notify(); //打印一个数字 if(number &lt;= 100)&#123; System.out.println(Thread.currentThread().getName() + &quot; : &quot; + number); number++; &#125;else &#123; break; &#125; //1、一个线程操作完后，通过调用wait()进入阻塞状态(并释放锁) try &#123; wait();//obj.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;public class CommunicationTest &#123; public static void main(String[] args) &#123; Number number = new Number(); Thread thread1 = new Thread(number); Thread thread2 = new Thread(number); thread1.setName(&quot;线程1&quot;); thread2.setName(&quot;线程2&quot;); thread1.start(); thread2.start(); &#125;&#125; wait&amp;sleep sleep() 和 wait()的异同？ 相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。 不同点： 方法定义位置：Thread类中声明sleep() , Object类中声明wait() 调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中 关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。 Lock线程通信略 生产者与消费者问题 示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.website.exer;/** * 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处 * 取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图 * 生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通 * 知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如 * 果店中有产品了再通知消费者来取走产品。 * @author yhd * @create 2021-06-06 10:08 *///店员对象class Clerk&#123; private static final int MAX_CAPACITY = 20; private int capacity = 0;//当前店员产品数 //进货函数，当库存满时，让生产者进程等待 //由于Clerk对象只有一份，this能保证同步监视器的唯一性 public synchronized void stock() throws InterruptedException &#123; if(capacity &lt; MAX_CAPACITY)&#123; capacity++; //Thread.sleep(500); System.out.println(Thread.currentThread().getName() + &quot;进货1&quot; + &quot;,当前库存&quot; + capacity); notify();//唤醒有可能被阻塞的消费者线程 &#125;else&#123; System.out.println(&quot;库存已满，请&quot; + Thread.currentThread().getName() + &quot;等待&quot;); wait();//阻塞生产者线程，让其等等，等候消费者线程将其唤醒 &#125; &#125; //售卖商品函数，当库存为0时，让消费者进程等待 //由于Clerk对象只有一份，this能保证同步监视器的唯一性 public synchronized void sell() throws InterruptedException &#123; if(capacity &gt; 0)&#123; capacity--; //Thread.sleep(500); System.out.println(Thread.currentThread().getName() + &quot;消费1&quot; + &quot;,当前库存&quot; + capacity); notify();//唤醒有可能被阻塞的生产者线程 &#125;else&#123; System.out.println(&quot;库存已空，请&quot; + Thread.currentThread().getName() + &quot;等待&quot;); wait();//阻塞消费者线程，让其等等，等候生产者线程将其唤醒 &#125; &#125;&#125;//消费者class Customer implements Runnable&#123; private Clerk clerk; public Customer(Clerk clerk)&#123; this.clerk = clerk; &#125; //从店员不断那买入商品 @Override public void run() &#123; while(true)&#123; try &#123; clerk.sell();//在店员处买入商品 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//生产者对象class Producer implements Runnable&#123; private Clerk clerk; public Producer(Clerk clerk)&#123; this.clerk = clerk; &#125; //不断往店员那进货商品 @Override public void run() &#123; while(true)&#123; try &#123; clerk.stock();//往店员那进货 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//多线程执行public class ProductTest &#123; public static void main(String[] args) &#123; Clerk clerk = new Clerk();//共享资源 Producer producer = new Producer(clerk); Customer customer = new Customer(clerk); //创建线程执行操作 Thread thread1 = new Thread(producer); Thread thread2 = new Thread(customer); thread1.setName(&quot;生产者&quot;); thread2.setName(&quot;消费者&quot;); thread1.start(); thread2.start(); &#125;&#125; 小结线程安全与通信比较 线程安全的同步监视器身份的是方法的调用者，即调用对象 线程通信的操作对象是执行代码的线程，而非调用代码的对象 如wait、notify、sleep是看当前执行代码的线程是谁，而不是执行代码的对象是谁 互斥关系：用线程安全解决，synchronized 或 Lock 同步关系：用线程通信解决，wait()，notify()，notifyAll()，或Thread.join() 锁释放操作释放锁操作 当前线程的同步方法、同步代码块执行结束。 当前线程在遇到break、return终止了同步代码块、同步方法中、 但该方法的继续执行。 当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。 当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。 不会释放锁操作 线程执行同步代码块或同步方法时，程序调用Thread.sleep()、 Thread.yield()方法暂停当前线程的执行 线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程 挂起，该线程不会释放锁（同步监视器）。 应尽量避免使用suspend()和resume()来控制线程 多线程编程分析分析 是否是多线程问题？ 是否存在共享资源，是什么？ 哪些线程操作是互斥关系，哪些是同步关系 互斥关系：用线程安全解决，synchronized 或 Lock 同步关系：用线程通信解决，wait()，notify()，notifyAll()，或Thread.join() 步骤 共享资源和多线程操作不是同一个类(常用) 多线程操作类 实现多线程操作，extends Thread，或 implements Runnable 声明共享资源属性 通过构造器的方式传入共享资源的引用，依次来保证其共享资源的同一性 在run方法里通过共享资源对象调用共享资源类中共享资源的操作方法 共享资源类中 由于多线程操作类通过引入该类对象方式操作共享资源，因此共享资源类中的共享资源不需要static修饰 在共享资源类中定义多线程操作需调用的方法操作共享资源 对于操作共享资源的方法，需要利用线程安全与通信知识来控制多线程的操作 参考代码：线程通信中的”生产者与消费者问题“实现代码 共享资源和多线程操作都是同一个类中执行(不常用) 将其类直接实现多线程：Thread或Runnable 将共享资源作为该类的属性：Thread用static修饰，Runnable则不用 参考代码：经线程安全改造的卖票模型 Callable线程创建 JDK5.0之后新增了实现Callable接口，与使用线程池创建多线程的方式 使用步骤实现Callable接口创建多线程的步骤如下： 创建一个实现Callable接口的实现类，可以定义泛型用来表示返回值的类型 实现call方法，将此线程需要执行的操作声明在call方法中 创建实现类的对象 创建FutureTask对象，并将Callable实现类对象作为参数传递到FutureTask类的构造器中，可以定义泛型用来表示返回值的类型 创建Thread类的对象，并将Future实现类对象作为参数传递到Thread类的构造器中 通过Thread类的对象调用start()启动线程 若有需要获取call方法中的返回值：线程启动执行完毕后，通过调用Future实现类对象的get();方法获取call的返回值参数。 示例代码 创建一个子线程，将0~100以内的偶数打印出来并累加其结果返回 123456789101112131415161718192021222324252627282930313233343536373839404142package com.website.java;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;/** * @author yhd * @create 2021-06-06 15:42 */public class ThreadNum implements Callable&lt;Integer&gt;&#123;//指明返回值类型 @Override public Integer call() throws Exception &#123; int sum = 0; for(int i = 0;i &lt;= 100;i++)&#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + &quot; i = &quot; + i); sum += i; &#125; &#125; return sum; &#125; public static void main(String[] args) &#123; //启动线程 ThreadNum threadNum = new ThreadNum(); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(threadNum); Thread thread = new Thread(futureTask); thread.start(); //获取线程执行的返回值结果 try &#123; Integer integer = futureTask.get(); System.out.println(&quot;累加和结果为：integer = &quot; + integer); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Callable接口相比Runnable，Callable的功能更强大 相比run()方法，call()方法可以有返回值 方法可以抛出异常 支持泛型的返回值 需要借助FutureTask类，比如获取返回结果 FutrueTask 可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等操作 FutrueTask是Futrue接口的唯一的实现类，同样也支持泛型操作 FutureTask同时实现了Runnable, Future接口。因此它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。 注意，使用的时候要用FutureTask，Future没有实现任何接口 线程池创建线程​ 由于在实际开发中需大量创建线程操作，如一些资源的异步加载，而这些资源数是非常庞大的，如果没有给资源加载都是创建一个新的线程去执行，消耗的资源是很大的。因此基本很少会自己亲自的去造一个个线程，实际效率不好，开发中大多数都是使用线程池技术。 基本概念 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程， 对性能影响很大。 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具、数据库连接池、缓冲池技术 好处： 提高响应速度（减少了创建新线程的时间） 降低资源消耗，提供资源的重用率（重复利用线程池中线程，不需要每次都创建） 便于线程管理 corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后会终止 … ExecutorsJDK 5.0起提供了线程池相关API：ExecutorService 和 Executors Executors是一个工具类、线程池的工厂类，用于创建并返回不同类型的线程池 方法 描述 Executors.newCachedThreadPool() 创建一个可根据需要创建新线程的线程池 Executors.newFixedThreadPool(n) 创建一个可重用，固定线程数量的线程池 Executors.newSingleThreadExecutor() 创建一个只有一个线程的线程池 Executors.newScheduledThreadPool(n) 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行 ExecutorServiceExecutorService：真正的线程池接口，常见子类ThreadPoolExecutor 方法 描述 void execute(Runnable command) 执行任务/命令，没有返回值，一般用来执行Runnable Future submit(Callable task) 执行任务，有返回值，一般又来执行 Callable void shutdown() 关闭连接池 使用步骤 通过Runnable(含Thread)或Callable的方式创建好线程执行的内容 通过调用Executors工具类的静态方法创建线程池对象 可以选择强制转换为ThreadPoolExecutor类型进行一些线程池的管理操作 通过调用线程池对象的execute或submit方法去执行多线程操作的执行体 示例代码1234567891011121314151617181920212223242526272829303132package com.website.java;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * @author yhd * @create 2021-06-05 21:56 */public class ThreadTest implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; 多线程执行&quot;); &#125; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newFixedThreadPool(10); //可选择性对线程池进行参数设置，强制转换为ThreadPoolExecutor实现类， //ThreadPoolExecutor tpe = (ThreadPoolExecutor) executorService; //tpe.setCorePoolSize(20); //tpe.setKeepAliveTime(); ThreadTest thread1 = new ThreadTest(); ThreadTest thread2 = new ThreadTest(); executorService/* tpe */.execute(thread1);//执行线程 executorService/* tpe */.execute(thread2);//执行线程 executorService/* tpe */.shutdown();//关闭线程池 &#125;&#125;","categories":[],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/tags/JavaSE/"}]},{"title":"Gitee-API使用HTTP协议有感","slug":"Gitee-API使用HTTP协议有感","date":"2021-06-04T09:31:32.000Z","updated":"2021-08-25T15:27:11.561Z","comments":true,"path":"2021/06/04/Gitee-API使用HTTP协议有感/","link":"","permalink":"http://yoursite.com/2021/06/04/Gitee-API%E4%BD%BF%E7%94%A8HTTP%E5%8D%8F%E8%AE%AE%E6%9C%89%E6%84%9F/","excerpt":"","text":"原始数据报分析fiddler抓取本地包通过浏览器或Windows设置本地代理为ip:8888，ip可尝试127.0.0.1或当前网络情况的其他ip尝试。由于fiddler默认的代理端口号就是8888。 文本类型测试分别发出GET和POST请求，请求的参数均为 param1：aaa param2：bbb chinese：中文 服务器响应的数据均为：aaa&lt;br/&gt;bbb&lt;br/&gt;中文&lt;br/&gt; GET GET请求原始数据报： 12345678910GET http://127.0.0.1:8080/16_TestCode/httpTestServlet?param1=aaa&amp;param2=bbb&amp;chinese=%E4%B8%AD%E6%96%87 HTTP/1.1Host: 127.0.0.1:8080User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:88.0) Gecko/20100101 Firefox/88.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: keep-aliveReferer: http://127.0.0.1:8080/16_TestCode/Cookie: JSESSIONID=F4B23411BF1A0000940BB19B223558F7Upgrade-Insecure-Requests: 1 GET响应原始数据报 12345678HTTP/1.1 200Content-Type: text/html;charset=UTF-8Content-Length: 27Date: Fri, 04 Jun 2021 09:06:25 GMTKeep-Alive: timeout=20Connection: keep-aliveaaa&lt;br/&gt;bbb&lt;br/&gt;中文&lt;br/&gt; POST POST请求原始数据报： tips：”中文”字符串的URL编码为”%E4%B8%AD%E6%96%87” 123456789101112131415POST http://127.0.0.1:8080/16_TestCode/httpTestServlet HTTP/1.1Host: 127.0.0.1:8080User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:88.0) Gecko/20100101 Firefox/88.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 48Origin: http://127.0.0.1:8080Connection: keep-aliveReferer: http://127.0.0.1:8080/16_TestCode/Cookie: JSESSIONID=F4B23411BF1A0000940BB19B223558F7Upgrade-Insecure-Requests: 1param1=aaa&amp;param2=bbb&amp;chinese=%E4%B8%AD%E6%96%87 POST响应原始数据报 12345678HTTP/1.1 200Content-Type: text/html;charset=UTF-8Content-Length: 27Date: Fri, 04 Jun 2021 09:06:28 GMTKeep-Alive: timeout=20Connection: keep-aliveaaa&lt;br/&gt;bbb&lt;br/&gt;中文&lt;br/&gt; 文件类型测试GET如请求首页操作，获取整个html文档 GET请求原始报文 1234567891011GET http://127.0.0.1:8080/16_TestCode/httptest.html HTTP/1.1Host: 127.0.0.1:8080User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:88.0) Gecko/20100101 Firefox/88.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: keep-aliveCookie: JSESSIONID=F4B23411BF1A0000940BB19B223558F7Upgrade-Insecure-Requests: 1If-Modified-Since: Fri, 04 Jun 2021 09:16:01 GMTIf-None-Match: W/&quot;1180-1622798161524&quot; GET响应原始报名 12345678910111213141516171819202122232425262728293031323334353637383940414243444546HTTP/1.1 200Accept-Ranges: bytesETag: W/&quot;1184-1622798265215&quot;Last-Modified: Fri, 04 Jun 2021 09:17:45 GMTContent-Type: text/htmlContent-Length: 1184Date: Fri, 04 Jun 2021 09:22:06 GMTKeep-Alive: timeout=20Connection: keep-alive&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;img/testImg.jpg&quot;&gt;图片&lt;/a&gt;&lt;br/&gt; &lt;a href=&quot;/16_TestCode/httpTestServlet?param1=a&amp;param2=b&amp;chinese=中文&quot;&gt;get请求&lt;/a&gt; &lt;br/&gt; get请求表单 &lt;form action=&quot;/16_TestCode/httpTestServlet&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;param1&quot; value=&quot;aaa&quot;&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;param2&quot; value=&quot;bbb&quot;&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;chinese&quot; value=&quot;中文&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;br/&gt; post请求表单 &lt;form action=&quot;/16_TestCode/httpTestServlet&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;param1&quot; value=&quot;aaa&quot;&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;param2&quot; value=&quot;bbb&quot;&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;chinese&quot; value=&quot;中文&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; post文件上传 &lt;br/&gt; &lt;form action=&quot;/16_TestCode/httpTestServlet&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; POST通过表单进行文件上传，表单使用分段二进制流形式上传enctype=&quot;multipart/form-data&quot; POST请求原始报文 123456789101112131415161718192021222324252627POST http://127.0.0.1:8080/16_TestCode/httpTestServlet HTTP/1.1Host: 127.0.0.1:8080User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:88.0) Gecko/20100101 Firefox/88.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------148424116915262504472899372157Content-Length: 399Origin: http://127.0.0.1:8080Connection: keep-aliveReferer: http://127.0.0.1:8080/16_TestCode/httptest.htmlCookie: JSESSIONID=F4B23411BF1A0000940BB19B223558F7Upgrade-Insecure-Requests: 1-----------------------------148424116915262504472899372157Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;testZip.zip&quot;Content-Type: application/x-zip-compressedPK\u0003\u0004 M R Fw \u0002 \u0002 testZip.txt21PK\u0001\u0002? M R Fw \u0002 \u0002 $ testZip.txt \u0001 \u0018 r #Y \u0001s #Y \u0001 $` #Y \u0001PK\u0005\u0006 \u0001 \u0001 ] + -----------------------------148424116915262504472899372157-- POST响应原始报文 12345678HTTP/1.1 200Content-Type: text/html;charset=UTF-8Content-Length: 27Date: Fri, 04 Jun 2021 09:26:44 GMTKeep-Alive: timeout=20Connection: keep-alivenull&lt;br/&gt;null&lt;br/&gt;null&lt;br/&gt; HTTP数据传递 URL请求参数中若包含中文字符，则需要通过URL编码。平时浏览器自动识别完成转换后才发起请求，如果自己写代码，则需要手动转换后拼凑URL再发出请求。 其实对于post请求，任何类型提交类型(前端中input 中name或上传文件的分段流方式)，或中直接的application/json;charset=UTF-8，其实都是在请求头末尾空行后的追加的二进制数据，理论上不指定contentType也是可以顺利读取(contentType)只是方便告诉服务器解析成什么文件 URL传递参数没要求一定要通过?开头键值对方式传递形参，这常用的浏览器传参格式。其实URL本身就是传递字符串，服务器接收后，就是从字符串中获取一个个数据而已，纯正的字符串处理操作而已，其实以前写thinkphp接口时，老师也有说，不一定要键值对，可以按顺序读取 HTTP报文一切都是字符串流(请求行、头、数据)，本质是二进制流 get请求相当于只能通过URL传递参数的请求，POST请求则是在get请求基础上，还支持了在请求头末尾空行后的二进制流传送数据 GiteeAPI使用有感官方信息初分析官方API查看接口信息如下 API_URL：Post：https://gitee.com/api/v5/repos/{owner}/{repo}/contents/{path} 必须参数详情表： Parameter Description Type Data Type owner* 仓库所属空间地址(企业、组织或个人的地址path) path string repo* 仓库路径(path) path string path* 文件的路径(其实是仓库下的路径+文件名) path string content* 文件内容(文件名), 要用 base64 编码 formData string message* 提交信息 formData string 首先请求类型为POST 必须提交的参数有5个 {owner}、{repo}、{path} {xxx}，有花括号表示这些参数是用户输入的。像content不是输入参数，而是固定的。 参数详情表中可以从的type属性看出是path类型，即通过URL路径传递的参数。 contents、message： 除了上面三个参数是通过URL路径传递的，这两个在POST请求中如何传递？从参数详情表中看出这两个参数是formData类型，属于表单数据。写代码时，如何把数据放入“表单”中传递？，原始代码发起请求，表单在哪？其实就是POST请求传输数据的载体。 测试与分析官方网页API测试 Parameters value owner yihangdeng repo* net-resources path* /PersonnelDocument/test.txt content* test.txt message* test curl：测试结果 curl -X POST –header ‘Content-Type: application/json;charset=UTF-8’ ‘https://gitee.com/api/v5/repos/yihangdeng/net-resources/contents/%252FPersonnelDocument%252Ftest.txt&#39; -d ‘{“content”:”AAAAAA”,”message”:”test”}’ 其实除验证上述分析外，从curl中能看出官方还没给出重要信息： 已知信息： 请求类型Post 通过URL传参的部分数据 新信息： 从&#39;&#123;&quot;content&quot;:&quot;AAAAAA&quot;,&quot;message&quot;:&quot;test&quot;&#125;&#39;与application/json;charset=UTF-8中看到三个formData类型的数据是封装成JSON格式，且为UTF-8编码，发送出去的。 原始HTTP数据报分析1234567891011121314POST https://gitee.com/api/v5/repos/yihangdeng/net-resources/contents/%252FPersonnelDocument%252Ftest.txt HTTP/1.1Host: gitee.comUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:87.0) Gecko/20100101 Firefox/87.0Accept: application/json, text/plain, */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflate, brContent-Type: application/json;charset=utf-8Content-Length: 87Origin: https://gitee.comConnection: keep-aliveReferer: https://gitee.com/api/v5/swaggerCookie: oschina_new_user=false; yp_riddler_id=a17b654c-c3b6-4da1-ae2e-f46b440c38a9; remote_way=http; Serve_State=true; user_locale=zh-CN; remember_user_token=BAhbCFsGaQNIl3BJIiIkMmEkMTAkY3p2b2UzbmhKYzJjZDQ0UGNwVS9NLgY6BkVUSSIXMTYxODI5NzIyNC44MjcwNTEyBjsARg%3D%3D--d098e954ed8786cfed3d584ca9a3187251d15ed2; gitee_user=true; gitee-session-n=RC9VMXJGVXFsWnI1RWhXL3phYyt1TDNEZlF1bENteE1VWjhhSmExMy81RlpVbnJaTW12amVQaWhyc3pBMis4bzVuN283L3VyV3g4TGJFc2xqZVdZdWF1aWtDSzN5dE5JZndmN2hMZVFTYm0rbkFubFh0ZFhCL1FBY3hXb093czFURGpNcnZuUWZ6U3RtNlBIa1gxVW9HdGVEcEtoK1NrZjlkQjIxM0VUOXYrRHMxbVNTS3VnTlJKVElINjNCelJQeWVRcjg2dlVPbGt0VGRFZm5NSkN1ZU5zNHNlc2gwS2IraksyQ25xTlI4Wm9lMEFERFdpbmduQjVlUUtnVVg2OTI5VmYwZ3o1dVQ1SGF0ZGhZTHgxOHFJUjYxNThEek5vMHV1Tlpvb1ZWN0N5UUc4SFhHM05FbGo2V2FlemlBNlN3dkx3UG14L3JLbFl6WEJjc2t1N2FtbVUvQjRpZXUzYWJZK2c5R2poWkxZPS0tYnFybmZDSU5BUnZJQzErdVF3K2V1dz09--0c976b2431be4a2c3d2b7f3369b18d5e67ffb1b9; tz=Asia%2FShanghai&#123;&quot;content&quot;:&quot;AAAAAA&quot;,&quot;message&quot;:&quot;test&quot;&#125; 结论 Post请求，且{owner}、{repo}、{path}这三个参数通过URL的方式传送 content、message 则以json格式，通过Post请求中最原始的空行后二进制数据传送 注意： 像这种URL传递参数没有以?开头键值对方式(浏览器默认方式)传递形参(即只有值)的方式 参数顺序是有严格要求的，因为无法通过键值对的方式定位参数，只能固定参数的输入顺序 像{path}这个参数，参数本身含 / 与中文，的特殊字符，在作为URL参数前一定要进行URL编码，编码类型具体看接口要求(一般UTF-8)","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"原生Web技术方案","slug":"原生Web技术方案","date":"2021-06-03T02:31:32.000Z","updated":"2021-08-25T15:27:11.732Z","comments":true,"path":"2021/06/03/原生Web技术方案/","link":"","permalink":"http://yoursite.com/2021/06/03/%E5%8E%9F%E7%94%9FWeb%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/","excerpt":"","text":"引言：原生Web技术方案涵盖了MVC设计模式、数据域使用、表单重复提交、分页技术、验证码、权限管理、事务管理、常见电商web功能模块、前后端分离技术、i18n国际化技术等。在于原生实现思路的体现，实现的代码部分可能存在bug，请注意。 MVC模式基础概念MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。 Model（模型） ：代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。 View（视图） ：代表模型包含的数据的可视化。 Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。 包命名规范 层次 包名 含义 实体bean对象 com.website.pojo/entity/domain.bean JavaBean类 dao持久层 com.website.dao Dao接口 com.website.dao.impl Dao接口实现类 web层 com.website.web/servlet/controller 视图控制层 service层 com.website.service service接口包 com.website.service.impl service接口实现类 测试包 com.website.test/junit 测试类 工具类 com.website.utils 工具类 后端编码流程tips：这里指编码流程阶段，指后端程序员工作角度，非整个软件的开发流程(需求分析等等)。 建库建表 编写JavaBean 后续准备测试类 编写DAO 业务service 视图控制层 建库建表分析页面内容，提取需要的数据表与数据库结构 JavaBean为每个数据库表建立一个JavaBean 测试类 以下开始，每编写一个功能类代码类，都需对应测试一遍(XxxTest.class，testMethod())，或通过IDE快速生成junit测试类。 注意，测试不仅要测试正确的返回值情况，还要测试错误的返回值情况是否符合预期 测试要全面，正确的所有情况，错误的所有情况 购物车类测试，可以进行累加测试(即复制上一个功能基础上继续做新的测试) com.website.test.BaseDaoTest 12345678910111213141516171819202122232425262728293031//自创建测试类public class BaseDaoTest extends BaseDao &#123; @Test public void testUpdate()&#123; String sql = &quot;insert into t_user(`username`,`password`,`email`) values(?,?,?)&quot;; int status = update(sql,&quot;priscilla&quot;,&quot;123&quot;,&quot;11111111@qq.com&quot;); System.out.println(&quot;status = &quot; + status); &#125; @Test public void testQueryForOne()&#123; String sql = &quot;select * from t_user where id = ?&quot;; User user = queryForOne(User.class, sql, 1); System.out.println(&quot;user = &quot; + user); &#125; @Test public void testQueryForList()&#123; String sql = &quot;select * from t_user&quot;; List&lt;User&gt; users = queryForList(User.class, sql); System.out.println(&quot;users.toString() = &quot; + users.toString()); &#125; @Test public void testQueryForValue()&#123; String sql = &quot;select username from t_user where id = ?&quot;; Object username = queryForValue(sql, 1); System.out.println(&quot;username = &quot; + username.toString()); &#125;&#125; com.website.test.UserServiceTest 1234567891011121314151617181920212223242526272829//IDEA自动生成的测试public class UserServiceTest &#123; private UserService service = new UserServiceImpl(); @Test public void login() &#123; User login = service.login(new User(&quot;admin&quot;, &quot;password&quot;, &quot;12345678@qq.com&quot;)); if(login == null)&#123; System.out.println(&quot;登录失败&quot;); &#125;else&#123; System.out.println(&quot;登录成功&quot;); &#125; &#125; @Test public void existsUsername() &#123; boolean flag = service.existsUsername(&quot;admin&quot;); if(flag)&#123; System.out.println(&quot;用户已存在&quot;); &#125;else&#123; System.out.println(&quot;用户不存在，可用&quot;); &#125; &#125; @Test public void registerUser() &#123; service.registerUser(new User(&quot;Jacky&quot;,&quot;333&quot;,&quot;333@qq.com&quot;)); service.registerUser(new User(&quot;Jacky&quot;,&quot;333&quot;,&quot;333@qq.com&quot;)); &#125;&#125; DAO编写DAO (DataAccessobjects 数据存取对象)是指位于业务逻辑和持久化数据之间实现对持久化数据的访问。通俗来讲，就是将数据库操作都封装起来。DAO相关类与文件操作涉及如下 jdbc.properties dbcUtils BaseDao 定制化业务Dao(XxxxDao接口及、XxxxDao实现类) .properties 创建存储jdbc连接参数的.properties文件， 编码前提准备好第三方jar包，如最基本数据库连接驱动jar包，其次有可能第三方(连接池、DbUtils等) jdbc.properties 123456username=rootpassword=rooturl=jdbc:mysql://localhost:3306/book1driverClassName=com.mysql.jdbc.DriverinitialSize=5maxActive=10 JdbcUtils编写JdbcUtils工具类，仅用于获取与回收数据库连接(一般项目经历准备好) com.website.utils.JdbcUtils.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.website.utils;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.InputStream;import java.sql.Connection;import java.util.Properties;/** * 用于获取数据库连接，通过druid数据库连接池实现 * 1、导包 * - druid-1.1.9.jar 数据库连接池 * - mysql-connector-java * @author yhd * @create 2021-04-11 11:21 */public class JdbcUtils &#123; private JdbcUtils()&#123;&#125;//私有化构造器 private static DataSource dataSource = null;//可多态，也可DruidDataSource //0、JdbcUtils均为静态方法，私有化构造器后通过static代码块实现初始化操作 static&#123; //6、处理编译异常问题 try &#123; //2、创建Properties对象， Properties properties = new Properties(); //4、获取配置文件的输入流对象 InputStream inputStream = JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); //3、已知Properties核心需调用load方法加载配置文件数据，得知需输入流 properties.load(inputStream); //1、创建通过DruidDataSourceFactory获取数据库连接池对象，得知需Properties对象 dataSource = DruidDataSourceFactory.createDataSource(properties); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取数据库连接对象，若获取失败返回null * @return */ public static Connection getConnection()&#123; //3、因处理异常而声明对象 Connection con = null; //2、处理异常问题 try &#123; //1、直接从数据库连接池获取连接对象并返回 con = dataSource.getConnection(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return con; &#125; /** * 释放数据库连接，回收到数据库连接池 * @param connection */ public static void close(Connection connection)&#123; try &#123; if(dataSource != null)&#123; connection.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; BaseDaoBaseDao：封装通用的CRUD操作类(可以基于一些工具类实现，如DbUtils)，如含以下主要方法，一般设计为抽象类，提供给别人继承使用。一般含如下方法： int update(String sql,Object…args)：执行insert、update、delete语句 T queryForOne(Class type,String sql, Object…args)：查询返回一个javaBean对象 List queryForList(Class type,String sql, Object…args)：查询返回多个JavaBean Obejct queryForSingleValue(String sql,Object…args)：查询返回单个值 com.website.dao.BaseDao.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.website.dao;import com.website.utils.JdbcUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;import java.sql.Connection;import java.util.List;/** * 封装通用的数据库操作：update、query * 基于DbUtils实现(commons-dbutils-1.3) * @author yhd * @create 2021-04-11 14:48 */public abstract class BaseDao &#123; //使用DbUtils private QueryRunner queryRunner = new QueryRunner(); /** * 查询返回一个值 * @param sql 执行的sql语句 * @param args sql语句填入的参数 * @return 执行成功返回Object，否则返回null */ public Object queryForValue(String sql,Object...args)&#123; Connection con = JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new ScalarHandler(),args); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.close(con); &#125; return null; &#125; /** * 查询返回javaBean的List集合 * @param type 返回javaBean类型 * @param sql 执行的sql语句 * @param args sql语句填充的参数 * @param &lt;T&gt; 返回类型的泛型 * @return 执行成功返回List，否则返回null */ public &lt;T&gt; List&lt;T&gt; queryForList(Class&lt;T&gt; type, String sql, Object...args)&#123; Connection con = JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new BeanListHandler&lt;T&gt;(type),args); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.close(con); &#125; return null; &#125; /** * 查询返回一个javaBean * @param type 返回的对象类型 * @param sql 执行的sql语句 * @param args sql对应参数值 * @param &lt;T&gt; 返回类型的泛型 * @return 执行成功返回JavaBean，否则返回null */ public &lt;T&gt; T queryForOne(Class&lt;T&gt; type,String sql,Object...args)&#123; Connection con = JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new BeanHandler&lt;T&gt;(type),args); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.close(con); &#125; return null; &#125; /** * 用于执行：Insert/Update/Delete操作 * @param sql 执行的sql语句 * @param args sql语句中填入参数 * @return 若成则返回受影响的行数，失败返回-1 */ public int update(String sql,Object...args)&#123; Connection con = JdbcUtils.getConnection(); try &#123; return queryRunner.update(con, sql, args); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.close(con); &#125; return -1; &#125;&#125; 定制化DAO 含interface接口，与对应的implements实现类。对应参与业务操作的JavaBean的Dao操作 方法命名要细致：如通过用户名Id查找用户信息的方法应命名为，queryUserById()，而非getUser() 一般关于update的操作，如add、delete、update都基于BaseDAO需返回受影响条数 Service业务层编写XxxxService的java类程序，Web开发的核心逻辑处理就写在Service层，把每个业务涉及的所有逻辑操作封装好，供视图控制层直接创建对象调用一个方法处理内部逻辑。 java类程序，每一个业务对应一个XxxService接口及其实现类XxxServiceImpl 像对数据库进行操作时，删除、修改时一般需判断这个数据是否存在数据库先(查询一次)，这些逻辑都是在service封装好的，BaseDao无需写(也无法写出一个通用的判断方法) 视图控制层 编写Servlet程序，接收post、get请求，并调用service层进行逻辑后对应地做出响应。 编写BaseServlet程序，完成同一个业务中同一类型请求的同一分发处理 基于第三方BeanUtils工具类实现WebUtils类，完成把请求参数直接注入到bean对象的操作。 业务Servlet 一般对于Service层，一个Service对应一个Servlet视图控制层 映射url命名：一般将XxxxServlet，映射URL为首字母小写，一般将xxxxServlet BaseServlet在IDEA这种项目结构的实际开发中，一般一个模块就一个servlet。负责一个模块，因此像LoginServlet与RegisterServlet应该和并成UserServlet 区分信息的传递 GET请求：可通过在URL传参中，添加action=login参数 POST请求：可通过在表单中添加隐藏域实现 分支方案 让同一业务范围同一请求类型的都请求同一个Servlet程序 分别在两者表单内添加一个隐藏域，用于表示请求的业务类型 12345&lt;!-- login表单中的隐藏域 --&gt;&lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;login&quot;/&gt;&lt;!-- register表单中的隐藏域 --&gt;&lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;regist&quot;/&gt; 后端在同一接收请求前，通过获取隐藏域action-value的值来区分业务 后端对每个业务功能创建如HttpServlet原生Post方法的结构，在if-else分支语句中进行调用 1234567891011121314151617181920212223242526272829303132333435363738public class UserServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doPost(req, resp); String action = req.getParameter(&quot;action&quot;); if(&quot;login&quot;.equals(action))&#123; login(req,resp); &#125;else if(&quot;regist&quot;.equals(action))&#123; regist(req,resp); &#125; &#125; /** * 处理登录功能 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //..... &#125; /*** * 处理注册功能 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //..... &#125;&#125; 反射方案 注意：要求请求的区分信息与被调用方法名一致(直接反射调用) 获取到区分信息后，通过反射的方式自动调用各种方法 123456789101112131415161718192021222324252627282930313233343536373839404142public class UserServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doPost(req, resp); req.setCharacterEncoding(&quot;UTF-8&quot;);//请求中文乱码 resp.setContentType(&quot;text/html;charset=UTF-8&quot;);//响应中文乱码 String action = req.getParameter(&quot;action&quot;); //反射方案 try &#123; Method method = this.getClass().getDeclaredMethod(action, HttpServletRequest.class, HttpServletResponse.class); method.invoke(this,req,resp); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 处理登录功能 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //..... &#125; /*** * 处理注册功能 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //..... &#125;&#125; BaseServlet由于每个业务一般都有若干个功能模块，因此如上的请求分发操作时很常见的。通过反射的方式实现请求分发的代码又极具通用性，因此可以选择把这部分的代码封装到一个父类(目的为了代码复用，设计成抽象父类)中。 把请求分发的反射代码写入BaseServlet抽象类中，让其继承HttpServlet 然业务XxxServlet继承BaseServlet 注意，访问url还是指向业务XxxServlet，BaseServlet只是起到代码复用功能 com.website.web.BaseServlet 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.website.web;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.Method;/** * 通过反射实现的同一请求类型不同请求接口的基类 * 请求参数： * action：传入需调用的方法名(反射使用) * @author yhd * @create 2021-04-22 10:34 */public abstract class BaseServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //post请求中文乱码问题，获取参数前调用有效 req.setCharacterEncoding(&quot;UTF-8&quot;); //GET&amp;POST请求响应中文乱码，获取响应流前调用有效 resp.setContentType(&quot;text/html;charset=UTF-8&quot;); String action = req.getParameter(&quot;action&quot;); System.out.println(&quot;action = &quot; + action); //反射方案 try &#123; Method method = this.getClass().getDeclaredMethod(action, HttpServletRequest.class, HttpServletResponse.class); method.invoke(this,req,resp); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(); &#125; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req,resp); &#125;&#125; com.website.web.UserServlet 12345678910111213141516171819202122232425262728//继承BaseServletpublic class UserServlet extends BaseServlet&#123; /** * 处理登录功能 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //..... System.out.println(&quot;login method-&quot;); &#125; /*** * 处理注册功能 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //..... System.out.println(&quot;regist method-&quot;); &#125;&#125; 数据回显对浏览器操作返回页面提醒信息、某些领域还需数据回显(用户注册失败回显已输入内容) 一般通过request域，通过请求转发的方式回传数据与提醒信息 观察需要回显页面当前的URL，若回显数据存在URL中，则可通过EL隐藏域param获取到 BeanUtils在视图控制层中，还有一部分代码的工作内容是高度相似的，即从request中获取请求的参数并封装成对应的JavaBean对象，如用户的登录，注册等等…。而且较大的项目，往往可能存在数十个请求参数，封装成一个对象，若都采用一个个编写getParameter()，获取每个参数，并创建对象，把每个参数setXxxx()进去，工作量和代码可维护性都是个问题。因此可以编写一个通用的方法去处理这些代码。 123456789101112protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding(&quot;UTF-8&quot;); //1、获取请求的参数 String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); //2、将请求参数封装成对象，new User(username,password,null) User user = service.login(new User(username,password,null)); //.....&#125; BeanUtils基本使用 由于BeanUtils是第三方的jar包，使用前需要先导包 commons-beanutils-1.8.0.jar commons-logging-1.1.1.jar (依赖) 注入前提：前端页面请求参数名(name)**与JavaBean属性名一致(核心是与setter()方法一致**) BeanUtils的注入操作 12345678User user = new User();try &#123; System.out.println(&quot;注入前，user = &quot; + user); BeanUtils.populate(user,req.getParameterMap()); System.out.println(&quot;注入后，user = &quot; + user);&#125;catch (Exception e) &#123; e.printStackTrace();&#125; WebUtils封装由于每次执行注入操作都需要上述BeanUtils的注入代码与异常处理，可以选择把这些操作封装成一个静态方法 com.website.utils.WebUtils 123456789101112131415/** * 把Map中的值注入到对应的JavaBean属性中 * @param value * @param bean * @param &lt;T&gt; * @return */public static &lt;T&gt; T copyParamToBean(Map value,T bean)&#123; try &#123; BeanUtils.populate(bean,value); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; return bean;&#125; 调用测试 1User user = WebUtils.copyParamToBean(req.getParameterMap(),new User()); BeanUtils源码分析最后通常将所有页面改为jsp页面 前端相关操作 抽取前端页面相同的内容，通过引用的方式 公共样式代码部分：如导航栏，底部栏/页脚等 公共外部引用标签部分，如共同的js、css，base标签 Web路径见问题相对路径跳转错乱场景驱动 前端页面代码中，如html、css、js使用相对路径进行资源的使用时，默认是相对当前浏览器页面中地址栏上的地址进行一个相对路径的定位。 仅在前端页面代码中进行相对路径跳转是没问题，但是，一旦出现某个前端代码访问的资源的响应方式是请求的转发响应到另一个页面的，此时就会由于请求的转发特性，使其浏览器地址栏还是处于发起请求前的样子，扰乱了前端代码页面相对路径定位的一个依据，使其路径错误跳转，找不到资源。 base标签介绍原生javaweb阶段可以使用 base+相对路径这个解决方案，但涉及框架参与的开发建议使用绝对路径。 base标签使用： 设置base标签可以修改前端代码相对寻址的依据，使其相对寻址以base标签设定的URI为基准。 注意：base标签设置只对当前页面有效。(多个页面需多个设置) base标签的href属性只取目录信息：因此末尾是目录的话斜杠不能省，省了就不是目录，而是资源了。 注意：一般设置base后，页面原本使用相对路径引入的资源一般都会失效了，如js、css、图片资源等，需对应的进行引入路径修改,(若之前加载过请清楚缓存后再查看)，或者F12查看Console错误提示 示例代码通过base标签与jsp结合实现路径的正确跳转方案步骤如下： 为所有页面设置统一的base标签(一份编写，其他通过引用) 通过jsp动态获取当前web项目的ip:port/project信息作为base标签的href属性值 base标签示例 示例代码： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;base href=&quot;http://www.testwebsite.com/&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;img.jpeg&quot;&gt;访问&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 测试效果： 动态服务器资源路径由于base标签需要填写绝对路径，而web项目在不同网络环境下ip是不一样的，因此需要jsp动态获取ip:port/project后作为组成base的href属性 123456789101112&lt;% //http:// StringBuffer basePath = new StringBuffer(); basePath.append(request.getScheme()); basePath.append(&quot;://&quot;); basePath.append(request.getServerName()); basePath.append(&quot;:&quot;); basePath.append(request.getServerPort()); basePath.append(request.getContextPath()); basePath.append(&quot;/&quot;);%&gt;&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt; 数据传送问题请求与重定向问题请求的转发用来传递数据，而请求的重定向是不可用来传输数据的，是用于终止数据的。场景请求转发与重定向使用场景归纳如下： 查询数据： 成功/失败：请求的转发，request域传回查询的结果。 修改数据：增删改 成功：请求的重定向，防止刷新页面表单重复提交。 失败：请求的转发，request域携带错误提示信息。 数据传送域问题分析 作用域的作用与生命周期的长短，即决定了资源的占用情况。 范围越大，周期越长，占用的资源就越大。因此传送到前端数据所承载的域越小越好，能尽快回收资源。 因此能用request域解决的问题不用session域，能用session域解决的问题不用application… 生命周期及作用范围排序：pageContext —&gt; request —&gt; session —&gt; application pageContext：仅限于当前 JSP 页面，因此Servlet或者其他页面都获取不到。 request：仅限于同一个请求. session：限于同一次会话，浏览器打开直到关闭称之为一次会话(前提在此期间会话不失效) application：限于当前WEB 应用，是范围最大的属性作用范围。只要在一处设置属性, 在其他各处的 JSP 或 Servlet 中都可以获取到。 常用功能数据域 用户请求响应数据传递：request 数据回显：request 配置：application 用户登录信息：Cooke 、session 纯Session实现的购物车：session 数据获取问题 直接访问JSP页面没有想要加载的数据时，可通过访问Servlet接口，再转发到指定JSP页面中。 首页数据获取如上所示，当index.jsp首页没数据时，可以通过先访问一个Servlet再转发到index.jsp页面内。但此时用户访问首页的时候必须访问一个Servlet地址。而一般网站的首页地址http://ip:port或 http://www.xxx.com下的index文件，不会是不方便用户记忆的Servlet长地址。 方案1：jsp跳板可以利用再工程根目录下创建一个index.jsp文件，这个文件里面只做一件事，就是进行一次请求的转发访问获取首页数据的Servlet，Servlet最终传送数据到正在的index.jsp页面。即访问过程，index.jsp ——&gt; Servlet ——&gt; index.jsp。 工程根目录下index.jsp：&lt;jsp:forward page=&quot;/include/xxxServlet&quot;&gt;&lt;/jsp:forward&gt; 首页数据Servlet 真正的index.jsp 注意：index首页通过请求转发到的页面不能是被过滤器拦截的页面，否则会进行转发拦截死循环 若首页转发的页面受拦截器作用，则只能用重定向 表单重复提交基本概念表单重复提交常见的分为两大类，三种情况： 间接重复提交(用户-浏览器)：由于浏览器保存请求机制与后端请求转发导致。 请求转发刷新重复提交 直接重复提交(用户)：有用户直接发起重复提交。 网络延迟重复提交 回退重复提交 部分动态示意图及其文字与代码案例引用如下： https://blog.csdn.net/chenzao666/article/details/81222855?spm=1001.2014.3001.5501 请求转发刷新重复提交基本概念 说明：间接重复提交常指的是”请求转发刷新重复提交“，用户对后端发起修改数据提交(增删改)时，后端通过请求的转发响应提交数据后。由于浏览器的“保留最近的一次请求机制”，在用户执行刷新操作(F5)操作时，会导致直接再提交一次请求。 场景复现：网络延迟重复提交可在Servlet程序中添加延时代码(Sleep)模拟网络差状态，在提交后页面一直处于加载状态下，再次点击提交便是网络延迟重复提交。 引发的问题：非用户主观意愿(刷新)所带来的操作冗余，即不经意间进行了多次操作。 场景复现一般表单的重复提交出现在向后台发起修改数据提交(增删改)，如图书管理中的添加图书功能。 com.website.web.BaseServlet.java 123456789101112131415161718/** * 添加一本图书 * @param req * @param resp * @throws ServletException * @throws IOException */protected void add(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1、获取请求参数并封装成java类 Book book = WebUtils.copyParamToBean(req.getParameterMap(), new Book()); //2、调用service层方法添加图书 service.addBook(book); //3、返回图书列表页面： req.setAttribute(&quot;books&quot;,book); //通过请求的转发响应提交数据 req.getRequestDispatcher(&quot;manager/bookServlet?action=list&quot;).forward(req,resp);&#125; 提交数据后返回图书列表情况：为演示明显，采用了get请求 原理分析： 由于浏览器默认会把用户最后一次请求的提交信息保留起来，当用户通过F5刷新页面时，浏览器就会自动提交该请求(对于POST请求一些浏览器还做提醒表单重复提交)。由于后台响应提交数据的方式是转发，而转发是一次请求，从图中可以看出URL还是处于add操作中，数据也被服务器保留着。 解决方案 解决方案：将用户对后台进行修改数据提交(增删改)后的操作响应设置为请求的重定向 resp.sendRedirect(req.getContextPath() + &quot;/manager/bookServlet?action=list&quot;); 原理：请求的重定向是两次独立的请求，第一次请求把提交数据通过request域发给了后台。紧接着后台要求浏览器再发送一个新的请求去访问指定页面(一般为数据呈现(查询)页面或Servlet)。此时，由于浏览器只记录最后一次请求，因此即使刷新提交的请求也不是提交数据的请求。而是查询信息的请求(这些是允许重复提交查询的) 网络延迟重复提交基本概念 说明：用户正常提交服务器，但是由于网络延迟等原因，迟迟未收到服务器的响应，这个时候，用户以为提交失败， 就会着急，然后多点了几次提交操作，也会造成表单重复提交。 场景复现：在接口响应代码中加入睡眠Thread.sleep()模拟网络环境不佳情况，再连续点击提交即可。 引发的问题：由服务器和浏览器响应的机制可知，延迟重复提交纯粹造成资源浪费，一份结果多次请求。 响应机制在介绍网络延迟所造成的重复提交前，先要说明涉及到服务器与浏览器对请求响应的机制知识 服务器 *服务器采用多线程处理多个请求，即并行处理请求 无论是多个客户发起同一个请求，还是一个用户发起多次请求，这些请求的处理都是独立且并行，互不干扰。 当然同时处理多个请求的数量是有限的，再超过限制后则服务器将会把请求存入队列中排队，采取先来先服务处理方式，每一个请求都将被处理完毕 小结：并行处理、所有请求均会被处理 浏览器注意：这里所指”请求“指由用户直接发起的请求，不包括资源加载自动对后台发起请求。一般存在如下两种请情况。 发起一个请求：客户端发起一个请求时，浏览器把请求发送出去，等待响应，收到响应并解析内容。 发起多个请求：包含发起多个不同或相同的请求 情况1：每一个请求都收到响应后再发起一个请求，则相当于发起了一个请求 情况2：在上一个请求未接收到响应时发起一个新的请求 用户发起请求A，浏览器提交请求A，浏览器等待请求A响应…，Status=(pending) 用户发起请求A’或请求B，浏览器将上一个还未收到响应的请求A的响应状态Status置为Status=(canceled)，表示当收到请求A的响应时，浏览器直接丢弃数据，不解析显示到页面。然后将新的请求A’或B发出。 此时若步骤2的发出的新请求也处于pending状态时用户又再发起新的请求，则继续执行步骤2操作 直至出现一个请求完整收到响应后，浏览器才会将数据解析，并显示到页面上。 请求与响应数如下图统计 不间断pending状态请求数 用户直接发起请求数 7 浏览器发出请求数 7 服务器接收请求数 7 服务器响应请求数 7 浏览器响应解析数 1 要点： 因此在多次还未收到响应就发出的新的请求操作过程中，最终呈现给用户的基于页面反馈的讯息是”多次请求，只响应最后一次“。 需要再次强调：被浏览器标记为Status=(canceled)的请求虽然浏览器不处理，但服务器是依然做出响应的，对于服务器而言，服务器会响应收到的一切请求 因此，pending状态下对同一请求(不包括不同请求)，进行连续状态下的新请求，造成的结果是请求了多份重复的资源或操作而最终给浏览器解析呈现给用户的只有一份，是纯粹的资源浪费。 小结： 服务器是并行处理多个请求的 服务器总是会接收并响应所有请求 浏览器对服务器的宏观通话过程是：”一问一答“ 解决方案原理对于延迟重复提交与回退重复提交本质上都是，跳过了获取这个提交页面的Servlet，时业务流程不按实际操作流程进行，而导致的一种重复请求操作，引发的是增加了服务器的响应压力。因此这种类型的重复提交的解决方案是：本防止跳过Servlet的情况下发出请求，保证业务流程按实际操作流程进行 正常流程： 成功：点击登录超链接/访问首页(Servlet处理) ——&gt; 登录页面 ——&gt; 提交登录 ——&gt; 转到登录后页面，且再无登录操作。 失败：——&gt; 失败(Servlet转发) ——&gt; 登录页面(提示错误) 网络延迟重复提交： 第一次请求：点击登录超链接/访问首页(Servlet处理) ——&gt; 登录页面 ——&gt; 提交登录 重复提交：登录页面 ——&gt; 提交登录… 回退重复提交： 第一次请求：点击登录超链接/访问首页(Servlet处理) ——&gt; 登录页面 ——&gt; 提交登录 重复提交：登录页面 ——&gt; 提交登录… Session方案 Session-Token对称验证方案简述：通过信息对称判断，强制业务流程按序进行(过滤非法业务流程操作) 在提交页面加载的Servlet程序中，生成一个唯一的随机标识号，专业术语称为Token(令牌)，同时在当前用户的Session域中保存这个Token 然后将Token发送到客户端的Form表单中，让表单提交的时候连同这个Token一起提交到服务器端(可以用隐藏域来存储这个Token) 然后在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致，如果不一致，那就是重复提交了，此时服务器端就可以不处理重复提交的表单(直接return，无数据响应的响应)。如果相同则属于正常业务流程的提交(经Servlet生成)，处理完后清除Session域中存储的标识号。 也可以改变编写逻辑，即步骤3改变为，服务器在Session域中获取验证码后，立即删除。后续null判断机率更高。逻辑一样，好处在于不容易忘记卸载Session域中的验证码。 方案效果： 原理其实是利用了”信息对称“来实现，由于Token只有在正常业务流程的加载页面Servlet程序中生成，在首次成功提交响应程序中删除。因此，除正常业务流程访问外，不按这个业务流程操作的动作，即重复提交都会造成Token不对称。或前后端Token值不一致，或后端Token值为null，都属于重复提交操作的Token不对称情况。 方案合并：由于Web表单提交页面中经常使用验证码来防止一些其他的恶意操作，而验证码的工作流程与工作时机和通过Session实现的直接重复提交解决方案一致，因此可以将两者合并起来，即Token = 验证码&#39;从而降低需要维护的机制与变量的数目。 可优化空间： 代码优化部分(推荐)：步骤1可以模仿kaptcha验证码生成方法，编写一个专门用于生成Token的Servlet程序并配置在web.xml中，可通过URL访问直接完成Token动态生成与保存到Session域中。这样就不用为了这个机制而单独转发一个页面。 当后端发现用户重复提交后，后端如何进行操作，由于浏览器只会解析最后一次请求(重复提交)，如何提示之前的提交已经成功，之后的提交是重复提交，请勿操作。 当后端发现用户重复提交后，如何遏制用户继续重复提交。 明显，这种方案虽然避免因重复提交导致的后端数据重复操作，但对于流向服务器的流量压力始终没改善(估计难以改善，就如DOS攻击的防护) 参考代码： 自编写： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.website.servlet;import com.google.code.kaptcha.Constants;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 基于验证码的Session-Token信息对称解决 */public class RegistServlet3 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String action = req.getParameter(&quot;action&quot;); //获取表单内容Servlet请求响应 if(&quot;getForm&quot;.equals(action))&#123; //1、生成动态唯一标识Token //String token = makeToken(); String token = (String) req.getSession().getAttribute(Constants.KAPTCHA_SESSION_KEY); //2、将Token放入Session域 req.getSession().setAttribute(&quot;token&quot;,token); //3、将token返回个前端表单存储 req.setAttribute(&quot;token&quot;,token); //4、执行正常的页面加载响应逻辑 req.getRequestDispatcher(&quot;/regist3.jsp&quot;).forward(req,resp); &#125;else&#123;//表单提交Servlet响应 try &#123; Thread.sleep(5000); &#125;catch (Exception e)&#123;&#125; //若存在重复提交操作 if(isRepeatSubmit(req))&#123; System.out.println(&quot;重复提交操作，不处理&quot;); return;//服务器接收请求，但不做任何操作(响应) //其实还需要处理 &#125;else &#123; resp.setContentType(&quot;text/html;charset=UTF-8&quot;); String username = req.getParameter(&quot;username&quot;); if(&quot;admin&quot;.equals(username))&#123; //修改数据库操作 System.out.println(&quot;请求处理-注册成功&quot;); &#125;else&#123; req.getRequestDispatcher(&quot;/registServlet2?action=getForm&quot;).forward(req,resp); &#125; &#125;//合法提交 &#125; &#125; /** * 重复提交判断函数 * @param req * @return true存在重复提交，否则合法提交 * @throws ServletException * @throws IOException */ private boolean isRepeatSubmit(HttpServletRequest req) throws ServletException, IOException&#123; //1、获取用户提交上来的token值 String clientToken = req.getParameter(&quot;code&quot;); if(clientToken == null)&#123; return true; &#125; //2、获取该用户Session域中的Token值 Object serverToken = req.getSession().getAttribute(Constants.KAPTCHA_SESSION_KEY); if(serverToken == null)&#123; return true; &#125; //3、对比token值 if(!clientToken.equals(serverToken))&#123; return true; &#125; //4、若为合法提交，立即卸载Session中的token值 req.getSession().removeAttribute(Constants.KAPTCHA_SESSION_KEY); return false; &#125;&#125; 尚硅谷2020javaWeb视频 由于基于kaptcha验证码实现，因此可直接访问表单页面.jsp文件通过kaptcha的验证码Servlet生成程序也可以调用到更新验证码的操作。所以不用先经过一个Servlet生成Token再转发到指定提交页面。 12345678910111213141516171819202122232425262728293031323334package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import static com.google.code.kaptcha.Constants.KAPTCHA_SESSION_KEY;public class RegistServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取Session中的验证码 String token = (String) req.getSession().getAttribute(KAPTCHA_SESSION_KEY); // 删除 Session中的验证码 req.getSession().removeAttribute(KAPTCHA_SESSION_KEY); String code = req.getParameter(&quot;code&quot;); // 获取用户名 String username = req.getParameter(&quot;username&quot;); if (token != null &amp;&amp; token.equalsIgnoreCase(code)) &#123; System.out.println(&quot;保存到数据库：&quot; + username); resp.sendRedirect(req.getContextPath() + &quot;/ok.jsp&quot;); &#125; else &#123; System.out.println(&quot;请不要重复提交表单&quot;); &#125; &#125;&#125; 网上引用： form.jsp 在form.jsp中使用隐藏域来存储Token(令牌) 1234567891011121314151617181920&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;form表单&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/servlet/DoFormServlet&quot; method=&quot;post&quot;&gt; &lt;%--使用隐藏域存储生成的token--%&gt; &lt;%-- &lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&lt;%=session.getAttribute(&quot;token&quot;) %&gt;&quot;&gt; --%&gt; &lt;%--使用EL表达式取出存储在session中的token--%&gt; &lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;$&#123;token&#125;&quot;/&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; FormServlet.java 创建FormServlet，用于生成**Token(令牌)**和跳转到form.jsp页面 1234567891011121314151617181920212223242526package xdp.gacl.session; import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class FormServlet extends HttpServlet &#123; private static final long serialVersionUID = -884689940866074733L; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String token = TokenProccessor.getInstance().makeToken();//创建令牌 System.out.println(&quot;在FormServlet中生成的token：&quot;+token); request.getSession().setAttribute(&quot;token&quot;, token); //在服务器使用session保存token(令牌) request.getRequestDispatcher(&quot;/form.jsp&quot;).forward(request, response);//跳转到form.jsp页面 &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; &#125; DoFormServlet.java 处理表单请求 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package xdp.gacl.session; import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class DoFormServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; boolean b = isRepeatSubmit(request);//判断用户是否是重复提交 if(b==true)&#123; System.out.println(&quot;请不要重复提交&quot;); return; &#125; request.getSession().removeAttribute(&quot;token&quot;);//移除session中的token System.out.println(&quot;处理用户提交请求！！&quot;); &#125; /** * 判断客户端提交上来的令牌和服务器端生成的令牌是否一致 * @param request * @return * true 用户重复提交了表单 * false 用户没有重复提交表单 */ private boolean isRepeatSubmit(HttpServletRequest request) &#123; String client_token = request.getParameter(&quot;token&quot;); //1、如果用户提交的表单数据中没有token，则用户是重复提交了表单 if(client_token==null)&#123; return true; &#125; //取出存储在Session中的token String server_token = (String) request.getSession().getAttribute(&quot;token&quot;); //2、如果当前用户的Session中不存在Token(令牌)，则用户是重复提交了表单 if(server_token==null)&#123; return true; &#125; //3、存储在Session中的Token(令牌)与表单提交的Token(令牌)不同，则用户是重复提交了表单 if(!client_token.equals(server_token))&#123; return true; &#125; return false; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; &#125; TokenProccessor.java 生成Token的工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package xdp.gacl.session; import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.Random;import sun.misc.BASE64Encoder; public class TokenProccessor &#123; /* *单例设计模式（保证类的对象在内存中只有一个） *1、把类的构造函数私有 *2、自己创建一个类的对象 *3、对外提供一个公共的方法，返回类的对象 */ private TokenProccessor()&#123;&#125; private static final TokenProccessor instance = new TokenProccessor(); /** * 返回类的对象 * @return */ public static TokenProccessor getInstance()&#123; return instance; &#125; /** * 生成Token * Token：Nv6RRuGEVvmGjB+jimI/gw== * @return */ public String makeToken()&#123; //checkException // 7346734837483 834u938493493849384 43434384 String token = (System.currentTimeMillis() + new Random().nextInt(999999999)) + &quot;&quot;; //数据指纹 128位长 16个字节 md5 try &#123; MessageDigest md = MessageDigest.getInstance(&quot;md5&quot;); byte md5[] = md.digest(token.getBytes()); //base64编码--任意二进制编码明文字符 adfsdfsdfsf BASE64Encoder encoder = new BASE64Encoder(); return encoder.encode(md5); &#125; catch (NoSuchAlgorithmException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 合并验证码方案 由上所述，通过Session-Token对称方案解决重复提交问题，还常与验证码机制合并使用，以下介绍基于第三方验证码生成包Kaptcha实现验证码生成。 验证码可以防止恶意破解密码、刷票、论坛灌水、刷页等非法操作，是Web非常常用的验证机制之一。 KaptchaGoogle Kaptcha图片验证是一个可高度配置的实用验证码生成工具，可自由配置的选项如： 验证码的字体 验证码字体的大小 验证码字体的字体颜色 验证码内容的范围(数字，字母，中文汉字！) 验证码图片的大小，边框，边框粗细，边框颜色 验证码的干扰线 验证码的样式(鱼眼样式、3D、普通模糊、…) … 使用步骤Kaptcha的使用是直接使用其生成验证码的Servlet程序，配置后直接是一个URL接口。 导入Google验证码的jar包：kaptcha-2.3.2.jar 在web.xml中去配置用于生成验证码的Servlet程序访问的URL 123456789&lt;servlet&gt; &lt;servlet-name&gt;KaptchaServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.google.code.kaptcha.servlet.KaptchaServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;KaptchaServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/kaptcha.jpg&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 前端页面获取验证码：直接访问Servlet配置URL，如上所例配置URL为ip:port/工程项目名/kaptcha.jpg 1234567 &lt;form action=&quot;http://localhost:8080/13_RepeatSubmit/registServlet&quot; method=&quot;get&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt; &lt;br&gt; 验证码：&lt;input type=&quot;text&quot; style=&quot;width: 60px;&quot; name=&quot;code&quot;&gt; &lt;img src=&quot;http://localhost:8080/13_RepeatSubmit/kaptcha.jpg&quot; alt=&quot;&quot; style=&quot;width: 100px; height: 28px;&quot;&gt; &lt;br&gt; &lt;input id=&quot;count&quot; type=&quot;hidden&quot; name=&quot;requestCount&quot; value=&quot;0&quot;&gt; &lt;input id=&quot;submit&quot; type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt; 效果如下图所示： 后端Servlet获取验证码数据：kaptcha生成验证码的Servlet程序被调用后有自动完成下述三个操作 自动生成随机的验证码 自动并生成验证码图片 自动把验证码保存到Session域中 kaptcha有专门存储常量的类Constants，里面KAPTCHA_SESSION_KEY即是存储在Session域中验证码Key值 后端直接通过Session域即可获取 1String token = (String)req.getSession().getAttribute(Constants.KAPTCHA_SESSION_KEY); 刷新验证码 通过JS为验证码图片添加点击事件 12345678// 给验证码的图片，绑定单击事件$(&quot;#code_img&quot;).click(function () &#123;//在事件响应的 function 函数中有一个 this 对象。这个 this 对象，是当前正在响应事件的 dom 对象//src 属性表示验证码 img 标签的图片路径。它可读，可写//当对img的src修改时(写操作)，img标签将会重新加载图片(重新发起get请求获取图片)//添加一个动态的任意请求参数是为了防止某些浏览器的缓存机制导致不能多次点击更新this.src = &quot;$&#123;basePath&#125;kaptcha.jpg?d=&quot; + new Date();&#125;) 浏览器静态资源缓存机制： 某些浏览器为了加快响应速度，常常对静态资源进行缓存，缓存机制如下 浏览器对首次响应后的静态资源本体暂存起来，并记录下这个静态资源的URL 当下次再发起同样的静态资源请求时，先从缓存区匹配URL，找到立即响应缓存的本体内容，不向服务器请求。 跳过浏览器静态资源缓存机制：添加一个动态的任意请求参数改变URL即可。 JavaScript方案解决的做法就是”用JavaScript控制Form表单只能提交一次”，或提交一次按钮就不可用。 form.jsp 单次提交 12345678910111213141516171819202122232425&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Form表单&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var isCommitted = false;//表单是否已经提交标识，默认为false function dosubmit()&#123; if(isCommitted==false)&#123; isCommitted = true;//提交表单后，将表单是否已经提交标识设置为true return true;//返回true让表单正常提交 &#125;else&#123; return false;//返回false那么表单将不提交 &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/servlet/DoFormServlet&quot; onsubmit=&quot;return dosubmit()&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 除了用这种方式之外，经常见的另一种方式就是表单提交之后，将提交按钮设置为不可用，让用户没有机会点击第二次提交按钮，代码如下： form.jsp 按钮设置为不可用 12345678function dosubmit()&#123; //获取表单提交按钮 var btnSubmit = document.getElementById(&quot;submit&quot;); //将表单提交按钮设置为不可用，这样就可以避免用户再次点击提交按钮 btnSubmit.disabled= &quot;disabled&quot;; //返回true让表单可以正常提交 return true;&#125; 回退重复提交 说明：用户正常提交服务器。服务器也没有延迟，但是提交完成后，用户点击回退键回退上一个操作后继续重新提交，也会造成表单重复提交。 场景复现：回退直接点击浏览器的&lt;-按钮或者按下键盘Backspace按钮再提交可看到 引发的问题：此时重复提交的问题是用户行为上的一个误导，所造成的操作冗余，间接造成的资源浪费。 例如：用户进入购物网站下单前需登录，登录后用户无意中进行了回退操作。此时用户看到了一个完整的需要登录的界面，常误认为就是网站系统需用户再次进行登录操作，一般用户就会再次输入信息登录。其实当用户按下回退键时，登录状态并没有被注销，用户可以操作浏览器[前进键]或直接访问需要登录后才能访问的页面都是允许的，即用户第二次的登录操作时多余的，一定程度上间接地加大了服务器的压力(比不要的操作/请求更多了) 解决方案采用”网络延迟重复提交“的Session-Token信息对称解决方案。 小结 间接重复提交：请求转发刷新重复提交 引发的问题：避免的是非用户主观意愿(刷新)带来的操作冗余。 解决方案：将涉及增删改操作的接口的成功响应使用重定向，失败响应使用转发。 直接重复提交： 网络延迟重复提交： 引发的问题：真正避免的是，连续发起多个处于State=(pending)(等待)状态下的同一请求而带来的资源浪费与操作冗余。而pending状态下发起不同的请求是常规允许的操作场景。 解决方案：Session-Token对称验证 Session-Token对称验证是，通过信息对称判断，强制业务流程按序进行(过滤非法业务流程操作) 回退重复提交： 引发的问题：此时重复提交的问题是用户行为上的一个误导，所造成的操作冗余，间接造成的资源浪费。 解决方案：Session-Token对称验证 同一表单不同请求场景说明 假如存在一个图书后台管理界面，有两个超链接按钮分别为：”添加图书”、”修改图书” 由于信息提交页面类似，现在规定这两个功能都跳转到同一个表单页面上，但又需要各自完成各自的功能 假设是通过传递action值来控制访问不同的接口，因此可以通过修改action的值来实现不同接口的访问，问题在于基于什么去动态修改action值。 123&lt;form action=&quot;manager/bookServlet&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;动态&quot;&gt;&lt;/form&gt; 解决方案增加请求参数做标识使用的前提是，超链接或是请求的转发，需保证页面跳转后是请求的URL 分别为，”添加图书”，”修改图书“两个超链接请求添加一个新的请求参数method，如xxx/book_edit.jsp?method=add或xxx/book_edit.jsp?method=update 通过JSP/EL表达式的param获取这个请求参数标识，修改action的值。(范式URL上存在的请求参数param都能获取) 123&lt;form action=&quot;manager/bookServlet&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;&#123;param.method&#125;&quot;&gt;&lt;/form&gt; 判断不同业务URL情况如当前”修改图书”操作URL上含id请求参数，而”添加图书”业务URL上没有id参数，因此在JSP页面可以通过判断是否存在id请求参数作为判断业务的标识。 JSP/EL判断 123&lt;form action=&quot;manager/bookServlet&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;&#123;empty param.id ? &quot;add&quot; : &quot;update&quot;&#125;&quot;&gt;&lt;/form&gt; 判断不同业务的隐藏域情况由于”修改图书“操作需要向后端先请求修改图书原本的数据，因此request域是存在数据的。而”添加图书“是不用向后端请求任何数据。request域为空，因此可以通过判断request域识别业务类型。 JSP/EL判断 123&lt;form action=&quot;manager/bookServlet&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;$&#123;empty requestScope.book ? &quot;add&quot; : &quot;update&quot;&#125;&quot;&gt;&lt;/form&gt; 分页技术基本概念分页功能在网页中是非常常见的一个功能，其作用也就是将数据分割成多个页面来进行显示。 使用场景：当取到的数据量达到一定的时候，就需要使用分页来进行数据分割。 不使用分页所面临的问题 客户端：若数据量太多，都显示在同一个页面的话，会因为页面太长严重影响到用户的体验，也不便于操作，也会出现加载太慢的问题。 服务端：如果数据量太多，可能会造成内存溢出，而且一次请求携带的数据太多，对服务器的性能也是一个考验。 常见分页实例 淘宝 百度 分页的分类分页的实现分为真分页(物理分页)和假分页(逻辑分页)两种。 真分页(物理分页) 实现原理：SELECT * FROM xxx [WHERE...] LIMIT #&#123;paran1&#125;，#&#123;paran2&#125; 优点：不会造成内存溢出 缺点：翻页的速度比较慢 假分页(逻辑分页) 实现原理：一次性将所有的数据查询出来放在内存之中，每次需要查询的时候就直接从内存之中去取出相应索引区间的数据 优点：分页速度比较快 缺点：可能造成内存溢出 分页基本概念与分类引用：https://www.cnblogs.com/wmyskxz/p/8945693.html 后端设计当前以真分页为主介绍原生方案 分页模型一般实现分页操作要建立一个分页模型对象Page类，一般含如下属性， 1234567public static final int PAGE_SIZE = 4;private int pageNo;//当前页码：private int pageTotal;//总页码private int pageTotalCount;//总记录数private int pageSize = PAGE_SIZE;//每页显示的数量private List&lt;T&gt; items;//分页后的数据集 pageNo：当前页码一般由用户提供给后端。 pageSize：每页显示数量一般有两种来源 由用户进行传递，如百度搜索中可设置每页返回的条目数量 由页面布局决定，由前端工程师决定(后端设定)。 pageTotalCount：总记录数可通过sql语句查询得出 select count(*) from table; pageTotal：总页码数可通过pageSize与pageTotalCount计算得出 1234int pageTotal = pageTotalCount / pageSize;if(pageTotalCount % pageSize != 0)&#123;//若不能整除 pageTotal++;&#125; items：当前分页后的数据集，有sql语句查询得出 select * from table limit begin,end; begin：begin = (pageNo - 1) * pageSize; end：end = pageSize; Page模型类只是封装分页操作的关键属性支持，分页操作的关键在于如何把这些属性进行设定。在Web应用开发中，这种核心的逻辑处理由Service层负责。 置顶向下实现开发中可以采用置顶向下的开发顺序即，从Servlet层、Service层、dao层，从用户需求往下展开实现。利于编码。 Servlet层 com.website.web.BookServlet 12345678910111213//响应指定分页信息的数据protected void page(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1、获取请求页码和页码数量(默认是第1页、每页Page.PAGE_SIZE 4 项内容) int pageNo = WebUtils.parseInt(req.getParameter(&quot;pageNo&quot;), 1); int pageSize = WebUtils.parseInt(req.getParameter(&quot;pageSize&quot;),Page.PAGE_SIZE); //2、调用bookService.page(pageNo,pageSize);方法获取分页后的数据 Page&lt;Book&gt; page = bookService.page(pageNo,pageSize); //3、把分页后的数据存储到request域中 req.setAttribute(&quot;page&quot;,page); //4、请求转发到 /pages/manager/book_manager.jsp页面中 req.getRequestDispatcher(&quot;/pages/manager/book_manager.jsp&quot;).forward(req,resp);&#125; Service层 com.website.service.BookService 1234567891011public interface BookService &#123; //....... /** * 获取当前分页对象 * @param pageNo 请求页号：1 ~ MAX * @param pageSize 每页条目数 * @return */ Page&lt;Book&gt; page(int pageNo, int pageSize);&#125; com.website.service.impl.BookServiceImp 12345678910111213141516171819202122232425262728293031323334@Overridepublic Page&lt;Book&gt; page(int pageNo, int pageSize) &#123; Page&lt;Book&gt; page = new Page&lt;&gt;(); //1、设置请求页码数 //不可封装到setPageNo中，如输入 10 ，此时 pageTotal == 0 则 10 &gt; 0 被赋予0， //协定一个方案，如若用户输入数字 &lt; 1，则显示首页，&gt; 总页数则显示尾页 if(pageNo &lt; 1)&#123; pageNo = 1;//因为total后面才能赋值，则放到最后在setPageNo &#125; //2、设置每页条目数 page.setPageSize(pageSize); //3、设置数据总量，如果查询结果为0，会引发bug int pageTotalCount = dao.queryForPageTotalCount(); page.setPageTotalCount(pageTotalCount); //4、设置总页码数 int pageTotal = pageTotalCount / pageSize; if(pageTotalCount % pageSize != 0)&#123;//若不能整除 pageTotal++; &#125; page.setPageTotal(pageTotal); if(pageNo &gt; pageTotal)&#123;//外层调用必须按序先给 pageNo = pageTotal; &#125; page.setPageNo(pageNo); //5、设置分页查询后的数据集 int begin = (pageNo - 1) * pageSize; List&lt;Book&gt; items = dao.queryForItems(begin,pageSize); page.setItems(items); //6、返回Page对象 return page;&#125; dao层 com.website.dao.BookDao 12345public interface BookDao &#123; //.... int queryForPageTotalCount(); List&lt;Book&gt; queryForItems(int begin,int end);&#125; com.website.dao.impl.BookDaoImp 1234567891011 @Overridepublic int queryForPageTotalCount() &#123; String sql = &quot;SELECT COUNT(*) FROM t_book&quot;; return ((Number) queryForValue(sql)).intValue();&#125;@Overridepublic List&lt;Book&gt; queryForItems(int begin, int end) &#123; String sql = &quot;select id,name,price,author,sales,stock,img_path imgPath from t_book limit ?,?&quot;; return queryForList(Book.class,sql,begin,end);&#125; 前端设计这里指的前端设计是一些部署到前端页面上的后端代码JSP(EL,JSTL)，和javaScript代码。 布局代码1234567891011 &lt;div id=&quot;page_nav&quot;&gt; &lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;上一页&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;3&lt;/a&gt; 【4】 &lt;a href=&quot;#&quot;&gt;5&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;下一页&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;末页&lt;/a&gt; 共10页，30条记录 到第&lt;input value=&quot;4&quot; name=&quot;pn&quot; id=&quot;pn_input&quot;/&gt;页 &lt;input type=&quot;button&quot; value=&quot;确定&quot;&gt;&lt;/div&gt; 首尾与上下页1234567891011&lt;%-- 大于1页才允许出现首页和上一页操作 --%&gt;&lt;c:if test=&quot;$&#123;requestScope.page.pageNo &gt; 1&#125;&quot;&gt; &lt;a href=&quot;manager/bookServlet?action=page&amp;pageNo=1&quot;&gt;首页&lt;/a&gt; &lt;a href=&quot;manager/bookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageNo - 1&#125;&quot;&gt;上一页&lt;/a&gt;&lt;/c:if&gt;&lt;%-- 若是最后一页则不显示下一页和莫页 --%&gt;&lt;c:if test=&quot;$&#123;requestScope.page.pageNo &lt; requestScope.page.pageTotal&#125;&quot;&gt; &lt;a href=&quot;manager/bookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageNo + 1&#125;&quot;&gt;下一页&lt;/a&gt; &lt;a href=&quot;manager/bookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageTotal&#125;&quot;&gt;末页&lt;/a&gt;&lt;/c:if&gt; 跳转页1234567891011121314&lt;script type=&quot;text/javascript&quot;&gt; //页面加载完成后 $(function()&#123; $(&quot;input.searchPageBtn&quot;).click(function ()&#123; //1、获取输入的页码(忽略非法输入情况) var pageNo = $(&quot;#pn_input&quot;).val(); //2、javaScript语言中提供了一个location地址栏对象， //其中具备一个名为href属性，可以对浏览器地址栏操作，可读可写 //读href属性：获取当前浏览器URL内容 //写href属性：替换当前浏览器URL并直接在当前页面访问(GET请求) location.href = &quot;manager/bookServlet?action=page&amp;pageNo=&quot; + pageNo; &#125;);&#125;)&lt;/script&gt; 范围页功能需求能显示若干个(5)个连续的页码，而且当前页码在中间。除了当前页码之外，每个页码都可以点击跳到指定页。 情况分析 showPageCount：拟显示页码数，即上图所示，“1，2，3，4，5“，共显示5个页码。一般为了布局对称，选取奇数。 pageTotal：总页码数 pageNo：当前页码数 情况1：pageTotal ≤ showPageCount，如总页码数只有3页，而拟显示5个页码 访问范围：1 ~ pageTotal，即把持有的所有页号全部显示 页码范围：1 ~ pageTotal 12345只有1页：【1】只有2页：【1】，2 1，【2】，只有3页：1，【2】，3】.... 代码实现： 12345678910111213&lt;c:choose&gt; &lt;%-- 情况1：总页码数 &lt;= 拟显示页码数 --%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageTotal &lt;= 5&#125;&quot;&gt; &lt;c:forEach begin=&quot;1&quot; end=&quot;$&#123;requestScope.page.pageTotal&#125;&quot; var=&quot;i&quot;&gt; &lt;c:if test=&quot;$&#123;i != requestScope.page.pageNo&#125;&quot;&gt; &lt;a href=&quot;manager/bookServlet?action=page&amp;pageNo=$&#123;i&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;i == requestScope.page.pageNo&#125;&quot;&gt; 【$&#123;i&#125;】 &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;/c:when&gt;&lt;/c:choose&gt; 情况2：pageTotal ＞ showPageCount，如总页码数多达10页，而拟显示5个页码 情况2细分三种情况图示如下： 情况2.1：当前访问页处于页码首部，且小于等于拟显示页码范围的前半段时，显示页码范围固定 访问范围：pageNo ≤ (showPageCount/2 + 1) 页码范围：1 ~ showPageCount 123456&#x2F;&#x2F;如上例子参数，showPageCount &#x3D; 5&#x2F;&#x2F;showPageCount&#x2F;2 + 1 &#x3D; 3，则在访问1~3页时，页码的访问访问不变，保持在1~5访问【1】2，3，4，51【2】3，4，51，2【3】4，5&#x2F;&#x2F;如访问第4页时应该展示的序列为(发生变化)：2，3【4】，5，6 代码实现： 1234567891011121314151617181920212223&lt;c:choose&gt; &lt;%-- 情况1：总页码数 &lt;= 拟显示页码数 --%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageTotal &lt;= 5&#125;&quot;&gt; &lt;%-- .... --%&gt; &lt;/c:when&gt; &lt;%-- 情况2：总页码数 &gt; 拟显示页码数 --%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageTotal &gt; 5&#125;&quot;&gt; &lt;c:choose&gt; &lt;%-- 情况2.1：当前访问页处于页码首部，且小于等于拟显示页码范围的前半段时%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageNo &lt;= (3)&#125;&quot;&gt; &lt;c:forEach begin=&quot;1&quot; end=&quot;5&quot; var=&quot;i&quot;&gt; &lt;c:if test=&quot;$&#123;i != requestScope.page.pageNo&#125;&quot;&gt; &lt;a href=&quot;manager/bookServlet?action=page&amp;pageNo=$&#123;i&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;i == requestScope.page.pageNo&#125;&quot;&gt; 【$&#123;i&#125;】 &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;/c:when&gt; &lt;/c:choose&gt; &lt;/c:when&gt;&lt;/c:choose&gt; 情况2.2：当前访问页处于页码尾部，且大于等于拟显示页码范围的后半段时，显示页码范围固定 访问范围：pageTotal - showPageCount/2 ≤ pageNo ≤ pageToal 页码范围：pageTotal - showPageCount + 1 ~ pageTotal 123456&#x2F;&#x2F;如上例子参数，showPageCount &#x3D; 5、pageTotal &#x3D; 10&#x2F;&#x2F;pageTotal - showPageCount&#x2F;2 &#x3D; 8，则在访问8~10页时，页码的访问访问不变，保持在6~10访问6，7，8，9【10】6，7，8【9】，106，7【8】，9，10&#x2F;&#x2F;如访问第7页时应该展示的序列为(发生变化)：5，6【7】，8，9 代码实现： 1234567891011121314151617181920212223&lt;c:choose&gt; &lt;%-- 情况1：总页码数 &lt;= 拟显示页码数 --%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageTotal &lt;= 5&#125;&quot;&gt; &lt;%-- .... --%&gt; &lt;/c:when&gt; &lt;%-- 情况2：总页码数 &gt; 拟显示页码数 --%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageTotal &gt; 5&#125;&quot;&gt; &lt;c:choose&gt; &lt;%--情况2.2 当前访问页处于页码尾部，且大于等于拟显示页码范围的后半段时--%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageNo &gt;= (8)&#125;&quot;&gt; &lt;c:forEach begin=&quot;$&#123;requestScope.page.pageTotal - 5 + 1&#125;&quot; end=&quot;$&#123;requestScope.page.pageTotal&#125;&quot; var=&quot;i&quot;&gt; &lt;c:if test=&quot;$&#123;i != requestScope.page.pageNo&#125;&quot;&gt; &lt;a href=&quot;manager/bookServlet?action=page&amp;pageNo=$&#123;i&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;i == requestScope.page.pageNo&#125;&quot;&gt; 【$&#123;i&#125;】 &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;/c:when&gt; &lt;/c:choose&gt; &lt;/c:when&gt;&lt;/c:choose&gt; 情况2.3：即除上述情况外，当前访问页处于首尾拟显示页码数访问范围的后前半段之间。即处于中中部。 访问范围：(showPageCount/2 + 2) ≤ pageNo ≤ (pageTotal - showPageCount/2 - 1) 一般不判断情况3的访问范围，除上述两种之外的条件就是情况3 页码范围：(pageNo - showPageCount/2) ~ (pageNo + showPageCount/2) 1234567&#x2F;&#x2F;如上例子参数，showPageCount &#x3D; 5、pageTotal &#x3D; 10 &#x2F;&#x2F;(showPageCount&#x2F;2 + 1) ≤ pageNo ≤ (pageTotal - showPageCount&#x2F;2)， &#x2F;&#x2F;则在访问4~7页时，页码的访问变化，(pageNo - 2) ~ (pageNo + 2) 2，3，【4】，5，6 3，4，【5】，6，7 4，5，【6】，7，8 5，6，【7】，8，9 代码实现： 12345678910111213141516171819202122232425262728&lt;%-- 一般配合上述两种情况最后作为一个else/default/otherwise条件处理 --%&gt; &lt;c:choose&gt; &lt;%-- 情况1：总页码数 &lt;= 拟显示页码数 --%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageTotal &lt;= 5&#125;&quot;&gt; &lt;%-- .... --%&gt; &lt;/c:when&gt; &lt;%-- 情况2：总页码数 &gt; 拟显示页码数 --%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageTotal &gt; 5&#125;&quot;&gt; &lt;c:choose&gt; &lt;%-- 情况2.3：即除上述情况外，当前访问页处于首尾拟 显示页码数访问范围的后前半段之间。即处于中中部 --%&gt; &lt;c:otherwise&gt; &lt;c:forEach begin=&quot;$&#123;requestScope.page.pageNo - 2&#125;&quot; end=&quot;$&#123;requestScope.page.pageNo + 2&#125;&quot; var=&quot;i&quot;&gt; &lt;c:if test=&quot;$&#123;i != requestScope.page.pageNo&#125;&quot;&gt; &lt;a href=&quot;manager/bookServlet?action=page&amp;pageNo=$&#123;i&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;i == requestScope.page.pageNo&#125;&quot;&gt; 【$&#123;i&#125;】 &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/c:when&gt; &lt;/c:choose&gt; 增删改分页调整若按上述实现过程，无论在对哪一页的数据项进行增删改之后都是跳转到首页。为了用户体验更好，应实现如下效果。 实现的前提是：后端已经具备若前端传送页码大于总页码数默认跳转到尾页的后端功能。 删除与修改： 效果：删除或修改指定一页中的数据项后，刷新回到该页。 实现：在删除与修改操作的前端请求中传送当前页码数据即可。对应后端的删改操作请求转发到page时也需把新的转发数据转发过去。 当前页删除跳回当前页，若尾页部分删除消失一页则会因传送页码大于实际页码总数而默认跳到最新的尾页。 增加： 效果：增加数据项后，应跳转到尾页。 实现：在增加操作前端请求中传送 (当前页码+1)的数据，使其总是跳转到最后一页。对应后端的增加操作请求转发到page时也需把新的转发数据转发过去。 代码实现：基于本文分页的实例项目结构的代码实现 删除：由于删除一个操作，接收参即可 book_manager.jsp 1&lt;td&gt;&lt;a class=&quot;deleteClass&quot; href=&quot;manager/bookServlet?action=delete&amp;id=$&#123;book.id&#125;&amp;pageNo=$&#123;requestScope.page.pageNo&#125;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; com.website.web.BookServlet.java 12345protected void delete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //省略代码.... resp.sendRedirect(req.getContextPath() + &quot;/manager/bookServlet?action=page&amp;pageNo=&quot; + req.getParameter(&quot;pageNo&quot;));&#125; 修改： book_manager.jsp 1&lt;td&gt;&lt;a href=&quot;manager/bookServlet?action=getBook&amp;id=$&#123;book.id&#125;&amp;pageNo=$&#123;requestScope.page.pageNo&#125;&quot;&gt;修改&lt;/a&gt;&lt;/td&gt; book_edit.jsp：由于删除和修改都是先跳转到一个页码上再提交给后端的。 123456&lt;div id=&quot;main&quot;&gt; &lt;form action=&quot;manager/bookServlet&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;pageNo&quot; value=&quot;$&#123;param.pageNo&#125;&quot;&gt; &lt;!-- 省略代码..... --&gt; &lt;/form&gt;&lt;/div&gt; com.website.web.BookServlet.java 1//同删除部分代码修改 增加： book_manager.jsp 1&lt;td&gt;&lt;a href=&quot;pages/manager/book_edit.jsp?pageNo=$&#123;requestScope.page.pageTotal&#125;&quot;&gt;添加图书&lt;/a&gt;&lt;/td&gt; book_edit.jsp 1&lt;%-- 同修改操作代码部分修改 --%&gt; com.website.web.BookServlet.java 12345678protected void add(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //补充分页增加部分 int pageNo = WebUtils.parseInt(req.getParameter(&quot;pageNo&quot;), 0); pageNo++;//添加后总是显示到尾页 //省略代码.... resp.sendRedirect(req.getContextPath() + &quot;/manager/bookServlet?action=page&amp;pageNo=&quot; + pageNo);&#125; 代码的抽取由于分页代码有极高的相似度，若读取的数据都一样，则不同页面上实用分页代码只有，访问的Servlet地址不一样而已。因此可以有效的进行代码抽取。开发中常用！ 将Page模型添加一个分页url属性，抽取至client/clientBookServlet?action=page。即含Servlet也含分页方法(因为存在同一Servlet不同分页函数的情况) 在不同的分页Servlet中设置与之对应的分页url 将前端分页代码抽取出来，统一通过动态获分页URL的方式访问。 区间查询分页总体上和普通的数据分页一样，只是要对应再建立一个架构而已。 验证码验证码可以防止恶意破解密码、刷票、论坛灌水、刷页等非法操作，是Web非常常用的验证机制之一。 KaptchaGoogle Kaptcha图片验证是一个可高度配置的实用验证码生成工具，可自由配置的选项如： 验证码的字体 验证码字体的大小 验证码字体的字体颜色 验证码内容的范围(数字，字母，中文汉字！) 验证码图片的大小，边框，边框粗细，边框颜色 验证码的干扰线 验证码的样式(鱼眼样式、3D、普通模糊、…) … 使用步骤Kaptcha的使用是直接使用其生成验证码的Servlet程序，配置后直接是一个URL接口。 导入Google验证码的jar包：kaptcha-2.3.2.jar 在web.xml中去配置用于生成验证码的Servlet程序访问的URL 123456789&lt;servlet&gt; &lt;servlet-name&gt;KaptchaServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.google.code.kaptcha.servlet.KaptchaServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;KaptchaServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/kaptcha.jpg&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 前端页面获取验证码：直接访问Servlet配置URL，如上所例配置URL为ip:port/工程项目名/kaptcha.jpg 1234567 &lt;form action=&quot;http://localhost:8080/13_RepeatSubmit/registServlet&quot; method=&quot;get&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt; &lt;br&gt; 验证码：&lt;input type=&quot;text&quot; style=&quot;width: 60px;&quot; name=&quot;code&quot;&gt; &lt;img src=&quot;http://localhost:8080/13_RepeatSubmit/kaptcha.jpg&quot; alt=&quot;&quot; style=&quot;width: 100px; height: 28px;&quot;&gt; &lt;br&gt; &lt;input id=&quot;count&quot; type=&quot;hidden&quot; name=&quot;requestCount&quot; value=&quot;0&quot;&gt; &lt;input id=&quot;submit&quot; type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt; 效果如下图所示： 后端Servlet获取验证码数据：kaptcha生成验证码的Servlet程序被调用后有自动完成下述三个操作 自动生成随机的验证码 自动并生成验证码图片 自动把验证码保存到Session域中 kaptcha有专门存储常量的类Constants，里面KAPTCHA_SESSION_KEY即是存储在Session域中验证码Key值 后端直接通过Session域即可获取 1String token = (String)req.getSession().getAttribute(Constants.KAPTCHA_SESSION_KEY); 刷新验证码 通过JS为验证码图片添加点击事件 12345678// 给验证码的图片，绑定单击事件$(&quot;#code_img&quot;).click(function () &#123;//在事件响应的 function 函数中有一个 this 对象。这个 this 对象，是当前正在响应事件的 dom 对象//src 属性表示验证码 img 标签的图片路径。它可读，可写//当对img的src修改时(写操作)，img标签将会重新加载图片(重新发起get请求获取图片)//添加一个动态的任意请求参数是为了防止某些浏览器的缓存机制导致不能多次点击更新this.src = &quot;$&#123;basePath&#125;kaptcha.jpg?d=&quot; + new Date();&#125;) 浏览器静态资源缓存机制： 某些浏览器为了加快响应速度，常常对静态资源进行缓存，缓存机制如下 浏览器对首次响应后的静态资源本体暂存起来，并记录下这个静态资源的URL 当下次再发起同样的静态资源请求时，先从缓存区匹配URL，找到立即响应缓存的本体内容，不向服务器请求。 跳过浏览器静态资源缓存机制：添加一个动态的任意请求参数改变URL即可。 权限管理 在配置Servlet程序URL地址定义时，应有意地借助在URL中添加额外的字符串信息用来将请求范围进行归类 分类方式多种，可按范围、资源类型、访问权限等分类 主要目的是方便后续通过Filter过滤器做进一步分离处理。 例如：按用户权限类型进行分类， 普通用户操作的资源或Servlet程序则在URL冠以client/标识，如/manager/bookServlet 管理员用户则冠以manager标识。如/client/clientBookServlet 最后Filter可以以/client/*或/manner/*清晰地实现拦截。 事务管理基本概念一个功能的实现往往需要一次性修改多次数据库数据，而这些多次修改操作必须保证要么全执行，要么全部不执行，这就是一个事务。如用户结算购物车中的产品生成订单的功能，涉及的操作如下： 模拟生成购物订单操作，凸显事务作用 12345678910111213141516171819202122232425262728293031323334353637383940package com.website.affair;/** * 模拟生成购物订单操作，凸显事务作用 * @author yhd * @create 2021-06-01 9:38 */public class OrderService &#123; Dao dao = new Dao(); public void createOrder()&#123; dao.updateGoods();//修改数据库中商品中的销量和库存量 dao.createOrder();//在数据库中创建订单信息数据 //int i = 12 / 0; //若程序在允许过程中出错，则数据库的库存销量被修改，订单 //也被生成，而订单中的商品信息却没生成，从而导致数据库数据操作不对称，是致命的错误。 //必须用事务控制整个createOrder操作要么执行要么全部不执行 dao.createOrderItem();//在数据库中创建订单商品项信息数据 System.out.println(&quot;订单成功生成！&quot;); &#125; public static void main(String[] args) &#123; new OrderService().createOrder(); &#125;&#125;class Dao&#123; public void updateGoods()&#123; System.out.println(&quot;修改数据库中商品中的销量和库存量&quot;); &#125; public void createOrder()&#123; System.out.println(&quot;在数据库中创建订单信息数据&quot;); &#125; public void createOrderItem()&#123; System.out.println(&quot;在数据库中创建订单商品项信息数据&quot;); &#125;&#125; 事务管理设计在设计之前，概括以下食物控制实现的几大要点，第1,2点属于数据库事务机制的要求，第3,4点属于对业务进行事务控制的基本逻辑。 手动管理：设置为手动管理事务模式 同一连接：事务内的所有数据库操作都是同一个数据库连接对象 异常传递：含数据库操作的业务的所有代码异常均需暴露，可被业务操作最顶层代码检测。 顶层捕获：最后业务操作的最顶层代码进行资源回收，或异常捕获后进行回滚与回收。 手动管理事务实现事务控制的前提是用户必须能自己控制事务，如事务的创建、提交、回滚操作。这些操作均由Connection对象提供的方法实现。 设置为手动管理事务 1connection.setAutoCommit(false);//设置为手动管理事务 事务的提交 12//未执行事务提交操作时，所有sql语句操作均未生效connection.commit();//含编译异常，由于受限于网络条件 事务的回滚 1connection.rollback();//含编译异常，由于受限于网络条件 注意：若发现就算设置connection.setAutoCommit(false);还出现没有调用commit()方法数据就进入到数据库了，除去代码问题外，很有可能是因为数据表的引擎设置成了MyISAM模式，该模式是不支持事务的。不管是设置setAutoCommit(false)还是‘SET AUTOCOMMIT=0’都没有用！应修改数据表的引擎改为InnoDB模式。 出处：https://zhidao.baidu.com/question/507577592.html 同一连接对象 确保事务内的所有数据库操作都是同一个数据库连接对象，是数据库事务机制可运作的基础。 在没有进行事务管理操作的底层Dao代码(BaseDao)是每进行一次数据库操作就做一次”获取连接-释放连接“。当某个业务功能单次运转内部就需要多次操作数据库时，显然这种每次操作都进行获取释放的控制是不能够保证，”事务内的所有数据库操作都位于同一连接对象上“这一要求的。 没有事务控制的BaseDao 123456789101112131415161718192021222324252627package com.website.dao;import com.website.utils.JdbcUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;import java.sql.Connection;import java.util.List;public abstract class BaseDao &#123; public int update(String sql,Object...args)&#123; //每一次进行数据库操作都获取一个新的数据库连接 Connection con = JdbcUtils.getConnection(); try &#123; return queryRunner.update(con, sql, args); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //每一次操作完毕都立即回收掉了这个数据库连接 JdbcUtils.close(con); &#125; return -1; &#125;&#125; 异常传递 事务的控制就在于控制数据库数据操作的异常情况，一旦哪一个环节出现异常，则整个环节回滚失效。 简而言之就是从最底层dao操作起，所有有可能出现的异常，都必须抛出，并能够往上传递至该业务的顶层代码(即这个业务功能结束时代码)，使其这个涉及数据库操作的业务在任意调用环节出错都可以被侦测到，进而顶层作为最后的异常抓取与处理，如选择回滚或其他操作，让事务保护整个业务流程的代码。 异常处理提点： 异常可以被内部try-catch捕获，但捕获后必须再抛出来。throw + throws 异常可以是显式地抛出，如第1点所示，也可以利用系统自带的隐式抛出(系统默认发现异常就会throw抛出) 模拟异常若不往上传递，而导致即使启用了事务控制，顶层代码也无法出现侦测做出回滚操作 123456789101112131415161718192021222324252627282930313233343536373839404142package com.website.test;import com.website.dao.OrderDao;import com.website.dao.impl.OrderDaoImp;import com.website.pojo.Order;import java.util.Date;/** * 异常测试 * @author yhd * @create 2021-06-01 17:10 */public class ExceptionTest&#123; //由于本案例所有dao操作都是继承BaseDao实现的，BaseDao就是最底层的dao //可以看出由于BaseDao由于捕获异常内部处理，且没有抛出异常，基础与BaseDao的OrderDao的方法 //在不存在编译时异常，而且当orderDao。若出现异常时代码会继续往下执行 public static void main(String[] args) &#123; try&#123; testException(); System.out.println(&quot;无异常，不回滚&quot;); &#125;catch (Exception e)&#123; System.out.println(&quot;检测到异常，回滚&quot;); &#125; &#125; //模拟异常内部处理且不抛出情况 public static void testException() &#123; OrderDao orderDao = new OrderDaoImp(); Order order = orderDao.queryOrderById(&quot;16224645526101&quot;); System.out.println(&quot;order = &quot; + order); //插入一个数据库查询出来的数据，造成主键冲突，模拟sql执行内部错误 orderDao.saveOrder(order); //继续进行数据库操作 orderDao.saveOrder(new Order(&quot;12345&quot;,new Date(),1.0,1,1)); System.out.println(orderDao.queryOrderById(&quot;12345&quot;)); &#125;&#125; 输出：成功查询数据库数据后，即使出现异常(仅打印)，代码扔继续执行，而且顶层检测不到异常。 123456789101112order = Order&#123;orderId=&#x27;16224645526101&#x27;, createTime=2021-05-31 20:35:52.0, price=80.0, status=0, userId=1&#125;java.sql.SQLException: Duplicate entry &#x27;16224645526101&#x27; for key &#x27;PRIMARY&#x27; Query: INSERT INTO t_order(`order_id`,`create_time`,`price`,`status`,`user_id`) VALUES(?,?,?,?,?); Parameters: [16224645526101, 2021-05-31 20:35:52.0, 80.0, 0, 1] at org.apache.commons.dbutils.QueryRunner.rethrow(QueryRunner.java:542) at org.apache.commons.dbutils.QueryRunner.update(QueryRunner.java:599) at com.website.dao.BaseDao.update(BaseDao.java:91) at com.website.dao.impl.OrderDaoImp.saveOrder(OrderDaoImp.java:24) at com.website.test.ExceptionTest.testException(ExceptionTest.java:36) at com.website.test.ExceptionTest.main(ExceptionTest.java:22)Order&#123;orderId=&#x27;12345&#x27;, createTime=2021-06-02 09:55:12.0, price=1.0, status=1, userId=1&#125;无异常，不回滚 顶层捕获service层捕获 通过上述“异常传递”的要求，需将异常上传至该业务的顶层代码，从Web开发原生MVC方案中，就是service层，service层正是调用DAO处理业务主要逻辑的部分。理论上说，从业务代码结束的角度上，应将异常上传至service层，通过将service层所有在一个try-cath里面编写，一旦出现异常则捕获，调用JdbcUtils进行回滚与资源回收。 目前可以通过代理设计模式，将service层的try-catch外壳抽取出来，实现代码复用。但仍然需要每一个业务的service层都需要设置。 Filet层捕获 更好的解决方案是，将service层的异常继续往上传递，一直传递到servlet、filter，直至被filter感知，通过Filter同一处理异常，进行回滚操作。 此时代码的复用程度最高，事务管理访问容易控制。 调用逻辑如下 事务管理实现以购物车结账生成订单createOrder功能为例，通过ThreadLocal + Filter 实现事务管理。主要操作简述步骤如下： 修改数据库连接管理(JdbcUtils)：含手动管理事务、同一连接对象操作 通过ThreadLocal存储Connection对象，保证之后的操作是同一个Connection对象 设置手动管理事务 封装[提交&amp;回滚]和、[提交&amp;回收]函数 增加remove操作，由于tomcat使用了线程池技术 底层DAO异常上抛(BaseDao)：异常传递操作 获取连接处：回收资源与回滚操作只能进行一次，通过外抛异常统一处理。 通过Filter统一捕获：顶层捕获操作 详细的修改操作如下： 连接管理如何确保一个功能内的所有数据库操作都是用同一个Connection对象呢？，用ThreadLocal存储可实现，而使用ThreadLocal实现前提又是所有操作都必须在同一个线程中完成，而Tomcat处理请求就是多个独立的线程处理。(有可能存在错误，先这样描述) 事务管理的JdbcUtils代码 修改 getConnection()方法 增加 commitAndClose()方法 增加 rollbackAndClose()方法 删除 close(Connection connection)方法 注意：若发现就算设置connection.setAutoCommit(false);还出现没有调用commit()方法数据就进入到数据库了，除去代码问题外，很有可能是因为数据表的引擎设置成了MyISAM模式，该模式是不支持事务的。不管是设置setAutoCommit(false)还是‘SET AUTOCOMMIT=0’都没有用！应修改数据表的引擎改为InnoDB模式。 出处：https://zhidao.baidu.com/question/507577592.html JdbcUtils.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * ThreadLocal事务管理版 * 获取数据库连接对象，若获取失败返回null * @return */public static Connection getConnection()&#123; //1、尝试从ThreadLocal中获取Connection对象 Connection connection = conns.get(); //2、若是首次获取连接则从数据库连接池中获取数据库连接，否则使用ThreadLocal中的连接 if(connection == null)&#123; try &#123; connection = dataSource.getConnection(); connection.setAutoCommit(false);//把当前连接设置为手动提交事务 conns.set(connection);//存入ThreadLocal中，并立即与当前线程绑定 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return connection;&#125;/** * 提交事务并回收连接资源 */public static void commitAndClose()&#123; //1、从ThreadLocal中取出数据库连接(保持一致性) Connection connection = conns.get(); if(connection != null)&#123; try &#123; connection.commit();//2、提交事务 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; connection.close();//3、关闭连接 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; //4、一定要执行remove操作，否则会报错，(由于Tomcat服务器底层使用了线程池技术) conns.remove();&#125;/** * 回滚事务并回收资源 */public static void rollbackAndClose() &#123; //1、从ThreadLocal中取出数据库连接(保持一致性) Connection connection = conns.get(); if(connection != null)&#123; try &#123; connection.rollback();//2、回滚事务 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; connection.close();//3、关闭连接 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; //4、一定要执行remove操作，否则会报错，(由于Tomcat服务器底层使用了线程池技术) conns.remove();&#125; 异常传递涉及数据库操作的必须将从最底层DAO(BaseDao)产生的异常均外抛，且能上传至Servlet层通过Filter方案统一处理。 createOrder业务功能调用逻辑：请求逻辑是系统自动处理调用，主要看响应逻辑 异常传递过程中，不一定全部显式抛出，也可以默认系统抛出，但一定要抛出。简而言之就是如下三种情况：(除JdbcUtils外) 响应逻辑中全程没有try-catch，按系统默认抛出异常后逐层传递。 响应逻辑中存在try-catch捕获异常操作，但捕获后要抛出(还不如不捕获直接抛出)。 响应逻辑中，对于SQL类型的异常直接抛出，其他选择性捕获后抛出。 演示案例中需要修改部分 BaseDao： 删除：所有finally中的close操作(保持同一对象) 添加：抛出异常，可以捕获异常(因为调用queryRunner.query()方法本身就会抛出异常)，但一定要抛出，或不捕获直接抛出。 OrderDao：抛出异常，throws SQLException OrderService：抛出异常，throws SQLException OrderServlet：抛出异常，throws SQLException BaseServlet：抛出异常，throws SQLException Filter捕获异常 通过了解Filter实际调用原理可以使用Filter进行异常捕获 TransactionFilter.java 123456789101112131415161718192021222324252627282930313233package com.website.filter;import com.website.utils.TransactionJdbcUtils;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpFilter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author yhd * @create 2021-06-02 15:07 */public class TransactionFilter extends HttpFilter &#123; @Override protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; try &#123; //响应中没有发生异常，则提交事务操作 chain.doFilter(request,response); TransactionJdbcUtils.commitAndClose(); &#125;catch (Exception e)&#123; e.printStackTrace(); //否则回滚事务 TransactionJdbcUtils.rollbackAndClose(); &#125; &#125;&#125; web.xml 12345678910&lt;!-- 事务管理过滤器，写在web.xml首部 --&gt;&lt;filter&gt; &lt;filter-name&gt;TransactionFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.website.filter.TransactionFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;TransactionFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Tomcat错误信息页如事务控制中处理异常后，若不进行任何处理，返回给用户就是空白页。因此还需要跳转到一些用户提示页面。可以添加代码重定向逐一设置各种情况错误跳转到哪里。更好的解决方案是，让Tomcat统一管理错误信息页，通过web.xml中配置实现。 使用步骤 创建错误信息展示页面 在web.xml中配置错误页面信息 web.xml 123456&lt;error-page&gt; &lt;!-- 设置HTTP错误代码，500即Tomcat发现内部错误(异常)时调用指定页面 --&gt; &lt;!-- 对于500内部异常错误，需Tomcat捕获到程序异常才能生效 --&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/error/error_500.html&lt;/location&gt;&lt;/error-page&gt; 某些错误状态码需被Tomcat服务器检测到异常才能生效，如500内部错误。(若存在Filter中使用try-catch，则要显式上抛异常) 创建错误信息页面 配置错误页面 web.xml 123456789101112&lt;error-page&gt; &lt;!-- 设置HTTP错误代码，500即Tomcat发现内部错误(异常)时调用指定页面 --&gt; &lt;!-- 对于500内部异常错误，需Tomcat捕获到程序异常才能生效 --&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/error/error_500.html&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt; &lt;!-- 404错误可被Tomcat直接捕获，不或访问到web程序，可直接配置生效 --&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error/error_400.html&lt;/location&gt;&lt;/error-page&gt; 上报异常如500内部错误状态码，需要Tomcat能感知到程序错误异常才能生效，如果在程序内部被拦截是无法生效的(程序内部捕获了也就不会产生内部错误) 下例为TransationFilter实现事务管理时500错误异常上报情况 1234567891011try &#123; //响应中没有发生异常，则提交事务操作 chain.doFilter(request,response); TransactionJdbcUtils.commitAndClose();&#125;catch (Exception e)&#123; e.printStackTrace(); //否则回滚事务 TransactionJdbcUtils.rollbackAndClose(); //继续上抛异常至Tomcat服务器，让Tomcat检测到跳转指定错误页面 throw new RuntimeException();&#125; 最终效果 ThreadLocal基本概念JDK提供用于解决线程安全的工具类，ThreadLocal它可以给当前线程，以线程名(唯一性)为key对指定一个Object类型数据进行绑定(关联)操作，使其避免其他线程访问的同时可对被绑定数据进行线程安全的存取操作(如Map存取操作)，达到线程安全操作的效果。 ThreadLocal特点 ThreadLocal 可以为当前线程关联一个数据。（它可以像 Map 一样存取数据，key 为当前线程） 每一个 ThreadLocal 对象，只能为当前线程关联一个数据，如果要为当前线程关联多个数据，就需要使用多个 ThreadLocal 对象实例。 每个 ThreadLocal 对象实例定义的时候，一般都是 static 类型 ThreadLocal 中保存数据，在线程销毁后。会由 JVM 虚拟自动释放 小结：ThreadLocal是以每个线程的线程名为key，存储某个Object数据的线程安全Map类型存储器。 模拟应用场景 创建类SimilarThreadLocal模仿ThreadLocal的实现与功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.webstite.threadlocal;import java.util.Hashtable;import java.util.Map;import java.util.Random;/** * 仿写ThreadLocal的功能 * 以线程名绑定某个Objetc类型数据，可对被绑定数据进行线程安全的存取操作。 * @author yhd * @create 2021-06-01 8:47 */public class SimilarThreadLocal &#123; //创建线程安全的Map，用于存储绑定数据及其实现存取操作 //key为当前线程名，value为任意的Object类型 //模仿ThreadLocal使用建议，设置为static类型 public static Map&lt;String,Object&gt; mapData = new Hashtable&lt;&gt;(); //随机数生成 private static Random random = new Random(); //创建三个线程，并为每个线程分配一个数据作为被绑定的数据 //在三个线程同时执行下，正确存取对应线程所分配的数据(线程安全测试) public static class Task implements Runnable&#123; @Override public void run() &#123; Integer num = random.nextInt(1000); //获取当前线程线程名(唯一性)，作为Map中的key String name = Thread.currentThread().getName(); System.out.println(&quot;线程[&quot;+ name +&quot;]绑定的随机数为：&quot; + num); mapData.put(name,num); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //获取数据测试，查看数据是否对称存取，检查线程安全操作 new OrderService().createOrder(); &#125; &#125;; //开启三个线程 public static void main(String[] args) &#123; for(int i = 0;i &lt; 3;i++)&#123; new Thread(new Task()).start(); &#125; &#125;&#125; 模仿在多线程环境获取特定的数据 1234567891011121314package com.webstite.threadlocal;/** * 模仿一应用需求：生成订单操作需在线程中获取一个数据 * @author yhd * @create 2021-06-01 9:02 */public class OrderService &#123; public void createOrder()&#123; //获取当前执行的线程名，作为获取数据的key标志 String name = Thread.currentThread().getName(); System.out.println(&quot;OrderService处于线程[&quot;+ name +&quot;]获取绑定数据&quot; + SimilarThreadLocal.mapData.get(name)); &#125;&#125; 打印输出 123456线程[Thread-0]绑定的随机数为：57线程[Thread-1]绑定的随机数为：655线程[Thread-2]绑定的随机数为：965OrderService处于线程[Thread-1]获取绑定数据655OrderService处于线程[Thread-0]获取绑定数据57OrderService处于线程[Thread-2]获取绑定数据965 使用ThreadLocal实现 修改SimilarThreadLocal.java 12//public static Map&lt;String,Object&gt; mapData = new Hashtable&lt;&gt;();public static ThreadLocal&lt;Object&gt; threadLocal= new ThreadLocal&lt;&gt;(); 修改OrderService.java 12//System.out.println(&quot;OrderService处于线程[&quot;+ name +&quot;]获取绑定数据&quot; + SimilarThreadLocal.mapData.get(name));System.out.println(&quot;OrderService处于线程[&quot;+ name +&quot;]获取绑定数据&quot; + SimilarThreadLocal.threadLocal.get()); 常用工具类带默认值字符串转整型优势 带默认值字符串转整型的操作，在处理web请求中使用的频率非常高 带默认值的功能，比屏蔽内部异常后返回统一判断标识的做法更高明，它使其调用者出现就算异常情况，也不用再写调用该方法的一些判断，而是将用户自定义的异常处理方案也预置在调用方法中，灵活性更高。 使其代码更加简洁，健壮性更高 示例 在获取请求页码和每页数据量时，带默认值的类型转换函数，可以让用户预置自定义异常出现后的解决方案。使其代码更简洁，健壮性更高。 1234567//获取请求页码和每页数据量(默认是第1页、每页Page.PAGE_SIZE 4 项内容)int pageNo = WebUtils.parseInt(req.getParameter(&quot;pageNo&quot;), 1);int pageSize = WebUtils.parseInt(req.getParameter(&quot;pageSize&quot;),Page.PAGE_SIZE);//补充int min = WebUtils.parseInt(req.getParameter(&quot;min&quot;),0);int max = WebUtils.parseInt(req.getParameter(&quot;max&quot;),Integer.MAX_VALUE); 在一些常规场合，也可以让代码更清晰 12// 获取商品编号int id = WebUtils.parseInt(req.getParameter(&quot;id&quot;), 0); 源代码 源代码 12345678910111213141516171819202122232425package com.website.utils;import org.apache.commons.beanutils.BeanUtils;import java.util.Map;/** * @author yhd * @create 2021-04-22 11:20 */public class WebUtils &#123; /** * 带默认值地将字符串数值转换为整型 * @param strInt 字符串数值 * @param defaultValue 若转换失败返回默认定义值 * @return */ public static int parseInt(String strInt,int defaultValue)&#123; try &#123; return Integer.parseInt(strInt); &#125; catch (NumberFormatException e) &#123; //e.printStackTrace(); &#125; return defaultValue; &#125;&#125; 命名词汇常用动词 查找/查询：query 获取：get 删除：delete … 常用介词 by….：通过….，基于….，根据…..， 通过id删除图书：deleteBookById() 基于价格来查找总页数：queryForPageTotalCountByPrice() for…：对…，给…，为…，供…表用途，;以帮助; 对总页码数进行查询：queryForPageTotalCount() BaseDao中常见： 对数值进行查询：queryForValue() 对List集合进行查询：queryForList() … to…：变成、转换到.. 转换/变成String类型：toString() 转换/变成JSON类型：gson.toJson() 前端请求方案 form表单直接提交 超链接get请求 js事件绑定-location.href赋值刷新当前页面发起请求方案 js事件绑定-ajax异步交互json数据 location.href123456789$(&quot;input.searchPageBtn&quot;).click(function ()&#123; //1、获取输入的页码(忽略非法输入情况) var pageNo = $(&quot;#pn_input&quot;).val(); //2、javaScript语言中提供了一个location地址栏对象， //其中具备一个名为href属性，可以对浏览器地址栏操作，可读可写 //读href属性：获取当前浏览器URL内容 //写href属性：替换当前浏览器URL并直接在当前页面访问(GET请求) location.href = &quot;manager/bookServlet?action=page&amp;pageNo=&quot; + pageNo;&#125;); 电商Web功能模块购物车基本功能 加入购物车 删除商品项 清空购物车 修改商品数量 … 对象模型 Cart：购物车对象 totalCount：总商品数量(可选项，因却决于items) totalPrice：总商品金额(可选项，因却决于items) Map&lt;Integer,CartItem&gt; items：购物车商品项集 CartItem：购物车专属商品项信息 id：商品编号 name：商品名称 count：商品数量 price：商品单价 totalPrice：商品总价 参考分析 实现技术目前市面上购物车实现技术有： Session版本：将用户的购物车信息保存到Session域中 数据库版本：将用户的购物车信息保存到数据库中 redis + 数据库 + Cookie：使用Cookie + Redis缓存，和数据库实现 Sessions方案一般web调用方案是，web层(Servlet)——&gt;业务层(service)——&gt;持久层(dao)，由于基于Session实现的用户数据存储在Session中，因此没有dao，这些增删改查方法，而且Session属于web层API，可以选择service直接操作，或封装到Cart对象模型中，目前选择后者。 Cart对象模型具备的方法： addItem(CartItem); deleteItem(id); clear(); updateCount(id,count); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package com.atguigu.pojo;import java.math.BigDecimal;import java.util.LinkedHashMap;import java.util.Map;/** * 购物车对象 */public class Cart &#123;// private Integer totalCount;// private BigDecimal totalPrice; /** * key是商品编号， * value，是商品信息 */ private Map&lt;Integer,CartItem&gt; items = new LinkedHashMap&lt;Integer,CartItem&gt;(); /** * 添加商品项 * * @param cartItem */ public void addItem(CartItem cartItem) &#123; // 先查看购物车中是否已经添加过此商品，如果已添加，则数量累加，总金额更新，如果没有添加过，直接放到集合中即可 CartItem item = items.get(cartItem.getId()); if (item == null) &#123; // 之前没添加过此商品 items.put(cartItem.getId(), cartItem); &#125; else &#123; // 已经 添加过的情况 item.setCount( item.getCount() + 1 ); // 数量 累加 item.setTotalPrice( item.getPrice().multiply(new BigDecimal( item.getCount() )) ); // 更新总金额 &#125; &#125; /** * 删除商品项 */ public void deleteItem(Integer id) &#123; items.remove(id); &#125; /** * 清空购物车 */ public void clear() &#123; items.clear(); &#125; /** * 修改商品数量 */ public void updateCount(Integer id,Integer count) &#123; // 先查看购物车中是否有此商品。如果有，修改商品数量，更新总金额 CartItem cartItem = items.get(id); if (cartItem != null) &#123; cartItem.setCount(count);// 修改商品数量 cartItem.setTotalPrice( cartItem.getPrice().multiply(new BigDecimal( cartItem.getCount() )) ); // 更新总金额 &#125; &#125; public Integer getTotalCount() &#123; Integer totalCount = 0; for (Map.Entry&lt;Integer,CartItem&gt;entry : items.entrySet()) &#123; totalCount += entry.getValue().getCount(); &#125; return totalCount; &#125; public BigDecimal getTotalPrice() &#123; BigDecimal totalPrice = new BigDecimal(0); for (Map.Entry&lt;Integer,CartItem&gt;entry : items.entrySet()) &#123; totalPrice = totalPrice.add(entry.getValue().getTotalPrice()); &#125; return totalPrice; &#125; public Map&lt;Integer, CartItem&gt; getItems() &#123; return items; &#125; public void setItems(Map&lt;Integer, CartItem&gt; items) &#123; this.items = items; &#125; @Override public String toString() &#123; return &quot;Cart&#123;&quot; + &quot;totalCount=&quot; + getTotalCount() + &quot;, totalPrice=&quot; + getTotalPrice() + &quot;, items=&quot; + items + &#x27;&#125;&#x27;; &#125;&#125; 添加购物添加购物后返回操作 需求描述：往往用户在含有分页、分类、价格区间下等等多种条件筛选下的页面情况进行加入购物车操作，当购物车操作处理完后，应该让页面回到原有状态下的情况。如用户在点击了电子产品类别，第三页中进行了添加购物车操作。操作完成后也应该让页面回到电子产品类别、第三页中。 解决方案：通过获取发起购物车请求时网页地址栏的URL，在加入购物车操作完成后，请求重定向回去这个网页，由于这些筛选项参数一般都通过GET请求实现，因此通过URL则可以回到原有状态的网页。在HTTP协议中通过获取Referer请求头获取到网页地址栏。 1req.getHeader(&quot;Referer&quot;); 删除商品项对于删除、清空、或不容易被用户感知的修改数据等操作，一定需要给出确认、取消提示框。 123456789101112$(&quot;a.deleteClass&quot;).click(function()&#123; /** * confirm 是确认提示框函数 * 参数：提示内容 * 提供两个按钮，确认、取消 * 返回true表示点击了确认，返回false则点击了取消 */ //直接return即，因为返回false则阻止元素的默认行为，不提交 //this：在事件的function函数中，this对象表示当前响应事件(前端响应)的dom对象 //在这里this == &lt;a class=&quot;deleteClass&quot; href=&quot;manager/bookServlet?action=delete&amp;id=$&#123;book.id&#125;&quot;&gt;删除&lt;/a&gt; return confirm(&quot;你确定要删除 &quot; + $(this).parent().parent().find(&quot;td:first&quot;).text() + &quot;?&quot;);&#125;); 修改购物车 业务功能： js代码： 123456789101112131415// 给输入框绑定 onchange内容发生改变事件$(&quot;.updateCount&quot;).change(function () &#123; // 获取商品名称 var name = $(this).parent().parent().find(&quot;td:first&quot;).text(); var id = $(this).attr(&#x27;bookId&#x27;); // 获取商品数量 var count = this.value; if ( confirm(&quot;你确定要将【&quot; + name + &quot;】商品修改数量为：&quot; + count + &quot; 吗?&quot;) ) &#123; //发起请求。给服务器保存修改 location.href = &quot;http://localhost:8080/book/cartServlet?action=updateCount&amp;count=&quot;+count+&quot;&amp;id=&quot;+id; &#125; else &#123; // defaultValue属性是表单项Dom对象的属性。它表示默认的value属性值。 this.value = this.defaultValue; &#125;&#125;); 若js需要后端的参数，如修改商品的id号，可通过在绑定事件中添加自定义的属性存储这些参数，如下的bookId属性就是自定义用于存储商品id信息，提供个js发出请求。 1&lt;input class=&quot;updateCount&quot; bookId=&quot;$&#123;entry.value.id&#125;&quot; type=&quot;text&quot; value=&quot;$&#123;entry.value.count&#125;&quot;&gt; 最后添加回显 Servlet修改 123//在addItem最后添加// 最后一个添加的商品名称,提供前端页面回显req.getSession().setAttribute(&quot;lastName&quot;, cartItem.getName()); 前端页面修改：除直接赋值外，由于清空购物车操作也不显示，因此需判断一下购物车 12345678910111213141516&lt;div style=&quot;text-align: center&quot;&gt; &lt;c:if test=&quot;$&#123;empty sessionScope.cart.items&#125;&quot;&gt; &lt;%--购物车为空的输出--%&gt; &lt;span&gt; &lt;/span&gt; &lt;div&gt; &lt;span style=&quot;color: red&quot;&gt;当前购物车为空&lt;/span&gt; &lt;/div&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;not empty sessionScope.cart.items&#125;&quot;&gt; &lt;%--购物车非空的输出--%&gt; &lt;span&gt;您的购物车中有 $&#123;sessionScope.cart.totalCount&#125; 件商品&lt;/span&gt; &lt;div&gt; 您刚刚将&lt;span style=&quot;color: red&quot;&gt;$&#123;sessionScope.lastName&#125;&lt;/span&gt;加入到了购物车中 &lt;/div&gt; &lt;/c:if&gt;&lt;/div&gt; Servlet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.atguigu.web;import com.atguigu.pojo.Book;import com.atguigu.pojo.Cart;import com.atguigu.pojo.CartItem;import com.atguigu.service.BookService;import com.atguigu.service.impl.BookServiceImpl;import com.atguigu.utils.WebUtils;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class CartServlet extends BaseServlet &#123; private BookService bookService = new BookServiceImpl(); /** * 修改商品数量 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void updateCount(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; // 获取请求的参数 商品编号 、商品数量 int id = WebUtils.parseInt(req.getParameter(&quot;id&quot;),0); int count = WebUtils.parseInt(req.getParameter(&quot;count&quot;), 1); // 获取Cart购物车对象 Cart cart = (Cart) req.getSession().getAttribute(&quot;cart&quot;); if (cart != null) &#123; // 修改商品数量 cart.updateCount(id,count); // 重定向回原来购物车展示页面 resp.sendRedirect(req.getHeader(&quot;Referer&quot;)); &#125; &#125; /** * 清空购物车 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void clear(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; // 1 获取购物车对象 Cart cart = (Cart) req.getSession().getAttribute(&quot;cart&quot;); if (cart != null) &#123; // 清空购物车 cart.clear(); // 重定向回原来购物车展示页面 resp.sendRedirect(req.getHeader(&quot;Referer&quot;)); &#125; &#125; /** * 删除商品项 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void deleteItem(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; // 获取商品编号 int id = WebUtils.parseInt(req.getParameter(&quot;id&quot;), 0); // 获取购物车对象 Cart cart = (Cart) req.getSession().getAttribute(&quot;cart&quot;); if (cart != null) &#123; // 删除 了购物车商品项 cart.deleteItem(id); // 重定向回原来购物车展示页面 resp.sendRedirect(req.getHeader(&quot;Referer&quot;)); &#125; &#125; /** * 加入购物车 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void addItem(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取请求的参数 商品编号 int id = WebUtils.parseInt(req.getParameter(&quot;id&quot;), 0); // 调用bookService.queryBookById(id):Book得到图书的信息 Book book = bookService.queryBookById(id); // 把图书信息，转换成为CartItem商品项 CartItem cartItem = new CartItem(book.getId(),book.getName(),1,book.getPrice(),book.getPrice()); // 调用Cart.addItem(CartItem);添加商品项 Cart cart = (Cart) req.getSession().getAttribute(&quot;cart&quot;); if (cart == null) &#123; cart = new Cart(); req.getSession().setAttribute(&quot;cart&quot;,cart); &#125; cart.addItem(cartItem); System.out.println(cart); System.out.println(&quot;请求头Referer的值：&quot; + req.getHeader(&quot;Referer&quot;)); // 最后一个添加的商品名称,提供前端页面回显 req.getSession().setAttribute(&quot;lastName&quot;, cartItem.getName()); // 重定向回原来商品所在的地址页面 resp.sendRedirect(req.getHeader(&quot;Referer&quot;)); &#125;&#125; 订单基本功能 用户： 生成订单 查看我的(全部)订单 查看订单详情(商品信息) 签收订单 管理员/店家 查看所有订单(管理员/店家) 查看订单详情(商品信息) 发货(管理员/店家) 对象模型 Order：订单类 orderId：订单号(唯一) createTime：下单时机 price：交易金额 status：交易状态，如0未发货，1已发货，2已签收 userId：用户编号，用于标记这个订单属于哪个用户 OrderItem items：订单信息专属商品项(采用数据库存储方案) OrderItem：订单信息专属商品项类 id：主键编号 name：商品名称 count：数量 price：单价 totalPrice：总价 orderId：订单号，属于哪个订单的商品项(数据库存储方案) 参考分析 功能实现 生成订单 Servlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.website.service.impl;import com.website.dao.BookDao;import com.website.dao.OrderDao;import com.website.dao.OrderItemDao;import com.website.dao.impl.BookDaoImp;import com.website.dao.impl.OrderDaoImp;import com.website.dao.impl.OrderItemDaoImp;import com.website.pojo.*;import com.website.service.OrderService;import java.util.Date;/** * @author yhd * @create 2021-05-31 16:03 */public class OrderServiceImp implements OrderService &#123; //先保存订单、再保存订单号 OrderDao orderDao = new OrderDaoImp(); OrderItemDao orderItemDao = new OrderItemDaoImp(); //用于生成订单后改变原有的库存量域销量数据 private BookDao bookDao = new BookDaoImp(); @Override public String createOrder(Cart cart, Integer userId) &#123; //1、先保存订单 //订单的唯一性 String orderId = System.currentTimeMillis() + &quot;&quot; +userId; Order order = new Order(orderId,new Date(),cart.getTotalPrice().doubleValue(),0,userId); orderDao.saveOrder(order); //2、保存订单的商品项目 //将购物车的商品项转换未购物车的商品项 for (CartItem cartItem : cart.getItems().values()) &#123; //更新图书销量和库存 Book book = bookDao.queryBookById(cartItem.getId()); book.setSales(book.getSales() + cartItem.getCount()); book.setStock(book.getStock() - cartItem.getCount()); bookDao.updateBook(book); OrderItem orderItem = new OrderItem(null,cartItem.getName(),cartItem.getCount(),cartItem.getPrice().doubleValue(),cartItem.getTotalPrice().doubleValue(),orderId); orderItemDao.saveOrder(orderItem); &#125; return orderId; &#125;&#125; 前后端分离基本概念 JSP + Servlet的Web技术方案存在的最大问题就是前后端业务耦合度高，数据是通过各种后端代码标签嵌入到前端页面中，随着技术的发展已经逐渐被淘汰。 现如今最常用的Web技术方案就是前后端分离方案。分离在于前后端都协定一种数据交换格式(JSON)，客户端与服务器之间任何数据传递都是先封装成这种格式然后在网络中进行传递，客户端或服务器收到后再自行解析。使其前后端的工作完全分离，直接面向这种数据格式编程。 JSONJSON概念JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON 采用完全独立于语言的文本格式，而且很多语言都提供了对 json 的支持（包括 C, C++, C#, Java, JavaScript, Perl, Python 等）。 使得 JSON 成为理想的数据交换格式。 json 是一种轻量级的数据交换格式，轻量级指的是跟 xml 做比较(早期数据交换格式使用XML)。 数据交换指的是客户端和服务器之间业务数据的传递格式。 格式定义 json是由键值对组成，并由花括号(大括号/ { } )包围。 每个键由双引号引起来 键和值之间使用冒号进行分隔：&#123;&quot;key&quot;:value&#125; 多组键值对之间进行逗号进行分隔：&#123;&quot;key1&quot;:value1,&quot;key2&quot;:value2,...&#125; 每个值支持多种类型： 数值：&#123;&quot;key&quot;:12&#125; 字符串：&#123;&quot;key&quot;:&quot;str&quot;&#125; 布尔型：&#123;&quot;key&quot;:true&#125; 数组：&#123;&quot;key&quot;:[11,&quot;arr&quot;,false]&#125; JSON对象：&#123;&quot;key&quot;: &#123;&quot;key1&quot;:1,&quot;key2&quot;:false&#125; &#125; JSON数组(数组)：&#123;&quot;key&quot;: [&#123;&quot;key1&quot;:1,&quot;key2&quot;:false&#125;,&#123;&quot;key3&quot;:123&#125;] &#125; JavaScript中，JSON格式示意 12345678910111213141516var jsonObj = &#123; &quot;key1&quot;:12, &quot;key2&quot;:&quot;abc&quot;, &quot;key3&quot;:true, &quot;key4&quot;:[11,&quot;arr&quot;,false], &quot;key5&quot;:&#123; &quot;key5_1&quot; : 551, &quot;key5_2&quot; : &quot;key5_2_value&quot; &#125;, &quot;key6&quot;:[&#123; &quot;key6_1_1&quot;:6611, &quot;key6_1_2&quot;:&quot;key6_1_2_value&quot;&#125;,&#123; &quot;key6_2_1&quot;:6621, &quot;key6_2_2&quot;:&quot;key6_2_2_value&quot; &#125;]&#125;; 反序列化与反序列化基本概念 持久化（Persistence）：将程序数据在瞬时状态转换为持久状态。即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。 序列化（Serialization）：是将对象的状态信息，转换为可存储或可传输的形式的过程，可以理解为一种对象持久化的过程。从json作为数据交换格式情况下，序列化即Java对象变成json的过程。序列化的目的在于： 存储：以某种存储形式使自定义对象持久化 传递：将对象从一个地方传递到另一个地方 维护：使程序更具维护性 反序列化：即序列化的逆过程，从json作为数据交换格式情况下，序列化即json变成Java对象的过程。 JavaScript序列化Json对象数据用来操作，Json字符串用于传送 把 json 对象转换成为 json 字符串:var jsonObjString = JSON.stringify(jsonObj); 反序列化 将后端发送过来的JSON字符串转换为JSON对象：var jsonObj = JSON.parse(jsonObjString); 解析JSON数据：json在JavaScript中就是一个对象，直接通过“**.点取**”操作获取即可 1234567891011121314151617181920212223242526272829303132333435363738&lt;script type=&quot;text/javascript&quot;&gt; // json的定义 var jsonObj = &#123; &quot;key1&quot;:12, &quot;key2&quot;:&quot;abc&quot;, &quot;key3&quot;:true, &quot;key4&quot;:[11,&quot;arr&quot;,false], &quot;key5&quot;:&#123; &quot;key5_1&quot; : 551, &quot;key5_2&quot; : &quot;key5_2_value&quot; &#125;, &quot;key6&quot;:[&#123; &quot;key6_1_1&quot;:6611, &quot;key6_1_2&quot;:&quot;key6_1_2_value&quot; &#125;,&#123; &quot;key6_2_1&quot;:6621, &quot;key6_2_2&quot;:&quot;key6_2_2_value&quot; &#125;] &#125;;// alert(typeof(jsonObj));// object json就是一个对象// alert(jsonObj.key1); //12// alert(jsonObj.key2); // abc// alert(jsonObj.key3); // true// alert(jsonObj.key4);// 得到数组[11,&quot;arr&quot;,false]// // json 中 数组值的遍历// for(var i = 0; i &lt; jsonObj.key4.length; i++) &#123;// alert(jsonObj.key4[i]);// &#125;// alert(jsonObj.key5.key5_1);//551// alert(jsonObj.key5.key5_2);//key5_2_value// alert( jsonObj.key6 );// 得到json数组//// // 取出来每一个元素都是json对象// var jsonItem = jsonObj.key6[0];// // alert( jsonItem.key6_1_1 ); //6611// alert( jsonItem.key6_1_2 ); //key6_1_2_value&lt;/script&gt; Java Gson 是 Google 提供的用来在 Java 对象和 JSON 数据之间进行映射的 Java 类库。使用前需添加jar包。gson-2.2.4.jar。 常用的序列化与反序列化的操作对象有：JavaBean、List、Map三种类型。使用步骤如下： 无论序列化还是反序列化第一步均需创建Gson对象：Gson gson = new Gson(); 序列化：统一调用son.toJson(Object src); 反序列化： javaBean：gson.fromJson(String json,Class&lt;T&gt; classOfT) 集合(List &amp; Map)：gson.fromJson(String json,Type typeOfT); 集合类反序列化不能使用：gson.fromJson(String json,Class&lt;T&gt; classOfT)原因： 错误测试 1234567891011121314@Testpublic void test2()&#123; //List与Json之间的转换 List&lt;Person&gt; personList = new ArrayList&lt;&gt;(); personList.add(new Person(1,&quot;陈慧娴&quot;)); personList.add(new Person(1,&quot;陈百强&quot;)); System.out.println(&quot;personList = &quot; + personList); Gson gson = new Gson(); String personJsonString = gson.toJson(personList); List&lt;Person&gt; list = gson.fromJson(personJsonString, personList.getClass()); Person person = list.get(0);//将报出类型转换错误&#125; 错误打印 12345java.lang.ClassCastException: com.google.gson.internal.LinkedTreeMap cannot be cast to com.website.pojo.Person at com.website.json.JsonTest.test2(JsonTest.java:68) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ..... 原理分析：gson.fromJson(String json,Class&lt;T&gt; classOfT);方法默认会转换为LinkedTreeMap类型由于gson功能设计，LinkedTreeMap可以部封装成bean也可以自由地进行通过key获取value的操作如JavaScript操作json对象一般，只要有key就能获取value。因此回来的数据类型是List&lt;LinkedTreeMap&gt;获取其中一个数据项转为Person类型肯定报错。 JavaBean JsonTest.java 12345678910111213141516@Testpublic void test1()&#123; //JavaBean与Json之间的转换 Person person = new Person(1,&quot;陈慧娴&quot;); System.out.println(&quot;person = &quot; + person); //1、创建Gson对象 Gson gson = new Gson(); //2.1、JavaBean——&gt;Json：调用gson.toJson(Object src); String personJsonString = gson.toJson(person); System.out.println(&quot;personJsonString = &quot; + personJsonString); //2.2、Json——&gt;JavaBean：调用：gson.fromJson(String json,Class&lt;T&gt; classOfT); Person person1 = gson.fromJson(personJsonString, Person.class); System.out.println(&quot;person1 = &quot; + person1);&#125; 打印结果： 123person = Person&#123;id=1, name=&#x27;陈慧娴&#x27;&#125;personJsonString = &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;陈慧娴&quot;&#125;person1 = Person&#123;id=1, name=&#x27;陈慧娴&#x27;&#125; List 创建Gson对象 序列化：son.toJson(Object src); 反序列化：gson.fromJson(String json,Type typeOfT); Type对象： 创建一个空白类继承com.google.gson.reflect.TypeToken泛型类 在继承TypeToken&lt;&gt;泛型类中填入目的转换的集合类型，如List&lt;Person&gt;或ArrayList&lt;Person&gt; 调用这个空白类的getType()方法，将返回的Type对象传fromJson()方法中 tips：实际开发中，直接通过匿名的方式继承创建这个空白类传入。 1gson.fromJson(personJsonString,new TypeToken&lt;ArrayList&lt;Person&gt;&gt;()&#123;&#125;.getType()); JsonTest.java 12345678910111213141516171819@Testpublic void test2()&#123; //List与Json之间的转换 List&lt;Person&gt; personList = new ArrayList&lt;&gt;(); personList.add(new Person(1,&quot;陈慧娴&quot;)); personList.add(new Person(1,&quot;陈百强&quot;)); System.out.println(&quot;personList = &quot; + personList); //1、创建Gson对象 Gson gson = new Gson(); //2.1、JavaBean——&gt;Json：调用gson.toJson(Object src); String personJsonString = gson.toJson(personList); System.out.println(&quot;personJsonString = &quot; + personJsonString); //2.2.1、调用gson.fromJson(String json,Type typeOfT)方法， List&lt;Person&gt; personList1 = gson.fromJson(personJsonString, new PersonListType().getType()); System.out.println(&quot;personList1 = &quot; + personList1);&#125; PersonListType.java 1234567891011121314package com.website.json;import com.google.gson.reflect.TypeToken;import com.website.pojo.Person;import java.util.ArrayList;/** * 空白类，仅用于继承TypeToken辅助Gson进行反射操作 * @author yhd * @create 2021-06-02 21:19 */public class PersonListType extends TypeToken&lt;ArrayList&lt;Person&gt;&gt; &#123;&#125; 打印结果： 123personList = [Person&#123;id=1, name=&#x27;陈慧娴&#x27;&#125;, Person&#123;id=1, name=&#x27;陈百强&#x27;&#125;]personJsonString = [&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;陈慧娴&quot;&#125;,&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;陈百强&quot;&#125;]personList1 = [Person&#123;id=1, name=&#x27;陈慧娴&#x27;&#125;, Person&#123;id=1, name=&#x27;陈百强&#x27;&#125;] Map 同理与List操作 1234567891011121314151617181920@Testpublic void test3()&#123; //Map与Json之间的转换 Map&lt;Integer,Person&gt; map = new HashMap&lt;&gt;(); map.put(1,new Person(1,&quot;陈慧娴&quot;)); map.put(2,new Person(2,&quot;陈百强&quot;)); System.out.println(&quot;map = &quot; + map); //1、创建Gson对象 Gson gson = new Gson(); //2.1、JavaBean——&gt;Json String mapJsonString = gson.toJson(map); System.out.println(&quot;mapJsonString = &quot; + mapJsonString); //2.2、Json——&gt;JavaBean Map&lt;Integer,Person&gt; mapPerson = gson.fromJson(mapJsonString, new TypeToken&lt;Map&lt;Integer, Person&gt;&gt;() &#123;&#125;.getType()); Person person = mapPerson.get(1); System.out.println(&quot;person = &quot; + person);&#125; AJAX基本概念AJAX 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML，由于以前数据交换格式使用XML），是指一种创建交互式网页应用的网页开发技术。 AJAX不是新的编程语言，而是一种使用现有技术集合的‘新’方法，不同库或框架有自己的AJAX实现。 AJAX所描述的技术集合：通过浏览器脚本编程语言调用一个隐藏请求装置，也就是XMLHttpRequest(简称XHR)，由这个请求装置异步地向服务器请求资源，使其页面不阻塞情况下返回一个资源载体。可在不重载页面的情况下与 Web 服务器交换数据，即在不需要刷新页面的情况下，就可以产生局部刷新的效果。 AJAX的优势： Ajax 在浏览器与 Web 服务器之间使用异步数据传输（HTTP 请求），这样就可使网页从服务器请求少量的信息，而不是整个页面。 Ajax可使因特网应用程序更小、更快，更友好 原生AJAX示例由于AJAX的基础是XMLHttpRequest服务器资源交互对象，因此实现AJAX首先围绕这个对象展开。w3school学习参考文档。实现原生的AJAX基本步骤如下： 创建XMLHttpRequest对象 设置请求链接及其参数，xmlhttp.open(); 发送请求前绑定onreadystatechange事件，设置处理请求完成后的操作。 向服务器发起请求，xmlhttp.send(); 在onreadystatechange 事件中处理数据 使用示例 ajax.html 1234567891011121314151617181920212223&lt;script type=&quot;text/javascript&quot;&gt; function ajaxRequest() &#123; //1、首先创建XMLHttpRequest var xmlHttp = new XMLHttpRequest(); //2、调用open方法设置请求参数 var requestUrl = &quot;/15_json_ajax_i18n/ajaxServlet?action=javaScriptAjax&quot; xmlHttp.open(&quot;GET&quot;,requestUrl,true); //3、在send方法前绑定onreadystatechange事件，处理请求完成后的操作。 xmlHttp.onreadystatechange=function ()&#123; //当XMLHttpRequest对象的readyState属性为4，表示请求完成，且响应就绪 //且HTTP响应码为200时，表示数据完整接收到 if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200)&#123; //证明顺利接收到完整的数据，开始处理数据 alert(xmlHttp.responseText); &#125; &#125; //4、调用send方法发送请求 xmlHttp.send();&#125;&lt;/script&gt; AjaxServlet.java 1234567891011121314151617181920212223242526package com.website.servlet;import com.google.gson.Gson;import com.website.pojo.Person;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author yhd * @create 2021-06-03 7:57 */public class AjaxServlet extends BaseServlet &#123; //响应JavaScript的Ajax请求 protected void javaScriptAjax(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //向ajax请求响应一个json格式的Person对象 Person person = new Person(1,&quot;陈慧娴&quot;); Gson gson = new Gson(); String personJsonString = gson.toJson(person); resp.getWriter().write(personJsonString); &#125;&#125; web.xml：配置servlet 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;AjaxServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.website.servlet.AjaxServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;AjaxServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/ajaxServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 效果 API详细的API文档，请查看w3school XMLHtppRequest对象 创建 XMLHttpRequest 对象的语法： 1variable=new XMLHttpRequest(); 老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象： 1variable=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); open() 方法 描述 open(method,*url,async) 规定请求的类型、URL 以及是否异步处理请求。 method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） onreadystatechange事件 当请求被发送到服务器时，我们需要执行一些基于响应的任务。 每当 readyState 改变时，就会触发 onreadystatechange 事件 readyState 属性存有 XMLHttpRequest 的状态信息。 下面是 XMLHttpRequest 对象的三个重要的属性： 属性 描述 onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化， 1: 服务器连接已建立， 2: 请求已接收， 3: 请求处理中， 4: 请求已完成，且响应已就绪 status 200: “OK”，404: 未找到页面 注释：onreadystatechange 事件被触发 5 次（0 - 4），对应着 readyState 的每个变化。 通用的响应判断：应判断readyState为4，且HTTP响应为200时才表示数据顺利完整接收，响应就绪 12345xmlhttp.onreadystatechange=function()&#123; if(xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)&#123; document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; &#125;&#125; XHR响应数据 如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。 属性 描述 responseText 获得字符串形式的响应数据。 responseXML 获得 XML 形式的响应数据。 responseText属性 如果来自服务器的响应并非 XML，请使用 responseText 属性。 responseText 属性返回字符串形式的响应，因此您可以这样使用： 1document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; responseXML属性 如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，请使用 responseXML 属性： 12345678xmlDoc&#x3D;xmlhttp.responseXML;txt&#x3D;&quot;&quot;;x&#x3D;xmlDoc.getElementsByTagName(&quot;ARTIST&quot;);for (i&#x3D;0;i&lt;x.length;i++) &#123; txt&#x3D;txt + x[i].childNodes[0].nodeValue + &quot;&lt;br &#x2F;&gt;&quot;; &#125;document.getElementById(&quot;myDiv&quot;).innerHTML&#x3D;txt; send() 方法 描述 send() 用于GET请求 send(string) 将请求发送到服务器。 string：仅用于 POST 请求 同步与异步同步测试延用“原生Ajax”中的示例来进行同步异步请求测试。 AjaxServlet.java：在响应中加入延时代码，模拟网络环境导致响应不能马上发回。 123456789101112131415161718192021222324252627282930313233package com.website.servlet;import com.google.gson.Gson;import com.website.pojo.Person;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author yhd * @create 2021-06-03 7:57 */public class AjaxServlet extends BaseServlet &#123; //响应JavaScript的Ajax请求 protected void javaScriptAjax(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //向ajax请求响应一个json格式的Person对象 Person person = new Person(1,&quot;陈慧娴&quot;); Gson gson = new Gson(); String personJsonString = gson.toJson(person); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; resp.getWriter().write(personJsonString); &#125;&#125; ajax.html： 将xmlHttp.open(&quot;GET&quot;,requestUrl,false);改为false，表示同步请求。 在xmlHtpp.send()方法下添加js代码，如alert(&quot;我被执行了&quot;); 添加多个触发事件按钮，button ，ajax request2 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot; /&gt; &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot; /&gt; &lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function ajaxRequest() &#123; //1、首先创建XMLHttpRequest var xmlHttp = new XMLHttpRequest(); //2、调用open方法设置请求参数 var requestUrl = &quot;/15_json_ajax_i18n/ajaxServlet?action=javaScriptAjax&quot; xmlHttp.open(&quot;GET&quot;,requestUrl,false); //3、在send方法前绑定onreadystatechange事件，处理请求完成后的操作。 xmlHttp.onreadystatechange=function ()&#123; //当XMLHttpRequest对象的readyState属性为4，表示请求完成，且响应就绪 //且HTTP响应码为200时，表示数据完整接收到 if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200)&#123; //证明顺利接收到完整的数据，开始处理数据 alert(xmlHttp.responseText); &#125; &#125; //4、调用send方法发送请求 xmlHttp.send(); //测试同步与异步特性 alert(&quot;我被执行了...&quot;); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;ajaxRequest()&quot;&gt;ajax request&lt;/button&gt; &lt;button onclick=&quot;ajaxRequest()&quot;&gt;ajax request2&lt;/button&gt; &lt;div id=&quot;div01&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 测试效果： alert(&quot;我被执行了...&quot;);代码必须等待onreadystatechange事件执行完毕后才能执行。 当点下第一个按钮响应还没回来时，无法点击第二个按钮。这就是同步，同步必须等待响应后才能执行。 异步测试 延用上述同步测试代码，将ajax.html中的将xmlHttp.open(&quot;GET&quot;,requestUrl,true);改为true，表示异步请求 测试效果： 先执行alert(&quot;我被执行了...&quot;);，再执行onreadystatechange事件中的alert(xmlHttp.responseText); 当点下第一个按钮时，alert(&quot;我被执行了...&quot;)立即执行，且在第一个按钮的响应未回来之前，页面不会阻塞，还可以继续点击第二个按钮，执行代码并发出新的请求，这就是异步效果。 异步的优势异步优势在于发起局部请求后，即使响应数据没马上到来，整个浏览器页面不会阻塞(卡死)，这就异步请求良好的用户体验。 jQuery-AJAX简介 jQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON - 同时您能够把这些外部数据直接载入网页的被选元素中。 提示：如果没有 jQuery，AJAX 编程还是有些难度的。 编写常规的 AJAX 代码并不容易，因为不同的浏览器对 AJAX 的实现并不相同。这意味着您必须编写额外的代码对浏览器进行测试。不过，jQuery 团队为我们解决了这个难题，我们只需要一行简单的代码，就可以实现 AJAX 功能。 具体API及其适用请参考：w3school $.ajax()该方法是 jQuery 底层 AJAX 实现。简单易用的高层实现见 $.get,$.post等，$.ajax() 返回其创建的 XMLHttpRequest 对象。大多数情况下你无需直接操作该函数，除非你需要操作不常用的选项，以获得更多的灵活性。 语法 语法：$.ajax([settings]) settings = &#123;key1:value2,key2:value2,...&#125;：通过键值对的方式设置方法参数。 参数 描述 settings 可选。用于配置 Ajax 请求的键值对{key:}集合。 可以通过 $.ajaxSetup() 设置任何选项的默认值。 参数 url：表示请求的地址 type：表示请求的类型 GET 或 POST 请求 data：表示发送给服务器的数据(只能是键值对)，格式有两种(默认都会转换为第一种) name=value&amp;name=value {key:value} success：请求成功，响应的回调函数。对调函数中含一个回传参数，响应数据存储在该回传参数中。 dataType：表示接收后转换的数据类型 text：表示纯文本 xml：表示xml 数据 json：表示 json 对象，直接返回json对象 示例 jq_ajax.js 12345678910111213141516&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; // ajax请求 $(&quot;#ajaxBtn&quot;).click(function()&#123; $.ajax(&#123; url:&quot;/15_json_ajax_i18n/ajaxServlet?action=jQueryAjax&quot;, type:&quot;GET&quot;, data:&quot;name=jqueryAjax&amp;password=123&quot;, success:function (data) &#123; alert(data); &#125;, dataType:&quot;text&quot; &#125;); alert(&quot;ajax btn&quot;); &#125;);&lt;/script&gt; $.get() 与 $.post() 通过远程 HTTP GET/POST 请求载入信息。 这是一个简单的 GET/POST 请求功能以取代复杂 $.ajax(少了一个请求类型参数)。请求成功时可调用回调函数。如果需要在出错时执行函数，请使用 $.ajax 语法将所有参数值按序直接传入 参数 url：待载入页面的URL地址 data：请求参数，字符串或键值对的形式&#123;key:value&#125;方式发送参数 callback：载入成功时回调函数 type：返回内容格式，xml, html, script, json, text, _default。 tips： 示例 jq_ajax.html 12345678910111213// ajax--get请求$(&quot;#getBtn&quot;).click(function()&#123; $.get(&quot;/15_json_ajax_i18n/ajaxServletaction=jQueryAjax&quot;,&quot;action=jQueryGet&quot;,function (data) &#123; alert(data); &#125;,&quot;json&quot;); &#125;);// ajax--post请求$(&quot;#postBtn&quot;).click(function()&#123; $.post(&quot;/15_json_ajax_i18n/ajaxServletaction=jQueryAjax&quot;,&quot;action=jQueryPost&quot;,function (data) &#123; alert(data); &#125;,&quot;json&quot;); &#125;); $.getJSON()通过 HTTP GET 请求载入 JSON 数据，即在$.get()方法基础上减少一个参数(type=json) 语法将所有参数值按序直接传入 参数 url：待载入页面的URL地址 data：请求参数，字符串或&#123;key:value&#125;方式发送参数 callback：载入成功时回调函数 示例jq_ajax.html 123456// ajax--getJson请求$(&quot;#getJSONBtn&quot;).click(function()&#123; $.getJSON(&quot;/15_json_ajax_i18n/ajaxServletaction=jQueryAjax&quot;,&quot;action=jQueryGetJSON&quot;,function (data) &#123; alert(data); &#125;);&#125;); $.serialize()将表单中的所有表单项数据序列化，序列化后的格式化为：name=value&amp;name=value... tips：serialize()的结果直接作为请求参数时，需要注意是否有缺少连字符$或分隔符? 示例 准备表单form： 1234567891011121314151617181920212223&lt;body&gt; &lt;form id=&quot;form01&quot; &gt; 用户名：&lt;input name=&quot;username&quot; type=&quot;text&quot; /&gt;&lt;br/&gt; 密码：&lt;input name=&quot;password&quot; type=&quot;password&quot; /&gt;&lt;br/&gt; 下拉单选：&lt;select name=&quot;single&quot;&gt; &lt;option value=&quot;Single&quot;&gt;Single&lt;/option&gt; &lt;option value=&quot;Single2&quot;&gt;Single2&lt;/option&gt; &lt;/select&gt;&lt;br/&gt; 下拉多选： &lt;select name=&quot;multiple&quot; multiple=&quot;multiple&quot;&gt; &lt;option selected=&quot;selected&quot; value=&quot;Multiple&quot;&gt;Multiple&lt;/option&gt; &lt;option value=&quot;Multiple2&quot;&gt;Multiple2&lt;/option&gt; &lt;option selected=&quot;selected&quot; value=&quot;Multiple3&quot;&gt;Multiple3&lt;/option&gt; &lt;/select&gt;&lt;br/&gt; 复选： &lt;input type=&quot;checkbox&quot; name=&quot;check&quot; value=&quot;check1&quot;/&gt; check1 &lt;input type=&quot;checkbox&quot; name=&quot;check&quot; value=&quot;check2&quot; checked=&quot;checked&quot;/&gt; check2&lt;br/&gt; 单选： &lt;input type=&quot;radio&quot; name=&quot;radio&quot; value=&quot;radio1&quot; checked=&quot;checked&quot;/&gt; radio1 &lt;input type=&quot;radio&quot; name=&quot;radio&quot; value=&quot;radio2&quot;/&gt; radio2&lt;br/&gt; &lt;/form&gt; &lt;button id=&quot;submit&quot;&gt;提交--serialize()&lt;/button&gt;&lt;/body&gt; 执行serialize()方法 12345$(&quot;#submit&quot;).click(function()&#123; // 把参数序列化 var serializeData = $(&quot;#form01&quot;).serialize(); alert(serializeData);&#125;); 操作表单 应用实例用户名校验判断实现逻辑 示例代码 前端页面：添加元素失去焦点函数blur，发送Ajax请求，处理请求响应 123456789101112131415//用户名是否已存在异步检测$(&quot;#username&quot;).blur(function()&#123;//绑定失去焦点事件 //1、获取用户输入的用户名 var username = this.value; //2、发送ajax请求 $.getJSON(&quot;userServlet?action=ajaxExistsUserName&quot;,&quot;username=&quot; + username,function(data)&#123; //console.log(data); if(data.existUsername)&#123; $(&quot;.errorMsg&quot;).text(&quot;用户名已存在&quot;); &#125;else&#123; $(&quot;.errorMsg&quot;).text(&quot;用户名可用&quot;); &#125; &#125;);&#125;); 后端代码： 12345678910111213141516//响应ajax请求，判断用户名是否存在protected void ajaxExistsUserName(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException, SQLException &#123; //1、获取ajax请求参数 String username = req.getParameter(&quot;username&quot;); //2、调用service层判断用户名是否存在 boolean existUsername = service.existsUsername(username); //3、对应单一响应数据，封装成map后以json格式发回(方便前端处理) Map&lt;String,Boolean&gt; resultMap = new HashMap&lt;&gt;(); resultMap.put(&quot;existUsername&quot;,existUsername); //4、转换为json格式 Gson gson = new Gson(); String json = gson.toJson(resultMap); //5、发回给浏览器 resp.getWriter().write(json);&#125; i18n国际化基本概念 国际化（Internationalization）指的是同一个网站可以支持多种不同的语言，以方便不同国家，不同语种的用户访问。 关于国际化我们想到的最简单的方案就是为不同的国家创建不同的网站，比如苹果公司，他的英文官网是： http://www.apple.com 而中国官网是 http://www.apple.com/cn 苹果公司这种方案并不适合全部公司，而我们希望相同的一个网站，而不同人访问的时候可以根据用户所在的区域显示 不同的语言文字，而网站的布局样式等不发生改变。 于是就有了我们说的国际化，国际化总的来说就是同一个网站不同国家的人来访问可以显示出不同的语言。但实际上这种需求并不强烈，一般真的有国际化需求的公司，主流采用的依然是苹果公司的那种方案，为不同的国家创建不同的页 面。所以国际化的内容我们了解一下即可。 国际化的英文 Internationalization，但是由于拼写过长，老外想了一个简单的写法叫做 I18N，代表的是 Internationalization 这个单词，以 I 开头，以 N 结尾，而中间是 18 个字母，所以简写为 I18N。以后我们说 I18N 和国际化是一个意思。 三要素Java原生的国际化操围绕着三个要素 Locale：描述不同的时区、位置及其语言类 Properties属性配置文件：存储某个国家的语言映射数据，一个文件一个国家 ResourceBundle：整合Locale及其语言配置文件，获取不同国家语言信息 Locale与ResourceBundle由JDK提供 LocaleLocale是JDK提供的描述程序允许所在地区的时区、位置、语言信息的类 获取当前操作系统的locale对象 打印所有可用的locale信息 通过常量获取指定国家的local对象 示例代码 1234567891011121314151617@Testpublic void test1()&#123; //获取当前操作系统的locale对象 Locale locale = Locale.getDefault(); System.out.println(&quot;当前系统的locale = &quot; + locale); //获取指定常量的locale对象 Locale china = Locale.CHINA; Locale us = Locale.US; System.out.println(&quot;china = &quot; + china); System.out.println(&quot;us = &quot; + us); //打印所有可用的locale信息 for (Locale availableLocale : Locale.getAvailableLocales()) &#123; System.out.println(&quot;availableLocale = &quot; + availableLocale); &#125;&#125; 配置文件国家化中的properties属性配置文件是有规范和要求的： 一个国际化配置文件存储一个国家的语言映射数据 文件命名要求：baseName_locale.properties baseName：自定义的字符串，作为ResourceBundle的一个传入参数 locale：Localer对象打印出来的信息，如 zh_CN、en_US等 例如：baseName设置为i18n时，中文的配置文件命名为：i18n_zh_CN.properties，英文配置文件命名为：i18n_en_US.properties ResourceBundleResourceBundle类由JDK提供，用于整合所有语言配置文件，自动通过不同locale对象匹配到不同配置文件，并提供方法以key-value方式获取配置文件的内容。 读取配置文件： ResourceBundle.getBundle(String baseName,Locale locale) 以键值对的方式获取配置文件中的数据： bundle.getString(String key) 实例创建配置文件在IDE的src根目录下创建语言配置properties文件，在IDEA中，同一类的i18n会被自动归类为”Resource Bundle ‘i18n’“虚拟目录下。 获取指定locale下的数据通过ResourceBundle加载并获取指定locale下的数据，若存在中文乱码上网找解决方案 123456789101112@Testpublic void test2()&#123; Locale locale = Locale.US; ResourceBundle bundle = ResourceBundle.getBundle(&quot;i18n&quot;,locale); String username = bundle.getString(&quot;username&quot;); String password = bundle.getString(&quot;password&quot;); String sex = bundle.getString(&quot;sex&quot;); System.out.println(&quot;username = &quot; + username); System.out.println(&quot;password = &quot; + password); System.out.println(&quot;sex = &quot; + sex);&#125; Web页面应用 i18n.jsp：国际化前 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot; /&gt;&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot; /&gt;&lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;&quot;&gt;中文&lt;/a&gt;| &lt;a href=&quot;&quot;&gt;english&lt;/a&gt; &lt;center&gt; &lt;h1&gt;注册&lt;/h1&gt; &lt;table&gt; &lt;form&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;username&quot; type=&quot;text&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;radio&quot; /&gt;男&lt;input type=&quot;radio&quot; /&gt;女&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;邮箱&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot; /&gt;&amp;nbsp;&amp;nbsp; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/form&gt; &lt;/table&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;/center&gt; 国际化测试： &lt;br /&gt; 1、访问页面，通过浏览器设置，请求头信息确定国际化语言。 &lt;br /&gt; 2、通过左上角，手动切换语言&lt;/body&gt;&lt;/html&gt; JSP方式 i18n.jsp：国际化后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;%@ page import=&quot;java.util.Locale&quot; %&gt;&lt;%@ page import=&quot;java.util.ResourceBundle&quot; %&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot; /&gt;&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot; /&gt;&lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% Locale locale = null; //1、先尝试从用户提交的参数中获取指定的地区 String country = request.getParameter(&quot;country&quot;); //2、判断用户参数所指定的locale对象 if (&quot;cn&quot;.equals(country)) &#123; locale = Locale.CHINA; &#125; else if (&quot;usa&quot;.equals(country)) &#123; locale = Locale.US; &#125; else &#123; //3、若不存在参数请求(如首次加载) //则使用当前HTTP请求头中的Locale信息（语言） locale = request.getLocale(); &#125; System.out.println(locale); //4、获取读取包（根据 指定的baseName和Locale读取 语言信息） ResourceBundle i18n = ResourceBundle.getBundle(&quot;i18n&quot;, locale); %&gt; &lt;!-- 通过超链接方式让用户自行选择 --&gt; &lt;!-- 带国家请求参数，发回到本jsp页面提供判断--&gt; &lt;a href=&quot;i18n.jsp?country=cn&quot;&gt;中文&lt;/a&gt;| &lt;a href=&quot;i18n.jsp?country=usa&quot;&gt;english&lt;/a&gt; &lt;!-- 国际化在于所有文本信息均通过ResourceBundle获取 --&gt; &lt;center&gt; &lt;h1&gt;&lt;%=i18n.getString(&quot;regist&quot;)%&gt;&lt;/h1&gt; &lt;table&gt; &lt;form&gt; &lt;tr&gt; &lt;td&gt;&lt;%=i18n.getString(&quot;username&quot;)%&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;username&quot; type=&quot;text&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;%=i18n.getString(&quot;password&quot;)%&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;%=i18n.getString(&quot;sex&quot;)%&gt;&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; /&gt;&lt;%=i18n.getString(&quot;boy&quot;)%&gt; &lt;input type=&quot;radio&quot; /&gt;&lt;%=i18n.getString(&quot;girl&quot;)%&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;%=i18n.getString(&quot;email&quot;)%&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;&lt;%=i18n.getString(&quot;reset&quot;)%&gt;&quot; /&gt;&amp;nbsp;&amp;nbsp; &lt;input type=&quot;submit&quot; value=&quot;&lt;%=i18n.getString(&quot;submit&quot;)%&gt;&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/form&gt; &lt;/table&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;/center&gt; 国际化测试： &lt;br /&gt; 1、访问页面，通过浏览器设置，请求头信息确定国际化语言。 &lt;br /&gt; 2、通过左上角，手动切换语言&lt;/body&gt;&lt;/html&gt; JSTL方式从从上诉JSP实现方式可知，在web页面上操作国际化主要三个参数： 设置Locale信息 设置baseName 使用ResourceBundle输出国际化信息 使用JSTL实现页面国际化前需要先引入fmt标签库，在JSP页面首行添加 &lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt; JSTL标签实现页面国际化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot; /&gt;&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot; /&gt;&lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%--1 使用标签设置Locale信息--%&gt; &lt;fmt:setLocale value=&quot;$&#123;param.locale&#125;&quot; /&gt; &lt;%--2 使用标签设置baseName--%&gt; &lt;fmt:setBundle basename=&quot;i18n&quot;/&gt; &lt;a href=&quot;i18n_fmt.jsp?locale=zh_CN&quot;&gt;中文&lt;/a&gt;| &lt;a href=&quot;i18n_fmt.jsp?locale=en_US&quot;&gt;english&lt;/a&gt; &lt;center&gt; &lt;h1&gt;&lt;fmt:message key=&quot;regist&quot; /&gt;&lt;/h1&gt; &lt;table&gt; &lt;form&gt; &lt;tr&gt; &lt;td&gt;&lt;fmt:message key=&quot;username&quot; /&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;username&quot; type=&quot;text&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;fmt:message key=&quot;password&quot; /&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;fmt:message key=&quot;sex&quot; /&gt;&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; /&gt;&lt;fmt:message key=&quot;boy&quot; /&gt; &lt;input type=&quot;radio&quot; /&gt;&lt;fmt:message key=&quot;girl&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;fmt:message key=&quot;email&quot; /&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;&lt;fmt:message key=&quot;reset&quot; /&gt;&quot; /&gt;&amp;nbsp;&amp;nbsp; &lt;input type=&quot;submit&quot; value=&quot;&lt;fmt:message key=&quot;submit&quot; /&gt;&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/form&gt; &lt;/table&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;/center&gt;&lt;/body&gt;&lt;/html&gt; SH","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"MVC","slug":"MVC","permalink":"http://yoursite.com/tags/MVC/"}]},{"title":"JavaWeb编程技术","slug":"JavaWeb编程技术","date":"2021-06-02T11:54:32.000Z","updated":"2021-08-25T15:27:11.852Z","comments":true,"path":"2021/06/02/JavaWeb编程技术/","link":"","permalink":"http://yoursite.com/2021/06/02/JavaWeb%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/","excerpt":"","text":"JavaWeb技术概述万维网 WWW是World Wide Web简称，目的为了实现全世界能利用因特网进行文档交换，是一个大规模、分布式、联机式的信息储藏所。 Web是基于客户/服务器的一种B/S体系结构，其基本工作原理为，客户使用浏览器向Web服务器发出请求，服务器响应客户请求，向客户送回所请求的网页，客户在浏览器窗口上显示网页的内容。 组成Web体系的三大结构 Web服务器 Web客户端 通信协议 Web服务器基本概念 Web服务器是向浏览器提供服务器的程序 Web服务器应用层使用HTTP协议，信息内容采用HTML，信息定位使用URL 最常用的Web服务器是Apache服务器，开源、免费、Linux/Windows。另一种较为流行的Web服务器为Microsoft公司专门为Windows平台开发的IIS服务器 Tomcat也是一种常用的Web服务器，它具有Web服务器功能同时也是Web容器，可允许Servlet和JSP Tomcat&amp;Sevlet/JSP/JDK版本对应关系 当前企业常用Tomcati的版本 7、8 Servlet2.5版本是现在世面使用最多的版本**(xml 配置**) Servlet3.0 之后就是注解版本的 Servlet 使用。 其他Web服务器 Jboss：是一个遵从 JavaEE 规范的、开放源代码的、纯 Java 的 EJB 服务器，它支持所有的 JavaEE 规范（免费）学习门槛高，不适合入门 GlassFish： 由 Oracle 公司开发的一款 JavaWeb 服务器，是一款强健的商业(收费)服务器，达到产品级质量（应用很少） Resin：是 CAUCHO 公司的产品，是一个非常流行的服务器，对 servlet 和 JSP 提供了良好的支持， 性能也比较优良，resin 自身采用 JAVA 语言开发（收费，应用比较多）。 WebLogic：是 Oracle 公司的产品，是目前应用最广泛的 Web 服务器，支持 JavaEE 规范， 而且不断的完善以适应新的开发要求，适合大型项目（收费，用的不多，适合大公司） Web客户端​ 浏览器主要功能想服务器发送请求与对响应信息进行解析、并正确显示出来 通讯协议HTTP HTTP协议成为超文本传输协议，规定了Web客户与服务器之间如何通信 是一个基于请求-响应的协议，是无状态的 主要通信流程 在浏览器输入网址，按下Enter键 浏览器建立一个HTTP请求信息，使用DNS获得网址的IP地址 通过IP地址与服务器建立一条TCP连接 通过这条TCP连接将HTTP信息发送给服务器，并从服务器接收回一条信息 URL&amp;URIURL称为统一资源定位符，用于在Internet中定位某个主机的资源，主要四部分组成 协议名称：如HTTP、FTP、TELNET、MAIL等 主机域名或IP地址：www.baidu.com、localhos、127.0.0.1等 [端口号]：Web应用的80端口等，可忽略不写 资源名称：资源在服务器上的相对路径和名称，如/index.html 12https:&#x2F;&#x2F;www.baidu.com&#x2F;https:&#x2F;&#x2F;www.baidu.com&#x2F;helloweb&#x2F;hello.jsp URI，URN URL：https://www.baidu.com/helloweb/hello.jsp URI：helloweb/hello.jsp 状态码 状态码范围 含义 示例 1** 表示信息 100表示服务器同意处理客户的请求 2** 表示请求成功 200表示请求成功，204表示内容不存在 3** 表示重定向 301表示页面移走了，304表示缓存的页面仍然有效 4** 表示客户的错误 403表示禁止的页面，404表示页面没有找到 5** 表示服务器的错误 500表示服务器内部错误，503表示以后再试 服务器资源资源类型Web服务器处理客户端请求有两种方式 静态请求：客户端所需请求的资源不需要进行任何处理，直接作为HTTP响应返回。对应的资源称之为静态资源 动态请求：客户端所需请求的资源需要在服务器委托给一些服务器端技术进行处理，如CGI、JSP、ASP等，然后将处理结果作为HTTP响应返回，对应地也成为动态资源 动态文档技术动态文档是指文档的内容可根据需要动态生成，同时又分以下两种技术： 服务器端动态文档技术： 模块化技术：CGI、Servlet—java解决方案 Web文档嵌入式脚本：ASP、PHP、JSP 客户端动态文档技术 JavaScript Tomcat安装 下载Tomcat，官方链接 将下载的安装包直接解压到指定目录即可 找到Tomcat目录下的bin目录，双击startup.bat文件即可启动 在浏览器输入输入地址 http://localhost:8080 ，若出现tomcat首页则表示安装成功 目录介绍 bin：用与存放Tomcat 服务器的可执行程序 conf：用与存放Tocmat 服务器的配置文件 lib：用与存放Tomcat 服务器的jar 包，对应javaEE的实现规范的实现类 logs ：用与存放Tomcat 服务器运行时输出的日志信息 temp：用与存放Tomcdat 运行时产生的临时数据 webapps：用与存放部署的Web工程，根目录下，一个文件夹一个Web工程 work：是Tomcat工作时的目录，用来存放 Tomcat 运行时 jsp 翻译为 Servlet 的源码，和 Session 钝化的目录 启动与关闭启动方式 Tomcat目录下的bin目录，双击startup.bat文件即可启动，或以命令行方式在路径下执行命令startup 用命令行方式在路径下执行命令catalina run startup命令的源码解析：为了可以在任意目录下启动 Tomcat 服务器，可以选择把bin目录添加到 path下，此时在任意目录下通过startup命令启动Tomcat服务器会提示如下错误，即要求设置 CATALINA_HOME 这个环境变量 12The CATALINA_HOME environment variable is not defined correctlyThis environment variable is needed to run this program 阅读startup.bat批处理文件源码可知，CATALINA_HOME环境变量指向为Tomcat安装的根目录(bin目录的上一级目录) startup.bat 文件，实际调用的是catalina.bat文件 通过命令行窗口直接输入catalina, 提示如下，表示catalina命令的可选参数 12345678910commands:debug Start Catalina in a debuggerdebug -security Debug Catalina with a security managerjpda start Start Catalina under JPDA debuggerrun Start Catalina in the current windowrun -security Start in the current window with security managerstart Start Catalina in a separate windowstart -security Start in a separate window with security managerstop Stop Catalinaversion What version of tomcat are you running? 常用的catalina命令选项如下 run：在 catalina 同一个命令行窗口下启动服务器. start：开启一个新窗口启动服务器 stop：关闭服务器 关闭方式 方式一：点击tomcat 服务器窗口右上角X关闭 方式二：把Tomcat 服务器窗口置为当前窗口，然后按快捷键 Ctrl+C 方式三：找到Tomcat的bin目录下的 shutdown.bat 双击，或cmd进入该目录执行shutdown，就可以停止 Tomcat 服务器 常见错误首先，建议通过CMD命令行的方式进入到bin目录下，通过命令行的方式执行catalina run命令，则会有错误提示信息显示 双击startup.bat出现黑窗口一闪而过，JAVA_HOME环境变量没有配置正确 修改默认端口号 找到Tomcat目录下的conf目录，找到 server.xml 修改如下标签下的port属性端口号信息即可 123&lt;Connector port=&quot;7777&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 修改后需重启Tomcat服务器才能生效 Web工程部署Tomcat目录下的webapps目录：存放部署的Web工程，一个文件夹一个Web工程。如默认tomcat含以下5个web应用。 无论静态还是动态资源，Tomcat中web工程部署均有两种 拷贝到webapps下的指定工程目录中 通过配置tomcat xml文件实现映射式的部署 静态资源部署 方式一：把 web 工程的目录拷贝到 Tomcat的webapps/web目录下 在webapps目录下新建web应用的文件夹，如helloWeb 将web应用内容拷贝的该文件夹内 http://localhost:8888 对应webapps的根目录，url与webapps目录的路径关系如下 稍等十几秒后，一般tomcat会自动重新部署。若没有效果，则可以尝试重启tomcat服务器 方式二：配置文件映射部署，即项目任意路径部署 找到Tomcat下的 conf目录\\Catalina\\localhost\\ 根目录下,创建如下xml配置文件，一般一个工程一个xml文件。(旧版本的tomcat可能不存在上述目录，没有就自己建立这个目录结构即可) 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Context path=&quot;/abc&quot; docBase=&quot;E:\\book&quot; /&gt; .xml文件的文件名：tomcat9测试，xml文件名才是决定访问(url)根路径 path：表示工程的访问(url)路径，如/abc docBase：表示你的工程目录在磁盘下的路径 一般修改添加或删除，tomcat中的web应用内容，稍等十多秒会自动重新部署。若没有效果，则可以重启tomcat服务器使其部署 动态资源部署Web工程目录Servlet 规范中定义了 web 应用程序的目录层次 1234567891011121314|--Web开发项目 |----src &#x2F;&#x2F;存放源代码 ---------------------以上为常见IDE开发时提供的目录结构---- ---------------------以下为Servlet规范目录结构---------- |----WEB资源根目录 &#x2F;&#x2F;约定：但不规定目录名(eclipse WebContent,IDEA web) |-------WEB-INF &#x2F;&#x2F;约定：存放供服务器访问的资源(浏览器无法直接访问) classes &#x2F;&#x2F;约定：存放编译后.class文件 web.xml &#x2F;&#x2F;约定：整个动态web工程的配置部署描述文件，配置如(servlet、filter...)组件 [apache-tomcata安装根目录]\\webapps\\docs\\WEB-INF 中复制过来 lib &#x2F;&#x2F;约定：存放web应用程序用到的jar文件 |----css |----img ... |----index.html 注意：在IDEA中，web根目录下不允许直接存放静态资源文件，如img、.js等，否则不能访问。换言之只允许直接存放html、jsp文件。其他文件均需至少创建一个文件夹目录后存入才可以访问。 步骤如下tips：以下以eclipse环境下，手动创建普通java项目，并手动拷贝部署到tomcat的过程，很少使用。拟在突出web工程目录的结构与作用。 在 src下新建一个 Person 12345public class Person &#123; public String getPersonInfo()&#123; return &quot;person info...&quot;; &#125;&#125; 手工的 Person 类对应的编译后的.class 文件(在工程的bin目录下，含包目录结构均需复制)复制到 classes 目录下 在 WebContent 目录下新建一个 JSP 文件 1234567&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=ISO-8859-1&quot; pageEncoding=&quot;ISO-8859-1&quot;%&gt;&lt;% Person person = new Person(); System.out.print(person.getPersonInfo()); %&gt; 把 WebContent 目录复制到 Tomcat 的 webapps 目录下, 并改名为: helloworld 在浏览器的地址栏中输入: http://localhost:8080/helloworld/hello.jsp 即可看到命令行的打印信息 半自动化工程部署tips：基于eclipse开发环境 可以通过修改src默认的输出目录达到自动把编译好的 class 放到 classes 目录下 通过方式二，实现开发目录与实际部署目录的映射 默认工程及首页 当地址栏输入访问地址没有工程名地址：http://ip:port/ ，默认访问的是 ROOT 工程。 当地址栏输入访问地址只有工程名地址： http://ip:port/工程名/，默认访问工程内的 index.html 页面 IDEA整合Tomcat整合Tomcat服务器 进入IDEA如下设置 配置你的 Tomcat 安装目录，可以添加多个不同版本的tomcat 创建动态Web工程 2020版本后的IDEA，建立非Maven管理的web项目需先建立一个普通的java Model。右键Add Framework Support (若选择使用maven则可以在建立model时选择java enterprise) 勾选Web Application ，勾选Create web.xml 创建成功如下图，(一般手动di在WEB-INF目录下建立一个lib目录) 启动Web工程 每当创建一个web工程时，IDEA会对应Web工程创建一个Tomcat实例 确认你的 Tomcat 实例中有你要部署运行的 web 工程模块 为了方便使用，一般将tomcat name、URL、Application context三者设置为与项目名称一致。则能实现启动项目后，自动调用浏览器且访问的就是Web工程 Server窗口下的URL与Deployement窗口下的Application context的区别 Server — URL：web应用启动后，IDEA自动调用浏览器访问的地址(不一定是web工程访问地址) Deployement — Application context：当前web工程的根目录访问地址，即在web.xml配置servlet的隐射地址时候斜杠/就是指该路径 如下图显示设置 URL设置为：http://localhost:8080/abc Application context设置为：http://localhost:8080/06_helloServlet/ 当项目启动后，IDEA自动调用浏览器访问的地址是：http://localhost:8080/abc。因为实际web应用的访问地址是application context决定的，所以找不到页面如下提示 当访问application context 设置的url即可访问到web应用 IDEA中、启动、debug启动、停止、与重启按钮说明 IDEA中默认启动web项目的效果 重启选项说明 IDEA中修改端口号 配置资源热部署热部署：正在运行状态的应用,修改了他的源码之后,在不重新启动的情况下能够自动把增量内容编译并部署到服务器上 IDEA创建Servlet 检查项目是否添加了servlet-api.jar与jsp-api.jar 在指定包下右键—&gt;New—&gt;Servlet创建即可 IDEA的部署逻辑IDEA整合Tomcat后部署逻辑 tips：一般的整合Tomcat的IDE，如eclipse、IDEA逻辑都类似 编写如下测试代码 12345678public class TestGetRealPath implements Servlet &#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; String path = servletConfig.getServletContext().getRealPath(&quot;/&quot;); System.out.println(&quot;path = &quot; + path); &#125; //@Override method....&#125; 在整合了Tomcat的IDEA中启动Web工程，可以从service信息打印窗口看到如下信息 Using CATALINA_BASE： Web项目编译后真正运行.class文件则被复制到C:\\Users\\[用户名]\\AppData\\Local\\JetBrains\\[IntelliJIdea版本]\\tomcat\\...目录下。即 含Web应用源码编译后的.class文件 含.jsp文件对应的_jsp.java源码，以及编译后的.class文件 含用于Tomcat中完整的配置与项目部署映射所有需要的配置文件。目的是使能在IDEA中直接设置一些有关Tomcat的配置生效，如设置端口号，IDEA自定义的项目映射部署等…. getRealPath(“/“)输出的内容其实是web部署的实际物理位置，IDEA会将部署的Web应用下的根目录(web目录)的所有内容拷贝到 创建项目物理机地址\\out\\artifacts\\项目工程名目录下，这个目录就是被IDEA认为的web应用部署后源代码的真实路径(非运行路径)**，并非开发目录。因此getRealPath(“/“)输出就是这个路径。并且是与开发代码时web下目录结构是完全对应**的。 ServletServlet及其容器 Servlet：Servlet是用Java编写的服务器端程序，主要功能在于交互式地浏览和生成动态Web内容。 狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。 Servlet是 JavaEE 规范之一，规范就是接口。 Servlet是JavaWeb 三大组件之一。(Servlet 程序、Filter 过滤器、Listener 监听器) Servlet是运行在服务器上的一个 java 小程序，可以接收客户端发送过来的请求，并响应数据给客端。 Servlet 容器: Servlet容器为JavaWeb应用提供运行时环境，它负责管理Servlet和JSP的生命周期，以及管理它们的共享数据 运行 Servlet、JSP、Filter 等的软件环境. 创建 Servlet, 并调用 Servlet 的相关生命周期方法。 Servlet接口实现 编写一个类去实现 Servlet 接口 编写实现service方法，处理请求，并响应数据 在web.xml中设置Servlet接口映射 &lt;servlet&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt;&lt;/servlet-mapping&gt; tips：任何web.xml的修改都需重新部署才会生效 实现接口：tips，IDEA若无法识别Servlet接口则需要手动导入servlet-api.jar包，一般在tomcat安装路径下lib目录中可以找到 12345678910111213141516171819202122232425262728293031323334public class HelloServlet implements Servlet &#123; //建立一个空参构造器 public HelloServlet()&#123; System.out.println(&quot;HelloServlet实例化成功&quot;); &#125; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(&quot;init...&quot;); &#125; @Override public ServletConfig getServletConfig() &#123; System.out.println(&quot;getServletConfig&quot;); return null; &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(&quot;hello service&quot;); &#125; @Override public String getServletInfo() &#123; System.out.println(&quot;getServletInfo&quot;); return null; &#125; @Override public void destroy() &#123; System.out.println(&quot;destroy&quot;); &#125;&#125; 设置web.xml接口映射：&lt;servlet&gt;标签与&lt;servlet-mapping&gt;映射标签 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;!--servlet-name 标签为Servlet程序自定义一个别名(一般是类名) --&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!--servlet-class 是 Servlet 程序的全类名--&gt; &lt;servlet-class&gt;com.test.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!--servlet-mapping 标签给 servlet 程序配置映射的访问地址--&gt; &lt;servlet-mapping&gt; &lt;!--servlet-name 标签指定设置映射的Servlet程序别名--&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!--url-pattern 标签配置访问地址 --&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;!-- &lt;url-pattern&gt;标签内容必须以斜杠打头 / 斜杠 ：表示地址为：http://ip:port/工程路径 /hello : 表示地址为：http://ip:port/工程路径/hello --&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 小结： &lt;url-pattern&gt;标签内容必须以斜杠打头 若使用通配符只有两种使用方式 .扩展名，如.html表示所有html结尾的文件均由该servlet受理 /*，所有接口调用都受理 常见错误： url-pattern 中配置的路径没有以斜杠打头 servlet-name 配置的值不存在 servlet-class 标签的全类名配置错误 最终效果 Servlet生命周期Servlet 生命周期：以下方法均由Serlvet容器负责调用. 构造器: 只被调用一次，对指定Servle进行首次访问时创建 Servlet 的实例 (Serlvet 的单实例) init：只被调用一次，在创建好Servlet实例后立即被调用，用于初始化当前 Servlet. service：被多次调用，每次请求都会调用 service 方法. 实际用于响应请求的. destroy：只被调用一次，在当前 Servlet所在的 WEB 应用被卸载前调用，用于释放当前 Servlet 所占用的资源. Servlet引擎检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第④步，否则，执行第2步。 装载并创建该Servlet的一个实例对象：调用该 Servlet 的构造器 调用Servlet实例对象的init()方法。 创建一个用于封装请求的ServletRequest对象和一个代表响应消息的ServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。 WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。 load-on-startup标签: 可以设置Serlvet被创建的时机，若为负数, 则在如上普通生命周期般，要被调用，才会实例化与初始化，若为0或正数, 则在当前 WEB 应用被Serlvet 容器加载时(启动web应用时，不用调用)就会创建实例，且数组越小越早被创建。 1234&lt;servlet&gt; &lt;!-- .... --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 相关接口与类 init()：ServletConfig service()：ServletRequest , ServletResponse 以讲解实现servlet接口后出现的相关接口与类展开学习servlet ServletConfig基本概念 每个 Servlet 程序创建时，就创建一个对应的 ServletConfig 对象。 Servlet 程序默认是第一次访问的时在init()中创建 作用 获取Servlet程序的别名，即获取标签&lt;servlet-name&gt;的值 获取初始化参数，即获取标签&lt;init-param&gt;的键值信息 获取 ServletContext API由服务器供应商提供实现，封装Servlet 程序的配置信息，并可获取ServletContext对象 javax.servlet Interface ServletConfig All Known Implementing Classes: GenericServlet, HttpServlet Method Summary String getInitParameter(String name) ：获取初始化参数，即标签&lt;init-param&gt;内配置的键值对 Enumeration getInitParameterNames() ：获取所有参数名组成的Enumeration对象 String getServletName() ：获取Servlet程序的别名，即获取标签&lt;servlet-name&gt;的值 ServletContext getServletContext()：获取ServletContext对象 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;!-- Servlet别名 --&gt; &lt;servlet-name&gt;ServletConfitTestName&lt;/servlet-name&gt; &lt;servlet-class&gt;com.test.servlet.ServletConfigTest&lt;/servlet-class&gt; &lt;!-- 配置初始化参数，可定义多个 --&gt; &lt;init-param&gt; &lt;param-name&gt;usn&lt;/param-name&gt; &lt;param-value&gt;username&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;psw&lt;/param-name&gt; &lt;param-value&gt;password&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletConfitTestName&lt;/servlet-name&gt; &lt;url-pattern&gt;/testConfig&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 12345678910111213141516171819202122232425public class ServletConfigTest implements Servlet &#123; @Override public void init(ServletConfig config) throws ServletException &#123; //1、获取当前Servlet的别名，即标签&lt;servlet-name&gt;的值 String name = config.getServletName(); System.out.println(&quot;servlet-name: &quot; + name); //2、获取初始化参数，即标签&lt;init-param&gt;内配置的键值对 String userName = config.getInitParameter(&quot;usn&quot;); String passWord = config.getInitParameter(&quot;psw&quot;); System.out.println(&quot;usn: &quot; + userName); System.out.println(&quot;psw: &quot; + passWord); //2.1、获取所有参数名组成的Enumeration 对象 Enumeration&lt;String&gt; names = config.getInitParameterNames(); while(names.hasMoreElements())&#123; System.out.println(names.nextElement()); &#125; //3、获取servletContext ServletContext servletContext = config.getServletContext(); System.out.println(servletContext); &#125; //@Override Method...&#125; 1234567&#x2F;&#x2F;打印结果如下servlet-name: ServletConfitTestNameusn: usernamepsw: passwordusnpsworg.apache.catalina.core.ApplicationContextFacade@5a298b72 ServletContext基本概念ServletContext称为“servlet上下文”，一个Web应用对应一个ServletContext，封装了Web诸多信息 ServletContext对象由**servletConfig.getServletContext();**获取 一个 web 工程，只有一个 ServletContext 对象 ServletContext 是在 web 工程部署启动的时候创建。在 web 工程停止的时候销毁 作用 获取当前WEB 应用的初始化参数，即&lt;context-param&gt;的值 &lt;context-param&gt;可以被所有的Servlet 所获取, 而Servlet的初始化参数&lt;init-param&gt;只有对应的 Serlvet 可获取 获取当前 WEB 应用的某一个文件在服务器上部署后的绝对路径 获取当前WEB 应用的工程路径 获取当前WEB应用的某一个文件对应的输入流 作为application域范围的属性(后续补充说明) APIjavax.servlet Interface ServletContext Method Summary String getInitParameter(String name) ：获取初始化参数，即标签&lt;context-param&gt;内配置的键值对 Enumeration getInitParameterNames()：获取所有参数名组成的Enumeration 对象 String getRealPath(String path) 获取当前 WEB 应用的某一个文件在服务器上部署后的绝对路径 输入参数/file.suffix，/对应Web应用的根目录(部署后) 同时getRealPath(“/”)映射到IDE代码开发目录中的根目录(web或webcontent) String getContextPath() ：获取当前WEB 应用的工程路径 InputStream getResourceAsStream(String path) 获取当前WEB应用的某一个文件对应的输入流 输入参数/file.suffix，/对应Web应用的根目录(IDEA-web) Attribute相关方法后续补充 Object getAttribute(String name) Enumeration getAttributeNames() void removeAttribute(String name) void setAttribute(String name, Object object) web.xml 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- 配置当前Web应用的初始化参数 --&gt; &lt;context-param&gt; &lt;param-name&gt;driver&lt;/param-name&gt; &lt;param-value&gt;com.mysql.jdbc.Driver&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;jdbcUrl&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql....&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;ServletContextTest&lt;/servlet-name&gt; &lt;servlet-class&gt;com.test.servlet.ServletContextTest&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletContextTest&lt;/servlet-name&gt; &lt;url-pattern&gt;/contextTest&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; ServletContextTest.java 1234567891011121314151617181920212223242526272829303132public class ServletContextTest implements Servlet&#123; @Override public void init(ServletConfig config) throws ServletException &#123; //获取ServletContext对象 ServletContext servletContext = config.getServletContext(); //1、获取当前Web应用的初始化参数，即&lt;context-param&gt;值 String driver = servletContext.getInitParameter(&quot;driver&quot;); String jdbcUrl = servletContext.getInitParameter(&quot;jdbcUrl&quot;); System.out.println(&quot;driver: &quot; + driver); System.out.println(&quot;jdbcUrl: &quot; + jdbcUrl); Enumeration&lt;String&gt; names = servletContext.getInitParameterNames(); while(names.hasMoreElements())&#123; System.out.println(&quot;names&quot; + names.nextElement()); &#125; //2、获取当前 WEB 应用的某一个文件在服务器上部署后的绝对路径 String realPath = servletContext.getRealPath(&quot;/test.txt&quot;); System.out.println(&quot;test.txt realPath&quot; + realPath); //3、获取当前WEB 应用的工程路径 String contextPath = servletContext.getContextPath(); System.out.println(&quot;contextPath: &quot; + contextPath); //4、获取当前WEB应用的某一个文件对应的输入流 InputStream resourceAsStream = servletContext.getResourceAsStream(&quot;/WEB-INF/jdbc.properties&quot;); System.out.println(&quot;resourceAsStream: &quot; + resourceAsStream); &#125; //@Override Method...&#125; 工程目录与打印结果 ServletRequest基本概念Servlet 的 service方法用于应答请求，每次请求都会调用 service() 方法。服务器并给予ServletRequest与ServletRsponse接口实现，将请求与响应的信息封装到这两个接口中，并在服务器调用 service 方法时传入实现类对象。 作用 ServletRequest: 封装了请求信息，可以从中获取到任何的请求信息. APIjavax.servlet Interface ServletRequest All Known Subinterfaces: HttpServletRequest/Respone (tips：重要的子接口) Method Summary：方法众多，以下为当前常用的方法，有需要查询API ServletRequest获取请求参数相关 String getParameter(String name)：根据html标签的name属性, 返回value. 若请求参数有多个值(例如 checkbox), 该方法只能获取到第一个提交的值 String[] getParameterValues(String name)：根据html标签的name属性, 返回对应的值的字符串数组 Enumeration getParameterNames()：返回所有请求参数名names对的Enumeration 对象 Map getParameterMap()：返回所有请求参数的键值对, String 数组类型 Attribute相关的方法，暂时略，后续补充说明 …… HttpServletRequest：以下功能需使用功能更强大的HTTP相关的(扩展)子接口 String getRequestURI()：获取请求的URI(URL除站点外的字符串) String getMethod()：获取请求方式 String getQueryString()**：获取URL中的请求字符串**(如GET请求?后部分) String getServletPath()：获取servlet映射路径(web.xml配置的mapping路径) …… 示例代码前端页面前端页面展示 前端页面源码12345678910111213&lt;form action=&quot;/06_helloweb/login&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt; interesting: &lt;input type=&quot;checkbox&quot; name=&quot;interesting&quot; value=&quot;java&quot; checked=&quot;checked&quot;&gt;java &lt;input type=&quot;checkbox&quot; name=&quot;interesting&quot; value=&quot;C++&quot;&gt;C++ &lt;input type=&quot;checkbox&quot; name=&quot;interesting&quot; value=&quot;C&quot; checked=&quot;checked&quot;&gt;C &lt;input type=&quot;checkbox&quot; name=&quot;interesting&quot; value=&quot;mysql&quot; checked=&quot;checked&quot;&gt;mysql &lt;input type=&quot;checkbox&quot; name=&quot;interesting&quot; value=&quot;php&quot;&gt;php &lt;input type=&quot;checkbox&quot; name=&quot;interesting&quot; value=&quot;go&quot;&gt;go &lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 参数传递格式 参数提交页情况 GET请求：user=admin&amp;password=123&amp;interesting=java&amp;interesting=C&amp;interesting=mysql POST请求： HTTP原生：键值对参数传递是与GET请求传递参数格式一致，唯一区别是POST请求将其放在请求体中，GET请求是直接追加到URL后 Chrome 解析的Form Data展示 12345user: adminpassword: 123interesting: javainteresting: Cinteresting: mysql 可以发现某种含多个参数值的参数名，实际传递还是按照每一个键值对传递，只是键都一样 web.xml12345678&lt;servlet&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.test.servlet.LoginServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; LoginServlet.java123456789101112131415161718192021222324252627282930313233343536373839public class LoginServlet implements Servlet &#123; @Override public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException &#123; //1、根据请求参数的name, 返回value. 若请求参数 //有多个值(例如 checkbox), 该方法只能获取到第一个提交的值 String user = request.getParameter(&quot;user&quot;); String password = request.getParameter(&quot;password&quot;); String interesting_one = request.getParameter(&quot;interesting&quot;); System.out.println(&quot;user = &quot; + user); System.out.println(&quot;password = &quot; + password); System.out.println(&quot;interesting_one = &quot; + interesting_one); //2、据请求参数的name, 返回对应的值的字符串数组 String[] interesting = request.getParameterValues(&quot;interesting&quot;); for (int i = 0; i &lt; interesting.length; i++) &#123; System.out.println(&quot;interest = &quot; + (i + 1) + &quot; &quot; + interesting[i]); &#125; //3、返回所有请求参数名names对的Enumeration 对象 Enumeration&lt;String&gt; parameterNames = request.getParameterNames(); while (parameterNames.hasMoreElements()) &#123; String name = parameterNames.nextElement(); String value = request.getParameter(name); System.out.println(&quot;name : value = &quot; + name + &quot; : &quot; + value); &#125; //4、返回所有请求参数的键值对, Map&lt;String,String&gt; 数组类型 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); for (Map.Entry&lt;String, String[]&gt; param : parameterMap.entrySet()) &#123; System.out.println(&quot;name : value = &quot; + param.getKey() + &quot; : &quot; + Arrays.asList(param.getValue())); &#125; &#125; // @Override...Method&#125; 打印结果如下 123456789101112user = testpassword = 123456interesting_one = javainterest = 1 javainterest = 2 Cinterest = 3 mysqlname : value = user : testname : value = password : 123456name : value = interesting : javaname : value = user : [test]name : value = password : [123456]name : value = interesting : [java, C, mysql] ServletResponse作用ServletResponse: 封装了响应信息, 如果想给用户什么响应, 具体可以使用该接口的方法实现. APIjavax.servlet Interface ServletResponse All Known Subinterfaces: HttpServletResponse (tips：重要的子接口) Method Summary ServletResponse： PrintWriter getWriter() 返回 PrintWriter 对象. 调用该对象的 print() 方法, 将把 print() 中的参数直接打印到客户的浏览器上. PrintWriter 对象还可配合setContentType响应类型，把内容输入到响应类型文件内 PrintWriter常用的方法于属性 * **out属性**：out属性是Writer类型的，servlet实现io的底层类，write方法基于调用out方法实现 write()：底层方法、调用PrintWriter的out属性的方法，将字符串(HTTP文本传送)数据写入输出缓冲区中，发送个浏览器。 print()：有多种传入类型重载的方法，把各种类型转换为字符串后调用write()实现。 flush()：将jsp中的JspWriter对象的缓冲区追加到response的缓冲区后，并执行相应操作，发回数据给客户端(response.getWriter()的PrintWriter的Writer缓冲区) void setContentType(String type)： 设置响应的内容类型，如pdf类型”application/pdf”，具体其他文件类型type值可打开[tomcat安装路径]]\\conf\\web.xml文件进行查询，例如 1234&lt;mime-mapping&gt; &lt;extension&gt;pdf&lt;/extension&gt; &lt;mime-type&gt;application/pdf&lt;/mime-type&gt; &lt;/mime-mapping&gt; 1 … HttpServletResponse： ③. void sendRedirect(String location)：请求的重定向，后续补充 GenericServlet需求驱动 在 web.xml 文件中设置两个 WEB 应用的初始化参数, user, password. 定义一个 login.html, 里边定义两个请求字段: user, password. 发送请求到 loginServlet 获取请求方式 在创建一个 LoginServlet, 在其中获取请求的 user, password. 比对其和 web.xml 文件中定义的请求参数是否一致 若一致，作出基本提示 LoginServlet.java文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 基于实现Servlet接口进行Servlet程序开发 */public class LoginServlet implements Servlet &#123; //在类内部声明一个ServletConfig属性， //用于暂存从init方法中获取的servletConfig对象 @Override public void init(ServletConfig servletConfig) throws ServletException &#123; this.servletConfig = servletConfig; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; private ServletConfig servletConfig; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //1、获取应用初始化参数username、password ServletContext servletContext = servletConfig.getServletContext(); String user = servletContext.getInitParameter(&quot;username&quot;); String psw = servletContext.getInitParameter(&quot;password&quot;); //2、获取login.html请求参数 String username = servletRequest.getParameter(&quot;username&quot;); String password = servletRequest.getParameter(&quot;password&quot;); PrintWriter writer = servletResponse.getWriter(); String mes; //3、将请求中的参数与web应用初始化参数信息进行比较 if(user.equals(username) &amp;&amp; psw.equals(password))&#123; mes = &quot;App: login succeed&quot;; &#125;else&#123; mes = &quot;App: login failed&quot;; &#125; writer.print(mes); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125;&#125; web.xml文件 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;context-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;12345&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;55555&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.test.java.LoginServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 解决思路由于WEB应用的初始化参数必须通过ServletContext对象获取，而该对象又需要ServletConfig对象获取。ServletConfig则需在init方法才能得到实体引用。因此关键实现步骤如下： 暂存从init方法中获取的ServletConfig引用 定义一个private ServletConfig servletConfig 属性，用于存储servletConfig的引用 从init方法中对servletConfig引用赋值 通过servletConfig获取ServletContext进而获取WEB应用的初始化参数 问题分析 存在的问题： 在完成上述简单功能时候为了实现Servlet接口，出现众多无需使用的空方法 想使用ServletConfig 或ServletContext每次都需创建一个属性从init方法中暂存引用 解决方案： 自定义一个Servlet实现类、尝试实现里面的方法。 在后续开发Servlet程序时通过继承的这个实现类的方式开发，以简化开发 MyGenericServlet.java 1234567891011121314151617181920212223242526272829303132333435363738/** * 在后续开发Servlet程序时通过继承的这个实现类的方式开发，以简化开发 */public abstract class MyGenericServlet implements Servlet &#123; //1、声明一个ServletConfig变量用于暂存init方法中获取到的引用 private ServletConfig servletConfig; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; this.servletConfig = servletConfig; &#125; //2、尝试实现方法：可以实现，即返回ServletConfig引用 @Override public ServletConfig getServletConfig() &#123; return this.servletConfig; &#125; /** * 3、由于service方法是开发servlet必须使用与实现的方法 * 可以将其定义未抽象方法，即强制继承的子类必须实现这个方法 * 由于该方法定义成abstract，因此MyGenericServlet需改成抽象类 */ @Override public abstract void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException; //4、尝试实现方法：无法实现 @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125;&#125; 通过继承MyGenericServlet.java实现优化后的LoginServlet开发 无需强制实现Servlet其他不需要的方法 可通过getServletConfig()，在任意位置获取到ServletConfig()对象 123456789101112131415161718192021222324252627/* * 基于自实现的GenericServlet——MyGenericServlet进行Servlet开发 */public class LoginServlet2 extends MyGenericServlet &#123; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //1、获取应用初始化参数username、password ServletContext servletContext = getServletConfig().getServletContext(); String user = servletContext.getInitParameter(&quot;username&quot;); String psw = servletContext.getInitParameter(&quot;password&quot;); //2、获取login.html请求参数 String username = servletRequest.getParameter(&quot;username&quot;); String password = servletRequest.getParameter(&quot;password&quot;); PrintWriter writer = servletResponse.getWriter(); String mes; //3、将请求中的参数与web应用初始化参数信息进行比较 if(user.equals(username) &amp;&amp; psw.equals(password))&#123; mes = &quot;App2: login succeed&quot;; &#125;else&#123; mes = &quot;App2: login failed&quot;; &#125; writer.print(mes); &#125;&#125; GenericServletGenericServlet是实现Servlet的一个抽像类，上述自实现的MyGenericServlet要解决的问题与思路和GenericServlet一致。不过官方的GenericServlet除了实现Servlet接口，还实现了ServletConfig接口，意义使继承GenericServlet的Servlet能够直接调用ServletConfig的所有方法(ServletConfig是对标一个Servlet的)，进而更一步提高了GenericServlet的功能。提高了开发Servlet的效率。GenericServlet一些其他细节如下所示： 源码中ServletConfig接口方法的实现，是使用从init方法中获取的ServletConfig对象直接调用对应方法来间接实现的。 123456789101112public abstract class GenericServlet implements Servlet, ServletConfig, Serializable &#123; //..... public String getInitParameter(String name) &#123; return this.getServletConfig().getInitParameter(name);//间接实现 &#125; public Enumeration&lt;String&gt; getInitParameterNames() &#123; return this.getServletConfig().getInitParameterNames();//间接实现 &#125; //.....&#125; GenericServlet在实现的Servlet接口中原生的init(ServletConfig servletConfig)方法的同时调用了一个自定义的**空参init()**方法。作用如下说明： **空参init()**方法用于给继承GenericServlet开发的子类想通过init方法进行一些初始化操作 由于GenericServlet关键在于声明了一个ServletConfig类型成员变量，在原生带参的init(ServletConfig)方法中进行了初始化。 若子类直接重写GenericServlet的带参init(ServletConfig)方法进行初始化操作。则会导GenericServlet对ServletConfig初始化失败，系统默认调用了子类重写的init方法。因此当子类在调用GenericServlet封装好且涉及ServletConfig参与实现的方法时，就会出现空指针异常。 小结： 若子类想使用初始化init方法，建议重写空参的init()方法，不建议重写init(ServletConfig) 若子类有必要重写init(ServletConfig)，则必须在init方法中super.init(ServletConfig)显式调用一下父类的带参init方法，使父类的ServletConfig能顺利被初始化 因此，严格来说，GenericServlet定义的空参init()方法并非Servlet的生命周期方法，init(ServletConfig)才是。 12345678910111213public abstract class GenericServlet implements Servlet, ServletConfig, Serializable &#123; //..... public void init(ServletConfig config) throws ServletException &#123; this.config = config; this.init(); &#125; public void init() throws ServletException &#123; &#125; //.....&#125; HTTP请求处理HTTP请求GET请求格式 请求行 请求的方式 GET 请求的资源路径[+?+请求参数] 请求的协议的版本号 HTTP/1.1 请求头：key : value 组成多个不同的键值对，表示不同的含义。 传递参数格式 键值对格式：http://www.xxx.com/index.jsp?name=lc&amp;password=123 ? 隔开URL与参数列表，用与表示请求参数的开始位置 每个参数有键值对 name=value组成 多个简直对之间用 &amp; 相隔 特点：参数在URL的位置任意，因为后端通过键值对解析。参数占用URL长度较多。 参数序列格式：http://www.xxx.com/api/name/password 没有明显的请求参数开始标记 参数值直接写入URL中，并通过/隔开 特点：请求参数必须按序放入，由于没有键值对的关联关系，因此位置信息是决定参数类型的唯一参考，每个位置对应指定的参数类型。优势是占用URL长度较少。 GET请求类型操作 form 标签method=get 超链接 a标签或img标签 在浏览器地址栏中输入地址后敲回车 特点POST请求格式 请求行 请求的方式 POST 请求的资源路径[+?+请求参数] 请求的协议的版本号 HTTP/1.1 请求头：key : value组成多个不同的请求头，有不同的含义 空行 请求体 ：发送给服务器的数据 POST请求类型操作 form 标签 method=post HTTP响应响应格式 响应行 响应的协议和版本号 响应状态码 响应状态描述符 响应头： key : value 不同的响应头，有其不同含义 空行 响应体：回传给客户端的数据 常用的响应码 200 表示请求成功 302 表示请求重定向 404 表示请求服务器已经收到了，但是你要的数据不存在（请求地址错误） 500 表示服务器已经收到请求，但是服务器内部错误（代码错误） MIME类型说明 MIME 的英文全称是”Multipurpose Internet Mail Extensions” 多功能 Internet 邮件扩充服务。 MIME 是 HTTP 协议中数据类型，用于表示某一种文件的扩展名。 MIME 类型的格式是“大类型/小类型” 具体可通过网络查询 HttpServletHttpServletRequest/Response初谈需求驱动 在通过Servlet去处理HTTP请求时，若想获取请求的方式，进而区分处理两种不同类型的请求(GET/POST)时，服务器给予的ServletRequest/Response实现类是不能满足需求的。 由于ServletReqeust与ServletResponse是基于请求—响应这个服务机制层面上的封装，严格来说没有指明使用的通信协议。而GET/POST请求时HTTP协议所特有的，因此在使用HTTP协议所涉及的相关功能时，需要使用——HttpServletRequest/Response接口 简介HttpServletRequest/Response分别是ServletRequest/Response接口基于HTTP协议的子接口，在ServletRequest/Response原有功能的基础上，规范定义许多HTTP协议特用的方法。与ServletRequest/Response类似，具体的实现类由HTTP服务器提供 获取HttpServletRequest/Response由于HttpServletRequest/Response是ServletRequest/Response的子接口。而在开发基于HTTP协议的应用时，HTTP服务器实现的肯定是HttpServletRequest/Response。而通过上层协议规范ServletRequest/Response传入 因此可以在获取ServletRequest/Response实体后通过向下转型(强制转换)**得到HttpServletRequest/Response。具体操作在service**(ServletRequest,ServletResponse)方法中实现 得到HttpServletRequest/Response实现类后，可调用request.getMethod();获取HTTP请求方式 1234567891011public class Test implements Servlet &#123; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //通过向下转型(强制类型转换)获得其实现类 HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; String requestMethod = request.getMethod(); &#125; //@Override...method，略&#125; 需求驱动即使通过继承GenericServlet开发Servlet已经方便了许多，但是当处理HTTP请求时还是需要将ServletRequest/Response手动强制转换为HttpServletRequest/Response才能更好的处理HTTP请求。而每次开发Servlet处理HTTP请求都需要书写强制类型转换语句，显然还有优化的空间。 因此，可以在GenericServlet基础上针对HTTP协议再进行优化，创建一个专门用于处理HTTP请求Servlet接口实现类。具备的基本功能如下： 如封装好将ServletRequest/Response转换为HttpServletRequest/Response的步骤。 实现GET请求、POST请求的分发处理 …. MyHttpServlet.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 自定义一个基于GenericServlet，HTTP协议的Servlet接口实现类，基本功能如下： * 1、封装好将ServletRequest/Response转换为HttpServletRequest/Response * 2、实现GET请求、POST请求的分发 */public class MyHttpServlet extends GenericServlet &#123; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //1、封装好将ServletRequest/Response转换为HttpServletRequest/Response //1.1、通过instanceof检查实现类的实际类型 if(servletRequest instanceof HttpServletRequest)&#123; HttpServletRequest request = (HttpServletRequest)servletRequest; if(servletResponse instanceof HttpServletResponse)&#123; HttpServletResponse response = (HttpServletResponse) servletResponse; //1.2、创建一个重载service(HttpServletRequest,HttpServletResponse) //传入转换后的HttpServletRequest/Response 实体引用。 //子类通过重写service(HttpServletRequest,HttpServletResponse)方法 //进而实现直接使用HttpServletRequest/Response service(request,response); &#125; &#125; &#125; //1.2、创建一个重载service(HttpServletRequest,HttpServletResponse) public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //2、实现GET请求、POST请求的分发处理 //2.1、通过HttpServletRequest获取当前HTTP请求类型，并进行判断 String requestMethod = request.getMethod(); if(&quot;GET&quot;.equals(requestMethod))&#123; doGet(request,response);//2.2、模仿service方法，创建专门处理GET请求的方法doGet &#125; if(&quot;POST&quot;.equals(requestMethod))&#123; doPost(request,response);//2.2、模仿service方法，创建专门处理POST请求的方法doPost &#125; &#125; //开发的时候，可以针对HTTP协议对不同的请求重写对应的doGet或doPost实现更方便的处理 //2.2、模仿service方法，创建专门处理GET请求的方法doGet public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; //2.2、模仿service方法，创建专门处理POST请求的方法doPost public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; 基于MyHttpServlet的servlet开发，更加有针对性，简洁，有效 123456789101112131415161718192021222324252627/** * 基于自实现的HttpServlet——MyHttpServlet进行Servlet开发 * @author yhd * @create 2021-04-06 8:10 */public class LoginServlet4 extends MyHttpServlet &#123; @Override public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1、获取应用初始化参数username、password String user = getServletContext().getInitParameter(&quot;username&quot;); String psw = getServletContext().getInitParameter(&quot;password&quot;); //2、获取login.html请求参数 String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); PrintWriter writer = response.getWriter(); String mes; //3、将请求中的参数与web应用初始化参数信息进行比较 if(user.equals(username) &amp;&amp; psw.equals(password))&#123; mes = &quot;App4: login succeed&quot;; &#125;else&#123; mes = &quot;App4: login failed&quot;; &#125; writer.print(mes); &#125;&#125; HttpServletHttpServlet继承与GenericServlet，上述自实现的MyHttpServlet要解决的问题思路以及功能与HttpServlet类似。在真正的Servlet开发中，是通过继承HttpServlet方式进行开发，根据请求方式重写doXxx()方法即可。 (了解)其中如果我们对一个请求没有进行任何doXxx()方法的重写，其实源码内部已经对该请求进行了一定程度的受理 HttpServletRequesttips：概念介绍请转至标题HttpServlet下的HttpServletRequest/Response初谈 API getRequestURI() ：获取请求的资源路径 getRequestURL() ：获取请求的统一资源定位符（绝对路径） getRemoteHost() ：获取客户端的 ip 地址 getHeader() ：获取请求头（User-Agent的值） getMethod()： 获取请求的方式 GET 或 POST – ServletRequest – 来自父接口的方法 getParameter()： 获取请求的参数 getParameterValues()： 获取请求的参数（多个值的时候使用） setAttribute(key, value)：设置域数据 getAttribute(key)：获取域数据 getRequestDispatcher()： 获取请求转发对象 … 请求中文乱码GET请求后端获取带中文的请求参数时，打印显示?????，由于HTTP协议传输URL默认编码为iso-8859-1(兼容ASCII) 方案1：先正确解码，再对应编码 1234//获取请求参数String username = req.getParameter(&quot;username&quot;);//先以iso8859-1 解码，再以utf-8进行编码username = new String(username.getBytes(&quot;iso-8859-1&quot;), &quot;UTF-8&quot;); 方案2：修改tomcat收到请求时url参数的编码方式 打开tomcat安装目录中的conf\\server.xml，修改成如下内容 1&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot; useBodyEncodingForURI=&quot;true&quot;/&gt; POST请求12//一定要在获取请求参数前设置，一旦获取了请求参数后设置无效request.setCharacterEncoding(&quot;UTF-8&quot;); HttpServletResponseAPIServletResponse接口定义 PrintWriter getWriter()：字符流，常用于回传字符串（常用） 返回 PrintWriter 对象. 调用该对象的 print() 方法, 将把 print() 中的参数直接打印到客户的浏览器上. PrintWriter 对象还可配合setContentType响应类型，把内容输入到响应类型文件内 OutputStream getOutputStream()：字节流，常用于下载（传递二进制数据） 注意：两个流同时只能获取一个，否则就会报错。 响应中文乱码当通过字符流PrintWriter getWriter()向浏览器直接传送中文字符时，常见显示?????乱码情况。 乱码的原因 乱码问题终归就是：发送方的编码字符集与接收方的编码字符集不兼容导致 可通过调用response.getCharacterEncoding();获取当前服务器的默认编码集(ISO-8859-1) 一般浏览器默认是GBK编码，因此服务器与浏览器字符集不匹配因此。这是造成乱码的首要原因 因此最直接的解决方案(不推荐！)：response.setCharacterEncoding(&quot;GBK&quot;); GBK编码：一个汉字占用两个字节，此编码为中国专用的汉字编码而形成之解决方案。 UTF-8编码：一个汉字占用3个字节。是全世界统一的编码结构。外国网站看的话不会乱码。 Unicode是「字符集」：为每一个「字符」分配一个唯一的 ID(学名为码位 / 码点 / Code Point） UTF-8 是「编码规则」：将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程） 小结：因此在选择中文编码集时，由于国际化问题，优先选用UTF-8。 若为了国际化将服务器编码设置为response.setCharacterEncoding(&quot;UTF-8&quot;);又会因为浏览器默认GBK编码而又导致了乱码。此时可以通过将浏览器的编码设置为UTF-8来解决问题，但不推荐，由于不可能让用户每次访问该网页时都手动设置一下编码。而且有些浏览器设置困难 推荐解决方案 方案1：设置响应头，告诉浏览器接收到数据时，采用UTF-8解析网页内容 1response.setHeader(&quot;Content-Type&quot;,&quot;text/html;charset=UTF-8&quot;); 方案2(推荐)：设置内容类型，同时设置了服务器和客户端都使用UTF-8字符集，还设置了响应头。注意：此方法一定要在获取流对象之前调用才有效 12//注意获取流对象前设置才有效，一旦获取了流对象设置无效resp.setContentType(&quot;text/html;charset=UTF-8&quot;); Servlet体系结构 由于Servlet，或者是Web开发，是一种被动式的开发。 服务器操作的占比远远高于编程人员 其实是在Web容器，服务器实现与一套机制管理下，通过开放给编程人员使用的部分接口(主要的service)而实现Web开发编程的 由于服务器操作的占比远远高于编程人员，因此Servlet体系中，大部分是接口的定义(给服务器处理)。 优化Servlet开发层面 请求处理层面 ServletRequest/Response 都是接口 定义成接口的原因就是这些类都是由服务器实现的 ServletRequest/Response服务器实现后通过传入参数给用户调用，这种接口层次是在通信协议之上的(HTTP之上) HttpServletRequest/Response是基于ServletRequest/Response的子接口，是针对HTTP协议定义的规范。对应由服务器实现后，即是ServletRequest/Response的子类。 完整结构体系 Web路径绝对与相对路径 相对路径： 符号 含义 . 表示当前目录 .. 表示上一级目录 资源名 表示当前目录/资源名 绝对路径：http://ip:port/工程路径/资源路径 ‘/‘ 斜杠的不同含义在 web 中 / 斜杠是一种绝对路径 / 若被浏览器解析（前端代码）：只定位到端口号，如 http://ip:port/ 1&lt;a href=&quot;/&quot;&gt;斜杠&lt;/a&gt; / 若被服务器解析（Servlet、web.xml、JSP）：定位到工程名，如 http://ip:port/工程路径对应WEB资源根目录(IDEA - web，eclipse - WebContent) 特殊情况，重定向：response.sendRediect(“/”); 把斜杠发送给浏览器解析 http://ip:port JSP需求驱动前端想通过发送一个请求返回整个java处理过的HTML页面(动态页面)，而非PrintWriter返回的几个字符串，则传统的方式只能通过PrintWriter逐一打印出整个html代码，如下所示。 ReturnHtml.java 123456789101112131415161718/** * @author yhd * @create 2021-04-07 21:33 */public class ReturnHtml extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; StringBuilder result = new StringBuilder(); Date date = new Date();//获取当前时间 result.append(&quot;&lt;form&gt;&quot;); result.append(&quot;当前时间：&lt;input type=\\&quot;text\\&quot; name=\\&quot;username\\&quot; value=\\&quot; &quot; + date + &quot; \\&quot;&gt;&lt;br/&gt;&quot;); result.append(&quot;&lt;/form&gt;&quot;); resp.setContentType(&quot;text/html;charset=UTF-8&quot;); PrintWriter writer = resp.getWriter(); writer.print(result.toString()); &#125;&#125; index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;/08_JSP/getHTML&quot; &gt;获取HTML页面&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 最终效果 小结：只能通过这种方式返回经过java处理过的页面，编写和维护都将非常困难，实在效率太低了 JSP基本概念 为弥补 Servlet 的缺陷，SUN公司在Servlet的基础上推出了JSP（Java Server Pages）技术作为解决方案。 JSP是简化Servlet编写的一种技术，它将Java代码和HTML语句混合在同一个文件中编写，只对网页中的要动态产生的内容采用Java代码来编写，而对固定不变的静态内容采用普通静态HTML页面的方式编写。 JSP文件就像普通的HTML文件一样，可以放置在WEB应用程序中的除了WEB-INF及其子目录外的其他任何目录中，JSP页面的访问路径与普通HTML页面的访问路径形式也完全一样。 HelloWorld 在IDEA 或 eclipse中右键新建一个JSP文件 在&lt;body&gt;标签内写入&lt;% %&gt; 在&lt;% %&gt;内可以编写Java代码 index.jsp 123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 我是JSP页面 &lt;% System.out.println(&quot;JSP：在前端页面编写后台打印语句！&quot;); %&gt; &lt;/body&gt;&lt;/html&gt; 最终效果 JSP运行原理运行原理 WEB容器（Servlet引擎）收到以.jsp为扩展名的URL的访问请求时，会把该访问请求交给JSP引擎去处理。 每个JSP页面在第一次被访问时，JSP引擎将它翻译成一个Servlet源程序(.java文件)， 接着再把这个Servlet源程序编译成Servlet的.class类文件 然后再由WEB容器（Servlet引擎）像调用普通Servlet程序一样的方式来装载和解释执行这个由JSP页面翻译成的Servlet程序。 JSP的Servlet源程序源程序路径 IDEA存放位置：C:\\Users\\[用户名]\\AppData\\Local\\JetBrains\\IntelliJIdea2020.3\\tomcat\\[XXXX-XX-标识符-XXXX-XXXX]\\work\\Catalina\\localhost\\[项目名称]\\org\\apache\\jsp目录下 JSP本质 观察JSP源程序：可以发现index_jsp这个类继承了HttpJspBase 通过观察HttpJspBase源码发现HttpJspBase继承HttpServlet 结论：因此可知JSP源程序是间接继承了HttpServlet的，即JSP本质上就是Servlet index_jsp.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package org.apache.jsp;import javax.servlet.*;import javax.servlet.http.*;import javax.servlet.jsp.*;public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent, org.apache.jasper.runtime.JspSourceImports &#123; //....省略部分代码.... //类似Servlet的Init方法 public void _jspInit() &#123; &#125; //类似Servlet的destroy方法 public void _jspDestroy() &#123; &#125; //类似Servlet的service方法 public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException &#123; //..... &#125; //类似Servlet相关的一些类，ServletContext、ServletCondig等... //这些其实就是后面所说的JSP隐函对象 final javax.servlet.jsp.PageContext pageContext; javax.servlet.http.HttpSession session = null; final javax.servlet.ServletContext application; final javax.servlet.ServletConfig config; javax.servlet.jsp.JspWriter out = null; final java.lang.Object page = this; javax.servlet.jsp.JspWriter _jspx_out = null; javax.servlet.jsp.PageContext _jspx_page_context = null; try &#123; response.setContentType(&quot;text/html;charset=UTF-8&quot;); pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out; out.write(&quot;\\n&quot;); out.write(&quot;\\n&quot;); out.write(&quot;&lt;html&gt;\\n&quot;); out.write(&quot; &lt;head&gt;\\n&quot;); out.write(&quot; &lt;title&gt;$Title$&lt;/title&gt;\\n&quot;); out.write(&quot; &lt;/head&gt;\\n&quot;); out.write(&quot; &lt;body&gt;\\n&quot;); out.write(&quot; 我是JSP页面\\n&quot;);//自编写的HTML元素 out.write(&quot; &quot;); //自编写的java代码 System.out.println(&quot;JSP：在前端页面编写后台打印语句！&quot;); out.write(&quot;\\n&quot;); out.write(&quot; &lt;/body&gt;\\n&quot;); out.write(&quot;&lt;/html&gt;\\n&quot;); &#125; catch (java.lang.Throwable t) &#123; //....省略部分代码.... &#125; &#125;&#125; HttpJspBase：继承了HttpServlet，里面的init、service等Servlet生命周期方法都对应调用了jsp源程序的相关Servlet生命周期代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public abstract class HttpJspBase extends HttpServlet implements HttpJspPage &#123; private static final long serialVersionUID = 1L; protected HttpJspBase() &#123; &#125; @Override public final void init(ServletConfig config) throws ServletException &#123; super.init(config); jspInit(); _jspInit(); &#125; @Override public String getServletInfo() &#123; return Localizer.getMessage(&quot;jsp.engine.info&quot;, Constants.SPEC_VERSION); &#125; @Override public final void destroy() &#123; jspDestroy(); _jspDestroy(); &#125; /** * Entry point into service. */ @Override public final void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; _jspService(request, response); &#125; @Override public void jspInit() &#123; &#125; public void _jspInit() &#123; &#125; @Override public void jspDestroy() &#123; &#125; protected void _jspDestroy() &#123; &#125; @Override public abstract void _jspService(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException;&#125; 9大隐含对象 从JSP运行原理中看到JSP对应的Servlet源程序时可发现，自编写的java代码在void _jspService()方法内，而该方法的首部，还定义了许多对象。这些便是JSP的隐函对象，可供我们在JSP编写java代码时不用声明(已经帮我们声明)直接使用使用。 JSP的9个隐函对象：request、response、pageContext、session、application、config、out、page、exception request：HttpServletRequest对象. response(了解)：HttpServletResponse 对象(在 JSP 页面中几乎不会调用 response 的任何方法.) pageContext: 页表示面的上下文，PageContext的一个对象封装了当前页面的一切信息(学习自定义标签时使用它) 可以从该对象中获取到其他 8 个隐含对象. 也可以从中获取到当前 session：代表浏览器和服务器的一次会话, 是 HttpSession 的一个对象. 后面详细学习 application: 代表当前 WEB 应用，是ServletContext对象. config(了解)：当前 JSP 对应的 Servlet 的 ServletConfig 对象(几乎不使用). 若需要访问当前 JSP页面。配置的初始化参数, 需要配置jsp页面的映射的地址才可以。 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;hellojsp&lt;/servlet-name&gt; &lt;jsp-file&gt;/hello.jsp&lt;/jsp-file&gt; &lt;init-param&gt; &lt;param-name&gt;test&lt;/param-name&gt; &lt;param-value&gt;testValue&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hellojsp&lt;/servlet-name&gt; &lt;url-pattern&gt;/hellojsp&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; out：JspWriter对象，结构功能与response.getWrite()的PrintWriter对象类似。调用 out.println() 可以直接把字符串打印到浏览器上 page(几乎不使用))：指向当前 JSP 对应的Servlet 对象的引用, 但为 Object 类型, 只能调用 Object 类的方法 exception：在声明了 page 指令的 &lt;%@ page isErrorPage=&quot;true&quot; %&gt; 时, 才可以使用。 JSP基本语法模板元素静态HTML内容称之为JSP模版元素，在静态的HTML内容之中可以嵌套JSP的其他各种元素来产生动态内容和执行业务逻辑。 注释1234&lt;!-- html注释：会被翻译导java源代码中，通过out.writer方式输出 --&gt;// 或 /* java注释，也会被翻译导java源代码中 */&lt;%-- JSP注释,真正的注释，不会被翻译 --%&gt;&lt;%-- 凡是涉及后端解析的代码，如JSP、EL、JSTL注释都必须是用JSP注释，否则会被解析 --%&gt; JSP脚本JSP小脚本语法格式：&lt;% %&gt; 12345&lt;!-- 打印当前时间 --&gt;&lt;% Date date = new Date();%&gt;&lt;% System.out.println(date); %&gt; 每次访问含小脚本的页面，小脚本都会被重头执行。 只能编写方法内语句。 原理：由于JSP小脚本内编写的代码时直接移植到jsp对应Servlet源程序的_jspService()方法内，因此像声明一个java方法的这些语句是不能够写在JSP小脚本内的(java中方法内不能定义方法)。 123456789public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent, org.apache.jasper.runtime.JspSourceImports &#123; public void _jspService(final javax.servlet.http.HttpServletRequest request , final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException &#123; //&lt;% %&gt;JSP小脚本代码移植的位置 &#125; &#125; JSP声明语法格式：&lt;%! %&gt; 12&lt;!-- 声明一个名为date的Date类型变量 --&gt;&lt;%! Date date = null; %&gt; 只能编写声明，定义类型的java语句。不能直接编写java代码 使用&lt;%! %&gt;声明变量仅在页面第一次加载时由容器只初始化一次，后续再访问页面不再执行。 若使用&lt;% %&gt;小脚本声明变量，由于小脚本每次访问页面时都被执行。因此每次都是重新声明变量。 原理：JSP声明的内容是移植到jsp对应Servlet源程序的类中，是属于类的成员的一部分。因此只能编写书写属性、方法声明语句。 tips：几乎不怎么使用 12345678public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent, org.apache.jasper.runtime.JspSourceImports &#123; //&lt;%! %&gt;JSP声明代码移植的位置(类成员) public void _jspService(/*...省略...*/)&#123; //&lt;% %&gt;JSP小脚本代码移植的位置(方法内) &#125;&#125; JSP表达式语法格式：&lt;%= %&gt; 12&lt;!-- 输出当前时间 --&gt;&lt;%= new Date() %&gt; 可直接输出任何对象(null)或任何基本数据类型、表达式、方法调用返回值等 JSP表达式的百分号%和等号=之间不能有空格 JSP表达式内的语句不用写分号，原理(out.print(翻译语句**;**));，若加了分号则导致 ));语句多出，语法错误 原理：与jsp小脚本一样，翻译在_jspService()方法内，通过调用PrintWrite，print方法打印，因此还可以获取request，response对象 JSP与HTML互嵌123456789101112&lt;% int i = 10; if(i &gt; 10)&#123;%&gt; &lt;a href=&quot;/08_JSP/index.jsp&quot;&gt;大于10&lt;/a&gt;&lt;% &#125;else&#123;%&gt; &lt;a href=&quot;/08_JSP/index.jsp&quot;&gt;小于10&lt;/a&gt;&lt;% &#125;%&gt; JSP指令用于向容器提供关于JSP页面的总体信息，并不产生任何输出，语法格式为&lt;%@ 指令 属性名 = &quot;值&quot; %&gt;。一般写在JSP首部。指令有三种类型： page include taglib page指令 描述JSP页面的总体特性，如输出内容类型、字符集编码等信息 配置多个属性可以用空格隔开，或使用多条指令语句单独设置 123&lt;!--返回的内容类型及返回内容的编码、翻译后语言、及JSP页面本身编码的字符集--&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot; %&gt; 其他属性：常用为加粗表示 language：表示jsp翻译后是什么语言，暂时只支持java extends=”package.class”：表明当前JSP被翻译成源程序(.java)时继承哪个类 import=”package.class”：与java一样导包，导类 session=”true | false”：设置当前页面是否启用session，使用session前必须设置为true errorPage=”错误页面路径”：jsp本身代码出错时，自动转发到这个页面。 还可以通过在web.xml中配置&lt;error-page&gt;信息来实现 12345678910&lt;!-- 通过http错误代码配置错误页面 --&gt;&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/WEB-INF/error.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;!-- 通过设定的异常类跳转错误页面 --&gt;&lt;error-page&gt; &lt;exception-type&gt;java.lang.ArithmeticException&lt;/exception-type&gt; &lt;location&gt;/WEB-INF/error.jsp&lt;/location&gt;&lt;/error-page&gt; isErrorPage=”true | false” ： 默认为false，true时可使用exception隐函对象，打印出错信息。 只有出错时exception才不会null，因此不建议直接访问含该对象时候的网页。 因此推荐把调用exception对象的错误页面放入WEB-INF中，通过外部请求的转发访问。 contentType=”mimeType [ ;charset=characterSet ]” | “text/html ;charset=ISO-8859-1” ] 指定当前JSP的响应类型，实际调用response.setContentType(); 同理也可以再配置中设置响应类型的字符编码charset pageEncoding=”characterSet| ISO-8859-1”] ：指定当前JSP页面编码的字符编码，一般与上述的字符编码设置一致 isELIgnored=”true | false”：指定当前JSP页面是否可以使用EL表达式，通常取值为true autoFlush：设置当out输出缓冲区满了之后，是否自动刷新缓冲区。默认true buffer：设置out缓冲区的大小，默认8kb include指令 include指令实现把另一个文件(HTML、JSP等)的内容静态包含到当前页面中。 静态包含 静态包含其实是吧被包含得jsp页面的代码拷贝到包含的位置执行输出(out.write()) 静态包含不会翻译被包含的jsp页面，即只有一个jsp源文件 1&lt;%@ include file = &quot;copyright.html&quot; %&gt; JSP动作JSP动作JSP页面发给容器的命令，它指示容器在页面执行期间(动态)，完成的某种任务。 基本语法：&lt;前缀: 动作名称 属性列表键值对 /&gt;，如&lt;jsp:include page=&quot;copyright.html&quot;/&gt; 动作类型：JSP标准动作、标准标签库(JSTL)、用户自定义动作 常用动作： jsp:include：在当前页面中动态包含另一个页面 非源码级搬运包含，而是通过内置调用一个方法包含 JspRuntimeLibrary.include(request, response, &quot;/include/footer.jsp&quot;, out, false 生成多个servlet源文件，即包含与被包含数目。 多数使用静态包含 jsp:forward page = “”：请求转发到指定页面 可以使用 jsp:param 子标签传入一些参数，响应端可通过getParameter() 123 &lt;jsp:forward page=&quot;/include/b.jsp&quot;&gt;&lt;jsp:param value=&quot;abcd&quot; name=&quot;username&quot;/&gt; &lt;/jsp:forward&gt; jsp:useBean：查找或创建一个javaBean对象 jsp:setProperty：设置JavaBeans对象的属性值 jsp:getProperty：返回JavaBeans对象的属性值 jsp:plugin：在JSP页面中嵌入一个插件 4大域对象通用方法pageContext，request，session，application对象都含以下方法 void setAttribute(String name, Object object)：设置数据内容，键值对key : value Object getAttribute(String name)：通过key获取value Enumeration getAttributeNames() ：获取所有key组成的Enumeration对象 void removeAttribute(String name) ：删除指定key的数据 属性作用范围范围从小到大：pageContext —&gt; request —&gt; session —&gt; application pageContext：仅限于当前 JSP 页面，因此Servlet或者其他页面都获取不到。 request：仅限于同一个请求. session：限于同一次会话，浏览器打开直到关闭称之为一次会话(前提在此期间会话不失效) application：限于当前WEB 应用，是范围最大的属性作用范围。只要在一处设置属性, 在其他各处的 JSP 或 Servlet 中都可以获取到。 tips：由于这些域对象存储数据都是占用资源的，因此在业务使用中，尽量能小作用域完成的工作交给小作用域，使其资源得到最快得释放。 转发与重定向请求转发基本概念请求转发：服务器收到请求后，从一次资源跳转到另一个资源(Servlet)的操作叫请求转发。 浏览器地址栏没有变化，为初次发出请求的地址。 只有一次请求，request始终是同一个对象，因此共享Request域中的数据 可以转发到WEB-INF目录下 只能转发给当前 WEB 应用的的资源、不可以访问工程以外的资源 转发地址全程由服务器操作，/ 代表的是当前 WEB 应用的根目录http://ip:port/web应用 实现步骤 调用HttpServletReques对象getRequestDispatcher()方法并填入转发路径 通过第1步获取到RequestDispatcher对象 通过调用RequestDispatcher的forward()方法进行请求的转发 12345678910111213public class ForwardServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //请求的转发. //1. 调用 HttpServletRequest的getRequestDispatcher()方法,需要传入要转发的地址 //获取RequestDispatcher对象 RequestDispatcher requestDispatcher = request.getRequestDispatcher(&quot;/testServlet&quot;); //2、调用 HttpServletRequest 的 forward(request, response) 进行请求的转发. requestDispatcher.forward(request, response); &#125;&#125; 请求的重定向基本概念请求重定向：指客户端给服务器发请求后，服务器告知客户端，去请求另一个地址。 浏览器地址栏会发生变化、初次发出的请求地址，地址栏为最后响应的那个地址 两次请求，request不是同一个对象，不能共享request域中的数据 不能访间WEB-INF下的资源 可以访问工程外的资源(可以重定向到任何资源，百度，淘宝等) 地址将被服务器发往浏览器进行解析，因此 / 代表 / 代表的是当前 WEB 站点的根目录. http://ip:port/ 实现步骤方式1通过设置响应头 1234// 设置响应状态码 302 ，表示重定向，（已搬迁）resp.setStatus(302);// 设置响应头，说明 新的地址在哪里resp.setHeader(&quot;Location&quot;, &quot;http://localhost:8080&quot;); 方式2直接调用HttpServletResponse的sendRedirect()方法 1response.sendRedirect(&quot;http://localhost:8080&quot;) out&amp;getWriter()场景复现 jsp测试代码： 1234567&lt;% out.write(&quot;out输出1&lt;br/&gt;&quot;); out.write(&quot;out输出2&lt;br/&gt;&quot;); response.getWriter().write(&quot;response输出1&lt;br/&gt;&quot;); response.getWriter().write(&quot;response输出2&lt;br/&gt;&quot;);%&gt; 输出结果反而是逆过来，先输出response，再输出out 原理分析 jsp中的out对象是JspWriter类型，response.getWrite()对象是PrintWriter类型，两者功能与结构非常相似 当JSP页面中所有代码执行完后会做一下两个动作 系统自动执行jsp的JspWriter对象的out.flush()操作，此时会把out缓冲区中得数据追加写入到response缓冲区后 系统自动执行response的PrintWriter对象的out.flush刷新操作，此时的flush操作是将全部数据响应给客户端。 步骤1：各自写入自己的缓冲区 步骤2：代码执行完后，系统先调用jsp的flush()追加数据到response中，后调用response的flush()操作响应到页面上。 测试 手动执行jsp的out.flush操作，控制jsp的out缓冲区追加到response缓冲区的时机 12345678&lt;% out.write(&quot;out输出1&lt;br/&gt;&quot;); out.flush(); out.write(&quot;out输出2&lt;br/&gt;&quot;); response.getWriter().write(&quot;response输出1&lt;br/&gt;&quot;); response.getWriter().write(&quot;response输出2&lt;br/&gt;&quot;);%&gt; 输出效果： 结论 由于 jsp 翻译之后，底层源代码都是使用jsp的JspWriter对象out来进行输出，所以一般情况下。我们在 jsp 页面中统一使用 jsp的out 来进行输出，而不建议使用response的out对象输出。避免打乱页面输出内容的顺序。 write &amp; print由于JspWriter和response.getWrite()的PrintWriter功能与结构是相似的，write()方法与print()方法的原理和使用也一致。 out.write() 输出字符串没有问题 out.print() ，有多个重载方法，因此输出任意数据都没有问题（都转换成为字符串后调用的 write 输出） EL表达式基础概念 EL 表达式的全称是：Expression Language，是表达式语言。 EL 表达式的作用：主要是代替jsp表达式脚本 ,负责jsp页面的数据输出。由于EL 表达式在输出数据时比jsp脚本更为简洁、强大、友好。 123456&lt;body&gt;&lt;% request.setAttribute(&quot;key&quot;,&quot;值&quot;); %&gt;表达式脚本输出key的值是： &lt;%=request.getAttribute(&quot;key1&quot;)==null?&quot;&quot;:request.getAttribute(&quot;key1&quot;)%&gt;&lt;br/&gt;EL 表达式输出 key 的值是：$&#123;key1&#125;&lt;/body&gt; EL表达式格式：$&#123;表达式&#125; EL表达式直接编写在JSP页面中，无需写在&lt;% %&gt;内 EL表达式在输出null值时，会自定转换为空串输出。 EL表达式所有语句输出都需要JavaBean的读方法支持(getter()、isXxxx())。 tips：&lt;%-- 凡是涉及后端解析的代码，如JSP、EL、JSTL注释都必须是用JSP注释，否则会被解析 --%&gt; 域数据的搜索顺序输出语法由于EL表达式主要用于在 jsp 页面中输出数据。 且主要是输出域对象中的数据。 格式：&lt;% request.setAttribute(&quot;key&quot;,&quot;值&quot;); %&gt; 等价于 $&#123;key&#125; 域数据的搜索顺序当四个域中都有相同的key 的数据的时，EL 表达式会按照四个域的从小到大的顺序去进行搜索，优先匹配则输出。 12345678&lt;%//往四个域中都保存了相同的 key 的数据。 request.setAttribute(&quot;key&quot;, &quot;request&quot;); session.setAttribute(&quot;key&quot;, &quot;session&quot;); application.setAttribute(&quot;key&quot;, &quot;application&quot;); pageContext.setAttribute(&quot;key&quot;, &quot;pageContext&quot;);%&gt;$&#123;key&#125; &lt;%-- 输出：pageContext --&gt; java类属性输出输出Java类中普通属性，数组属性。list 集合属性和 map 集合属性。 JSP部分 123456789101112131415&lt;% Person person = new Person(); person.setName(&quot;Denny！&quot;); person.setPhones(new String[]&#123;&quot;18610541354&quot;,&quot;18688886666&quot;,&quot;18699998888&quot;&#125;); List&lt;String&gt; cities = new ArrayList&lt;String&gt;(); cities.add(&quot;北京&quot;); cities.add(&quot;上海&quot;); cities.add(&quot;深圳&quot;); person.setCities(cities); Map&lt;String,Object&gt;map = new HashMap&lt;&gt;(); map.put(&quot;key1&quot;,&quot;value1&quot;); map.put(&quot;key2&quot;,&quot;value2&quot;); map.put(&quot;key3&quot;,&quot;value3&quot;); person.setMap(map);pageContext.setAttribute(&quot;p&quot;, person);%&gt; EL表达式部分 1234567输出 Person：$&#123; p &#125;&lt;br&#x2F;&gt;输出 Person 的 name 属性：$&#123;p.name&#125; &lt;br&gt;输出 Person 的 pnones 数组属性值：$&#123;p.phones[2]&#125; &lt;br&gt;输出 Person 的 List 集合：$&#123;p.cities&#125; &lt;br&gt;输出 Person 的 List 集合中个别元素值：$&#123;p.cities[2]&#125; &lt;br&gt;输出 Person 的 Map 集合: $&#123;p.map&#125; &lt;br&gt;输出 Person 的 Map 集合中某个 key 的值: $&#123;p.map.key3&#125; &lt;br&gt; 运算符关系运算符 逻辑运算符 算术运算符 empty运算empty 运算可以判断一个数据是否为空，若为空输出 true $&#123;empty requestScope.book&#125; //假设空串，则返回false 输出 false几种情况 值为null值 值为空串 值是 Object 类型数组，长度为零 list、map集合，元素个数为零 三元运算符$&#123;empty requestScope.book ? &quot;add&quot; : &quot;update&quot;&#125; “.”与[]中括号运算 .点运算，可以输出 Bean 对象中某个属性的值。 []中括号运算 可以输出有序集合中某个元素的值。 并且[]中括号运算，还可以输出 map 集合中 key 里含有特殊字符的 key 的值 将key值用单引号’’ 包含 将含特殊字符的key值整个用 [ ] 中括号包含 1234567891011&lt;% Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;a.a.a&quot;, &quot;aaaValue&quot;); map.put(&quot;b+b+b&quot;, &quot;bbbValue&quot;); map.put(&quot;c-c-c&quot;, &quot;cccValue&quot;); request.setAttribute(&quot;map&quot;, map);%&gt;&lt;%-- $&#123; map.a.a.a&#125; &lt;br&gt; 输出失败--&gt;$&#123; map[&#x27;a.a.a&#x27;] &#125; &lt;br&gt;$&#123; map[&quot;b+b+b&quot;] &#125; &lt;br&gt;$&#123; map[&#x27;c-c-c&#x27;] &#125; &lt;br&gt; 11个隐函对象隐函对象列表 隐函对象 返回类型 作用 pageContext PageContextImpl 可获取 jsp 中的九大内置对象 pageScope Map&lt;Strubg,Object&gt; 获取 pageContext 域中的 requestScope Map&lt;Strubg,Object&gt; 获取 Request 域中的数 sessionScope Map&lt;Strubg,Object&gt; 获取 Session 域中的数据 applicationScope Map&lt;Strubg,Object&gt; 获取 ServletContext 域中的数据 param Map&lt;Strubg,String&gt; 获取请求参数的值(同getParameter()) paramValues Map&lt;Strubg,String[]&gt; 同上，获取多个值的时候使用 header Map&lt;String,String&gt; 获取请求头的信息 headerValues Map&lt;Strubg,String[]&gt; 同上，获取多个值的情况使用 cookie Map&lt;Strubg,Cookie&gt; 获取当前请求的 Cookie 信息 initParam Map&lt;String,String&gt; 获取web.xml中&lt;context-param&gt;参数 域隐函对象 pageScope ——&gt; pageContext 域 requestScope ——&gt; request 域 sessionScope ——&gt; Session 域 applicationScope ——&gt; ServletContext 域 示例 1234567891011&lt;% pageContext.setAttribute(&quot;key1&quot;, &quot;pageContext1&quot;); pageContext.setAttribute(&quot;key2&quot;, &quot;pageContext2&quot;); request.setAttribute(&quot;key2&quot;, &quot;request&quot;); session.setAttribute(&quot;key2&quot;, &quot;session&quot;); application.setAttribute(&quot;key2&quot;, &quot;application&quot;);%&gt;$&#123; key2 &#125; &lt;%-- 非指定域搜索数据，默认从小到大 --&gt;&lt;%-- 指定域搜索数据 --&gt;$&#123; requestScope.key2 &#125;$&#123; applicationScope.key2 &#125; pageContextpageContext隐函对象可获取任意9大jsp隐函对象，获取后常用功能如下 协议 服务器 ip 服务器端口 获取工程路径 获取请求方式 获取客户端 ip 地址 获取会话的 id 编号 示例 123456789101112131415161718&lt;%-- 原生方法说明 request.getScheme() 它可以获取请求的协议,如 http、https request.getServerName() 获取请求的服务器ip或域名，如 127.0.0.1 request.getServerPort() 获取请求的服务器端口号，如 80 request.getContextPath() 获取当前工程路径，如 /09_EL_JSTL request.getMethod() 获取请求的方式，如（GET 或 POST） request.getRemoteHost() 获取客户端的 ip 地址 session.getId() 获取会话的唯一标识--%&gt;1.协议： $&#123; pageContext.request.scheme &#125;&lt;br&gt;2.服务器 ip：$&#123; pageContext.request.serverName &#125;&lt;br&gt;3.服务器端口：$&#123; pageContext.request.serverPort &#125;&lt;br&gt;4.获取工程路径：$&#123; pageContext.request.contextPath &#125;&lt;br&gt;5.获取请求方法：$&#123; pageContext.request.method &#125;&lt;br&gt;6.获取客户端 ip 地址：$&#123; pageContext.request.remoteHost &#125;&lt;br&gt;7.获取会话的 id 编号：$&#123; pageContext.session.id &#125;&lt;br&gt; 提高EL表达式简洁度的技巧 1234567&lt;% //如需调用request相关方法，则不通pageContext获取request对象 //而将JSP的request隐函对象存入pageContext域后直接用EL表达式调用 pageContext.setAttribute(&quot;req&quot;, request);%&gt;优化前： $&#123; pageContext.request.scheme &#125;&lt;br&gt;优化后： $&#123; req.scheme &#125;&lt;br&gt; param param Map&lt;String,String&gt;：它可以获取请求参数的值 paramValues Map&lt;String,String[]&gt;： 它也可以获取请求参数的值，获取多个值的时候使用。 示例代码 1234输出请求参数 username 的值：$&#123; param.username &#125; &lt;br&gt;输出请求参数 password 的值：$&#123; param.password &#125; &lt;br&gt;输出请求参数 hobby 的值：$&#123; paramValues.hobby[0] &#125; &lt;br&gt;输出请求参数 hobby 的值：$&#123; paramValues.hobby[1] &#125; &lt;br&gt; header header Map&lt;String,String&gt;：它可以获取请求头的信息的各种键值对 headerValues Map&lt;String,String[]&gt;： 它可以获取请求头的信息，它可以获取多个值的情况。 示例代码： 123输出请求头【User-Agent】的值：$&#123; header[&#x27;User-Agent&#x27;] &#125; &lt;br&gt;输出请求头【Connection】的值：$&#123; header.Connection &#125; &lt;br&gt;输出请求头【User-Agent】的值：$&#123; headerValues[&#x27;User-Agent&#x27;][0]&#125; &lt;br&gt; cookie cookie Map&lt;String,Cookie&gt;： 它可以获取当前请求的 Cookie 信息 示例代码 12获取 Cookie 的名称：$&#123; cookie.JSESSIONID.name &#125; &lt;br&gt;获取 Cookie 的值：$&#123; cookie.JSESSIONID.value &#125; &lt;br&gt; initParam initParam Map&lt;String,String&gt; ：它可以获取在 web.xml 中配置的上下文参数 web.xml 123456789&lt;context-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;root&lt;/param-value&gt;&lt;/context-param&gt;&lt;context-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql:///test&lt;/param-value&gt;&lt;/context-param&gt; 示例代码 12输出&amp;lt;Context-param&amp;gt;username 的值：$&#123;initParam.username&#125; &lt;br&gt;输出&amp;lt;Context-param&amp;gt;url 的值：$&#123;initParam.url&#125; &lt;br&gt; JSTL简介 JSTL 标签库全称是指 JSP Standard Tag Library，即JSP标准标签库。是一个不断完善的开放源代码的 JSP 标签库。 属于JSP动作，其开源性起始源于自定义标签库的功能。可以说JSTL是最广泛使用友好的自定义标签库典范。 EL 表达式主要是为了替换 jsp 中的表达式脚本，而标签库则是为了替换JSP小脚本。使得整个jsp 页面变得更加简洁。 本章内容不涉及自定义标签库知识，有需求时学(保留2013版JavaWeb资源即可) 通常，JSTL是结合EL表达式使用的，EL表达式用于获取与显示数据，JSTL用于操作数据。 tips：&lt;%-- 凡是涉及后端解析的代码，如JSP、EL、JSTL注释都必须是用JSP注释，否则会被解析 --%&gt; 标签库类型 功能范围 URI 前缀 核心标签库 http://java.sun.com/jsp/jstl/core c 格式化 http://java.sun.com/jsp/jstl/fmt fmt 函数 http://java.sun.com/jsp/jstl/functions fn 数据库(不使用) http://java.sun.com/jsp/jstl/sql sql XML(不使用) http://java.sun.com/jsp/jstl/xml x JSTL的使用步骤JSTL是一系列标签库，主要用于操作数据。如遍历操作 先导入jstl 标签库的jar 包。 taglibs-standard-impl-1.2.1.jar taglibs-standard-spec-1.2.1.jar 使用 taglib 指令引入标签库，使用哪种类型的标签库则引入对应的URI &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; core核心库setset 标签可以往域中保存数据，**等同于setAttribute()**操作(较少使用) scope属性：设置保存到哪个域中 page 表示 PageContext 域（默认值） request 表示 Request 域 session 表示 Session 域 var属性：设置key值 value属性：设置属性值 123保存前：$&#123; sessionScope.abc &#125; &lt;br&gt;&lt;c:set scope=&quot;session&quot; var=&quot;abc&quot; value=&quot;abcValue&quot;/&gt;保存后：$&#123; sessionScope.abc &#125; &lt;br&gt; ifif标签实现if逻辑操作，单路判断，即只能if，不能if-else(if-else只能拆解成两个条件进行) test属性：表示判断的条件，使用EL表达式编写 1234567&lt;c:if test=&quot;$&#123; 12 == 12 &#125;&quot;&gt; &lt;h1&gt;12 等于 12&lt;/h1&gt;&lt;/c:if&gt;&lt;c:if test=&quot;$&#123; 12 != 12 &#125;&quot;&gt; &lt;h1&gt;12 不等于 12&lt;/h1&gt;&lt;/c:if&gt; choose-when-otherwise多路判断，类似于switch … case …. default ，区别是，当前标签一旦匹配一个则退出执行，否则执行otherwise choose标签：开始选择判断，类switch when标签：每一种判断情况，类case test属性：表示当前判断情况的值，类case value : ? otherwise标签：剩余的情况，类 default 示例代码 123456789101112131415161718&lt;% request.setAttribute(&quot;height&quot;, 180); %&gt;&lt;c:choose&gt; &lt;c:when test=&quot;$&#123; requestScope.height &gt; 190 &#125;&quot;&gt; &lt;h2&gt;小巨人&lt;/h2&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123; requestScope.height &gt; 180 &#125;&quot;&gt; &lt;h2&gt;很高&lt;/h2&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123; requestScope.height &gt; 170 &#125;&quot;&gt; &lt;h2&gt;还可以&lt;/h2&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;h2&gt;其他&lt;/h2&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt; 使用注意点： 标签里不能使用 html 注释，要使用 jsp 注释 when标签的父标签一定要是choose标签 示例代码 1234567891011121314151617&lt;%-- 例如若想在otherwise里面再细分，则需要先写一个choose标签再写when标签 --&gt;&lt;c:otherwise&gt; &lt;c:choose&gt; &lt;c:when test=&quot;$&#123;requestScope.height &gt; 160&#125;&quot;&gt; &lt;h3&gt;大于 160&lt;/h3&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;requestScope.height &gt; 150&#125;&quot;&gt; &lt;h3&gt;大于 150&lt;/h3&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;requestScope.height &gt; 140&#125;&quot;&gt; &lt;h3&gt;大于 140&lt;/h3&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; 其他小于 140 &lt;/c:otherwise&gt; &lt;/c:choose&gt;&lt;/c:otherwise&gt; forEach遍历输出普通遍历输出，等价于for(int i;i &lt;= 10;i++) begin属性：设置开始的索引 end属性：设置结束的索引，&lt;= var属性：表示循环的变量(也是当前正在遍历到的数据) 示例代码1：遍历 1 到 10，输出，类同普通for循环for(int i;i &lt;= 10;i++) 123&lt;c:forEach begin=&quot;1&quot; end=&quot;10&quot; var=&quot;i&quot;&gt; $&#123;i&#125;&lt;/c:forEach&gt; 遍历数组遍历Object类型数组，类同增强for循环for(Object obj: args) items属性：表示遍历的数据源，类同上述的 args var属性：同上，表示当前遍历到的数据 12345678&lt;% request.setAttribute(&quot;arr&quot;, new String[]&#123;&quot;18610541354&quot;,&quot;18688886666&quot;,&quot;18699998888&quot;&#125;);%&gt;&lt;c:forEach items=&quot;$&#123; requestScope.arr &#125;&quot; var=&quot;item&quot;&gt; $&#123; item &#125; &lt;br&gt;&lt;/c:forEach&gt; 遍历Map遍历Map，类同for ( Map.Entry&lt;String,Object&gt; entry : map.entrySet()) 12345678910&lt;% Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;key1&quot;, &quot;value1&quot;); map.put(&quot;key2&quot;, &quot;value2&quot;); map.put(&quot;key3&quot;, &quot;value3&quot;); request.setAttribute(&quot;map&quot;, map);%&gt;&lt;c:forEach items=&quot;$&#123; requestScope.map &#125;&quot; var=&quot;entry&quot;&gt; &lt;h1&gt;$&#123;entry.key&#125; = $&#123;entry.value&#125;&lt;/h1&gt;&lt;/c:forEach&gt; 遍历List注意：以下借助遍历List说明forEach标签各种属性结合实现的效果，并非只有遍历List才可使用。 测试Java类 12345678910public class Student &#123; //编号，用户名，密码，年龄，电话信息 private Integer id; private String username; private String password; private Integer age; private String phone; //省略构造器以及getter与setter方法...&#125; 示例代码1：普通遍历(全部遍历) 12345678910111213141516&lt;% //数据准备 List&lt;Student&gt; studentList = new ArrayList&lt;Student&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; studentList.add(new Student(i,&quot;username&quot;+i ,&quot;pass&quot;+i,18+i,&quot;phone&quot;+i)); &#125; request.setAttribute(&quot;stus&quot;, studentList);%&gt;&lt;c:forEach items=&quot;$&#123;requestScope.stus&#125;&quot; var=&quot;stu&quot;&gt; $&#123;stu.id&#125;&lt;br/&gt; $&#123;stu.username&#125;&lt;br/&gt; $&#123;stu.password&#125;&lt;br/&gt; $&#123;stu.age&#125;&lt;br/&gt; $&#123;stu.phone&#125;&lt;br/&gt;&lt;/c:forEach&gt; 示例2：指定区间、步长遍历 12345678&lt;c:forEach begin=&quot;2&quot; end=&quot;7&quot; step=&quot;2&quot; items=&quot;$&#123;requestScope.stus&#125;&quot; var=&quot;stu&quot;&gt; $&#123;stu.id&#125;&lt;br/&gt; $&#123;stu.username&#125;&lt;br/&gt; $&#123;stu.password&#125;&lt;br/&gt; $&#123;stu.age&#125;&lt;br/&gt; $&#123;stu.phone&#125;&lt;br/&gt; $&#123;status.step&#125;&lt;br/&gt;&lt;/c:forEach&gt; 示例3：varStatus对象 varStatus 属性表示当前遍历到的数据的状态，是一个实体对象。 123&lt;c:forEach varStatus=&quot;status&quot; items=&quot;$&#123;requestScope.stus&#125;&quot; var=&quot;stu&quot;&gt; $&#123;status&#125;&lt;/c:forEach&gt; 该对象所在类在源码中实现了LoopTagStatus接口，接口包含如下方法 12345678910public interface LoopTagStatus&#123; public Object getCurrent();//获取当前遍历到的数据 public int getlndex();//获取当前遍历的索引 public int getCount();//获取已遍历的个数 public boolean isFirst();//判断当前遍历的数据是否属于第一条 public boolean isLast();//判断当前遍历的数据是否属于最后一条 public Integer getBegin();//获取遍历的起始值 public Integer getEnd();//获取遍历的结束值 public Integer getStep();//获取当前设置的步长值&#125; Listener监听器什么是监听器？监听器就是实时监视一些事物状态的程序，我们称为监听器。 Listener 监听器它是 JavaWeb 的三大组件之一：Servlet 程序、Filter 过滤器、Listener监听器。 Listener它是 JavaEE 的规范，就是接口 监听器的作用是监听某种事物的变化。然后通过回调函数，反馈给客户(程序)去做一些相应的处理。 ServletContextListener随之技术的变革，绝大多数类型的监听器已经用不上了，剩下ServletContextListener有较高的使用频率。 功能 ServletContextListener它可以监听 ServletContext 对象的创建和销毁 ServletContext对象在 web 工程启动的时候创建，在 web 工程停止的时候销毁 监听到创建和销毁之后都会分别调用ServletContextListener监听器的方法反馈。 12345678910public interface ServletContextListener extends EventListener &#123; /** * 在 ServletContext 对象创建之后马上调用，做初始化 */ public void contextInitialized(ServletContextEvent sce); /** * 在 ServletContext 对象销毁之后调用 */ public void contextDestroyed(ServletContextEvent sce);&#125; 操作步骤 编写一个类去实现ServletContextListener接口 实现其两个回调方法 到 web.xml中去配置监听器 ServletContextListenerTest.java 由于接口中用的时default作为修饰符，且方法体已空实现（有大括号），所以不会提示有熟悉的红色下划线 快捷实现接口中的抽象方法 的操作，需自己在IDE中编写方法，提示重写。 12345678910public class ServletContextListenerTest implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; System.out.println(&quot;servletContext对象已被创建&quot;); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; System.out.println(&quot;servletContext对象已被销毁&quot;); &#125;&#125; web.xml 123&lt;listener&gt; &lt;listener-class&gt;com.website.test.ServletContextListenerTest&lt;/listener-class&gt;&lt;/listener&gt; 文件上传与下载文件上传基本步骤 form标签 method = post：由于get请求有长度限制因此使用post请求 encType = multiparty/form-data 表示提交的数据，以多段(每一个表单项一个数据段)的形式进行拼接，然后以二进制流的形式发送给服务器。 注意：以二进制流形式发送时，不能再用getParameter()取获取数据，结果只能为null，应该使用getInputStream()获取 在form标签中使用input type = file 添加上传文件 编写服务器代码，处理上传数据。 HTTP协议部分 前端代码 123456&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/uploadServlet&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt; 头像：&lt;input type=&quot;file&quot; name=&quot;photo&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 前端页面 后端代码：打印上传的流内容 1234567891011public class UploadServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;文件上传&quot;); ServletInputStream inputStream = req.getInputStream(); byte[] buffer = new byte[1024 * 1024]; int len = inputStream.read(buffer); System.out.println(new String(buffer,0,len)); &#125;&#125; 后端打印结果： 12345678910111213141516文件上传------WebKitFormBoundaryVldrwB6NIgx1Eq3SContent-Disposition: form-data; name&#x3D;&quot;username&quot;wzg168------WebKitFormBoundaryVldrwB6NIgx1Eq3SContent-Disposition: form-data; name&#x3D;&quot;photo&quot;; filename&#x3D;&quot;d.jpg&quot;Content-Type: image&#x2F;jpeg??? \u0010JFIF \u0001\u0001\u0001 x x ?? C\u0006\u0006\u0007\u0006\u0007\u0007\u0007 \u00182!\u001c!22222222222222222222222222222222222222222222222222?? \u0002@\u0004Q\u0003\u0001&quot; \u0002\u0011\u0001\u0003\u0011\u0001?? \u001f \u0001\u0005\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0002\u0003\u0004\u0005\u0006 ?? ?\u0010 \u0002\u0001\u0003\u0003\u0002\u0004\u0003\u0005\u0005\u0004\u0004 \u0001&#125;\u0001\u0002\u0003 \u0004\u0011\u0005\u0012!1A\u0006\u0013Qa\u0007&quot;q\u00142亼#B绷\u0015R佯$3br? \u0016\u0017\u0018\u0019\u001a%&amp;&#39;()*456789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz儎厗噲墛挀敃枟槞殺￥ウЖ┆渤吹斗腹郝媚牌侨墒矣哉肿刭卺忏溴骁栝犟蝮趱鲼?? \u001f\u0001 \u0003\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0002\u0003\u0004\u0005\u0006 ?? ?\u0011 \u0002\u0001\u0002\u0004\u0004\u0003\u0004\u0007\u0005\u0004\u0004 \u0001\u0002w \u0001\u0002\u0003\u0011\u0004\u0005!1\u0006\u0012AQ\u0007aq\u0013&quot;2\u0014B憽绷 #3R?\u0015br?攽&lt;hz噔痆?\u001dА矸宒f疇\u000f挐籘柭XU草?&gt;X龅j0猹M\u001e\u0006z裶&quot;\u0014m?8п筧P\u0017诶U廿A\u001f#\u001cR邦7f險湑弌z播堒?\u0005螶庒\u0015?#僙#6SWa匝?\u000e袈pH5\u0018晤焪z?\u001b幖?\u0004\u0010犛?:圆媕I\u0019猡_璘嶠^*&#96;Mf?\u0011d\u000fz慩儌sU崭隣躴溤 焢&gt;敼\u0019郥E?&#39;?\u0017\u001aB硘?\u001c?...... 上传文件，HTTP协议分析 上传实现当清楚了上传文件的HTTP请求头信息格式后，其实剩下的就是对服务器接收到的流数据进行解析即刻，如通过请求头的boundary获取到每段数据的分隔符，然后再分解不同表单的数据，对应处理即可…，在java开发一般这种数据解析操作常使用apache提供的commons-fileupload.jar实现。 jar包依赖 commons-fileupload-1.2.1.jar commons-io-1.4.jar 常用类说明 ServletFileUpload：用于解析上传的数据 boolean ServletFileUpload.isMultipartContent(HttpServletRequest request); 判断当前上传的数据格式是否是多段的格式，true则是多段格式，false则不是 public List&lt;FileItem&gt; parseRequest(HttpServletRequest request) ：解析上传的数据 。 FileItem：封装每一个表单项的数据。 boolean FileItem.isFormField()：判断当前表单项属于普通还是上传表单项 true：表示普通类型的表单项 false：表示上传的文件类型 String FileItem.getFieldName()： 获取表单项的name属性值 String FileItem.getString()： 获取当前表单项的值。 String FileItem.getName()：获取上传的文件名 void FileItem.write(file) ：将上传的文件写到参数file所指向抽硬盘位置 示例代码 index.jsp 123456&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/uploadServlet&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt; 头像：&lt;input type=&quot;file&quot; name=&quot;photo&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; UploadServlet.java 12345678910111213141516171819202122232425262728293031323334353637public class UploadServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1、通过静态方法判断上传的数据是否为多段数据(只有是多段数据，才是文件上传) if(ServletFileUpload.isMultipartContent(req))&#123; //3、创建FileItemFactory接口实现类对象，传入ServletFileUpload构造器中 FileItemFactory fileItemFactory = new DiskFileItemFactory(); //2、创建ServletFileUpload对象进行数据解析工作，注意空参构造器不是给我们初始化的 ServletFileUpload servletFileUpload = new ServletFileUpload(fileItemFactory); try &#123; //3、解析所有数据 List&lt;FileItem&gt; list = servletFileUpload.parseRequest(req); //4、遍历每个表单项数据 for(FileItem item : list)&#123; if(item.isFormField())&#123;//5、普通表单项目获取name-value String name = item.getFieldName();// String value = item.getString();//中文乱码可传入&quot;UTF-8&quot;形参 System.out.println(&quot;普通表单项 name = &quot; + name); System.out.println(&quot;普通表单项 value = &quot; + value); &#125;else&#123;//6、上传表单项获取name-fileName-流操作 String name = item.getFieldName(); String fieldName = item.getName(); System.out.println(&quot;上传表单项 name = &quot; + name); System.out.println(&quot;上传表单项 fieldName = &quot; + fieldName); //流操作，将上传文件写入本地磁盘 item.write(new File(&quot;d:\\\\TestFolder\\\\uploadTest\\\\&quot; + fieldName)); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 文件下载基本步骤 从客户的请求中读取要下载的文件名 设置响应类型 String servletContext.getMimeType(String filePath); String filePath：表示文件的实际存储路径，”/“ 表明当前web应用的web根目录 response.setContentType(String mimeType); 可选：设置响应头，表明数据是用于下载的(如图片，实现非直接打开，而是弹出浏览器下载) response.setHeader(“Content-Disposition”,”attachement;filename=文件名”); Content-Disposition响应头：指明收到的数据如何处理 attachement：意为附件，表示下载使用 filename=文件名：设置响应给客户时下载的文件名(可自定义) 读取下载文件的内容：获取文件的InputStream对象，获取途径可能存在多种 文件存储在web应用本身可用：servletContext.getResourceAsStream(String path); 把下载文件回传给客户端 首先获取用于响应的输出流：OutputStream response.getOutputStream(); 把文件的输入流逐一读取并传入响应的输出流 下载实现下载操作代码实现基本不用使用其他第三方jar包，IO操作中可以使用apache的commons-io-1.4.jar(也是commons-fileupload-1.2.1.jar的依赖)来简化IO代码书写。其余大部分使用源生代码实现。 项目结构：在web根目录下创建file文件夹，里面存放abc.jpg图片 downloadPage.jsp 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/downloadServlet&quot;&gt;下载文件&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; DownloadServlet.java 123456789101112131415161718192021222324252627282930313233343536373839404142package com.website.download;import org.apache.commons.io.IOUtils;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;/** * @author yhd * @create 2021-04-14 16:29 */public class DownloadServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1、从客户端请求中读取拟下载文件的文件名，(演示写死文件名) String fileName = &quot;abc.jpg&quot;; //2、设置响应类型 ServletContext servletContext = getServletContext(); String mimeType = servletContext.getMimeType(&quot;/file/&quot; + fileName); resp.setContentType(mimeType); System.out.println(&quot;mimeType = &quot; + mimeType); //3、设置响应头：指明响应数据的处理方式，调用浏览器附件下载(fileName可自定义) resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot; + fileName); //4、获取拟回传文件的输入流 InputStream resourceAsStream = servletContext.getResourceAsStream(&quot;/file/&quot; + fileName); System.out.println(&quot;resourceAsStream = &quot; + resourceAsStream); //5、获取响应输出流 ServletOutputStream outputStream = resp.getOutputStream(); //6、把数据读出并想响应输出流输出(为方便IO操作代码，使用apache，commons-io的IOUtils) IOUtils.copy(resourceAsStream,outputStream); &#125;&#125; setHeader中文乱码当通过setHeader()设置回传给浏览器附件下载时的下载明含中文时出现乱码，如下： 1resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename&#x3D;&quot; + &quot;中国.jpg&quot;); 解决方案1：URLEncoder编码，仅适用(IE，Chrome浏览器) 解决方案2：Base64编码，适用(火狐浏览器) URL编码方案URLEncoder编码，仅适用(IE，Chrome浏览器) 编码格式：把字符串转换称为%xx%xx%xx...内容，xx是十六进制 123String str = &quot;attachment;fileName=&quot; + URLEncoder.encode(&quot;中文.jpg&quot;, &quot;UTF-8&quot;);//str = %E4%B8%AD%E5%9B%BD.jpgresponse.setHeader(&quot;Content-Disposition&quot;, str); Base64编码方案Base64编码，适用(Chrome、火狐浏览器)，不适用IE base64编码与解码操作： 12345678910111213141516171819//base64解码与编码操作public class Base64Test &#123; public static void main(String[] args) throws Exception &#123; String str = &quot;这是base64编码&quot;; System.out.println(&quot;原始 str = &quot; + str); //base64编码操作 BASE64Encoder encoder = new BASE64Encoder(); str = encoder.encode(str.getBytes(&quot;UTF-8&quot;)); System.out.println(&quot;base64编码 str = &quot; + str); //base64解码操作 BASE64Decoder decoder = new BASE64Decoder(); byte[] bytes = decoder.decodeBuffer(str); //解码成字节数组后，重新以UTF-8的方式编码成字符串 str = new String(bytes,&quot;UTF-8&quot;); System.out.println(&quot;base64解码 str = &quot; + str); &#125;&#125; setHeader中的应用：火狐浏览器中文乱码问题 修改请求头部分信息 原始请求头：Content-Disposition: attachment; filename=中文名 修改请求头：Content-Disposition: attachment; filename==?charset?B?xxxxx?= =?charset?B?xxxxx?=说明 =?**：表示编码内容的开始** charset：填充字符集类型，如UTF-8 B：表示使用BASE64编码 xxxx：BASE64编码的内容，这里即表示文件名 ?=**：表示编码内容的结束** 123String downloadFileName = new BASE64Encoder().encode(&quot;中国.jpg&quot;.getBytes(&quot;UTF-8&quot;));download = &quot;=?UTF-8?B?&quot; + downloadFileName + &quot;?=&quot;;resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot; + downloadFileName); 综合解决方案 通过判断User-Agent分两种情况处理，兼容chrome、火狐、ie浏览器 若为火狐浏览器、则使用base64编码 其他浏览器则使用URL编码 12345678String downloadFileName; //若是火狐浏览器则使用base64编码，否则使用URL编码(UTF-8)if(req.getHeader(&quot;User-Agent&quot;).contains(&quot;Firefox&quot;))&#123; downloadFileName = &quot;=?UTF-8?B?&quot; + new BASE64Encoder().encode(&quot;中国.jpg&quot;.getBytes(&quot;UTF-8&quot;)) + &quot;?=&quot;;&#125;else&#123; downloadFileName = URLEncoder.encode(&quot;中国.jpg&quot;,&quot;UTF-8&quot;);&#125;resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot; + downloadFileName); 会话机制基本概念需求驱动在很多应用中，要求Web服务器能够跟踪客户的状态，如不同用户在同一购物网站上发出不同用户的购买订单请求。此时就要求服务器知道哪个请求是属于哪个用户的，这就是跟踪客户状态的一个应用。 无状态特性协议能记住客户身份及其发出的请求的能力称为状态(state)，以这个观点可将协议分为两种类型：有状态和无状态协议。 HTTP协议是一种无状态的协议，对于浏览器发出的每一个请求，服务器是不能识别由哪个客户发送过来的。 这种无状态特性对于一些无需记录用户身份的应用是很好的，如一个在线查询系统就不用记录用户身份和状态。但对于购物车这种场景，则不能满足。 会话概念会话(session)是客户与服务器进行通讯的过程，可以理解为就是”通话“。在这个”通话“持续的过程中，服务器能明确用户的身份，及其发出的所有请求。会话的跟踪就是指身份与请求源的跟踪。 会话跟踪方案Web服务器跟踪客户的状态有多种方法，以下是常用的跟踪方案，第二种方法是目前最常用的方法，其他几种是传统的实现会话跟踪的方法，每种方法都有各自的优缺点。 使用数据库记录 使用Servlet API 的Session(会话)机制 使用持久的Cookie对象 使用URL的重写机制 使用隐藏的表单域 … Cookie基本概念Cookie是客户访问Web服务器时，服务器在客户端硬盘上存放的一小段键值对文本信息，属于一种持久化技术，好像服务器送给客户的“点心/饼干”一样。客户以后访问同一个Web服务器时浏览器会把他们原样发还服务器。常用于标识用户的身份。 客户端一旦有了对应URL的Cookie后，每次请求都会发回给服务器 每个Cookie的大小不能超过4KB(一小段) Cookie的Value值不支持中文和很多特殊字符(空格、方括号、等号、叹号….)，若内容包含这些信息需使用BASE64编码 Cookie是HTTP协议的一部分，通过请求头Set-Cookie，Cookie:key:value;等传递cookie数据 创建Cookie com.website.servlet.CookieServlet.java 12345678//创建并发送一个Cookieprotected void createCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1、创建Cookie对象 Cookie cookie = new Cookie(&quot;key1&quot;,&quot;value1&quot;); //2、通知客户端保持Cookie resp.addCookie(cookie);&#125; Cookie创建机制：由服务器通过Set-Cookie请求头通知客户端，客户端收到后转存在硬盘中或修改已有的Cookie内容。 获取Cookie服务器获取Cookie只有一行代码，也仅有一个方法。getCookies() com.website.servlet.CookieServlet.java 1234567891011//服务器获取Cookieprotected void getCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取cookie只有一个方法，获取当前请求所有cookie Cookie[] cookies = req.getCookies(); for (Cookie cookie : cookies) &#123;//打印所有Cookie的键值对数据 String str = &quot;Cookie:[key=&quot; + cookie.getName() + &quot; : value=&quot; + cookie.getValue() + &quot;]&lt;br/&gt;&quot;; resp.getWriter().write(str); &#125;&#125; com.website.util.CookieUtils.java 由于查找指定Cookie操作非常常用，因此可封装成一个工具方法。 1234567891011121314151617/** * 查找并返回指定键的Cookie对象引用 * @param name 查找的Cookie键信息 * @param cookies 被查询集 * @return 若不存在返回null */public static Cookie findCookie(String name,Cookie[] cookies)&#123; if(name == null || cookies == null || cookies.length == 0)&#123; return null; &#125; for (Cookie cookie : cookies) &#123; if(name.equals(cookie.getName()))&#123; return cookie; &#125; &#125; return null;&#125; 客户端发送Cookie机制：通过请求头Cookie:key1:value1;key2...包含所有发回的Cookie键值对 修改Cookie方案1：重构 创建一个与修改Cookie同名(Key)的Cookie对象 在构造器创建时，赋予新的Cookie值 调用response.addCookie(cookie)方法发回 com.website.servlet.CookieServlet.java 1234567//更新指定Cookie值protected void updateCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //方案1：重构修改。如修改Cookie名为key1的值 Cookie cookie = new Cookie(&quot;key1&quot;,&quot;newValue1&quot;); resp.addCookie(cookie);&#125; 方案2：setValue() 查找到需修改的Cookie对象 调用setValue()方法赋予新的Cookie值 调用response.addCookie(cookie)方法发回 com.website.servlet.CookieServlet.java 12345678910//更新指定Cookie值protected void updateCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //方案2：setValue()修改 Cookie cookie = CookieUtils.findCookie(&quot;key2&quot;, req.getCookies()); if(cookie != null)&#123; cookie.setValue(&quot;newValue2&quot;); resp.addCookie(cookie); &#125; &#125; 生命控制Cookie的生命控制一般指控制Cookie什么时候被销毁，可以通过setMaxAge(second)函数设置。 MaxAge值含义：单位秒 正数：表示在指定的秒数后过期 负数(默认-1)：表示浏览器关闭后，Cookie就会被删除，属于标准的Session作用级别 0：表示立即删除Cookie com.website.servlet.CookieServlet.java 12345cookie.setMaxAge(60 * 60); // 设置 Cookie 一小时之后被删除。无效cookie.setMaxAge(-1);//创建Cookie默认-1，浏览器关闭后删除cookie.setMaxAge(0); //马上删除，不需要等待浏览器关闭resp.addCookie(cookie);//发回给客户端 setMaxAge原理 通过HTTP请求头Set-Cookie追加了一个Expires=time键值对信息标识过期时间实现的 Expires指示的过期时间是GMT时间，即格林时间，非本土时间。 立即删除Cookie是将过期时间设置为一个已经过去了的时间，默认是时间戳的开始计数时间(1970.1.1) 有效路径Cookie的有效路径Path(目录信息)指只有在该路径下，浏览器才会对于将属于Path路径下的Cookie才发送给客户端。因此path属性可以用于有效过滤Cookie。(被过滤掉的Cookie，Chrome浏览器为了安全性默认屏蔽调，就是存在也不显示) 过滤原理实例 123456789101112&#x2F;&#x2F;注意 path默认就是指示目录信息Cookie_A path&#x3D;&#x2F;工程路径Cookie_B path&#x3D;&#x2F;工程路径&#x2F;abc请求地址如下：http:&#x2F;&#x2F;ip:port&#x2F;工程路径&#x2F;a.htmlCookie_A 发送Cookie_B 不发送http:&#x2F;&#x2F;ip:port&#x2F;工程路径&#x2F;abc&#x2F;a.htmlCookie_A 发送Cookie_B 发 com.website.servlet.CookieServlet.java 1234cookie.setPath(req.getContextPath()); //默认值cookie.setPath(req.getContextPath() + &quot;/abc&quot; ); //基于工程路径下追加/abc路径resp.addCookie(cookie);//发回给客户端 setPath原理 通过HTTP请求头Set-Cookie追加了一个Path=/xxx/xxx键值对设置有效路径 Cookei默认Path参数为当前web工程名路径，即/工程名路径，对应request.getContextPath()的值 查看CookieChrome Firefox Cookie应用免登录 login.jsp 12345678910111213&lt;html&gt;&lt;head&gt;&lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;login&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码:&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; name=&quot;check&quot; value=&quot;check&quot;/&gt;自动登录 &lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt; &lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; CheckUserServlet.java 该实现利用了GET和POST本身的特性去划分了业务处理。GET应对了直接访问URL的情况，POST处理了常规登录。 引用《JavaWeb编程技术》第3版(微课版)第四章用Cookie实现自动登录代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@WebServlet(&quot;/CheckUserServlet&quot;)public class CheckUserServlet extends HttpServlet &#123; String message = null; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); String value1 = &quot;&quot;, value2 = &quot;&quot;; Cookie cookie = null; Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; for (int i = 0; i &lt; cookies.length; i++) &#123; cookie = cookies[i]; if (cookie.getName().equals(&quot;username&quot;)) value1 = cookie.getValue(); if (cookie.getName().equals(&quot;password&quot;)) value2 = cookie.getValue(); &#125; if (value1.equals(&quot;admin&quot;) &amp;&amp; value2.equals(&quot;admin&quot;)) &#123; message = &quot;欢迎您！&quot; + value1 + &quot;再次登录该页面！&quot;; request.getSession().setAttribute(&quot;message&quot;, message); response.sendRedirect(&quot;welcome.jsp&quot;); &#125; else &#123; response.sendRedirect(&quot;login.jsp&quot;); &#125; &#125; else &#123; response.sendRedirect(&quot;login.jsp&quot;); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); String username = request.getParameter(&quot;username&quot;).trim(); String password = request.getParameter(&quot;password&quot;).trim(); if (!username.equals(&quot;admin&quot;) || !password.equals(&quot;admin&quot;)) &#123; message = &quot;用户名或口令不正确，请重试！&quot;; request.getSession().setAttribute(&quot;message&quot;, message); response.sendRedirect(&quot;login.jsp&quot;); &#125; else &#123; // 如果用户选中了“自动登录”复选框，向浏览器发送2个Cookie if ((request.getParameter(&quot;check&quot;) != null) &amp;&amp; (request.getParameter(&quot;check&quot;).equals(&quot;check&quot;))) &#123; Cookie nameCookie = new Cookie(&quot;username&quot;, username); Cookie pswdCookie = new Cookie(&quot;password&quot;, password); nameCookie.setMaxAge(60 * 60); pswdCookie.setMaxAge(60 * 60); response.addCookie(nameCookie); response.addCookie(pswdCookie); &#125; message = &quot;你已成功登录！&quot;; request.getSession().setAttribute(&quot;message&quot;, message); response.sendRedirect(&quot;welcome.jsp&quot;); &#125; &#125;&#125; Session基本概念上述可知，实现会话跟踪有多种方案。除Cookie外，还可以通过Servlet API 提供的Session接口标准来实现会话跟踪。有别于Cookie，Servlet API - Session的客户信息主要存放在服务器。因此Session能存放的信息更丰富，更抽象，如Servlet API 有专门的Session数据域，可以存放Object类型数据，而Cookie只能存放有限的键值对文本信息。小结如下： Servlet API Session 是一个接口，一种实现会话跟踪的技术规范之一 Session的客户信息主要存放在服务器中，常用于保存登陆后的信息 Servlet API Session是基于Cookie与Web容器结合实现的一种新机制 无特殊说明，以下Session均特指Servlet API 下的Session接口标准，非广义概念上的会话，因此从这个角度来说，Session是java特有的(JSESSIONID)。 Session机制 当首次收到到客户端的请求时，服务器可通过调用request.getSession(); 来创建Session对象，并将请求对象与其会话对象关联起来。最后响应时通过Cookie搭载这个会话的唯一标识id号一并发回给客户端。 Cookie搭载id：发回给客户端的会话标识符id，是通过Cookie返回的：键统一命名为：JSESSIONID，值则为：唯一的32位标识符。由于Servlet API 是通过规定了该Cookie的Expires/Max-Age为Session(-1)，因此当浏览器关闭时搭载JSESSIONID的Cookie将会在浏览器中被销毁。因此整个基于Servlet API - Session机制的生命周期对外表现出：”始于第一次请求，止于关闭浏览器“。Session会话就会终结(在客户端角度)，因为客户端已经无法通过JSESSIONID发回给服务器获取到于之对于的会话对象了。 当下一次客户端发送请求时，将通过Cookie携带这个会话id号一并发送请求给服务器。服务器收到请求后并获取会话id，并从服务器中匹配这个id，若匹配成功则返回这个请求与之关联的会话对象。此时可通request.getSession();获取到已经关联的会话对象。 Session销毁时机及机制： 客户端角度：取决于搭载id的Cookie生命周期，默认-1，关闭浏览器后销毁(JSESSIONID) 由于客户端中搭载id的是Cookie，若修改JSESSIONID的存活时机则可实现Session的持久化 服务器角度：由于服务器无法得知客户端何时销毁，因此只能超时判断或后端代码控制。 session超时控制：客户端两次请求的最大间隔时长，默认30分钟 后端立即销毁： Web应用被卸载：清除所有资源。 由于保存用户信息及相关数据的会话对象是存放在服务器，从这个因素可凸显如下几个特征： Session Cookie 数据存储位置 服务器 客户端 数据类型 Object 4KB文本键值对 数据安全性 高，主要信息在服务器，标识在客户端 低，全部信息在客户端 生命周期 客户端：默认-1，取决搭载Id的Cookie 自定义 服务器：默认无请求操作后30分钟、或代码控制立即失效 常用领域 在线用户跟踪(经一定操作后) 离线用户跟踪 如，用户登录后临时存放的信息(购物车) 离线自动登录 Session机制实现示意图 创建与获取当收到客户端的请求时，服务器可通过调用request.getSession(); 来创建或获取Session对象。 首次调用：服务器创建会话对象，并将请求对象与其会话对象关联起来。并发回会话的唯一标识id号给客户端。id内容可通过session.getId();获取 再次调用：获取请求对象与之关联的Session会话对象。 isNew：通过调用isNew();方法可以判断这个会话是不是刚创建的（新的） true：表示刚创建 false：表示获取之前创建 com.website.servlet.SessionServlet.java 123456789protected void createOrGetSession(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //创建返回或获取Session会话对象 HttpSession session = req.getSession(); //判断当前Session会话是否为新创建 boolean isNew = session.isNew(); //获取Session会话的唯一标识 String id = session.getId();&#125; Session数据域12session.setAttribute(&quot;key&quot;,&quot;Object&quot;);Object object = session.getAttribute(&quot;key&quot;); 销毁控制由于客户端取决于JSESSIONID的Cookie的MaxAge，因此这里所说的生命周期控制指服务器对Session的生命周期控制。服务器控制Session生命周期如下两种方法 超时销毁 setMaxInactiveInterval：通过该方法可以设置 Session 的超时时间（以秒为单位），超过指定的时长，Session 就会被服务器自动销毁。 正数：超时时长，单位秒 负数：永不超时(极少使用) 1session.setMaxInactiveInterval(3600);//最后一次请求1小时内无下次请求销毁 getMaxInactiveInterval：通过该方法可获取Session的超时机，默认30分钟 1int maxInactiveInterval = session.getMaxInactiveInterval();//默认1800秒，即30分钟 修改当前Web-Session默认超时时间： 由于setMaxInactiveInterval只能对一个session对象设置超时时间，若想web项目中所有session的超时时间都改变，则需要改变web项目中的web.xml配置文件。web.xml修改后需重启才生效。 WEB-INF/web.xml 1234&lt;!-- 修改当前web工程session超时时间，web.xml修改需重新部署web生效 --&gt;&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config 修改Tomcat-Session默认超时时间 若想修改当前Tomcat默认的Session超时时间，即在此Tomcat上运行的所有Web项目Session默认超时时间都将会被改变，则需改变Tomcat中的web.xml配置文件。 conf/web.xml 1234&lt;!-- 修改当前Tomcat搭载的所有web工程session超时时间 --&gt;&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config IDEA开发过程中整合Tomcat后的web.xml映射地址在项目部署打印 Using CATALINA_BASE路径的conf目录下。 立即销毁 invalidata：可调用该方法立即销毁一个session对象 1session.invalidate();//立即销毁 小结Cookie基于HTTP协议实现(包含Cookie)，Servlet API Session 基于Cookie与API实现 过滤器基本概念过滤器(Filter)是Web服务器三大组件之一(Servlet、Listener)，因此Filter是JavaEE的规范，即接口。过滤器的主要作用是拦截客户对某个资源的请求和响应。允许建立多个过滤器，形成过滤链。 常见应用场景： 权限检查过滤器 登录检查过滤器 数据压缩过滤器 日记操作过滤器 事务管理过滤器 … 过滤器作用示意图： Filter接口实现由于Filter和Servlet都是javaEE的组件，规范接口。因此学习起来应存在有共性。 编写一个类去实现Filter接口 在doFilter()方法中编写过滤的处理或判断逻辑。 return语句或从未调用过doFilter执行完代码则拦截/结束 FilterChain对象的doFilter()方法放行 在web.xml中配置声明拦截器并为其指定拦截范围(路径)，类似Servlet 123456789101112&lt;filter&gt; &lt;filter-name&gt;AdminFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.website.servlet.AdminFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;AdminFilter&lt;/filter-name&gt; &lt;!-- &#x27;/&#x27; 与Servlet配置一样，表示请求地址为：http://ip:port/工程路径/ 即映射到IDEA的web目录 --&gt; &lt;!-- 拦截资源的作用范围(拦截路径) --&gt; &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 现如今有一应用场景，只有用户登录之后才能访问指定资源(admin目录下的web资源)。此时可以通过使用Filter过滤器实现请求资源的拦截判断处理。 注意：测试过程中若访问过静态资源后，非登录状态下仍能访问资源很可能是静态资源缓存问题，清除一下浏览器缓存再次尝试即可。 文件目录情况： login.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/14_Filter/userServlet&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;admin&quot;&gt;&lt;/br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/br&gt; &lt;/form&gt; &lt;/br&gt; 访问登录后的资源: &lt;/br&gt; &lt;a href=&quot;admin/shoppingCart.html&quot;&gt;shoppingCart&lt;/a&gt; &lt;/br&gt; &lt;a href=&quot;admin/testImg.jpg&quot;&gt;testImg&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; UserServlet.java 123456789101112131415161718192021222324252627282930package com.website.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author yhd * @create 2021-05-31 21:19 */public class UserServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding(&quot;UTF-8&quot;); resp.setContentType(&quot;text/html;charset=UTF-8&quot;); String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); System.out.println(&quot;username = &quot; + username); if(&quot;admin&quot;.equals(username) &amp;&amp; &quot;password&quot;.equals(password))&#123; req.getSession().setAttribute(&quot;user&quot;,username); resp.sendRedirect(req.getContextPath() + &quot;/login.html&quot;); &#125;else&#123; resp.getWriter().write(&quot;登录失败&lt;/br&gt;&quot;); &#125; &#125;&#125; AdminFilter.java 1234567891011121314151617181920212223242526272829303132333435363738package com.website.servlet;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;/** * @author yhd * @create 2021-05-31 21:29 */public class AdminFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; HttpSession session = request.getSession(); String user = (String) session.getAttribute(&quot;user&quot;); if(user == null)&#123;//未登录，拦截，并跳转到登录页面提示登录 response.sendRedirect(request.getContextPath() + &quot;/login.html&quot;); &#125;else&#123;//登录成功，放行 filterChain.doFilter(servletRequest,servletResponse); &#125; &#125; @Override public void destroy() &#123; &#125;&#125; web.xml 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;filter&gt; &lt;filter-name&gt;AdminFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.website.servlet.AdminFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;AdminFilter&lt;/filter-name&gt; &lt;!-- &#x27;/&#x27; 与Servlet配置一样，表示请求地址为：http://ip:port/工程路径/ 即映射到IDEA的web目录 --&gt; &lt;!-- 拦截资源的作用范围(拦截路径) --&gt; &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;UserServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.website.servlet.UserServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;UserServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/userServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Filter生命周期生命周期Filter 的生命周期包含几个方法： 构造器方法 **init 初始化方法 **(FilterConfig filterConfig) 在 web 工程启动的时候执行1，2 步骤（Filter 已经创建） **doFilter过滤方法 **(FilterChain filterChain) 每次拦截到请求，就会执行 destroy销毁方法 停止web工程的时候，就会执行 FilterConfig在Filter生命周期的init方法中，含有一个传入对象FilterConfig对象。封装了当前Filter配置文件(web.xml)的配置信息。类似ServletConfig 获取Filter在配置中的名称filter-name的内容： 获取Filter在配置的init-param初始化参数 获取ServletContext 对象 123456filterConfig.getFilterName();filterConfig.getInitParameter(&quot;key&quot;);filterConfig.getInitParameterNames();filterConfig.getServletContext(); FilterChainFilterChain译为过滤链，即多个过滤器组合起来的过滤序列，简称过滤链。 doFilterFilterChain对象只有一个方法，就是doFilter()，基本功能描述如下： 当只有一个过滤器，则直接放行，执行目标请求资源，否则执行下一个Filter过滤器 doFilter()：之上的代码为当前请求拦截处理代码，doFilter()之下为响应拦截处理代码。 原理在于doFilter()实际上是内嵌调用目标请求资源或下一个过滤器，以下解释 过滤链的使用执行特点 doFilter的调用逻辑，实际上是包裹主目标请求资源，过滤链即多个过滤器的内嵌式调用 一个请求中，所有的Filter和目标资源，默认都执行在同一个线程中 多个Filter公同执行时，都使用同一个ServletRequest对象(从doFilter方法中可知，类转发操作) 调用逻辑一开始提及过，Filter不仅能够拦截过滤对某个资源的请求操作，还能拦截过滤响应操作。其中doFilter()：之上的代码为当前请求拦截处理代码，doFilter()之下为响应拦截处理代码。 原理：chain.doFilter()方法是将Servlet包裹起来进行内嵌调用的。(从Filter事务管理也能体会到) 当多个过滤器组合工作时，形成的过滤链工作流程如下： javaEE三大组件调用逻辑如下： 过滤链的配置过滤链的配置实际上就是多个的Filter配置，真正需要注意配置的是过滤链中过滤器的执行顺序配置： 多个Filter组成的过滤链中Filter的执行顺序取决于：web.xml中配置的上下位置顺序 Filter实际使用概念类似Servlet组件，为了开发的便利与高效也会进行一系列的优化与封装，Filter也有如： Servlet ——&gt; GenericServlet ——&gt; HttpServlet Filter ——&gt;GenericFilter ——&gt; HttpFilter 接口 说明 GenericFilter 该抽象类，实现了FilterConfig接口的方法和Filter接口的Init方法 HttpFilter 该抽象类，继承了GenericFilter类，实现了针对HTTP协议的过滤器 结论：因此在实际Web开发中，直接通过继承HttpFilter来使用Filter过滤器。 注意：index首页通过请求转发到的页面不能是被过滤器拦截的页面，否则会进行转发拦截死循环 若首页转发的页面受拦截器作用，则只能用重定向 使用步骤 编写一个类去继承HttpFilter抽象类 实现doFilter()方法，并在其中编写过滤的处理或判断逻辑。 return语句或从未调用过doFilter执行完代码则表示拦截/结束 FilterChain对象的doFilter()方法放行 在web.xml中配置声明拦截器并为其指定拦截范围(路径)，类似Servlet 123456789101112&lt;filter&gt; &lt;filter-name&gt;AdminFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.website.servlet.AdminFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;AdminFilter&lt;/filter-name&gt; &lt;!-- &#x27;/&#x27; 与Servlet配置一样，表示请求地址为：http://ip:port/工程路径/ 即映射到IDEA的web目录 --&gt; &lt;!-- 拦截资源的作用范围(拦截路径) --&gt; &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 拦截路径/访问的几种配置，匹配的操作：注意，Filter 过滤器它只关心请求的地址是否匹配，不关心请求的资源是否存在！！ 精确匹配： 单精确匹配： 请求地址必须为：http://ip:port/工程路径/target.jsp 1&lt;url-pattern&gt;/target.jsp&lt;/url-pattern&gt; 多精确匹配： 请求地址必须为：http://ip:port/工程路径/index.html或http://ip:port/工程路径/test.jsp 12345&lt;filter-mapping&gt; &lt;filter-name&gt;AdminFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/pages/index.html&lt;/url-pattern&gt; &lt;url-pattern&gt;/pages/test.jsp&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 目录匹配： 请求地址必须为：http://ip:port/工程路径/admin/* 1&lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt; 后缀名匹配： 123456&lt;url-pattern&gt;*.html&lt;/url-pattern&gt;以上配置的路径，表示请求地址必须以.html 结尾才会拦截到&lt;url-pattern&gt;*.do&lt;/url-pattern&gt;以上配置的路径，表示请求地址必须以.do 结尾才会拦截到&lt;url-pattern&gt;*.action&lt;/url-pattern&gt;以上配置的路径，表示请求地址必须以.action 结尾才会拦截到 web.xml基本概念 在Servlet 3.0之前，每个Web应用程序都必须有一个部署描述文件（web.xml），部署描述文件（Deployment Descriptor，简称DD文件）。它用来部署Web应用中所包含的组件，如Servlet等。 从Servlet 3.0开始，有些组件可使用注解配置，但还有些内容（安全配置等）需要使用部署描述文件配置。 Web应用启动时，容器读取该文件，对应用程序配置，所以有时也将该文件称为配置文件。 注解使用 注解属于javax.servlet.annotation包，因此在定义Servlet时应使用下列语句导入。 import javax.servlet.annotation.WebServlet; 注解代码示例 12345678@WebServlet(name = &quot;testServlet&quot;,urlPatterns = &#123;&quot;/testServlet&quot;&#125;)public class TestServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;注解注册servlet&quot;); &#125;&#125; 等价与以下的web.xml配置 12345678&lt;servlet&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.website.servlet.TestServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/testServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 启动页设置 可配置多个，服务器启动后逐一匹配至可访问资源展示为启动页 若均不匹配返回404错误 12345&lt;welcome-file-list&gt; &lt;welcome-file&gt;/index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;/index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;/test_welcome.html&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; 错误页配置 配置错误页面，由Tomcat容器进行统一的错误页面跳转 配置错误信息的方式有两种：HTTP响应码、java异常类全类名 使用前提是，Tomcat容器必须能检测到这些异常，有些默认能直接检测，有些异常抛出 404：无需代码干涉，Tomcat容器能直接首先检测到 500：程序内部错误，一般编程人员没有进行异常捕获，异常最终是能够传递给Tomcat的，但若代码捕获过异常，又想依赖于Tomcat错误页面检测，则需再把异常抛出来。 HTTP响应码匹配12345678910111213&lt;!-- 通过匹配HTTP响应代码跳转错误页面 --&gt;&lt;error-page&gt; &lt;!-- 404错误可被Tomcat直接捕获，不或访问到web程序，可直接配置生效 --&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error/error_400.html&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt; &lt;!-- 设置HTTP错误代码，500即Tomcat发现内部错误(异常)时调用指定页面 --&gt; &lt;!-- 对于500内部异常错误，需Tomcat捕获到程序异常才能生效 --&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/error/error_500.html&lt;/location&gt;&lt;/error-page&gt; 异常类类型匹配1234&lt;error-page&gt; &lt;exception-type&gt;java.lang.RuntimeException&lt;/exception-type&gt; &lt;location&gt;/error/error_500.html&lt;/location&gt;&lt;/error-page&gt; xml解析技术Dom4j解析技术dom4j 是优秀的第三方解析XML类库。需要使用 dom4j 就需要到 dom4j 官网下载 dom4j 的 jar 包。具体操作可以查看官方文档，或者下载离线jar包后查看离线帮助文档，如下 Dom4j编程步骤 添加jar包，如 dom4j-1.6.1.jar 通过创建SAXReader对象调用read方法加载xml文件获取Document对象 通过Document对象获取对应的xml对象的根元素 通过根元素调用element(标签名)或elements(标签名)方法获取对应的xml标签对象或集合 获得标签对象后通过调用对应方法获取属性，或子标签。具体演示如下 创建实例XML文件 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;books&gt; &lt;book sn=&quot;SN12341232&quot;&gt; &lt;name&gt;effective of java&lt;/name&gt; &lt;price&gt;9.9&lt;/price&gt; &lt;author&gt;刘德华&lt;/author&gt; &lt;/book&gt; &lt;book sn=&quot;SN12341231&quot;&gt; &lt;name&gt;深入了解虚拟机&lt;/name&gt; &lt;price&gt;99.99&lt;/price&gt; &lt;author&gt;陈慧娴&lt;/author&gt; &lt;/book&gt;&lt;/books&gt; 编写标签对应的java类，并封装成java类，输出所有属性。 1234567public class Book &#123; private String book; private String name; private Double price; private String author; //....建立构造，重写toString等基操&#125; 1234567891011121314151617181920212223242526@Testpublic void test() throws DocumentException &#123; //1、通过创建SAXReader对象调用read方法加载xml文件获取Document对象 SAXReader reader = new SAXReader(); Document read = reader.read(&quot;src/books.xml&quot;); //2、通过Document对象获取对应的xml对象的根元素 Element rootElement = read.getRootElement(); //3、通过根元素获取对应的xml标签对象,主要使用element()与elements()方法 List&lt;Element&gt; books = rootElement.elements(&quot;book&quot;); for(Element book : books)&#123; //1、获取当前标签属性 String sn = book.attributeValue(&quot;sn&quot;); //2、获取book标签下name、price、author标签的值 //方式1：通过再获取子标签的element对象,再调用getText() String name = book.element(&quot;name&quot;).getText(); //方式2：直接通过 String author = book.elementText(&quot;author&quot;); Double price = Double.parseDouble(book.elementText(&quot;price&quot;)); System.out.println(new Book(sn,name,price,author)); &#125;&#125;/*输出如下Book&#123;book=&#x27;SN12341232&#x27;, name=&#x27;effective of java&#x27;, price=9.9, author=&#x27;刘德华&#x27;&#125;Book&#123;book=&#x27;SN12341231&#x27;, name=&#x27;深入了解虚拟机&#x27;, price=99.99, author=&#x27;陈慧娴&#x27;&#125;*/","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"Java语言PV操作初使用","slug":"Java语言PV操作初使用","date":"2021-05-24T12:36:32.000Z","updated":"2021-08-25T15:27:11.839Z","comments":true,"path":"2021/05/24/Java语言PV操作初使用/","link":"","permalink":"http://yoursite.com/2021/05/24/Java%E8%AF%AD%E8%A8%80PV%E6%93%8D%E4%BD%9C%E5%88%9D%E4%BD%BF%E7%94%A8/","excerpt":"","text":"基本概念原语 原语（primitive）是机器指令的延伸，往往是为完成某些特定的功能而编制的一段系统程序 原语操作也称做“原子操作”（atomic action），即一个操作中的所有动作要么全做，要么全不做 执行原语操作时，系统会自动屏蔽中断，以保证其操作的不可分割性。 信号量 信号量(semaphore)是由荷兰科学家Dijkstra在1965年提出的一种进程同步机制 计数信号量(整型)的物理意义：S&gt;=0时表示某资源的可用数，S&lt;0时其绝对值表示阻塞队列中等待该资源的进程数。 PV操作的原语操作在信号量同步机制中包含“检测”与“归还”两个操作，检测操作称为P操作，归还操作称为V操作，对应的原语操作如下。(注意原语操作不一定是代码实现就这样) P操作的原语操作：passeren(通过、检测) 12345&#x2F;&#x2F;x是计数信号量P(x)&#123; while(x &lt;&#x3D; 0); x--;&#125; V操作原语操作：vrijgeven(释放) 123V(x)&#123; x--;&#125; PV操作的使用基本概念单纯开启多个线程，直接使用PV操作的原语操作(while)自封装PV函数，设置整型信号量进行线程同步和互斥操作是不行的。原因在于： PV操作必须是原子操作，即在运行过程中，占有完整的一个时间片，不可分割。而未被特殊处理过的普通程序代码是不具备这种特性的。 现如今一般采用的是”记录型信后量机制“，即含线程控制，避免忙等待状态。管理线程队列并控制使其线程阻塞、中断、唤醒等操作。若自定义 以前没有基于标准多线程编程的程序，由于都是一些简单双线程同步操作，对于少量的线程同步操作，只要有足够的时间让系统反应，程序运行总体看起来满足要求的。但对于复杂高响应的同步，或高竞争的线程互斥操作，没有标准的相关多线程编写方法，是无法达成的。而且像子线程里面跑while死循环，还会被系统自动阻塞掉。需要手动唤醒 Semaphore封装类Semaphore，java专用信号量封装类，可声明信号量并内置了PV操作(应该是记录型信号量) 构造器：可初始化信号量的值：Semaphore mutex = new Semaphore(1); 方法： void acquire()：从信号量获取一个许可，如果无可用许可前将一直阻塞等待，对应P操作 void release()： 释放一个许可，对应V操作。 …… void acquire(int permits) ：获取指定数目的许可，如果无可用许可前也将会一直阻塞等待 boolean tryAcquire()：从信号量尝试获取一个许可，如果无可用许可，直接返回false，不会阻塞 boolean tryAcquire(int permits)： 尝试获取指定数目的许可，如果无可用许可直接返回false boolean tryAcquire(int permits, long timeout, TimeUnit unit)： 在指定的时间内尝试从信号量中获取许可，如果在指定的时间内获取成功，返回true，否则返回false int availablePermits()： 获取当前信号量可用的许可 …… Semaphore 源码 因此学习Semaphore 源码也是学习如何源码级别实现PV操作的一个绝佳途径。 PV操作实例父母儿女水果问题题目桌上有一只盘子，每次只能放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放桔子，一个女儿专等吃盘子里的苹果，一个儿子专等吃盘子里的桔子。只要盘子空则爸爸或妈妈都可以向盘子放一个水果，仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果 操作分析 信号量设计 方案1： father 或 mother 盘子有水果时不能放入，生产者信号量empty = N = 1; 盘子没有apple时，daughter 需等待，消费者信号量 (full) apple = 0; 盘子没有orange时，son 需等待，消费者信号量(full) orange = 0; father、mother、daughter、son 之间互斥适用盘子，mutex = 1; 方案2：更少信号量，但竞争更激烈 father 或 mother 盘子有水果时不能放入，生产者信号量empty = N = 1; 盘子没有水果时，daughter和son都需等待，消费者信号量 fruit = 0; father、mother、daughter、son 之间互斥适用盘子，mutex = 1; 方案2即将方案1的apple、orange信号量合并，即有水果就会引发儿女去争夺，争夺后再对资源进行分类选择吃与不吃。 代码实现 com.test.pojo.Person.java 1234567891011121314151617package com.test.pojo;public class Person extends Thread&#123; private String name; public Person(String name) &#123; this.name = name; // TODO Auto-generated constructor stub &#125; public String getPName() &#123; return name; &#125; public void setPName(String name) &#123; this.name = name; &#125;&#125; com.test.pojo.PVtest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.test.pojo;import java.util.concurrent.Semaphore;public class PVtest &#123; //java封装的信号量类 Semaphore apple = new Semaphore(0); //是否有苹果，没有d需等待 Semaphore orange = new Semaphore(0); //是否有橘子、没有s需等待 Semaphore empty = new Semaphore(1); //没有空闲区时f与m均不能放入水果 Semaphore mutex = new Semaphore(1); //f、m、d、s互斥操作盘子信号量 //PV操作:基于Semaphore实现 public void P(Semaphore semaphore)&#123; try &#123; semaphore.acquire(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void V(Semaphore semaphore)&#123; semaphore.release(); &#125; //主函数调用 public void test()&#123; //父亲线程 new Person(&quot;father&quot;)&#123; public void run() &#123; while(true)&#123; P(empty); P(mutex); System.out.println( Thread.currentThread().getId() + &quot; : &quot; + &quot;父亲放入一个苹果&quot;); V(mutex); V(apple); &#125; &#125; &#125;.start(); //母亲线程 new Person(&quot;mother&quot;)&#123; public void run()&#123; while(true)&#123; P(empty); P(mutex); System.out.println( Thread.currentThread().getId() + &quot; : &quot; + &quot;母前放入一个橘子&quot;); V(mutex); V(orange); &#125; &#125;; &#125;.start(); //女儿线程 new Person(&quot;daughter&quot;)&#123; public void run() &#123; while(true)&#123; P(apple); P(mutex); System.out.println( Thread.currentThread().getId() + &quot; : &quot; + &quot;女儿吃掉一个苹果&quot;); V(mutex); V(empty); System.out.println(); &#125; &#125;; &#125;.start(); //儿子线程 new Person(&quot;son&quot;)&#123; public void run() &#123; while(true)&#123; P(orange); P(mutex); System.out.println( Thread.currentThread().getId() + &quot; : &quot; + &quot;儿子吃掉一个橘子&quot;); V(mutex); V(empty); System.out.println(); &#125; &#125;; &#125;.start(); &#125; public static void main(String[] args) &#123; new PVtest().test(); &#125;&#125; 输出效果 1234567891011121314151617181920212223242511 : 母前放入一个橘子13 : 儿子吃掉一个橘子10 : 父亲放入一个苹果12 : 女儿吃掉一个苹果11 : 母前放入一个橘子13 : 儿子吃掉一个橘子10 : 父亲放入一个苹果12 : 女儿吃掉一个苹果11 : 母前放入一个橘子13 : 儿子吃掉一个橘子10 : 父亲放入一个苹果12 : 女儿吃掉一个苹果11 : 母前放入一个橘子13 : 儿子吃掉一个橘子10 : 父亲放入一个苹果12 : 女儿吃掉一个苹果.... PV操作的自实现初步估计：应该需要基于多线程控制中Wait和Notify，和通过关键字synchronized(重量级锁)或volatile，保证了PV操作函数是一条原语 待开发… 参考：https://www.cnblogs.com/TQCAI/p/7700354.html","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"html&css&js&jq&xml入门","slug":"html&css&js&jq&xml入门","date":"2021-03-23T11:54:32.000Z","updated":"2021-08-25T15:27:11.615Z","comments":true,"path":"2021/03/23/html&css&js&jq&xml入门/","link":"","permalink":"http://yoursite.com/2021/03/23/html&css&js&jq&xml%E5%85%A5%E9%97%A8/","excerpt":"","text":"[TOC] HTML基本规范123456789101112131415&lt;!DOCTYPE html&gt;&lt;!-- 约束,声明 --&gt;&lt;!-- html标签表示html的开始 lang=&quot;zh_CN&quot;表示中文--&gt;&lt;!-- html标签中一般分为两部分,分别是:head和body --&gt;&lt;!-- 表示头部信息,一般包含三部分内容,title标签,css样式,js代码 --&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;!-- 表示当前页面使用UTF-8字符集 --&gt; &lt;title&gt;某东&lt;/title&gt;&lt;!--表示标题--&gt;&lt;/head&gt;&lt;!--body标签是整个html页面显示的主体内容--&gt;&lt;body &gt; Hello world!&lt;/body&gt;&lt;/html&gt; HTML标签介绍 标签的格式： &lt;标签名&gt;封装的数据&lt;/标签名&gt; &lt;html&gt;Hello&lt;/html&gt; 标签名大小写不敏感 标签拥有自己的属性：基本属性、事件属性 基本属性：bgcolor=&quot;red&quot; 可以修改简单的样式效果 事件属性：onclick=&quot;alert(&#39;你好！&#39;);&quot; 可以直接设置事件响应后的代码 .标签又分为，单标签和双标签。 单标签格式： &lt;标签名 /&gt; ，如&lt;br/&gt; 换行 ，&lt;hr/&gt; 水平线 双标签格式: &lt;标签名&gt; …封装的数据…&lt;/标签名&gt; 常用标签介绍w3c手册https://www.w3school.com.cn/ 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;!-- 约束,声明 --&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;某东&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 1、标题 --&gt;&lt;h1 align=&quot;left&quot;&gt;标题 1左对齐&lt;/h1&gt;&lt;h2 align=&quot;center&quot;&gt;标题 2居中&lt;/h2&gt;&lt;h3 align=&quot;right&quot;&gt;标题 3右对齐&lt;/h3&gt;&lt;!-- 2、a标签是 超链接target属性：属性设置哪个目标进行跳转 _self 表示当前页面(默认值) _blank 表示打开新页面来进行跳转--&gt;&lt;a href=&quot;http://baidu.com&quot;&gt;百度&lt;/a&gt;&lt;a href=&quot;http://baidu.com&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt; &lt;!--div、span、p标签 div 标签 默认独占一行 span 标签 它的长度是封装数据的长度 p 段落标签 默认会在段落的上方或下方各空出一行来（如果已有就不再空）--&gt;&lt;div&gt;div 标签 1&lt;/div&gt;&lt;div&gt;div 标签 2&lt;/div&gt;&lt;span&gt;span 标签 1&lt;/span&gt;&lt;span&gt;span 标签 2&lt;/span&gt;&lt;p&gt;p 段落标签 1&lt;/p&gt;&lt;p&gt;p 段落标签 2&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 表单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!-- 7、表单 --&gt;&lt;!-- action提交服务器地址、method提交方式 --&gt;&lt;!--一、单提交的时候，数据没有发送给服务器的三种情况： 1、表单项没有 name 属性值 2、单选、复选（下拉列表中的 option 标签）都需要添加 value 属性，以便发送给服务器 3、表单项不在提交的 form 标签中二、GET 请求的特点是： 1、浏览器地址栏中的地址是：action 属性[+?+请求参数] 请求参数的格式是：name=value&amp;name=value 2、不安全 3、它有数据长度的限制三、POST 请求的特点是： 1、浏览器地址栏中只有 action 属性值 2、相对于 GET 请求要安全 3、理论上没有数据长度的限制 --&gt;&lt;form action=&quot;loginServlet/login&quot; method=&quot;post&quot;&gt; 用户名称：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;默认值&quot;/&gt;&lt;br/&gt; 用户密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;123&quot;/&gt;&lt;br/&gt; &lt;!-- 提交按钮 --&gt; &lt;input type=&quot;submit&quot; name=&quot;login&quot; value=&quot;登录&quot;/&gt; &lt;!-- 单选：name属性分组成为单选, checked=&quot;checked&quot; 默认单选--&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked=&quot;checked&quot;/&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot;/&gt;女&lt;br/&gt; &lt;!-- 复选 --&gt; &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;/&gt;Java&lt;input type=&quot;checkbox&quot;/&gt;C&lt;input type=&quot;checkbox&quot;/&gt;C++ &lt;!-- 下拉列表 selected=&quot;selected&quot; 表默认选中--&gt; &lt;select&gt; &lt;option&gt;--请选择国籍--&lt;/option&gt;&lt;!-- 选项 --&gt; &lt;option selected=&quot;selected&quot; value=&quot;China&quot;&gt;--中国--&lt;/option&gt; &lt;option&gt;--美国--&lt;/option&gt; &lt;/select&gt;&lt;br/&gt; &lt;!-- 多行文本输入框 rows 属性设置可以显示几行的高度 cols 属性设置每行可以显示几个字符宽度 --&gt; &lt;textarea&gt; 默认值 &lt;/textarea&gt;&lt;br/&gt; &lt;!-- 重置 --&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;!-- 文件上传域 --&gt; &lt;input type=&quot;file&quot; name=&quot;fileUpload&quot; value=&quot;上传&quot;&gt; &lt;!-- 隐藏域，这些信息不显示，但提交表单时会提交到后台服务器 --&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot;&gt;&lt;/form&gt; 常用特殊字符 诸如’’&lt;’’ 与’’&gt;’’符号在HTML中拥有特殊含义，若显示这些特殊含义的字符则需使用特殊字符书写 HTML会默认裁掉连续的空白字符(空格,TAB…) 特殊字符 实体字符 意义 &lt; &amp;lt less than &gt; &amp;gt great than 空格 &amp;nbsp 牛逼space 12&lt;!-- 把&lt;br&gt;换行标签变成文本输出 --&gt;&amp;lt br &amp;gt CSS语法规则三元组：选择器、属性、值 CSS和HTML的结合 html中直接使用style属性设置 style 标签专门用来定义 css 样式代码 把 css 样式写成一个单独的css 文件，再通过 link 标签引入即可复用 style属性在标签的 style 属性上设置”key:value value;”修饰 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--需求 1：分别定义两个 div、span 标签，分别修改每个 div 标签的样式为：边框 1 个像素，实线，红色。--&gt;&lt;div style=&quot;border: 1px solid red;&quot;&gt;div 标签 1&lt;/div&gt;&lt;div style=&quot;border: 1px solid red;&quot;&gt;div 标签 2&lt;/div&gt;&lt;span style=&quot;border: 1px solid red;&quot;&gt;span 标签 1&lt;/span&gt;&lt;span style=&quot;border: 1px solid red;&quot;&gt;span 标签 2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; style标签1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;/title&gt; &lt;!--style 标签专门用来定义 css 样式代码--&gt;&lt;style type=&quot;text/css&quot;&gt;/* 需求 1：分别定义两个 div、span 标签，分别修改每个 div 标签的样式为：边框 1 个像素，实线，红色。*/ div&#123; border: 1px solid red; &#125; span&#123; border: 1px solid red; &#125;&lt;/style&gt; &lt;/head&gt;&lt;body&gt;&lt;div&gt;div 标签 1&lt;/div&gt;&lt;div&gt;div 标签 2&lt;/div&gt;&lt;span&gt;span 标签 1&lt;/span&gt;&lt;span&gt;span 标签 2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; css文件&amp;ink标签 test.css文件如下 123456div&#123; border: 1px solid yellow;&#125;span&#123; border: 1px solid red;&#125; test.html文件如下 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;/title&gt;&lt;!--link 标签专门用来引入 css 样式代码--&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;test.css&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;div 标签 1&lt;/div&gt;&lt;div&gt;div 标签 2&lt;/div&gt;&lt;span&gt;span 标签 1&lt;/span&gt;&lt;span&gt;span 标签 2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; CSS选择器 标签名选择器 id选择器 class选择器 组合选择器 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;CSS选择器&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*标签选择器*/ body&#123; font-size: 30px; border: 1px yellow solid; &#125; /*id 选择器*/ #test1&#123; color: blue; &#125; /*class 选择器*/ .test2&#123; color: red; &#125; /*组合选择器*/ #test1,.test2&#123; background: green; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;test1&quot;&gt;id 001&lt;/div&gt; &lt;div class=&quot;test2&quot;&gt;class 002&lt;/div&gt; &lt;div class=&quot;test2&quot;&gt;class 002&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 常用样式 字体颜色 color : red; 颜色可以写颜色名如：black, blue, red, green 等 颜色也可以写 rgb 值和十六进制表示值：如 rgb(255,0,0)，#00F6DE，如果写十六进制值必须加# 宽度 width:19px;宽度可以写像素值：19px； 也可以写百分比值：20% 高度 height:20px; 高度可以写像素值：19px； 也可以写百分比值：20% 背景颜色 background-color:#0F2D4C; 字体样式： color：#FF0000;字体颜色红色 font-size：20px; 字体大小 红色 1 像素实线边框 border：1px solid red; DIV 居中: margin-left: auto; margin-right: auto; 文本居中： text-align: center; 超连接去下划线: text-decoration: none; 表格细线 1234567table &#123; border: 1px solid black; /*设置边框*/ border-collapse: collapse; /*将边框合并*/&#125;td,th &#123; border: 1px solid black; /*设置边框*/&#125; 列表去除修饰，兼容IE 123ul &#123; list-style: none;&#125; JavaScript基础介绍Javascript 语言诞生主要是完成页面的数据验证。因此它运行在客户端，需要运行浏览器来解析执行 JavaScript 代码。 JS 是 Netscape 网景公司的产品，最早取名为 LiveScript;为了吸引更多 java 程序员。更名为 JavaScript。 JS 是弱类型(类型可变)，Java 是强类型(定义变量已确定且不可变)。 特点： 交互性（它可以做的就是信息的动态交互） 安全性（不允许直接访问本地硬盘） 跨平台性（只要是可以解释 JS 的浏览器都可以执行，和平台无关） js和html结合方式 直接在html的head或 body 标签中， 使用 script 标签来书写JavaScript 通过script标签外部引入单独的 JavaScript 代码文件 script标签中书写12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt; // alert 是 JavaScript 语言提供的一个警告框函数。 // 它可以接收任意类型的参数，这个参数就是警告框的提示信息 alert(&quot;hello javaScript!&quot;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 通过script标签引入js文件12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;/title&gt;&lt;!--现在需要使用 script 引入外部的 js 文件来执行 src 属性专门用来引入 js 文件路径（可以是相对路径，也可以是绝对路径） script 标签可以用来定义 js 代码，也可以用来引入 js 文件 但是，一个script标签只能做一件事，作为引入则不能在里面书写JavaScript代码--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;1.js&quot;&gt;该领域书写js代码无效&lt;/script&gt;&lt;!-- 若想在当前情况下还在htmlzh写js，必须再创建一个script标签作为js代码书写 --&gt;&lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;国哥现在可以帅了&quot;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 变量变量类型 数值类型： number (对应java：byte int short long float double等) 字符串类型： string 对象类型： object 布尔类型： boolean 函数类型： function JavaScript中特殊的值： undefined：未定义，所有 js 变量未赋于初始值的时候，默认值都是 undefined. null：空值 NaN：全称是：Not a Number。”非数字,非数值”。 123var a = 12;var b = &quot;abc&quot;;alert(a * b);//输出NaN 定义变量格式 声明：var 变量名; 声明+初始化：var 变量名 = 值; 关系(比较)运算符特殊讲解 == ：等于，是简单的做字面值的比较 ===：全等于，除了做字面值的比较之外，还会比较两个变量的数据类型 1234var a = 12;var b = &quot;12&quot;;alert(a == b);//truealert(a === b);//false 逻辑运算 在 JavaScript 语言中，所有的变量，都可以做为一个 boolean 类型的变量去使用 0 、null、 undefined、””(空串) 都认为是 false 逻辑运算后返回值 &amp;&amp; 与运算：有两种情况 情况1：当表达式全为真的时候。返回最后一个表达式的值 情况2：当表达式中，有一个为假的时候。返回第一个为假的表达式的值 || 或运算： 情况1：当表达式全为假时，返回最后一个表达式的值 情况2：只要有一个表达式为真。就会把第一个为真的表达式的值 &amp;&amp; 和 ||运算有短路。 123456789101112131415var a = &quot;abc&quot;;var b = true;var d = false;var c = null;// &amp;&amp; 与运算alert( a &amp;&amp; b );//truealert( b &amp;&amp; a );//abcalert( a &amp;&amp; d ); // falsealert( a &amp;&amp; c ); // null// || 或运算alert( d || c ); // nullalert( c || d ); //falsealert( a || c ); //abcalert( b || c ); //true 数组数组的定义12var 数组名 = []; // 空数组var 数组名 = [1 , ’abc’ , true]; // 定义数组同时赋值元素 数组定义时可不指定长度、且可变长度 只要我们通过数组下标赋值(不赋值则不会扩容)，那么最大的下标值，就会自动的给数组做扩容操作 12345678910111213var arr = [true,1]; // 定义一个空数组// alert( arr.length ); // 0arr[0] = 12;alert( arr[0] );//12alert( arr.length ); // 0arr[2] = &quot;abc&quot;;alert(arr.length); //3alert(arr[1]);// undefined// 数组的遍历for (var i = 0; i &lt; arr.length; i++)&#123; alert(arr[i]);&#125; 函数格式112345678910111213141516171819//1. 无参无返回值函数function fun()&#123; alert(&quot;无参无返回值函数&quot;);&#125;fun();//函数调用//2.带形参函数function fun1(a ,b) &#123; alert(&quot;有参函数 fun2()被调用了 a=&gt;&quot; + a + &quot;,b=&gt;&quot;+b);&#125;fun1();//函数调用//3. 在 JavaScript 语言中，如何定义带有返回值的函数？//只需要在函数体内直接使用 return 语句返回值即可！function sum(num1,num2) &#123; var result = num1 + num2; return result;&#125;alert(sum(100,50) ); 格式212345//可以把函数名忽略作为var变量的引用var fun = function () &#123; alert(&quot;无参函数&quot;);&#125;fun();//调用 常用函数 函数 意义 typeof() 传入变量，返回数据类型 jQuery应用实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;script type=&quot;text/javascript&quot;&gt; //Jq、页面加载完成后执行 $(function()&#123; //给注册按钮绑定单击事件 $(&quot;#sub_btn&quot;).click(function () &#123; // 验证用户名：必须由字母，数字下划线组成，并且长度为 5 到 12 位 // 验证密码：必须由字母，数字下划线组成，并且长度为 5 到 12 位 // 验证确认密码：和密码相同 // 邮箱验证：xxxxx@xxx.com // 验证码：现在只需要验证用户已输入。因为还没讲到服务器。验证码生成 // 1、验证用户名：必须由字母，数字下划线组成，并且长度为 5 到12位 //获取用户名内容 var username = $(&quot;#username&quot;).val(); //创建正则表达式对象 var usernamePatt = /^\\w&#123;5,12&#125;$/; //调用test方法进行测试 //给非法输入进行提示 var $errorMsg = $(&quot;.errorMsg&quot;); if(!usernamePatt.test(username))&#123; $errorMsg.text(&quot;用户名非法输入&quot;); return false;//终止提交 &#125; //2、验证密码：必须由字母，数字下划线组成，并且长度为 5 到 12 位 //同理如上 var password = $(&quot;#password&quot;).val(); //创建正则表达式对象 var passwordPatt = /^\\w&#123;5,12&#125;$/; //调用test方法进行测试 //给非法输入进行提示 if(!passwordPatt.test(password))&#123; $errorMsg.text(&quot;密码非法输入&quot;); return false; &#125; //3、验证确认密码：和密码相同 // 获取确认密码 var repwd = $(&quot;#repwd&quot;).val(); if(password != repwd)&#123; $errorMsg.text(&quot;两次密码输入不一致&quot;); return false; &#125; //4、邮箱验证：xxxxx@xxx.com var emalil = $(&quot;#email&quot;).val(); var emailPatt = /^[a-z\\d]+(\\.[a-z\\d]+)*@([\\da-z](-[\\da-z])?)+(\\.&#123;1,2&#125;[a-z]+)+$/; if(!emailPatt.test(emalil))&#123; $errorMsg.text(&quot;邮箱格式非法&quot;); return false; &#125; //5、获取验证码信息，只要输入不为空(去除空格后)即可 // 验证码：现在只需要验证用户已输入。因为还没讲到服务器。验证码生成 var code = $(&quot;#code&quot;).val(); code = $.trim(code); if(code == null || code == &quot;&quot;)&#123; $errorMsg.text(&quot;验证码输入为空&quot;); return false; &#125; //错误信息清除 $errorMsg.text(&quot;&quot;); return true; &#125;)&#125;)&lt;/script&gt; XMLxml是可扩展的标记性语言 XML作用 用来保存数据，而且这些数据具有自我描述性 它还可以做为项目或者模块的配置文件 还可以做为网络传输数据的格式（现在 JSON 为主） xml 语法 文档声明 元素（标签） xml 属性 xml 注释 文本区域（CDATA 区） 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!-- xml声明 version是版本的意思(自从除了第一版每更新过) encoding是编码 --&gt;&lt;books&gt; &lt;!-- 这是xml注释,books标识多本图书 --&gt; &lt;book id=&quot;SN123123413241&quot;&gt; &lt;!-- book标签描述一本图书 id属性描述 的是图书 的编号 --&gt; &lt;name&gt;java编程思想&lt;/name&gt; &lt;!-- name标签描述 的是图书 的信息 --&gt; &lt;author&gt;华仔&lt;/author&gt; &lt;!-- author单词是作者的意思 ，描述图书作者 --&gt; &lt;price&gt;9.9&lt;/price&gt; &lt;!-- price单词是价格，描述的是图书 的价格 --&gt; &lt;/book&gt; &lt;book id=&quot;SN12341235123&quot;&gt; &lt;!-- book标签描述一本图书 id属性描述 的是图书 的编号 --&gt; &lt;name&gt;葵花宝典&lt;/name&gt; &lt;!-- name标签描述 的是图书 的信息 --&gt; &lt;author&gt;班长&lt;/author&gt; &lt;!-- author单词是作者的意思 ，描述图书作者 --&gt; &lt;price&gt;5.5&lt;/price&gt; &lt;!-- price单词是价格，描述的是图书 的价格 --&gt; &lt;/book&gt;&lt;/books&gt; XML标签对大小写敏感 每个属性的值必须使用引号引起来 XML某一种标签只能有一个顶级元素(没有父标签的元素) 12345&lt;books&gt;&lt;!-- 没有父标签，为顶级元素 --&gt; &lt;book&gt;ABC&lt;/book&gt; &lt;book&gt;ABC&lt;/book&gt;&lt;/books&gt;&lt;books&gt;出错&lt;/books&gt; &lt;!-- 与顶级元素books重复，错误 --&gt; XML中的特殊字符 123&lt;books&gt; &lt;book&gt;&amp;lt;C语言&amp;gt;&lt;/book&gt; &lt;!--显示 &lt; C语言 &gt; --&gt;&lt;/books&gt; 文本区域若XML中有大量需要转义的字符，如想显示&lt;&lt;&lt;&lt; A &gt;&gt;&gt;&gt;则可使用CDATA语法。CDATA 语法可以告诉 xml 解析器，CDATA 里的文本内容，只是纯文本，不需要 xml 语法解析 CDATA 格式：&lt;![CDATA[]]&gt;在最里面的[]内输入指定不解析文本内容 12345&lt;book&gt;&lt;!-- 正常显示&lt;&lt;&lt;&lt; A &gt;&gt;&gt;&gt; --&gt; &lt;![CDATA[ &lt;&lt;&lt;&lt; A &gt;&gt;&gt;&gt; ]]&gt;&lt;/book&gt; XML的解析技术 不管是 html 文件还是 xml 文件它们都是标记型文档，都可以使用 w3c 组织制定的 dom 技术来解析。 早期 JDK 为我们提供了两种 xml 解析技术DOM 和 Sax 简介（已经过时，但我们需要知道这两种技术） Dom ：解析技术是 W3C 组织制定的，而所有的编程语言都对这个解析技术使用了自己语言的特点进行实现。 Java 对 dom 技术解析标记也做了实现。 SAX：Sun 公司在 JDK5 版本对 dom 解析技术进行升级：SAX（ Simple API for XML ） SAX 解析，它跟 W3C 制定的解析不太一样。它是以类似事件机制通过回调告诉用户当前正在解析的内容。 它是一行一行的读取 xml 文件进行解析的。不会创建大量的 dom 对象。 所以它在解析 xml 的时候，在内存的使用上。和性能上。都优于 Dom 解析。 第三方的解析： jdom 在 dom 基础上进行了封装 dom4j 又对 jdom 进行了封装。 pull 主要用在 Android 手机开发，是在跟 sax 非常类似都是事件机制解析 xml 文件。","categories":[],"tags":[{"name":"xml","slug":"xml","permalink":"http://yoursite.com/tags/xml/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Maven","slug":"Maven","date":"2021-03-20T13:22:32.000Z","updated":"2021-08-25T15:27:11.832Z","comments":true,"path":"2021/03/20/Maven/","link":"","permalink":"http://yoursite.com/2021/03/20/Maven/","excerpt":"","text":"导言：生产环境下开发不再是一个项目一个工程，而是每一个模块创建一个工程，而多个模块整合在一起就需要 使用到像 Maven 这样的构建工具。 [TOC] 现今项目开发问题 project - package 结构的不足 若一个项目就是一个工程，当项目非常庞大时，不适合用这种二级机构管理。如一个项目多个功能模块，一个功能模块就一个MVC 推祟三层结构：engineering - project - package 则能更好的适应大工程的分工开发(如IDEA) 工程拆分后又如何进行互相调用和访问呢？这就需要用到 Maven 的依赖管理机制 项目中jar包的问题 jar包必须手动“复制”、“粘贴”到WEB-INF/lib目录下 同样的jar包文件重复出现在不同的项目工程中 jar包来源不明确，不规范 jar 包之间的依赖关系繁多，且难以得知 Maven是什么Maven基本概念​ Maven [ˈmeɪvn] 是一款服务于java平台的自动化构建工具。 java平台自动化构建工具发展历史：Make—&gt;Ant—&gt;Maven(使用面广)—&gt;Gradle 何为项目构建基本概念：以java源文件,框架配置文件,JSP,HTML,图片等资源为原材料,去生产一个可以运行的项目的过程 清理：将以前编译得到的旧的class字节码文件删除，为下一次编译做准备 编译：将Java源程序编程编译成class字节码文件 测试：自动测试，自动调用junit程序 报告：输出测试程序执行的结果 打包：动态Web工程打war包，Java工程打jar包 安装：Maven特定的概念——将打包得到的文件复制到“仓库”中的指定位置 部署：将动态Web工程生成的war包复制到Servlet容器的指定目录下，使其可以运行 安装Maven核心程序下载maven核心程序 官网 检查JAVA_HOME环境变量maven也是java编写的程序,所以运行是也需要java的虚拟机 解压Maven核心程序建议解压到一个非中文没有空格的目录下 配置Maven环境变量 新增MAVEN_HOME或者是M2_HOME 以前Maven的版本配置的变量为M2_HOME,为了向下兼容低版本,所以可以配置为M2_HOME,而且配置M2_HOME可以防止一些奇怪的错误) 添加PATH的环境变量 检查配置结果mvn -v 修改阿里云镜像 修改成从阿里云镜像中获取资源，速度更快且能避免很多maven依赖导入失败情况 在maven配置文件apache-maven-xxx\\conf\\settings.xml中修改或添加如下代码 123456789101112131415&lt;!-- 远程仓库配置(maven远程仓库阿里镜像) --&gt;&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 约定目录结构约定目录结构的意义 maven要负责我们这个项目的自动化构建，以编译为例,maven要想进行自动编译，至少需要知道java源文件保存在哪里。可采取两种方式 以配置文件的方式明确 遵守框架内部已存在的约定. 在开发中本着能用约定解决的问题就不用配置解决，能用配置解决的就不去编写代码。 约定&gt;配置&gt;编码 凡是符合maven约定目录结构的项目都可称为Maven工程 目录结构基本目录结构 web项目中目录映射 Maven常用命令常用命令 注意：执行与构建过程相关的Maven命令，必须进入pom.xml 所在的目录。 如当使用CMD命令时候必须进入到能看到pom.xml目录路径才能执行构建相关的mvn 命令 常用命令 mvn clean : 清理 mvn compile : 编译主程序 mvn test-compile : 编译测试程序 mvn test : 执行测测试 mvn package : 打包 mvn install ： 安装 mvn site ：生成站点 上述大部分命令第一次运行后都会产生一个target文件夹，之后所有构建相关产生的文件都在此目录下 mvn compile：编译后会产生一个classes文件夹，包含主程序编译的结果 mvn test-compile : 编译会产生一个test-classes文件夹，包含测试程序的编译结果 mvn package : 产生、maven-archiver、surefire-reports、XXXX.jar maven-archiver文件夹：maven一个辅助性文件 surefire-reports：内含一个.txt测试报告 XXXX.jar：打包后的jar包 关于联网问题 Maven 的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须有特定的插件来完成。而插件本身不包含在Maven核心程序中。 当我们执行的Maven命令需要用到某些插件时，Maven核心程序会首先到本地仓库中查找。 本地仓库的默认位置：[系统登陆用户的家目录] \\ .m2\\repository Maven核心程序如果在本地仓库中找不到需要的插件，那么它会自动连接外网，到中央仓库下载。如果此时无法连接外网，则构建失败。 修改默认本地仓库的位置可以让Maven核心程序到我们事先准备好(插件与jar包全有)的目录下查找插件 修改本地仓库位置 打开本地仓库位置的配置信息文件：apache-maven-3.2.2\\conf\\settings.xml 找到&lt;localRepository&gt;标签，若在注释内，请去除注释使其生效。路径设置必须设置到能看到如下图示文件内容为止 例如：应将路径配置成：&lt;localRepository&gt;D:/ManageTools/maven/repository&lt;/localRepository&gt; 对jar 包进行引用操作的先例 项目目录结构与编译后的目录结构对比 实际动态WEB项目运行是以编译后的目录结构 因此在开发过程中，所有的路径或配置文件中配置的类路径等都是以编译结果的目录结构为标准 Maven核心概念 Maven 是如何实现自动化构建的 POM 约定的目录结构 坐标 依赖管理 仓库管理 生命周期 插件和目标 继承 聚合 POM基本含义 含义：Project Object Model 项目对象模型类似：DOM ：Document Object Model 文档对象模型 pom.xml：Maven工程是核心配置文件，与构建过程相关的一切设置都在这个文件中进行配置。 POM文件简述 注意：每一个java项目(Maven项目)本身也是一个jar包的存在(打包或安装(Maven概念)) 一定程度上：Java/Maven工程 == jar包 1234567891011&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 从Maven2开始固定内容 --&gt; &lt;!-- 坐标：唯一标识当前项目/Jar --&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;Hello&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;Hello&lt;/name&gt; &lt;/project&gt; 坐标(GAV) 使用下面三个向量在仓库中唯一定位一个Maven工程：groupid、artifactid、version groupid：公司或组织域名倒序 + 项目名 &lt;groupid&gt;com.atguigu.maven&lt;/groupid&gt; artifactid：模块名 &lt;artifactid&gt;Hello&lt;/artifactid&gt; version：版本 &lt;version&gt;1.0.0&lt;/version&gt; tips：关键字，SNAPSHOT快照版、RELEASE，分离版(较成熟版本) Maven工程的坐标信息与执行mvn install命令后生成文件在仓库中路径的对应关系，以spring为例 12345&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt;&lt;version&gt;4.0.0.RELEASE&lt;&#x2F;version&gt;org&#x2F;springframework&#x2F;spring-core&#x2F;4.0.0.RELEASE&#x2F;spring-core-4.0.0.RELEASE.jar 仓库仓库的分类 本地仓库：当前电脑上部署的仓库目录，为当前电脑上所有Maven工程服务 远程仓库 私服：搭建在局域网环境中，为局域网范围内的所有Maven工程服务 以Nexus这个Maven仓库管理器来表示私服的工工作流程 中央仓库：假设在Internet上，为全世界所有Maven工程服务 中央仓库镜像：为了分担中央仓库流量，提升用户访问速度 仓库中保存的内容 Maven自身所需要的插件 第三方框架或工具的jar包 自己开发的Maven工程 不管是什么样的 jar 包，在仓库中都是按照坐标生成目录结构，所以可以通过统一的方式查询或依赖。 依赖基本概念​ 当 A jar 包用到了 B jar 包中的某些类时，A 就对 B 产生了依赖。Maven解析依赖信息时会到仓库中查找被依赖的jar包。 依赖的使用 标签的使用：&lt;dependency&gt; 坐标 + &lt;scope&gt;范围&lt;/scope&gt; &lt;/dependency&gt; &lt;dependencies&gt;内存放多个&lt;dependency&gt;标签 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; &lt;scope&gt;范围，常用取值有：compile、test、provided tips：若不添加&lt;scope&gt;标签默认是compile 范围效果\\类型 compile test provided 对主程序是否有效 有效 无效 有效 对测试程序是否有效 有效 有效 有效 是否参与打包 参与 不参与 不参与 是否参与部署 参与 不参与 不参与 示例 自定义类/jar包 junit servlet-api.jar 从开发和运行这两个阶段理解compile 和 provided 的区别 对于自己开发的Maven工程，要使用mvn install命令安装后就可以进入仓库。执行后产生如下文件 依赖的传递性tips：依赖的深入特性，首次学习建议先浏览 Eclipse中使用Maven 注意：这里描述的是工程三层结构，即一个应用工程，包含多个功能模块，每个功能模块都是一个eclipse project 基本概念eclipse项目中存在：A项目模块 —依赖—&gt; B项目模块 —依赖—&gt; C项目模块 A与B，B与C关系为直接依赖，可点击pom.xml文件底部切换为Dependency窗口查看 A与C的关系为间接依赖，可点击pom.xml文件底部切换为Dependency Hierarchy窗口查看直接与间接依赖 依赖的传递效果 传递的条件：只有compile范围的依赖才能传递 当存在：A项目模块 —依赖—&gt; B项目模块 —依赖—&gt; C项目模块 若C项目再添加某一种依赖D后，A、B模块会自动添加依赖D 传递依赖的好处：可以传递的依赖不必在每个模块工程中都重复声明，在“最下面”的工程中依赖一次即可。 依赖的排除依赖的排除相当于依赖传递的反操作 依赖排除使用场景： 添加依赖排除标签：假定当前项目的依赖是由上层的直接依赖HelloFriend项目传递过来的，则排除指定依赖操作如下 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;HelloFriend&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;!-- 依赖排除标签 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 依赖的原则路径最短者优先原则 情景：若某个项目模块受到来自两个项目模块的同jar包不同版本依赖。因为某些特殊的原因，HelloFriend使用了非Hello传递下来的jar包版本，而使用了其他的一个版本。此时MakeFreidens则会同时接收啊斗HelloFriend与Hello传递下来的不同的两个版本 就近原则：maven对这种原则默认使用就近原则，因此MakeFriends最终受到传递的是 1.2.14版本 路径相同时先声明者优先 情景：路径相同时，如下 先声明者优先：先声明指的是dependency标签的声明顺序。即MakerFriends依赖HelloFriende与OurFriends的一个相对声明顺序 统一管理依赖版本 场景：这里对Spring各个jar包的依赖版本都是4.0.0如果需要统一升级为4.1.1，怎么办？手动逐一修改不可靠。 使用properties标签： 使用properties标签内使用自定义标签统一声明版本号 123456789&lt;properties&gt; &lt;!-- 通过自定义标签统一声明版本号 --&gt; &lt;test.spring.version&gt;4.1.1.RELEASE&lt;/test.spring.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt; ...&lt;/dependencies&gt; 在需要统一版本的位置，使用$&#123;自定义标签名&#125;引用声明的版本号 12345678910111213141516171819202122232425262728&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;!-- 统一引用 --&gt; &lt;version&gt;$&#123;test.spring.version&#125;&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;test.spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;test.spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;test.spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;test.spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; 这种自定义标签和标签内容引用的方式，并不只适用于此场景，这是xml的特性，任何地方都可以通过 &lt;自定义标签&gt;&lt;/自定义标签&gt; 、 ${自定义标签} 这种方式进行声明和引用 生命周期tips：了解即可 基本概念 生命周期：各个构建环节执行的顺序，必须按照既定的正确顺序来执行。 Maven的核心程序中定义了抽象的生命周期，生命周期中各个阶段的具体任务是由插件来完成的。 为更好的实现自动化构建，不论现在要执行生命周期中的哪一阶段，都是从某一个生命周期最初的位置开始执行 即不用担心打包之前要编译，要测试，直接执行打包命令，会重头完成这些必备功能 Maven有三套相互独立的生命周期，分别是： Clean Lifecycle：在进行真正的构建之前进行一些清理工作。 Default Lifecycle：构建的核心部分，编译、测试、打包、安装、部署等等。 Site Lifecycle：生成项目报告，站点，发布站点。 他们相互独立。也可以直接运行mvn clean install site 运行所有这三套生命周期。 每套生命周期都由一组阶段(Phase)组成，平时在命令行输入的命令总会对应于一个特定的阶段。 比如，运行 mvn clean，这个clean是 Clean 生命周期的一个阶段 Clean声明周期 pre-clean 执行一些需要在clean之前完成的工作 clean 移除所有上一次构建生成的文件 post-clean 执行一些需要在clean 之后立刻完成的工作 Default声明周期Default 生命周期是 Maven 生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段： validate generate-sources process-sources generate-resources process-resources 复制并处理资源文件，至目标目录，准备打包。 compile 编译项目的源代码。 process-classes generate-test-sources process-test-sources generate-test-resources process-test-resources 复制并处理资源文件，至目标测试目录。 test-compile 编译测试源代码。 process-test-classes test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。 prepare-package package 接受编译好的代码，打包成可发布的格式，如 JAR。 pre-integration-test integration-test post-integration-test verify install 将包安装至本地仓库，以让其它项目依赖。 deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享或部署到服务器上运行。 … Site生命周期 pre-site 执行一些需要在生成站点文档之前完成的工作 site 生成项目的站点文档 post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 site-deploy 将生成的站点文档部署到特定的服务器上 这里经常用到的是 site 阶段和 site-deploy 阶段，用以生成和发布 Maven 站点，这可是 Maven 相当强大的功能，Manager 比较喜欢，文档及统计数据自动生成，很好看。命令mvn site Eclipse中使用Maven基本设置 当今版本eclipse一般已内置Maven插件 Maven插件的设置： Window-&gt;Preferences-&gt;Maven installations : 指定Maven核心程序的位置。默认是插件自带的Maven程序，一般改为我们自己解压的那个。 user settings : 指定Maven核心程序中 conf/settings.xml 文件的位置，进而获取本地仓库的位 创建Maven版java工程 创建Maven版的Java工程 创建时勾选上 Create a simple project(skip archetype selection) ，然后点击 next 输入前三行基本信息后，点击finish 即可创建 创建的Maven工程格式如下， 编写的java源程序放在，名为src/main/java的目录下，即上图的第二行 创建的Maven工程默认使用的是JDK1.5，改变方法有两种 eclipse设置中修改 (推荐)打开Maven核心程序 settings.xml 文件，找到profiles标签，在该标签内加入如下配置，即可更改 注意，若想更高版本的JDK，除了修改如下配置文件版本号外，还需注意目前maven版本是否支持 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.7&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.7&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.7&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 执行Maven命令 选中Maven工程中的pom.xml文件，右键Run As，则有一系列命令列出，点击即可执行某种命令 若在Run As 中没有找到想要执行的命令如上图中没有编译命令，则点击 Run As 列表中含三个点的命令Maven build...直接在Goals：中输入命令执行即可 创建Maven版Web工程 New Maven project时，Packaging 选择 war 调整web目录结构，在项目上点右键 -&gt; properties-&gt;Project Facets -&gt; 把Dynamic Web Module 勾选去掉，并Apply -&gt; 将Dynamic Web Module 重新勾选 -&gt; 点击Further configuration available -&gt; 修改 Content directory为src/main/webapp -&gt; Apply 即在Maven工程上生成动态Web目录结构 新建jsp文件发现报错：The superclass “javax.servlet.http.HttpServlet” was not found on the Java Build Path“。因为缺少Tomcat 运行时环境，解决方法有两种 经典的通过eclipse设置加入ServletAPI依赖依赖 以Maven方式添加：在pom.xml文件中添加 123456&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; jsp写入EL表达式时发现报错：”javax.servlet.jsp cannot be resolved to a type”，将JSPAPI导入。在pom.xml文件中添加 123456&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.1.3-b06&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 注意：像这种在部署的时候运行时环境会提供的jar包，开发阶段使用scope一定要设置成provided，不然待部署时，maven会将设置为compile的jar包一同部署到容器中，则会发生冲突，运行时会报空指针异常。 导入Maven工程 方式1：传统的项目导入方式，前提是必须是在eclipse中创建的项目(普通项目或maven项目)，即必须包含eclipse认可为java项目的.settings、.classpath、.project等文件 方式2：通用的maven项目导入，只要maven项目含pom.xml文件即可 继承应用场景​ 解决无法进行依赖传递的jar包版本统一问题。例如score为test的junit。由于test范围的依赖不能传递，所以必然会分散在各个模块工程中，很容易造成版本不一致。 如下情况 123Hello依赖的Junit：4.0HelloFriend依赖的Junit：4.0MakeFriends依赖的Junit：4.9 解决方案：​ 将Junit依赖统一提取到“父”工程中，在子工程中声明Junit依赖是不指定版本，以父工程中统一设定的为准。同时也便于修改。 创建一个新的Maven工程作为父工程。注意：打包的方式pom 对应自动生成配置文件信息如下所示 1234&lt;groupId&gt;com.test.maven&lt;/groupId&gt;&lt;artifactId&gt;Parent&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt; 所有子工程中声明对父工程的引用：适用&lt;parent&gt;&lt;/parent&gt;标签 12345678910111213&lt;!-- 子工程中声明父工程 --&gt;&lt;!-- 1. 使用parent标签进行对父工程的引用 --&gt;&lt;parent&gt; &lt;!-- 2. 将父工程中的坐标信息复制过来 --&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;Parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 3. 设置以当前文件为基准的父工程pom.xml文件的相对路径 --&gt; &lt;relativePath&gt;../Parent/pom.xml&lt;/relativePath&gt;&lt;/parent&gt;&lt;!-- 同级--&gt;&lt;dependencies&gt;&lt;/dependencies&gt; 将子工程的坐标中与父工程坐标中重复的内容删除，报出以下错误信息的内容均删除即可 在父工程中添加统一的junit的依赖 在子工程中删除junit依赖的版本标签version tips：配置集成后，执行安装命令时要先安装父工程 聚合 功能：对一个工程中的多个功能项目进行一键安装 配置方式：在一个”总的聚合工程”中配置各个参与聚合的模块 1234567&lt;!-- 在作为总的聚合工程中配置聚合(不一定是父工程) --&gt;&lt;modules&gt; &lt;!-- 指定各个子工程的相对路径 --&gt; &lt;module&gt;../HelloFriend&lt;/module&gt; &lt;module&gt;../MakeFriends&lt;/module&gt; &lt;module&gt;../Hello&lt;/module&gt;&lt;/modules&gt; 使用方式：在聚合工程的pom.xml 上点右键 -&gt; run as -&gt; maven install Web工程的自动化部署 在pom.xml 中添加如下配置： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--配置当前工程构建过程中的特殊设置 --&gt;&lt;build&gt; &lt;finalName&gt;AtguiguWeb&lt;/finalName&gt; &lt;!-- 配置构建过程中需要使用的插件 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;!-- cargo是一家专门从事启动Servlet容器的组织 --&gt; &lt;groupId&gt;org.codehaus.cargo&lt;/groupId&gt; &lt;artifactId&gt;cargo-maven2-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;!-- 针对插件进行的配置 --&gt; &lt;configuration&gt; &lt;!-- 配置当前系统中容器的位置 --&gt; &lt;container&gt; &lt;containerId&gt;tomcat6x&lt;/containerId&gt; &lt;home&gt;D:\\DevInstall\\apache-tomcat-6.0.39&lt;/home&gt; &lt;/container&gt; &lt;configuration&gt; &lt;type&gt;existing&lt;/type&gt; &lt;home&gt;D:\\DevInstall\\apache-tomcat-6.0.39&lt;/home&gt; &lt;!-- 如果Tomcat端口为默认值8080则不必设置该属性 --&gt; &lt;properties&gt; &lt;cargo.servlet.port&gt;8989&lt;/cargo.servlet.port&gt; &lt;/properties&gt; &lt;/configuration&gt; &lt;/configuration&gt; &lt;!-- 配置插件在什么情况下执行 --&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;cargo-run&lt;/id&gt; &lt;!-- 以下总的意思是，当执行install声明周期时，执行插件run目标 --&gt; &lt;!-- 生命周期的阶段 --&gt; &lt;phase&gt;install&lt;/phase&gt; &lt;goals&gt; &lt;!-- 插件的目标 --&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 执行mvn deploy 命令 tips：一般这个命令不在eclipse中使用，因为eclipse中启动后无法停止(无法输入 ctrl + c取消)，一般在命令行中使用 查找依赖信息网站搜索需要的 jar 包的基本依赖信息：http://mvnrepository.com/","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"项目构建","slug":"项目构建","permalink":"http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"}]},{"title":"网络资源库","slug":"网络资源库","date":"2021-03-14T13:11:32.000Z","updated":"2021-08-25T15:27:11.829Z","comments":true,"path":"2021/03/14/网络资源库/","link":"","permalink":"http://yoursite.com/2021/03/14/%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E5%BA%93/","excerpt":"","text":"专属下载器：复制链接后在新标签页打开","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"个人文档","slug":"个人文档","permalink":"http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%96%87%E6%A1%A3/"}]},{"title":"JavaSE基础","slug":"JavaSE基础","date":"2021-03-04T03:40:32.000Z","updated":"2021-08-25T15:27:11.848Z","comments":true,"path":"2021/03/04/JavaSE基础/","link":"","permalink":"http://yoursite.com/2021/03/04/JavaSE%E5%9F%BA%E7%A1%80/","excerpt":"","text":"语言概述语言历史​ 创始人：java之父James Gosling SUN(Stanford University Network，斯坦福大学网络公司 )1995推出 1991年 Green项目，开发语言最初版本命名为Oak (橡树) … 2004年，发布里程碑式版本：JDK 1.5，为突出此版本的重要性，**更名为JDK 5.0** 2005年，改名J2SE -&gt; JavaSE(桌面级)**，J2EE -&gt; **JavaEE(企业WEB)**，J2ME -&gt; **JavaME 2009年，Oracle公司收购SUN，交易价格74亿美元 … 2014年，**发布JDK 8.0**，是继JDK 5.0以来变化最大的版本** … 2018年3月，发布JDK 10.0，版本号也称为18.3(改为时间命名)号称每月一更 2018年9月，发布JDK 11.0，版本号也称为18.9 语言特点 java是一种半编译半解释型语言 面向对象：类、对象、封装、继承、多态 健壮性：垃圾回收机制(GC机制)，但仍存在内存泄漏与溢出。c通过malloc与free手动管理) 跨平台性：java虚拟(JVM)，write once,run anywhere 一次编译，到处运行 开发环境JDK&amp;JRM&amp;JVM JDK ：Java开发工具包 (Java Development Kit), 用与开发及运行 JDK = JRE+开发工具集 Java开发工具：javac.exe (编译工具) ，jar.exe(打包工具)等 JRE：Java运行环境(Java Runtime Environment)，仅用于运行java项目 JRE = JVM+Java SE标准类库 JVM：Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等 环境搭建下载安装JDK官网，一键式傻瓜安装。可自定义安装路径，但注意安装软件的路径中不能包含中文、空格。(建议安装文件夹保留JDK版本号) 配置环境变量配置path环境变量： 进入系统变量设置：(win10)计算机，右键属性，高级系统变量，环境变量 把安装JDK的bin目录路径添加到环境变量path中(若不存在path则新建) 方式1：直接把JDK下的bin目录路径添加到path变量中即可 方式2(推荐)： 在系统变量中新建名为JAVA_HOME，值为JDK目录路径的环境变量 在path中通过引用的方式添加，即在path中添加 %JAVA_HOME%\\bin; (注意win10末尾无需分号) 新建JAVA_HOME变量如下图 在Path环境变量中引用JAVA_HOME在bin目录下配置如下图 Tips：推荐使用方式2，后续tomcat运行环境需识别JAVA_HOME 验证配置注意，要重新打开一个新的cmd窗口输入javac命令显示如下内容信息则安装成功，java -version只能检查是否安装了jdk，不能检查有关环境变量的配置。 常见问题 重写打开一个新的cmd窗口测试javac 尝试把java的环境变量的位置以至最前面(防止部分功能失效) win10环境下配置环境变量，无需添加末尾的分号’;’ JDK内容概要默认安装路径：C:\\Program Files\\Java\\jdk1.8.0_144 bin – 开发工具（常用，javac.c 编译，java.exe 解析运行，javadoc.exe，生成文档） db – java 实现的数据库 include – 含c语言编写的头文件 jre – java运行时环境 lib – 存放jar包 src.zip – 存放java开源代码，一些常用的类库(IDE中查看源码可引用它) JDK主要的包(packed)介绍 java.lang(language)：包含一些Java语言的核心类，如String、Math、Integer、 System和 Thread，提供常用功能 java.net：包含执行与网络相关的操作的类和接口 java.io：包含能提供多种输入/输出功能的类 java.util：包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数 java.text：包含了一些java格式化相关的类 java.sql：包含了java进行JDBC数据库编程的相关类/接口 java.awt：包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 B/S C/S 环境变量详解 path环境变量：windows系统在cmd内执行命令时要搜寻的路径。配置path环境变量可实现在任何目录下都可以执行配置在path内容里的程序的效果。 环境变量类型：用户变量针对当前用户有效。系统变量，针对所有用户有效 cmd命令的搜索逻辑：从当前目录—&gt;path路径(从前往后) 环境变量值格式：由绝对路径组成。多个值用分号“;” (win7)隔开或(win10) 通过” 新建”的方式直接添加。 %**JAVA_HOME%\\bin;中“%%”表示获取这个环境变量的值** 一台电脑允许同时安装多个版本JDK，实际使用哪个，却决与环境变量的指定 官方JDK安装过程会弹出两个安装框，一个是JDK安装，一个是独立的JRE安装，其实理论上安装JDK已经包含JRE，这个多出来的独立安装的JRE为了方便eclipse识别而安装，建议安装。 Java程序运行逻辑执行逻辑 编译及运行命令 编译.java文件：javac XXX.java (需含.java后缀) 同目录下会编译出.class字节码文件，该字节码文件名由代码中class类名决定的 运行.class文件：java .class文件名 (无需.class后缀) 演示 新建一个HelloWorld.java结尾的文件 12345class HelloChina&#123; public static void main(String []args)&#123; System.out.println(&quot;hello,world!&quot;); &#125;&#125; 编译及运行 补充说明 javac命令因在Windows平台下执行，因此不区分大小写 java命令是涉及java中的的执行，java是严格区分大小写的 任何书写语法都没错，但还是报出“错误：找不到或无法加载主类”，有可能电脑配置了classpath的环境变量，classpath的配置表示使所有**.class文件**的执行都往该路径去寻找，导致在classpath路径下找不到对于执行的.class文件，因此提示错误。只需要删除classpath环境变量即可 public class 在一个java源文件中可以声明多个类，但一个源文件中只能有一个类能声明public， 而且声明public的类的类名必须与源文件文件名相同，才不会出现编译错误 存在多个class的源文件编译会生成对应的多个字节码文件，java.exe只需执行含main方法的类即可 基本语法注释​ java包含三种注释：单行注释、多行注释、文档注释(java特有) 文档注释文档注释：通过指定的注释格式，使注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。可以进入生成的文件夹，打开index.html即可。 注释格式：javadoc 工具默认只处理以 public 或 protected 修饰的内容 123456789101112/**@author 指定java程序的作者@version 指定源文件的版本文本内容，在类头部形成对class的文档注释*/public class XXX&#123; /** 在方法头部形成对方法的一个文档注释 */ method();&#125; javadoc命令使用：javadoc –d filename –author –version javaFile.java bug： 错误提示：javadoc 编码GBK的不可映射字符 原因：由于jdk是国际版的, 在编译时, 如果没有使用-encoding参数指定java源程序的编码格式, javac.exe则会获取操作系统默认的编码格式. 解决方案： 方案1：追加指定编码命令：javadoc -d filename -author -version -encoding utf-8 HelloWorld.java 关键字、保留字、标识符 关键字：被Java语言赋予了特殊含义，用做专门用途的字符串。如**int、for、class…**（小写单词） 保留字：现Java版本尚未使用，但以后版本可能会作为关键字使用。如：goto 、const 标识符(Unicode编码)**：凡是自己可以起名字的地方都叫标识符 (为了提高阅读性，要尽量意义，“见名知意**”) 规则： 由26个英文字母大小写，0-9，**_或$**组成 数字不可以开头，不可以使用关键字和保留字，但能包含关键字和保留字 Java中严格区分大小写，长度无限制。 标识符不能包含空格。 命名规范 包名：多单词组成，所有字母小写，xxxyyyzzz 类名、接口名：多单词组成时，所有单词的首字母大写，XxxYyyZzz(大驼峰) 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写，xxxYyyZzz(小驼峰) 常量名：所有字母都大写。多单词时每个单词用下划线连接，XXX_YYY_zzz 数据类型类型分类 数据类型 内存空间 默认值 表示范围 byte 1 byte (20) 0 -128 ~ 127 short /char 2 byte (21) 0 -215~215-1 / 0 ~ 216-1 (无符号整型) int 4 byte (22) 0 -231~231-1(约21亿) long 8 byte (23) 0L 或 0l -263~263-1 float 4 byte 0.0F 或 0.0f double 8 byte 0.0 整型与浮点型初始化 Java的整型常量默认为 int 型，因此声明long型常量须后加 ‘l’或‘L’ Java 的浮点型常量默认为double型，因此声明float型常量，须后加‘f’或‘F’ 无论是赋值语句的数字还是字面常量的数字，只要是整型数字 java就认为是int，只要浮点数字就认为double 123456789101112//编译成功，但bigValue并非long型，而是int型long bigValue = 100;/*编译失败 ，系统不会把 9999999999999 当成long类型处理所以超出 int 的表数范围，从而引起错误*/ long bigValue1 = 9999999999999;//下面代码是正确的，在巨大的整数值后使用 L 后缀 ，强制使用long 类型long bigVa1ue2 = 9223372036854775807L;//编译失败，12.3默认是double型，大类型转小类型必须加强制转换符，或改为12.3ffloat f1 = 12.3; 整数型 整数值的4种表示方式 1234567891011//定义两个 8 位的二进制整数// 注意，计算机底层都是以补码的方式存储数据的int binVal1 = 0b11010100; byte bnVal2= 0B01101001;//以 0 开头的整数值是八进制的整数int octa1Va1ue = 013 ; //0~9组成的十进制整数int decValue = 10;//以 0x 或0X 开头的整数值是十六进制的整数int hexVa1uel = 0x13 ; int hexVa1ue2 = 0XaF; 字符型 字符型的3种表示方式 123456//直接指定单个字符作为字符值char aChar = &#x27;a&#x27;; //使用转义字符来作为字符值char enterChar = &#x27;\\r&#x27;; //使用 Unicode 编码值来指定字符值char ch = &#x27;\\u9999&#x27;; 常用acsii编码字符 字符 ASCII码 a ~ z 97 ~ 122 A ~ Z 65 ~ 90 0 ~ 9 48 ~ 57 常见编码积累 Windows CMD 默认编码是：ANSI编码，即GBK编码 UTF-8 是 Unicode 编码的一种形式，是国际最通用的编码 浮点型 浮点型的2种表示方式 十进制数形式：如5.12 、512.0 、.512 。浮点数必须包含一个小数点 科学计数法形式：例如 5.12e2 (即 5.12x102)，5.12E2 也是5.12x102 float：单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求 虽说float只占4个字节，但因为尾数表示方式，表示数值的范围比long还大 double：双精度，精度是float的两倍。通常采用此类型。 小结：整型通常使用int类型，浮点型通常使用double 类型间转换类型间运算及其转换(不含boolean) 自动类型转换 自动类型转换发生在不同数据类型之间进行运算时，结果自动提升为容量大的数据类型。 当byte、char、short三种类型之间任何两种，包括自身两种变量做运算时，结果都转换为int型 如：byte + byte = int….、byte + short = int 、char + byte = int 、char + short = int 示例代码 123456//相关练习与测试System.out.println(&quot;* *&quot;); //* *System.out.print1n(&#x27;*&#x27; + &#x27;\\t&#x27; + &#x27;*&#x27;); //93System.out.println(&#x27;*&#x27; + &quot;\\t&quot; + &#x27;*&#x27;); //* *System.out.printin(&#x27;*&#x27; + &#x27;\\t&#x27; + &quot;*&quot;); //51*System.out.println(&#x27;*&#x27; + (&#x27;\\t&#x27; + &quot;*&quot;)); //* * 强制类型转换 自动类型转换的逆运算，加强制转换符 ()，注意精度损失，或溢出 12double d = 100.0;int i = (int)d; String与其他类型的运算：String可以和8种基本数据类型变量做+运算，且运算只能是连接运算，运算的结果仍然是String类型 123int number = 100;String numberStr = &quot;学号&quot;;System.out.println(numberStr + number);//输出 &quot;学号100&quot; 无论是自动转换还是强制转换，只能适用数值间的转换，即强制类型转换符()也只适用数值的数据类型 运算符算术运算符 前至++与后至++ 前置++：++i，先自增，后使用 后置++：i++，先使用，后自增 ++与–的特点：不改变原数据类型的情况下进行++与–，效率高 无论前置还是后置++还是–，均改变变量，i++ == i = i +1 1234short s1 = 10;s1 = s1 + 1;//编译失败，int不能直接转换为shorts1 = (short)s1 + 1 //正确写法，效率低，截断方式s1++; //编译运行均通过，正确写法，效率高 /除运算： 无论在什么地方，两个int型相除，结果一定为整型 1double result = 12 / 5; // result = 2.0; %模运算/取余： 模运算 = 前除后，求余数 java规定，结果的符号与被模数(前面的数)的符号相同 模运算式 结果 0 % 1 0 0除以任何数=0，不会存在余数 1 % 0 error 0不能作除数，作分母，溢出 2 % 1 0 整除余0 7 % 5 2 够除 1余2 2 % 3 3 不够除：0余2 12 % -5 2 符号由被模数决定 -12 % -5 -2 同上 赋值运算符 复合/扩展运算符： 基本原理：num1 +=2; 等价 num1 = num1 + 2; 特点，同++一样，复合赋值运算符同样可以在不改变原数据类型情况下运算，更加高效 12short s1 = 1; s1 += 2;//编译运行均通过int i = 1; i *= 0.1; //编译运行均通过 输出0 综合练习 12int n = 10;n += (n++) + (++n); //n = n + (n++) + (++n); n = 10 + 10 + 12 逻辑运算符 布尔 数值(按位与) &amp; if( true &amp; num++ )，全部执行 二进制按位与 &amp;&amp; 短路与：if ( true &amp;&amp; num++ )，可得出结果就停止执行，即num++不执行 注意：**&amp;，|，^这三个运算符同为逻辑运算符与位运算符，具体表示哪种，取决于参与运算对象**是数值还是布尔值 位运算符位运算类型 位运算符 含义 &amp; 按位与 | 按位或 ^ 按位异或 ~ 按位取反 &lt;&lt;n 左移n位右补零 &gt;&gt;n 按位右移n位，补最高位(正数0，负数1) &gt;&gt;&gt; 无符号右移，空缺位均补零 tips：注意，真正对计算机数值数据移位也是移动该数值的补码，如 -5 &lt;&lt; 2结果如下 位运算技巧 示例代码 12345678910111213141516171819202122232425262728//1、你能否写出最高效的2 * 8的实现方式？ 2 &lt;&lt; 3 或 8 &lt;&lt; 1//2、交换两个数值变量的几种方式int num1 = 10;int num2 = 20;System.out.println(&quot;num1 = &quot; + num1 + &quot;,num2 = &quot; + num2);//方式一：定义临时变量的方式//推荐的方式//int temp = num1;//num1 = num2;//num2 = temp;//方式二：好处：不用定义临时变量 //弊端：① 相加操作可能超出存储范围 ② 有局限性：只能适用于数值类型//num1 = num1 + num2;//num2 = num1 - num2;//num1 = num1 - num2;/*方式三：使用位运算符 num1=(numl ^ num2)^num2; num2=(num2 ^ num1)^num1;*///有局限性：只能适用于数值类型num1 = num1 ^ num2;num2 = num1 ^ num2;num1 = num1 ^ num2;//此时num2 == num1System.out.println(&quot;num1 = &quot; + num1 + &quot;,num2 = &quot; + num2); 三元/目表达式 格式：表达式1 ? 表达式2 : 表达式3 ​ 含义：若表达式1为真，整个条件表达式返回表达式2的结果反之表达式3的结果 三元运算符可以嵌套使用 若程序使用三元运算符，又可以使用if-else结构，优先选择三元运算符。原因：简洁、执行效率高。 表达式1和表达式2不要求完全一致，但必须可兼容为其中一种类型 对于数值基本数据类型，使用三元运算符还会想使用比较运算符那样进行自动类型转换 1System.out.println(true ? 3 : 4.0);//输出3.0，自动转换为double型 比较运算符 ‘==，&gt;，&lt;，&gt;=，&lt;= ‘：粗略来说，比较运算符只能用于数值类型(类型不一定完全相同，底层是数值即可) 特别说明，’==’ 也可以在引用类型中使用，但也聚焦在数值上(地址值) 流程控制顺序结构分支结构if-else结构 if：符合则执行 if - else：2选1 if - else if - else ：n选1 若if-else结构中只有一条执行语句，则可以省略{} 同时，省略{}的if语句的else总是与最近的未匹配的if匹配 switch结构语法逻辑 执行逻辑：根据switch表达式的值，依次匹配各个case中的常量。一旦匹配成功，则执行case结构中语句。若此时没有遇到break语句，则不判断地直接继续向下执行其他case结构中的执行语句，直到遇到break关键字或末尾结束为止。(为更好理解，表达式与case 后语句划上等号进行的判断) 表达式支持6种数据类型：byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增) 把default语句理解成为一个无条件case语句则一切明了。 1234567891011121314151617181920212223242526//例1：常见方式switch(表达式)&#123; case 常量表达式1 : 语句1;//break; … case 常量表达式n : 语句n;//break; default : 语句n+1;&#125;//输出1，2，3，4int i =1;switch(i)&#123; case 1:System.out.println(&quot;1&quot;); case 2:System.out.println(&quot;2&quot;); case 3:System.out.println(&quot;3&quot;); case 4:System.out.println(&quot;4&quot;);&#125;//例2：多个case共用一条语句//应理解为，每个case的执行语句都为空，且没有break，因此连续执行//不应该理解为内嵌case语句//值为‘A\\B\\C’都执行语句1switch(表达式)&#123; case ‘A’ : case ‘B’ : case ‘C’ : 语句1;break; …&#125; 编写经验若多个条件表达式之间的关系是： “互斥“关系(或没有交集的关系),哪个判断和执行语句声明在上面还是下面，无所谓 交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面 有包含的关系，通常情况下，需要将范围小的声明在范围大的上面。否则，范围小的就没机会执行了 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//例1：class Person &#123;&#125;class Student extends Person &#123;&#125;class Graduate extends Student &#123;&#125;public class InstanceTest &#123; public static void main(String[] args) &#123; InstanceTest test = new InstanceTest(); test.method(new Student()); &#125; public void method(Person e)&#123; //错误写法,每次执行第一个if //if(e instanceof Person)&#123;// System.out.println(&quot;a graduated student&quot;);// System.out.println(&quot;a student&quot;);// System.out.println(&quot;a person&quot;);// &#125;else if(e instanceof Student)&#123;// System.out.println(&quot;a student&quot;);// System.out.println(&quot;a person&quot;);// &#125;else if(e instanceof Graduate)&#123;// System.out.println(&quot;a person&quot;);// &#125; //方式一，包含关系应将范围小的在范围大前判断 if(e instanceof Graduate)&#123; System.out.println(&quot;a graduated student&quot;); System.out.println(&quot;a student&quot;); System.out.println(&quot;a person&quot;); &#125;else if(e instanceof Student)&#123; System.out.println(&quot;a student&quot;); System.out.println(&quot;a person&quot;); &#125;else&#123; System.out.println(&quot;a person&quot;); &#125; //方式二 if(e instanceof Graduate)&#123; System.out.println(&quot;a graduated student&quot;); &#125; if(e instanceof Student)&#123; System.out.println(&quot;a student&quot;); &#125; if(e instanceof Person)&#123; System.out.println(&quot;a person&quot;); &#125; &#125;&#125; 循环结构相关关键字 break：结束当前循环体的循环 continue：结束当次循环体当的循环 break与continue语句后均不能声明执行语句 break与continue只作用在离关键字最近的循环体 带标签break与continue语句使用：可指定作用在哪一层循环结构 在拟作用循环体前声明标签：label : for() 在break或continue语句后追加标签民：break label; 12345678910label:for(int i=1;i&lt;=4;i++)&#123; for(int j = 1;j &lt;= 10;j++)&#123; if(j % 4 == 0)&#123; //break;//默认跳出包裹此关键字最近的一层循环。 //continue; break label;//结束指定标识的一层循环结构 //continue labe1；//结束指定标识的一层循环结构当次循环 &#125; System.out.print(j); &#125; for循环 for内的变量只在for中有效 123456//首次执行：1-&gt;2-&gt;3-&gt;4//循环执行：2-&gt;3-&gt;4，2-&gt;3-&gt;4...//可输入多个语句用逗号“，”for( 1,?,? ; 2 ; 4)&#123; 3&#125; while循环123456//首次执行：1-&gt;2-&gt;3//循环执行：2-&gt;3,2-&gt;3...1while(2)&#123; 3;&#125; do-while循环 do-while循环至少会执行一次循环体！ 1234567//首次执行：1 - 3 - 4 //循环执行：2 - 3 - 4 1do&#123; 3; 4;&#125;while(2); 数组一维数组基本概念 数组的类型可以是基本数据类型，也可引用数据类型 数组是引用数据类型，必须含new，含方法，含属性(常用length) 数组长度一旦确定，就不可修改 声明与初始化含静态初始化，动态初始化 静态初始化：指定数组元素的初始值，由系统决定数组长度 动态初始化：指定数组长度(可以是变量)，由系统为数组元素分配初始值 数组初始化默认值 整型：0 浮点型：0.0 char型：0或’\\u0000’，而非’0’ boolean型：false 用数据类型：null 12345int [] ids;//声明ids = new ids[]&#123;1001,1002,1003&#125;;//初始化int[] a = &#123;5,6,7,8&#125;//简化语法格式String[] names = new String[4];//动态初始化，数组长度可以是变量 数组的内存解析 待补充，暂时不需要 多维数组基础概念 从数组底层的运行机制上来看(线性内存，多维映射)，没有多维数组 把多维数组看成多个一维数组的内嵌，如二维数组是一个一维数组，每个数组元素也是一个数组 二维数组使用初始化 Java二维数组动态初始化有别于C语言 Java：半自动初始化：new int[3][]; C语言：全自动初始化：int[][3]; 示例代码 123456int[][] arr1 = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;//静态初始化String[][] arr2 = new String[2][3];//动态初始化String[][] arr3 = new String[3][];//动态初始化，但不能直接使用，还需实例化列才可使用 //注意，指定哪个(实例化哪个)用哪个可用arr3[0] = new String[4]; 获取长度 1234int[][] arr1 = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;arr1.length;//3arr1[0].length;//3arr1[1].length;//2 内存解析 示例代码 12345678910111213//规定：二维数组分为外层数组的元素，内层数组的元素int[][] arr = new int[4][3];//外层元素：arr[0],arr[1]等//内层元素：arr[0][0],arr[1][2]等//数组元素的默认初始化值 int[][] arr = new int[4][3];//外层元素的初始化值为：地址值//内层元素的初始化值为：与一维数组初始化情况相同 int[][] arr = new int[4][];//外层元素的初始化值为：null//内层元素的初始化值为：不能调用，否则报错。 图示分析 常见异常 ArrayIndexOutOfBoundsException：角标越界异常 NullPointerException：空指针异常 面向对象基础概念 类：对一类事物的描述，是抽象的，概念上的定义 对象：某个类的具体实体，也成为实例(instance)，创建一个对象 == 实例化 属性：类中的成员的变量(field)，调用 对象.属性; 行为：类的成员的方法(method)，调用 对象.方法() 类成员：属性、方法、构造器、代码块、内部类 属性与局部变量属性 直接定义在类的一对{}内 声明属性可指明其权限：private、public、缺省(默认不写权限)、protected 局部变量 声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量 不可使用权限修饰符 方法方法的创建123public static void method(String name)&#123; System.out.println(name);&#125; 形参与实参12method(&quot;Tom&quot;);//传入的为实参public void method(String name)&#123;&#125;//方法参数。形式参数 重载“两同一不同”。与权限修饰符、返回值类型、形参变量名、方法体均无关(按可区分调用角度理解即可) 同一个类、相同方法名 参数列表不同：参数个数不同，参数类型不同 可变个数形参可变个数形参(jdk 5.0)格式：数据类型 ... 变量名,如 String...strs tips：当方法不止一个形参且含可变形参时，可变形参只能置于末尾，否则编译不通过(不可区分变量类型) 12//public void show(String...strs,int i); //错误情况，public void show(int i,String...strs);// 正确情况 内在逻辑：除与数组作为新参的实参传入格式不一样外(可变形参用逗号)，可变个数形参等价于数组 因此可与数组类型构成重写 12345678show(&quot;Tom&quot;,&quot;Wang&quot;,&quot;Deng&quot;)//可连续传入多个数据，用逗号隔开。show(new String[]&#123;&quot;Tom&quot;,&quot;Wang&quot;,&quot;Deng&quot;&#125;);//同样可以通过数组的方式传入实参public void show(String...strs)&#123; for(int i = 1;i &lt; stes.length;i++)&#123;//等价与数组 System.out.println(strs[i]); &#125; &#125;public void show(String name)&#123;&#125;//可以构成重载 return关键字 无返回值：结束当前方法 有返回值：结束当前方法且返回指定变量 匿名对象 匿名对象：new Person().run(); 匿名对象只能调用一次 值传递机制Java方法参数传递方式只有一种，值传递！ 基本数据类型：变量值 引用数据类型：地址值 String与值传递机制 字符串是存储在字符串常量池，是不可变(特性)的字符序列 当字符串常量池中已经有相同的字符串，则直接复用执行该字符串的地址 123456String s1 = &quot;hello&quot;;method(s1);System.out.println(s1);//仍输出hello public void method(String str)&#123; str = &quot;hi~&quot;;&#125; String确实是引用数据类型，值传递也确实在传递s1的地址值，但由于字符串常量池的特性(不可变序列)导致没有改变 由于字符串在java中大量使用，因此JVM特意开辟一个空间专门用于存储字符串，若同时又两个相同的字符串，常量池只记录一个 在字符串常量池创建字符串”hello”，因为字符串底层是通过char[]存储的，确定后是不可变的字符序列 把“hello”字符串与s1关联起来 调用方法时，实参传入s1的地址值，并赋值给str 由于字符串常量池不可变的特性，拟赋值的“hi~~”字符串只能新建一份 并将“hi~~”字符串与赋值语句中的str关联 例题分析12345678910public class Test&#123; public static void main(String[] args)&#123; int a = 10; int b = 10; //需实现调用method方法后，打印除a=100,b=200,请写出method方法代码 method(a,b); System.out.println(&quot;a=&quot; + a); System.out.println(&quot;b=&quot; + b); &#125;&#125; 由于Java基本数据类型无指针操作，若想通过方法调用实现交换两个基本数据类型的值。严格来说是不行的 1234567891011121314151617181920212223//实现方式1：方法内打印，立即终止程序public static void method(int a,int b)&#123; a = a*10; b = b*10; System.out.println(&quot;a=&quot; + a); System.out.println(&quot;b=&quot; + b); System.exit(0);//终止程序&#125;//实现方式2：方法重写/覆盖 public static void method(int a,int b)&#123; PrintStream ps = new PrintStream(System.out)&#123; @Override public void println(String x)&#123; if(&quot;a=10&quot;.equals(x))&#123; x = &quot;a=100&quot;; &#125;else if(&quot;b=10&quot;.equals(x))&#123; x = &quot;b=200&quot;; &#125; super.println(x); &#125; &#125;; System.setOut(ps); &#125; 若想通过调用一个方法实现数组两个元素值交换，则必须通过引用类型作为引导媒介进行交换 123456//例：若想通过调用一个方法的形式交换数组中某两个值，只能如下写法public void swap(int[] arr,int i,int j)&#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125; 封装基础概念 高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉； 低耦合 ：仅对外暴露少量的方法用于使用 封装性的一些体现：具体体现在面向对象程序设计上 属性私有化(private)、公共(public)方法来调用 不对外暴露的私有方法 单例模式… 权限修饰符修饰符类型权限修饰符： private、缺省(默认不写权限)、 protected、 public(从小到大)，可添加到类的成员与类(class)前 可修饰对象类成员可修饰类型：：属性、方法、构造器、内部类、代码块 注意：以下权限范围的调用对象类成员，是类的成员可以不可被调用，不是类可不可以创建 常用private与public，需注意是(缺省)与protected的对比 修饰符 类内部 同一个包 不同包的子类 同一工程 private Yes (缺省) Yes Yes(需注意) protected Yes Yes Yes(需注意) public Yes Yes Yes Yes 类 类：仅允许public与缺省(default) package结构在jdk9之前都没有统一的管理结果，可通过import导入指定的包/类 构造器基础语法12//创建类的对象：new + 构造器Person p = new Person(); //new Person()就是调用构造器 隐式语法 子类实例化加载前是先对其父类及所有间接父类先加载，通过从子类构造器一直往上调用父类的构造器 因此没显式的定义类的构造器的话，则系统默认提供一个空参的构造器 当构造器的首行没有显式地使用this()或super()关键字调用指定的构造器结构时，默认构造器首行存在一个super()语句。 构造器不可定义返回值，其实构造器的作用就是返回引用的地址值，因此不能自定义 其他语法 一个类中定义的多个构造器，彼此构成重载 一旦显式的定义了类的构造器之后，系统就不再提供默认的空参构造器 一个类中，至少会有一个构造器 JavaBeanJavaBean：由java语言编写的可重用组件 类是公共的 有一个public的无参构造器 有属性，且含属性对应的getter和setter方法 this关键字基本含义 this理解为“当前创建的对象”，即谁调用this，谁就是this 可调用的结构：属性、方法；构造器 属性与方法解决形参与属性同名时，通过this特指类成员的属性/方法 格式：this.field; 或 this.method(); 123456class Person&#123; String name; public Person(String name)&#123; this.name = name;//同名解决 &#125;&#125; 构造器用于构造器中调用其他重载构造器，常用于解决重载构造器代码冗余问题 调用空参构造器：this(); 构造器内部，只能使用一次this调用其他构造器 构造器中”this(形参列表)”必须声明在当前构造器的首行 由于子类构造器默认必须存在调用父类构造器的操作，因此子类构造器间的调用不能构成死循环 在自身构造器中不能再调用自身构造器 同理如类中有n个构造器，则最多有 n - 1构造器中使用了”this(形参列表)” 12345678910111213141516171819202122232425262728//需求：Person初始化时，均需要调用的一相同的部分初始化代码//则可以使用this()方式调用指定的重载构造器class Person&#123; private String name; private int age; public Person()&#123; //通用的初始化逻辑 System.out.println(info); &#125; public Person(String name)&#123; this();//其他构造器调用空参构造器逻辑即可 this.name = name; &#125; public Person(int age)&#123; this();//其他构造器调用空参构造器逻辑即可 this.age = age; &#125; public Person(String name,int age)&#123; this(age);//还可以通过形参指定构造器调用 this.name = name; &#125;&#125; UML简述 UML简述 package基本功能 为了方便管理项目中的类，提供包的概念，一个包含多个类 使用package关键字声明类或接口所属的包时，应声明在头部 MVC规范定义 Model 模型层：处理数据 数据对象封装：model.bean/domain 数据库操作类：model.dao 数据库：model.db Controller 控制层：处理业务逻辑 应用界面相关：controller.activity 存放fragment：controller.fragment 显示列表的适配器：controller.adapter 服务相关的：controller.service 抽取的基类：controller.base View 视图层： 显示数据 相关工具类：view.utils 自定义view：view.ui import功能与语法 在源文件中显式的使用import关键字结构导入指定包下的类、接口 可以使用xxx.*(通配符)方式，表示可以导入xxx包下的**所有结构 **import java.util.*; 如果使用的类或接口是java.lang包下定义的，则可以省略import结构 如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示 1234567891011//若存在com.test.java1.Account与com.test.java2.Account//想同时使用不同包下的Account类则至少一个使用全类名的方式使用import com.test.java1; class Test&#123; public static void main(String[] args)&#123; Account acct = new Account();//使用了com.test.java1 //通过全类名的方式指定使用 com.test.java2.Account acct2 = new com.test.java2.Account(); &#125;&#125; 通配符下的子包 当时用通配符方式导入包结构时，如需使用的该包下的子包的结构，则仍需要显式导入子包 例如： 如存在： com.test.java1 与 com.test.java1.son，则son属于com.test.java1的子包 即就算import com.test.java1.*;若使用com.test.java1.son仍需显式导入 导入静态结构 import static:导入指定类或接口中的静态结构(非类结构)，而是静态的属性和方法 12345//如JDK中System类import static java.lang.System.*;//此时所有System静态的书写和方法都被导入...//此时使用打印语句可以省略Systemout.println(&quot;Hello&quot;); 继承继承的效果继承的效果(extends：延展、扩展)： 当子类继承父类后，子类就加载了(获得了)父类的所有结构(属性、方法等)(包括间接父类、包括私有结构) 确实是把父类的结构加载到子类了，因为每一个子类对象都是独立拥有父类的结构的 但当子类调用父类的结构时是受父类结构的权限修饰符影响的，即子类是无法直接调用父类私有结构(private) 继承的作用 减少了代码的冗余，提高了代码的复用性 便于功能的扩展 为之后多态性的使用，提供了前提 继承的使用基础语法继承的格式：class A extends B&#123;&#125;，若B is A == true ，在逻辑上符合继承 A：子类、派生类、subclass B：父类、超类、基类、superclass 单继承特性Java的单继承性：一个类只能有一个父类，但可多层单继承。 子类直接继承的父类称为，直接父类 子类间接继承的父类称为，间接父类 根父类 若一个类的没有显式继承某个父类的，则此类默认直接继承于java.lang.Object类 因此可以说除java.lang.Object类外，所有java类都直接或间接的继承于java.lang.Object类 意味着，所有java类都加载了java.lang.Object类的结构，Object类也常称为根父类 方法的重写重写效果重写(override/overwrite) 当子类继承父类以后，可以对父类中同名同参的方法，进行覆盖操作(重写操作) 当子类重写了父类方法时，子类的方法将覆盖父类的方法，即会被优先调用子类重写过的方法 重写规则重写的对象 只能重写方法，属性无重写一说 子类定义父类的同名属性叫左把父类的同名属性“隐藏” 若子类与父类声明同名属性，按就近原则调用同名属性 即编译时的类型，左边的类型 多态：父类 子类：子类 无法重写父类private权限的方法：由于private权限的方法子类无法调用，无法感知，不存在重写。 无法重写父类static修饰的方法：static修饰的结果属于类的结构，不是类的成员。 且当字符类存在同名方法，而父类中声明为static时，子类必须也声明成static，但还是不属于方法重写 重写的权限修饰符 子类重写的方法的权限修饰符范围 ≥ 父类被重写方法的权限修饰符 即子类重写方法时不能降低原有父类方法的权限。 重写的返回值 void类型：只能对应void 引用数据类型：被重写的返回类型为A类型，则重写的返回类型可以是A类或A类的子类 基本数据类型：重写的返回值类型必须与被重写返回类型相同 重写的异常 子类重写的方法抛出的异常类型 ≤ 父类被重写的方法抛出的异常类型 即子类重写方法抛出的异常不能越界与父类抛出的异常。 super基本含义super关键字：特指父类的结构 可调用的结构：类this关键字，同样适用于属性、方法、构造器 super关键字定位父类结构，默认按直接父类到间接父类一层层往上找，一旦匹配则结束 属性与方法 常用于在子类中调用父类同名的属性(属性无重写之说) 常用在子类中调用父类被重写的方法 常见IDE快捷创建重写方法操作时，会默认补上一句super.method()，即对被覆盖方法的重新调用 防止某些进行了重写行为，但没有写重写方法体时，也可调用回父类被重写的方法。一种保护作用 构造器 可以在子类的构造器中显式的使用”super(形参列表)“的方式，调用父类中声明的指定的重载构造器 super对构造器的使用与this一致，必须声明在子类构造器的首行 this与super调用构造器只能二选一，不能同时出现 多态多态概念 从表意上看：多态是指一个事物在不同场合下具有多个不同的表现形式或形态的能力 代码语法层面看： 多态指，父类的引用指向子类的对象，同时对父类进行虚拟方法调用 菜鸟教程：多态就是同一个接口，使用不同的实例而执行不同操作 多态也是引用数据类型向上转型的一个过程 多态使用 多态使用语法表现：父类的引用指向子类的对象 1Person p = new Man(); 编译期/编码期：只能操作父类的结构(如属性、方法等) 运行期： 属性：调用父类的属性(属性无重写即无多态 ; 可通过向下转型调用子类的内容) 方法：默认调用父类声明的方法，若方法被子类重写则调用子类重写的方法(虚拟方法调用) 一般多态的使用，主要集中在虚拟方法的调用。一般子类继承父类都常重写父类的特定方法。 因此粗略归纳多态的使用条件可以有两点 类的继承关系 方法的重写 注：多态基于继承或实现方式形成。对于继承来说子类肯定是已经先加载了父类的所有结构，只是由于变量声明为父类类型，导致编译时只能调用父类声明的属性和方法 多态的作用 消除类型之间的耦合关系 可替换性 可扩充性，(自带，归类分配控制器，减少编写重载方法) 接口性 灵活性 简化性 多态的作用与优点不仅几段文字描述，需从面向对象程序设计思想中学习多态的作用 示例代码 Java类 1234567891011121314151617181920212223242526public class Animal &#123; public void eat()&#123; System.out.println(&quot;动物，在进食&quot;); &#125; public void run()&#123; System.out.println(&quot;动物，在跑&quot;); &#125;&#125;class Dog extends Animal&#123; public void eat()&#123; System.out.println(&quot;Dog，在进食&quot;); &#125; public void run()&#123; System.out.println(&quot;Dog，在跑&quot;); &#125;&#125;class Cat extends Animal&#123; public void eat()&#123; System.out.println(&quot;Cat，在进食&quot;); &#125; public void run()&#123; System.out.println(&quot;Cat，在跑&quot;); &#125;&#125; 测试类调用 123456789101112131415161718192021public class Test &#123; public static void main(String[] args) &#123; Animal a = new Dog(); active(a);//输出：Dog，在进食，Dog，在跑 &#125; //多态的使用，只需编写一个方法，减少重载方法的编写 public static void active(Animal animal)&#123; animal.eat(); animal.run(); &#125; //若不使用多态// public static void active(Dog dog)&#123;// dog.eat();// dog.run();// &#125;// // public static void active(Cat cat)&#123;// cat.eat();// cat.run();// &#125;&#125; 重载与重写重载 重载：不表现为多态性 对于编译器而言，这些同名方法就成了不同的方法。在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；属于一个编译型行为。 Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法 重写 重写：表现为多态性 对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法 这样的方法调用在编译时其无法确定，称为“晚绑定”或“动态绑定”。属于一个运行时行为 引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态！” 向下转型多态与类型转换 多态的从语法层面上，是一种引用数据类型向上转型的过程 相反，通过多态定义的对象，也可以通过向下转型恢复回本身的子类类型 多态的Java类可通过 ()进行强制向下转型 向下转型后的对象是子类的引用与实例，此时则可调用子类特用的属性和方法 instanceof关键字基本概念 只要是向下转型(强制类型转换)，无论是引用数据类型还是基本数据类型，都是存在风险的 基本数据类型：溢出风险 引用数据类型：转换类型不兼容风险 通常向下转型前先用instanceof 关键字判别实际类型是否符合想要转换的类型 提前避免不兼容的类型强转，报出 ClassCastException 异常 使用介绍 功能：a instanceof A：判断对象a是否是类A的类型。如果是，返回true；否则返回false。 推论：若a instanceof A == true，则A类及其A类所有直接间接父类(顶级父类Object)都返回true 因为若a是A类型，则A类型多态与它的父类或间接父类是一个很正常的合法行为 示例代码 instanceof使用 12345678910111213//使用上述例子的Animal、Dog、Cat类public class Test &#123; public static void main(String[] args) &#123; Animal a = new Dog(); //强制向下转型 Dog dog = (Dog)a;//通过 Cat cat = (Cat)a;//报错 if(a instanceof Dog)&#123; System.out.println(&quot;向下转型成功，此对象为Dog&quot;);//正常输出 &#125; &#125;&#125; 概念练习测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445//问题一：编译时通过，运行时不通过 //举例一：// Person p3 = new Woman();// Man m3 = (Man)p3; //举例二：// Person p4 = new Person();// Man m4 = (Man)p4; //问题二：编译通过，运行时也通过// Object obj = new Woman();// Person p = (Person)obj; //问题三：编译不通过// Man m5 = new Woman();// String str = new Date();class Base &#123; int count = 10; public void display() &#123; System.out.println(this.count); &#125;&#125;class Sub extends Base &#123; int count = 20; public void display() &#123; System.out.println(this.count); &#125;&#125;public class FieldMethodTest &#123; public static void main(String[] args) &#123; Sub s = new Sub(); System.out.println(s.count);//20 s.display();//20 Base b = s;//多态性 //==：对于引用数据类型来讲，比较的是两个引用数据类型变量的地址值是否相同 System.out.println(b == s);//true System.out.println(b.count);//10 b.display();//20 &#125;&#125; Object概述 java.lang.Object类是所Java类的根父类，所有类的直接或间接地继承它 因此Object类中的结构(属性、方法)就具通用性 以下主要介绍Object API结构，Object没有定义属性，只有构造器和方法 APIConstructor Object类只声明了一个空参的构造器(所有对象实例化都调用) Methods Method Descriptions Object clone() 创建该对象的副本，即对象克隆 boolean equals(Object obj) 判断this对象与obj对象是否相同 void finalize() 对象垃圾回收之前被系统自动调用，一般不主动调用 Class&lt;?&gt; getClass() 返回此对象的运行时类，即对应的Class实例 int hashCode() 生成对象的哈希值 wait重载、notify、notifyAll 多线程操作相关 注：目前详细讲解equals和toString方法 equals“==”的使用“ == ” 是一个运算符，对比数值概念上的相等，可用于基本数据类型和引用数据类型 基本数据类型：数学数值上是否相等 引用数据类型：对象的地址值是否相等，前提是比较双方类型可兼容，否则会出现编译型错误 1234567891011public static void main(String[] args)&#123; //1、基本数据类型：数值 int i = 10; double d = 10.0; System.out.println(i == d);//输出true //2、引用数据类型：地址值(数值)，此时没有重写Person的equals方法 Person p1 = new Person(&quot;小明&quot;,21); Person p2 = new Person(&quot;小明&quot;,21); System.out.println(p1 == p2);//输出false&#125; 原生定义 Object对equals的源码实现是返回的对象等号“ == ”比较的结果 即Object的equals的方法是比较两个对象的地址值是否相同 Object equals源码： 12345public class Object &#123; public boolean equals(Object obj) &#123; return (this == obj); &#125;&#125; 重写定义 实际开发中常对equals方法进行重写，用来比较两个引用类型实体内容是否相等，并非地址值 String、Date、File、包装类等都重写了Object类中的equals()方法：被重写成实体内容是否相等 示例代码： 1234567891011121314151617public static void main(String[] args)&#123; //1、未重写Object equals()方法：等同==，比较两个引用地址值 Person p1 = new Person(&quot;小明&quot;,21); Person p2 = new Person(&quot;小明&quot;,21); System.out.println(p1.equals(p2));//输出false //2、某java提供类重写了equals()实现了比较实体内容是否相等的功能 String s1 = new String(&quot;ABC&quot;); String s2 = new String(&quot;ABC&quot;); System.out.println(s1.equals(s2));//输出true //这里主要通过String new的方式说明源码重写了String的equals方法 //但通过 == 的方式直接创建字符串会因字符串常量池原理而出现== 为true情况 //String s3 = &quot;ABC&quot;; //String s4 = &quot;ABC&quot;; //System.out.println(s3 == s4);//输出true&#125; 重写范例 自实现，重逻辑引入，非绝对范例 12345678910111213141516//3、自定义重写equals方法实现自定义类实体内容上的比较//简陋版@Override public boolean equals(Object obj) &#123; if(this == obj) //若地址一致，内容则肯定一致 return true; if(obj instanceof Person)&#123; //判断前提是类型一致， Person anObj = (Person)obj; return this.name.equals(anObj.name) &amp;&amp; this.age == anObj.age; &#125;else&#123; return false; &#125;&#125;System.out.println(p1.equals(p2));//输出true IDE自动生成的标准equals 被生成Person类只有String name和int age属性 自动生成的方式equals和自编写的逻辑一直，只是其中大量使用了“判断内容先判断地址，在判断实体”的优化操作 12345678910111213141516171819202122//eclipse自动生成equals方法(标准高效参考)@Overridepublic boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Person other = (Person) obj; if (age != other.age) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true;&#125; String的equals源码重写范例 12345678910111213141516171819202122232425public boolean equals(Object anObject) &#123; //1、若引用地址都一样，则内容肯定一样(重写equals通用代码) if (this == anObject) &#123; return true; &#125; //2、若与String比较的传入类型不是String，则不允许，返回false if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length;//String底层通过char [] value;数组存储 //3、若字符序列的长度都不一样，则内容肯定不一样 if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; //4、挨个字符比较 while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 重写要求 Null-false：任何情况下，x.equals(null)，永远返回是“false” 类型一致：x.equals(和x不同类型的对象)永远返回是“false” 对称性：如果x.equals(y)返回是“true” ，那么y.equals(x)也应该返回是 “true” 自反性：x.equals(x)必须返回是“true” 传递性：如果x.equals(y)返回是“true” ，而且y.equals(z)返回是“true” ， 那么z.equals(x)也应该返回是“true” 一致性：如果x.equals(y)返回是“true” ，只要x和y内容一直不变，不管你 重复x.equals(y)多少次，返回都是“true” toString原生定义 Object对equals的源码实现是返回返回对象的字符串表示形式 即返回对象的类名 + 所在堆空间存储地址(虚拟地址) Object toString源码 1234public String toString() &#123; //类名 + 堆空间存储地址(通过hashCode计算出来数值并转换为十六进制的) return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125; 重写定义 实际开发中常对toString方法进行重写，用于打印引用类型实体的内容(一般为全部属性) 像String、Date、File、等都重写了toString()方法，Date重写后就输出时间内容 IDE对自定义类重写toString方式示例代码： 1234567@Overridepublic String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;;&#125; print与toString 其中，System.out.println(引用数据类型)，输出语句底层也是调用对象的toString方法 代码示例： 123Person p1 = new Person(&quot;ABV&quot;, 10);System.out.println(p1); //输出：com.yhd.test.Person@15db9742System.out.println(p1.toString()); //输出：com.yhd.test.Person@15db9742 源码分析： 先将所有类型即Object类型通过String.valueOf()都转换为字符串类型 在String.valueOf()方法中调用了对象的toString()方法 PrintStream.java 1234567public void println(Object x) &#123; String s = String.valueOf(x); //主要通过调用了String.valueOf(); synchronized (this) &#123; print(s); newLine(); &#125;&#125; String.java 123public static String valueOf(Object obj) &#123; return (obj == null) ? &quot;null&quot; : obj.toString();//调用了toString()&#125; 包装类背景 由于Java推出时倡导就是万物皆对象，基本数据类型显得格格不入 为了使基本数据类型的变量具有类的特征。java提供8种基本数据类型的包装类 这些包装类可以完成对应基本数据类型的所有功能操作(都含对应基本数据类型的value属性)。 同时因为封装成类，还可提供各种丰富的方法调用 包装类的作用小结如下两点： 使基本数据类型具有类的特征 由于封装成类，可提供各种丰富方法调用 注：包装类的出现不能也不是为了改变基本数据类型在java方法中只能通过return来修改内容的特性 这种特性的源泉也不能完全是java语法特性所造成，这是大部分语言的共性(由于形参是局部变量) c语言可以通过方法修改基本数据类型只是因为，c语言与&amp;指针操作符，通过传递其种子达到修改能指针指向的内容，本质还是因为形参是局部变量而不能改变指针的引用。 包装类类型 除int对应Integer和char对应Charactet，其他基本数据类型的包装类均为其首字母大写 自动装箱与拆箱 装箱：从基本数据类型转换为包装类类型 拆箱：从包装类类型转换为基本数据类型 jdk5的时候退出了自动拆箱与装箱的功能 装箱与自动装箱123456789101112//1、基本数据类型 ——&gt; 包装类//1、手动装箱：构造器封装/创建int i = 1;Integer itg1 = new Integer(i);Integer itg2 = new Integer(&quot;2&quot;);//Integer itg3 = new Integer(&quot;2B&quot;);//异常：数字格式/匹配异常System.out.println(&quot;itg1: &quot; + itg1 + &quot; , itg2：&quot; + itg2);//2、自动装箱int j = 1;Integer j_itg = j;System.out.println(&quot;j_itg: &quot; + j_itg); 拆箱与自动拆箱1234567//2、包装类 ——&gt; 基本数据类型(多种类型)//1、手动拆箱：调用包装类的 xxxValue();方法Float flt = new Float(1F);float f = flt.floatValue();//2、自动拆箱float f2 = flt; String之间的转换12345678910111213141516//1、[数值型] —— &gt; String //方式1：与空串 &quot;&quot; 进行连接运算 String s1 = i + &quot;&quot;; //方式2：调用String重载的valueOf(XXX xxx) 重载方法 String s2 = String.valueOf(i);//基本数据类型 s2 = String.valueOf(itg1);//包装类/obj多态传入 //方式3：调用包装类的toStrin方法 s2 = itg1.toString();//2、String ——&gt; [数值型] //方式1：调用包装类parseXxx()方法 String s3 = &quot;123&quot;; int num1 = Integer.parseInt(s3); 注：除了boolean，其他有关字符串的装拆箱，与转换若存在字符匹配问题都会报错，需注意 Integer缓存 Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[]，保存了从-128~127范围的整数 如果我们使用自动装箱的方式，给Integer赋值的范围在-128~127范围内时， 可以直接使用Integer[]数组中的元素，不用再去new了，从而达到节省内存消耗 12345678910111213141516171819202122232425262728@Testpublic void test3() &#123; Integer i = new Integer(1); Integer j = new Integer(1); System.out.println(i == j);//false Integer m = 1; Integer n = 1; System.out.println(m == n);//true //注意，如果数值不一样是肯定不一样的 Integer a = 210; Integer b = 211; System.out.println(a == b);//false Integer x = 128; Integer y = 128; System.out.println(x == y);//false&#125;// Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[],// 保存了从-128~127范围的整数。如果我们使用自动装箱的方式，给Integer赋值的范围在// -128~127范围内时，可以直接使用数组中的元素，不用再去new了。目的：提高效率// Integer m = 1; //-128~127范围内相当于同一个数组地址// Integer n = 1;// Integer x = 128;//相当于new了一个Integer对象// Integer y = 128;//相当于new了一个Integer对象 static基本概念 可修饰结构：属性、方法、代码块、内部类 被static修饰的结构称为类结构，随着类的加载而加载(加载要早于对象的创建) 由于随类的加载而加载，因此无需实例化对象也可以直接通过类名进行调用”类.静态结构“ 由于类只会加载一次，因此对应的静态结构也只会加载一份，存放在方法区的静态域中。因此所有类及其对象都共用一份 静态属性 被static修饰的变量称为静态变量或类变量， 由于类只会加载一次，则静态变量在内存中也只会存在一份 由于只存在一份，因此静态变量将会被同一个类多个对象共用 静态属性举例： 1234public static void main(String[] args) &#123; PrintStream out = System.out; double pi = Math.PI;&#125; 静态资源的内存结构 静态方法 同样随着类的加载而加载，可以通过”类.静态方法“的方式进行调用 在静态方法中，只能调用静态的方法或属性，而(因为静态方法和属性比对象加载的早) 同理：在静态的方法内，不能使用this关键字、super关键字(因为这些都是创建对象使用的关键字) 非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性 static应用场景共享数据 当属性是可以被多个对象共享的，不会随着对象的不同而不同的 类中的常量也常常声明为static 工具类 操作静态属性的方法，通常设置为static的 工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections 单例模式基本概念 单例模式：采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例 常见的单例模式含，懒汉式、饿汉式 代码实现 若让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private 这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象 因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象 静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的 两种单例模式编写 123456789101112131415161718192021//1、(简单/不安全)懒汉式：什么时候用，什么时候创建class Bank&#123; private Bank()&#123;&#125;//1、构造器私有化 private static Bank instance;//2、静态化 public static Bank getInstance()&#123;//2、静态化 if(instance == null) instance = new Bank(); return instance; &#125;&#125;//2、饿汉式：不管什么，先创建再说class Order&#123; private Order()&#123;&#125;//1、构造器私有化 private static Order instance = new Order();//2、直接实例化(静态只有一份) public Order getInstance()&#123; return instance; &#125;&#125; 单例模式间对比 饿汉式： 缺点：对象加载时间过长 优点：线程安全 懒汉式： 缺点：目前写法线程不安全(两个线程挤入if == null)，可以改写为线程安全 优点：延迟对象的创建 其他 网站的计数器，一般也是单例模式实现，否则难以同步 应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志 文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源 项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置 文件数据，都生成一个对象去读取 Application 也是单例的典型应用 Windows的Task Manager (任务管理器)就是很典型的单例模式 Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程 中，回收站一直维护着仅有的一个实例。 main方法概述 main()方法作为程序的入口 main()方法也是一个普通的静态方法 main()方法可以作为我们与控制台交互的方式，即将控制台获取的数据传入main函数形参String[] args eclipse参数输入 在允许程序的Run As一项，选中Run Configurations 如下图所示操作，并在Program arguments里输入参数 控制台参数输入 直接在控制台java指令最后最加内容，默认就是字符串，不用写双引号也行。 多个参数同样用逗号隔开 注意：记事本方式javac编译需把 packeage 代码去掉 输入参数获取获取方式 main函数中的String[]args字符数组就是以此存放用户输入的参数的 按一般数组处理，可以通过args[0]获取到第一个输入参数 注意，为防止角标越界，获取指定位置参数时，先判断用户是否输入了这么多参数，即判断数组length 示例 控制台用户指向命令有： java -jar TestJava.jar Tom Jerry 123 true 程序后台获取的结果为 123sysout(args[0]);//&quot;Tom&quot;sysout(args[3]);//&quot;true&quot; --&gt;Boolean.parseBoolean(args[3]);sysout(args[4]);//报异常,角标越界 代码块功能与作用 代码块的作用，用来初始化类、对象的信息 初始化类、对象信息不是构造器负责的吗？为什么还要代码块？ 与构造器相比，代码块应用场景在于类的内部私有化构造器后，用于顶替构造器的地位用于初始化，或在外部调用的情况下进行初始化 创建代码块 代码块使用：如同方法一般的声明位置，格式为&#123;&#125; 123456789public class Person&#123; private String name; &#123; System.out.println(&quot;我是代码块&quot;); &#125; &#125; 非静态代码块 随着对象的创建而执行，每创建一次执行一次，且在构造器执行前执行 多个非静态代码块，则按声明的先后顺序执行(一般只写一个) 静态代码块基本概念 代码块只能被static关键字修饰 静态代码块，随着类的加载而执行，即只执行一次 类中定义了多个静态代码块，则按照声明的先后顺序执行(一般只写一个) static修饰类同性质 静态代码块随类的加载而加载一次，非静态随对象创建而加载 静态代码块的执行要优先于非静态代码块的执行 静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构 非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法 应用场景 静态代码块，常用于给静态方法提供的看似为”静态构造器“的作用，完成一种静态的初始化(一次性初始化) 示例场景：JdbcUtils中静态代码块的使用 123456789101112131415161718192021222324252627282930313233//如JDBC连接池public class JDBCUtils &#123; private static DataSource dataSource = null; //一次性初始化/实例化，DataSource 数据库连接池 static&#123; InputStream is = null; try &#123; is = DBCPTest.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;); Properties pros = new Properties(); pros.load(is); //调用BasicDataSourceFactory的静态方法，获取数据源。 dataSource = BasicDataSourceFactory.createDataSource(pros); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; if(is != null)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //使用DBCP数据库连接池获取数据库的连接 public static Connection getConnection2() throws SQLException&#123; Connection conn = dataSource.getConnection(); System.out.println(conn); return conn; &#125; &#125; 再谈对象实例化顺序 无论使静态还是非静态，代码块都在构造器前执行 由父及子，静态先行 代码块属性赋值执行顺序：系统初始化 —&gt; 显示初始化 / 代码块初始化 —&gt; 构造器初始化 —&gt;外部调用初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.atguigu.java3;//总结：由父及子，静态先行class Root&#123; static&#123; System.out.println(&quot;Root的静态初始化块&quot;); &#125; &#123; System.out.println(&quot;Root的普通初始化块&quot;); &#125; public Root()&#123; super(); System.out.println(&quot;Root的无参数的构造器&quot;); &#125;&#125;class Mid extends Root&#123; static&#123; System.out.println(&quot;Mid的静态初始化块&quot;); &#125; &#123; System.out.println(&quot;Mid的普通初始化块&quot;); &#125; public Mid()&#123; super(); System.out.println(&quot;Mid的无参数的构造器&quot;); &#125; public Mid(String msg)&#123; //通过this调用同一类中重载的构造器 this(); System.out.println(&quot;Mid的带参数构造器，其参数值：&quot; + msg); &#125;&#125;class Leaf extends Mid&#123; static&#123; System.out.println(&quot;Leaf的静态初始化块&quot;); &#125; &#123; System.out.println(&quot;Leaf的普通初始化块&quot;); &#125; public Leaf()&#123; //通过super调用父类中有一个字符串参数的构造器 super(&quot;尚硅谷&quot;); System.out.println(&quot;Leaf的构造器&quot;); &#125;&#125;public class LeafTest&#123; public static void main(String[] args)&#123; new Leaf(); System.out.println(); new Leaf(); &#125;&#125;/*输出结果如下：Root的静态初始化块Mid的静态初始化块Leaf的静态初始化块Root的普通初始化块Root的无参数的构造器Mid的普通初始化块Mid的无参数的构造器Mid的带参数构造器，其参数值：尚硅谷Leaf的普通初始化块Leaf的构造器*/ final概述 final关键字译为“最终”，可修饰结构含类、方法、变量 final与不同修饰结构结合后具有类同的概念和功能 final Class 被final修饰的类，即为“最终的类”，不能再被延续传承下去 即final修饰的类不能被其他类所继承(无子类) 常用于表示该类已经功能完全，没有继承和重写的意义，常见有内置的API定义成final 如，String类、System类、StringBuffer类都定义成了final 1234public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; &#125; final Method 被final修饰的方法，即为“最终的方法”，不能再被延续扩充了 被final修饰的的方法不可以被重写 如：Object类中getClass() 123public final void method()&#123; &#125; final Field基本概念 被final修饰的变量，即为“最终的变量”，不能再被修改 被final修饰的变量称为常量，必须提供初始化且不能被修改，只能被使用 而变量又有类成员变量、和局部变量 静态属性类中的初始化结构 在类的结构中，有3种初始化结构：显式初始化、代码块中初始化、构造器中初始化 因此静态属性必须在3种结构之一得到初始化 静态局部变量局部变量 必须显式初始化，只能使用，不能重新赋值 形参局部变量 新参采用final修饰，表示方法体内对该变量只能使用，不能重新赋值 可以修饰基本数据类型，引用类型的形参 示例代码： 12345678910//基本数据类型形参public void method(final int i)&#123; //i++; //报错，只能使用不能赋值&#125;//引用数据类型形参public void addOne(final Person p)&#123; p.age++;//通过 p = new Person();//错误&#125; static finalstatic final 同时修饰结为两个关键字效果之和 属性：全局(静态)常量，比较常见 方法：静态方法且不可重写 抽像类基本概念 abstract译为“抽象”，可修饰，类、方法结构 abstract自身是“抽象化”的代表，是不能够直接使用，不提供具体的内容 它的存在就是被用来给子类将其从抽象化概念至变为实际的存在的概念 因此abstract只能修饰在能被其他类(子类)感知的领域，反之即abstract不能修饰如下： final的类：任何类都无法继承，不能对其提供实现。那样的抽象只有抽象本身，没有意义了 private方法：子类无法感知，更加无法重写(实现) final的方法：不允许方法的重写(实现) static方法：不属于继承范畴，是类本身的结构 abstract class基本概念 被修饰成abstract的类称为抽象类 抽象类不能实例化，但也有构造器，用于维持子类继承抽象类时实例化调用 由于抽象类本身不能被实例化，因此开发中，都会提供抽象类的子类，让子类继承抽象类进行操作 除此之外，抽象类和普通类一样，可以定义一般类的成员，如，属性、方法、代码块… 也和普通类一样具备面向对象的一般操作，如继承，多态，子类自身实例化等等 假设Person是抽象类 123//Person p = new Person();//不允许Person p = new Man();//允许，假设class Man extends Person Man m = new Man();//允许 作用 抽象类的使用具备继承特性，可多态特性，以及抽象方法特性 由于抽象类被子类所继承才由存在意义，因此抽象类自身具有绝对的继承关系 由于抽象类还可具备抽象方法，这使得抽象类比普通的父类从基于继承特性来设计类的角度上，具备比普通父类更高层次的概念抽象设计。即可定义一些抽象类本身从概念上完全无法实现，只能由子类实现的抽象方法 其次绝对的继承关系，为后续在使用多态特性提供了绝对的支持 abstract method基本概念 被abstract修饰的方法称为抽象方法 抽象方法只有声明，没有方法体：public abstract void eat(); 抽象方法只能声明在抽像类中。反之，抽象类中可以没有抽象方法的 继承抽象类的子类必须强制实现(重写)抽象父类中的所有的抽象方法，若子类也是抽象类则不用 作用 抽象方法只能在抽象类中定义，因此都是结合抽象类使用的 抽象方法使其抽象类可定义一些抽象类本身从概念上完全无法实现，只能由子类实现的抽象方法 能够提供更加抽象的抽象设计 匿名继承子类示例代码12345678910111213141516171819202122232425262728293031//抽线类Personabstract class Person&#123; public abstract void eat(); public abstract void run(); &#125;//书写步骤：Person p = new Person()&#123;&lt;回车&gt;&#125;;//创建一个匿名子类对象(其实是通过多态的一种方式实现了匿名实例化)Person p = new Person()&#123; @Override public abstract void eat()&#123; &#125; @Override public abstract void run()&#123; &#125;&#125;;//创建一个匿名子类的匿名对象//书写：method(new Person()&#123;&lt;回车&gt;&#125;);method(new Person()&#123; @Override public abstract void eat()&#123; &#125; @Override public abstract void run()&#123; &#125; &#125;); 应用场景类的设计领域 在类设计领域，抽象类的核心在于结合抽象方法提供比普通父类更高抽象化的设计 如上所述的抽象类与抽象方法的作用的基础上，对类进行设计 IO流中涉及到的抽象类：InputStream/OutputStream / Reader /Writer。在其内部定义了抽象的read()、write()方法。 Servlet API 中GenericServlet的过渡与整合设计 模板方法设计模式基本概念 抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模 板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式 当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以 把不确定的部分暴露出去，让子类去实现。 换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用， 这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽 象出来，供不同子类实现。这就是一种模板模式 程序允许时间模板示例12345678910111213141516171819202122232425262728public class TemplateTest &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub TemplateSub ts = new TemplateSub(); ts.spendTime(); &#125;&#125;//模板方法设计模式体现abstract class Template&#123; public final void spendTime()&#123; long start = System.currentTimeMillis(); code();//易变部分，不确认部分 long end = System.currentTimeMillis(); System.out.println(&quot;运行时间：&quot; + (end - start) + &quot; ms&quot;); &#125; public abstract void code();&#125;class TemplateSub extends Template&#123; @Override public void code() &#123; // TODO Auto-generated method stub for(int i = 0,j=0;i &lt; 100000;i++) j+=j; System.out.println(&quot;代码执行中...&quot;); &#125;&#125; 业务流程模板示例12345678910111213141516171819202122232425262728293031323334353637383940414243//抽象类的应用：模板方法的设计模式public class TemplateMethodTest &#123; public static void main(String[] args) &#123; BankTemplateMethod btm = new DrawMoney(); btm.process(); BankTemplateMethod btm2 = new ManageMoney(); btm2.process(); &#125;&#125;abstract class BankTemplateMethod &#123; // 具体方法 public void takeNumber() &#123; System.out.println(&quot;取号排队&quot;); &#125; public abstract void transact(); // 办理具体的业务 //钩子方法 public void evaluate() &#123; System.out.println(&quot;反馈评分&quot;); &#125; // 模板方法，把基本操作组合到一起，子类一般不能重写 public final void process() &#123; this.takeNumber(); this.transact();// 像个钩子，具体执行时，挂哪个子类，就执行哪个子类的实现代码 this.evaluate(); &#125;&#125;class DrawMoney extends BankTemplateMethod &#123; public void transact() &#123; System.out.println(&quot;我要取款！！！&quot;); &#125;&#125;class ManageMoney extends BankTemplateMethod &#123; public void transact() &#123; System.out.println(&quot;我要理财！我这里有2000万美元!!&quot;); &#125;&#125; 实际应用场景模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的 影子，比如常见的有： 数据库访问的封装 Junit单元测试 JavaWeb的Servlet中关于doGet/doPost方法调用 Hibernate中模板程序 Spring中JDBCTemlate、HibernateTemplate等 接口概念与作用类的设计角度有时须从几个类中抽取出一些共同的行为特征，而它们之间又没有is-a的关系，仅仅是具有通用的行为特征而已，此时就把这种行为特征定义成接口，比在内部声明这些行为 由若干个类构成的类型概念范畴中的共同行为特征 接口与这些类之间没有“is-a”的关系，即接口和类没有直接关系 若由关系则应该定义成类或者其父类的内部结构，如属性、方法等，不应该定义成接口 反过来说，即定义成接口概念的事物必须在一定的类型概念范畴中，具备绝对的概念上的通用性 继承是一个”是不是“的关系，而接口实现则是 “能不能“ 的关系 接口的本质是契约，标准，规范，是您支持这种功能所必须具备的一种规范的集合体 如你像实现打羽毛球的接口，那你必须实现打羽毛球这个行为能力所具备的其他行为的集合 如实现打羽毛球接口，必须实现里面所有的规范/方法，比如含羽毛球发球抽象方法()、羽毛球回球的抽象方法等等，此时当实现完这些规范的集合时，你就真正地具备类这种功能，这种行为 注意，接口不能理解为抽象类的更高抽象化层次表现，它们之间不是同一类概念。 同类一概念，或者说基于同一概念上衍生的出来的概念，应该是普通父类与抽象类之间的关系，而不是接口与抽象类之间的关系。接口和抽象类两者从概念上，定义上无任何关系。 其实太过注重语法从而导致无法真正掌握接口和普通类得概念是一个意料之外有情理之中的表现 由于初学课程介绍知识讲授时，秉持以先掌握“实”再掌握“形”的正确理念。 为了更容易建立语法体系与区分语法概念，常会以普通父类到抽线类，再到接口。从有构造器可实例化，到有构造器没实例化，到无构造器无实例化。这样的一个递进关系去解释 这就让初学者很容易陷入，它们之间就是一种递进关系。 小结：接口是“能不能”的概念，是一种在一定范畴内通用的行为特征所应具备的规范的集合体 语法层面 错误逻辑是，单从语法层面上理解，Java具备允许多实现，但只能单继承的特性 但我们不能就语法层面特性与区别，反过来去推到和理解接口和继承的含义 正确的逻辑应该是，因接口和继承类本身从概念上的不同，从而决定了接口能够多实现，而类只能单继承 接口设计示例示例1 示例2 接口的语法定义 接口使用interface关键字来定义 1interface Flyable&#123;&#125; 接口定义上的语法体现接口的定义 因秉持正确的逻辑推断，即由接口的本质去推断接口的结构与语法，即 接口是“能不能”的概念，是一种在一定范畴内通用的行为特征所应具备的规范的集合体 接口不是类的概念，更加没有继承关系 接口不存在实例化，因为接口是一种规范的集合体，本身是一种规范，是给别人实现的规范。本身就不是类和对象的概念。 同时接口从概念上就脱离了继承的概念，因此接口不存在构造器 如何定义接口的规范 接口通过抽象方法的定义来使实现类从语法层面必须基于规范的实现 由于接口就是规范的集合体，本身就以为被别人实现而存在 因此接口中的规范(抽象方法)，一定是能够被别人所感知的 因此接口中的抽象方法必有，public abstract的修饰 由于接口中的抽象方法具有统一的修饰，因此定义抽象方法时省略public abstract 即public abstract void method();等价于 void method() 接口是行为特征 接口不像类，不是会与实现类/子类构成继承层面上的关系 接口知识行为特征的规范集合体，而一个类可以拥有多个行为特征，这是合理的 因此Java中的接口可以多实现，即一个类可实现多个接口 非概念性语法描述接口自身的结构 java从语法角度上支持了除抽象方法外其他结构在接口中的定义，使其接口自身描述更丰富 JDK Version Support Structure JDK 1 public static final field; JDK 8 public static xxx mehtod(){}default xxx method(){} JDK 9 private xxx method(){} 属性java允许在接口中定义属性，但只能是全局静态常量属性，即public static final public staic：接口不具备继承特性，定义的属性不能被实现类所继承，因此只供描述接口自身使用 final：接口本身是规范的集合，可变的属性违背了接口的定义，同时也不具备使用的价值 由于接口属性只能是全局静态常量属性，因此public static final可省略 即public static final int MAX;等价于int MAX; 全局静态常量可通过接口名直接调用，Interface.field; 方法 public static xxxx method java为了便于接口对应的工具类合并，以后不用再另外新建(如Collection与Collections) 想通过接口本身充当接口的工具类，因此提供了静态方法 例如JDK8可以将Collection与Collections工具类提供的静态方法合并一起 (public) default xxxx method default不是静态方法，它需通过实现类的对象才可调用，属于一个白给的方法，不能理解为继 default方法可以被实现类重写 若实现类又继承了一个父类，而且存在与接口default的同名方法，优先调用父类的 default还要研究，只为了某些便利性？ private xxx method private方法只能有接口内部调用 其实从可以default方法开始，private方法就应该可定义 因为当接口中有明确的方法体的方法可创建时，如default方法。就应该与之对应开放出代码封装的功能，即去实现代码复用的效果 static方法显然不能作为封装代码的表现，default又有特殊含义，因此只能开放private方法供接口内部方法体编写时用于实现代码封装与复用 因此猜测是属于一种新特性支持没考虑周全的表现 接口的实现 接口通过让实现类以implements关键字方式实现接口 当实现类实习某个接口时，必须实现该接口定义的所有规范(抽象方法) 接口多态性 接口和类是从语法角度上是并列的 此时可以通过让接口引用指向实现类的对象，来形成多态性 类同普通类的多态效果 编译时：调用接口中定义的方法 运行时：执行实现类实现的方法 12//示例List&lt;String&gt; list = new ArrayList&lt;&gt;(); 接口间的继承 接口可以通过extends关键字继承父接口 当子接口继承父接口后，子接口拥有父接口的所有结构，且不要求子接口实现的抽象方法 java中接口实际支持多继承 其他 接口和类是从语法角度上是并列的，均只能public 和 缺省两种修饰符修饰 匿名实现类 接口匿名实现类：同抽象类的匿名实现类创建方式 应用场景类的设计领域 接口对于类的设计，反应客观世界的新的关系具有非常重要的作用 是面向对象程序设计不可或缺的概念 相关设计模式代理模式 安全代理：屏蔽对真实角色的直接访问 远程代理：通过代理类处理远程方法调用（RMI） 延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象 比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有 100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理 模式，当需要查看图片时，用proxy来进行大图片的打开。 分类 静态代理（静态定义代理类） 动态代理（动态生成代理类） JDK自带的动态代理，需要反射等知识 工厂模式 工厂模式指让创建对象的工作交付给一个类 而且可以通过设置工厂类的某些参数定制化地自动地产生对应的定制化的类 就如同工厂一般，能按照用户的需求进行生产 内部类基本概念 当一个事物的内部，还有一个部分需要一个完整的结构进行描述， 且这个内部的结构又只为该事物提供服务，那么整个内部的完整结构最好使用内部类封装 内部类的分类内部类是类的成员变量的一份子，可以变量在类中的不同定义来区分不同类型的内部类 成员变量：属性(成员内部类) 非静态成员变量：属性(非静态内部类) 静态变量：类变量(静态内部类) 局部变量：方法、构造器、代码块内 局部内部类 示例代码： 1234567891011121314151617181920212223242526272829303132class TestInClass&#123; //非静态成员内部类 class AA&#123; &#125; //静态成员内部类 static class BB&#123; &#125; public void testMethod()&#123; class EE&#123;//局部内部类 &#125; &#125; public TestInClass() &#123; //局部内部类 class CC&#123; &#125; &#125; &#123; //局部内部类 class DD&#123; &#125; &#125;&#125; 成员内部基本概念 作为外部类的成员(属性理解)： 可以调用外部类的结构 可以被static修饰(外部类-普通类不可以) 可以被4种权限修饰符修饰(普通类只有缺省和public) 作为类：拥有普通类的常见情况 类内可以定义属性、方法、构造器等 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承 可以被abstract修饰 实例化 实例化成员内部类 1234567//创建静态的Dog内部类的实例(静态的成员内部类):Person.Dog dog = new Person.Dog();//创建非静态的Bird内部类的实例(非静态的成员内部类)://Person.Bird bird = new Person.Bird();//错误的Person p = new Person();Person.Bird bird = p.new Bird(); 内部类与外部类同名属性调用12345678910111213141516class Person&#123; String name = &quot;小明&quot;; public void eat()&#123; &#125; //非静态成员内部类 class Bird&#123; String name = &quot;杜鹃&quot;; public void display(String name)&#123; System.out.println(name);//方法的形参 System.out.println(this.name);//内部类的属性 System.out.println(Person.this.name);//外部类的属性 //Person.this.eat(); &#125; &#125;&#125; 局部内部类在局部内部类的方法中的调用方法的局部变量话,要求此局部变量声明为final的。 jdk 7及之前版本：要求此局部变量显式的声明为final的 jdk 8及之后的版本：可以省略final的声明 1234567891011public class InnerClassTest &#123; public void method()&#123; int num = 10; class AA&#123; public void show()&#123; //num = 20;//错误，num默认为final System.out.println(num); &#125; &#125; &#125; &#125; 返回内部类实例方法定义12345678910111213141516171819202122//返回一个实现了Comparable接口的类的对象public Comparable getComparable()&#123; //创建一个实现了Comparable接口的类:局部内部类 //方式一： class MyComparable implements Comparable&#123; @Override public int compareTo(Object o) &#123; return 0; &#125; &#125; return new MyComparable(); //方式二： return new Comparable()&#123; @Override public int compareTo(Object o) &#123; return 0; &#125; &#125;; &#125; 内部类字节码文件成员内部类和局部内部类，在编译以后，都会生成字节码文件 成员内部类：外部类$内部类名.class 局部内部类：外部类$数字 内部类名.class 异常处理异常概述 在Java语言中，将程序执行中发生的不正常情况称为“异常” (开发过程中的语法错误和逻辑错误不是异常)。 运行中所发生的异常事件可分为：Error、Exception 两种异常 ErrorJava虚拟机无法解决的严重问题。如：JVM系统内部错误、资源 耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。 1234567891011public class ErrorTest &#123; public static void main(String[] args) &#123; //1、栈溢出：java.lang.StackOverflowError //通过死循环调用方法使其申请无限个形参(局部变量)， //由于局部变量是存放在栈空间，所以会引发栈溢出错误 //main(args); //2、堆溢出：java.lang.OutOfMemoryError，new出来的内容均存放在堆空间 Integer[] arr = new Integer[1024 * 1024 * 1024]; &#125;&#125; Exception因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。(无特别说明，以下异常均指Exception) 空指针访问 试图读取不存在的文件 网络连接中断 数组角标越界等 异常分类异常可分为编译时异常和运行时异常 捕获错误最理想的是在编译期间(可预知的异常)， 但有些错误只有在运行时才发生。 比如：除数为0，数组下标越界等，叫做运行时错误 异常体系结构异常体系结构均为类，且均为继承关系 1234567891011121314* java.lang.Throwable* |-----java.lang.Error:一般不编写针对性的代码进行处理。* |-----java.lang.Exception:可以进行异常的处理* |------编译时异常(checked)* |-----IOException* |-----FileNotFoundException* |-----ClassNotFoundException* |------运行时异常(unchecked,RuntimeException)* |-----NullPointerException* |-----ArrayIndexOutOfBoundsException* |-----ClassCastException* |-----NumberFormatException* |-----InputMismatchException* |-----ArithmeticException 图示1 API图示1：Exception API图示2：RuntimeException 常见异常运行时异常 运行时异常 含义 NullPointerException 空指针异常 ArrayIndexOutOfBoundsException 数组角标越界 StringIndexOutOfBoundsException 字符串角标越界 ClassCastException 类型转换异常 NumberFormatException 数字格式异常 InputMismatchException 输入不匹配异常 ArithmeticException 算术异常 示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//******************以下是运行时异常***************************//NullPointerException@Testpublic void test1()&#123; //int[] arr = null; //System.out.println(arr[3]); String str = &quot;abc&quot;; str = null; System.out.println(str.charAt(0));&#125;//IndexOutOfBoundsException//StringIndexOutOfBoundsException@Testpublic void test2()&#123; //ArrayIndexOutOfBoundsException //int[] arr = new int[10]; //System.out.println(arr[10]); //StringIndexOutOfBoundsException String str = &quot;abc&quot;; System.out.println(str.charAt(3));&#125;//ClassCastException@Testpublic void test3()&#123; Object obj = new Date(); String str = (String)obj;&#125;//NumberFormatException@Testpublic void test4()&#123; String str = &quot;123&quot;; str = &quot;abc&quot;; int num = Integer.parseInt(str);&#125;//InputMismatchException@Testpublic void test5()&#123; Scanner scanner = new Scanner(System.in); int score = scanner.nextInt(); System.out.println(score);//当输入非int类型时 scanner.close();&#125;//ArithmeticException@Testpublic void test6()&#123; int a = 10; int b = 0; System.out.println(a / b);&#125; 编译时异常123456789101112131415//******************以下是编译时异常***************************//如下代码逻辑合语法均没错误//但IDE会提示存在IOException、FileNotFoundException等编译时异常@Testpublic void test7()&#123; File file = new File(&quot;hello.txt&quot;); FileInputStream fis = new FileInputStream(file); int data = fis.read(); while(data != -1)&#123; System.out.print((char)data); data = fis.read(); &#125; fis.close();&#125; 异常的产生与处理异常的产生异常的产生，又叫异常的抛出，有两种情况都就抛出异常，注意下面两种异常都能被用户捕获。 运行时异常，由系统隐式自动抛出 编译时异常，由用户手动throw抛出，也可以理解为用户自定义的异常 捕获运行时异常，由系统隐式抛出。 123456789101112131415161718/** * @author yhd * @create 2021-06-01 10:48 */public class TestException &#123; public static void method()&#123; System.out.println(&quot;TestException-method方法执行开始&quot;); int i = 12 / 0;//运行时异常，出现异常后，系统默认抛出异常，是可被捕获的 System.out.println(&quot;TestException-method方法执行结束&quot;); &#125; public static void main(String[] args) &#123; try&#123; method(); &#125;catch (Exception e)&#123; System.out.println(&quot;捕获到异常：&quot; + e.getMessage()); &#125; &#125;&#125; 异常的处理java中异常的处理有两种： catch捕获异常处理 throws把异常抛出处理，让上一级调用者处理。(不作为也是一种作为) 异常处理机制引言：在编写程序时，经常要在可能出现错误的地方加上检测的代码， 如进行x/y运算时，要检测分母为0，数据为空，输入的不是数据 而是字符等。过多的if-else分支会导致程序的代码加长、臃肿， 可读性差。因此采用异常处理机制。 Java采用的异常处理机制是将异常处理的程序代码集中在一起， 与正常的程序代码分开，使得程序简洁、优雅，并易于维护。 抓抛模型“抛” 程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应的异常类的对象，并将此对象抛出。一旦抛出异常对象以后，其后的代码就不再执行。 关于异常对象的产生 系统自动生成的异常对象 手动的生成一个异常对象，并抛出（throw） “抓” “抓“：可以理解为异常的处理方式：① try-catch-finally ② throws try-catch-finally语法格式1234567891011try&#123; //可能出现异常的代码&#125;catch(异常类型1 变量名1)&#123; //处理异常的方式1&#125;catch(异常类型2 变量名2)&#123; //处理异常的方式2&#125;....finally&#123;//可选项 //一定会执行的代码&#125; 语法说明 try-catch-finally中：至少try-catch或try-finally(此时异常属于未处理状态)，至多try-catch-finally。 使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配。一旦匹配到某一个catch时则不再匹配，随之进入匹配的catch中进行异常的处理，处理完毕后继续执行其后的代码。（没有写finally的情况） catch中的异常类型如果没有子父类关系，则声明次序无关。 catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错 常用的异常对象的调用的方法 String getMessage()：打印异常基本描述信息 printStackTrace()：打印异常所涉及的整个堆栈调用信息 在try结构中声明的变量，再出了try结构以后，就不能再被调用 try-catch-finally结构可嵌套 finally结构说明： finally是可选的。 finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中return语句，catch中return语句等情况，finally都会被执行。 注意：从第2点可以看出，若try-catch中出现return语句，finally是在return之前执行的。因此若finally中出现return语句，肯定是整个方法的return结果 如像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。 小结： 使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。 相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。 开发中，运行时异常一般只能重新构造代码逻辑，不针异常编写try-catch-finally了(没用) 对于编译时异常，则一定要考虑异常的处理。 throws语法说明语法格式：throws 异常类型1,异常类型2... “throws + 异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！ throws的方式只是将异常抛给了方法的调用者。并没有真正将异常处理掉 子类重写的方法抛出的异常类型小于或等于父类被重写的方法抛出的异常类型 子类重写的方法的异常处理方式必须与父类处理异常的方式一致。 try-catch-finally真正的将异常给处理掉了。 throws方式只是将异常抛给了方法的调用者。并没真正将异常处理掉。 开发中异常处理的选择： 在执行某个方法A时，这个方法内又递归地调用的几个方法，而且这几个被调用的方法都可能存在异常。则建议内部几个被递归调用的方法都采用throws，总的方法A采用try-catch的方式处理。 如下，方法float method 中递归地调用了三个方法，递归地调用指如method1返回值拿去调用method2返回的值又再给method3调用。 由于这种递归调用的方式，若在method1、2、3中使用try-catch方式处理，则会出现某个被带哦用的方法出现了异常，确实被处理了，代码也继续执行，但返回的值已经不能供下一个方法正常执行。所以在这种递归地调用方法结构上过早地通过try-catch处理调异常并非是件好事。 手动抛出异常对象-throwtips：throws是异常处理的一种方式，而throw是创建异常的关键字。其实当系统发现异常时，默认自动执行的操作就是throw操作。 语法要求语法：在方法内throw 异常类 一般选择抛出Exception(含编译与运行时异常)或运行时异常RuntimeException，或自定义异常类。抛出时通过使用这些异常类的重载构造器(如带参描述) 1234public void method(int i)&#123; if(i &lt; 0) throw new Exception(&quot;i &lt; 0&quot;);&#125; 需求场景模拟 没有通过抛出异常处理 1234567891011121314151617181920212223242526272829/* 如下限制Person的age必须&gt;0，若采用传统的if-else无法达到效果 因为即使断绝了age的赋值，age都会以默认初始化值为0(非法)继续 执行，无法有效断绝非法数据的执行。如下代码效果*/public class ThrowTest &#123; public static void main(String[] args) &#123; Person p = new Person(); p.setAge(-1); System.out.println(&quot;age：&quot; + p.getAge()); System.out.println(&quot;代码继续执行.....&quot;); &#125;&#125;class Person&#123; private String name; private int age; public void setAge(int age) &#123; if(age &gt; 0)&#123; this.age = age; &#125;else&#123; System.out.println(&quot;输入非法数据&quot;); &#125; &#125; public int getAge() &#123; return age; &#125;&#125; 打印结果如下 123输入非法数据age：0代码继续执行..... 异常处理方式1：抛出运行时异常，编译的时候setAge()方法无需对异常处理 123456789101112131415161718192021222324public class ThrowTest &#123; public static void main(String[] args) &#123; Person p = new Person(); p.setAge(-1); System.out.println(&quot;age：&quot; + p.getAge()); System.out.println(&quot;代码继续执行.....&quot;); &#125;&#125;class Person&#123; private String name; private int age; public void setAge(int age) &#123; if(age &lt; 0)&#123; throw new RuntimeException(&quot;运行时异常：非法年龄输入&quot;); &#125; this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125; 打印结果如下 123Exception in thread &quot;main&quot; java.lang.RuntimeException: 运行时异常：非法年龄输入at com.test.java.Person.setAge(ThrowTest.java:19)at com.test.java.ThrowTest.main(ThrowTest.java:7) 异常处理方式2：抛出异常，编译的时候setAge()会检查到异常，需即刻对异常进行处理 1234567891011121314151617181920212223242526public class ThrowTest &#123; public static void main(String[] args) &#123; Person p = new Person(); try &#123; p.setAge(-1); System.out.println(&quot;age：&quot; + p.getAge()); System.out.println(&quot;代码继续执行.....&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Person&#123; private String name; private int age; public void setAge(int age) throws Exception &#123; if(age &lt; 0)&#123; throw new Exception(&quot;运行时异常：非法年龄输入&quot;); &#125; this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125; 打印结果如下 123java.lang.Exception: 运行时异常：非法年龄输入at com.test.java.Person.setAge(ThrowTest.java:24)at com.test.java.ThrowTest.main(ThrowTest.java:8) 自定义异常类 如何自定义异常类？ 继承于现有的异常结构：常用RuntimeException 、Exception 提供全局常量：serialVersionUID，用于序列化传输时唯一标识当前类 提供重载的构造器 123456789public class MyException extends Exception&#123; static final long serialVersionUID = -7034897193246939L; public MyException()&#123; &#125; public MyException(String msg)&#123; super(msg); &#125;&#125; 资源加载与JVM变量类型作用角度上 局部变量：方法体构造体内、形参、代码块内 成员变量 非静态成员变量：属性 静态成员变量：类变量 局部变量 局部变量指：方法体、构造器体内定义的变量，方法构造器的形参、代码块内定义的变量 局部变量随着所在结构被调用时申请空间，并在该结构调用结束后释放 成员变量属性 属性使定义在类中的，方法体外的非静态变量 随着对象的创建而创建，随着对象的销毁而销毁 类变量 类变量是指static静态修饰的类属性 随着类的加载而被加载 数据类型上 基本数据类型：byte、short/char、int、long、float、double… 引用数据类型：数组、String、各种自定义类 引用数据类型比基本数据类型多一个实体引用，即地址值 变量初始化声明与初始化变量的声明 变量的声明是指，仅定义了变量名，但未为其赋值的操作 如基本数据类型变量的声明 1int num; 引用数据类型的声明 1InputStream ips; 变量的初始化 变量的初始化即为变量声明后赋值上一个初始值 基本数据类型 123456//方式1，先声明后初始化/赋值int num;num = 0;//方式2，声明同时初始化/赋值int i = 0; 引用数据类型 1String str = null; 局部变量 在java中的局部变量没有默认初始值，必须先声明再使用 即局部变量必须显式初始化后(赋值)才能使用(运算/调用)够使用 否则是无法通过编译的，报编译错误 1234public static void main(String[] args)&#123; int num; System.out.println(num);//编译阶段就不通过&#125; 成员变量当用户没有显式初始化时，成员变量是具有默认的初始值 成员变量类型 具体类型 默认值 整数型 byte、short、int、long 0 浮点型 float、double 0.0 字符型 char 0 或 ‘\\u0000’ 布尔型 boolean false 引用数据类型 类、数组 null JVM内存结构Java程序加载流程：编译 、一个或多个字节码文件(class) 、JVM类加载器和解析器进行解析运行 虚拟机堆(heap)：存放非静态引用数据类型的实体，如数组的内容、对象实例的结构(含非static属性) 虚拟机栈(stack)：存放局部变量、对象的引用 方法区(method area)：存储虚拟机已加载的、类信息、常量、静态变量、编译后的代码 本地方法栈(native method stack)： 程序计数器(PC)： 类的加载过程实例化对象加载过程为什么要向上加载在学习面向对象过程中提及子类实例化的构造器必须调用父类构造器，为什么要调用父类构造器？ 由于java是支持面向对象程序设计，具备支持类的继承特性 当子类继承与父类时，子类就需拥有了直接父类与所有间接父类的所有结构 此时，子类实例化时就要求必须加载父类的资源，每一个子类对象都是独自占有父类资源的 而实例化一个类的资源，使用的就是构造器 而且除了加载直接父类外，还有间接父类，即对于父类来说的直接父类…一直延续到Object根父类 Object类是所有类的根父类，仅提供了一个空参构造器，作为上层加载的终点 其次，任何类都需要向上加载，因为即使没有显式地继承其他类，但也默认继承了Object类 如Object中定义的方法，任何类都要加载 虽然创建子类对象时，调用了许多父类的构造器，但自始至终只创建过一个对象，即为new的子类对象。调用父类构造器只是加载父类结构的过程，而并非实例化父类 例如如下 Dog继承了Animal，Animal继承了Creature，Creature继承了Object的内存加载 则Dog dog = new Dog(&quot;小花&quot;,&quot;小红&quot;);在堆空间加载的资源状况如下 结论：由于继承特性，任何类都需加载直接父类继承的资源。而加载资源的渠道就是调用上层构造器。 如何进行向上加载通过上述可知，任何类都需加载上层资源，具体就是调用直接父类的构造器 因此，Java编译时期就要求任何类的构造器都需要隐式或显式地，加载直接父类的资源、即调用构造器 当用户没有显式声明类的构造器时，系统默认提供一个空参构造器 向上加载直接父类的资源，不要求一定是调用空参构造器，只要能绝对地成功调用父类构造器进行资源加载即可。 可以隐式地加载，也可以显式地super()加载，反正就至少有一个构造器能够调用直接父类的构造器 再而任何构造器的首行若没有使用this(空参或形参)或super(形参)显式调用其他构造器时，系统默认都在构造器的首行隐含了一句super()，即默认都调用父类的空参构造器 由以上种种机制辅助下加编译时的检查，确保任何类都能够直接调用直接父类的构造器 资源的加载顺序 虽然实例化加载资源的代表是构造器的调用，但实际加载资源中构造器是最后被调用的 系统申请变量空间，提供属性的默认初始化值，多个属性按声明顺序初始化 加载显式初始化的赋值，多个属性按声明顺序初始化 调用代码块进行初始化，多个代码块按声明顺序调用 调用构造器进行初始化，若静态资源加载没有构造器调用这一步 静态资源的优先加载 静态资源并非在实例化对象时加载，而是随着类的加载而加载，即在实例化之前加载 因此静态资源又称为类的结构，如静态属性、静态方法又称为类属性、类方法 由于类只会加载一遍，因此静态的资源也只会加载一份，同一个类的多个对象是共享这些静态资源的 类的加载时机是当用户首次操作该类时，系统将其自动加载，含多种情况 情况1：首次操作只调用了类的静态资源，则只加载了类而没有进行实例化 情况2：首次操作是类的对象实例化，则先进行了类的加载，再进行对象的初始化 123456789101112131415161718192021222324252627282930package com.company.java;/** * @author yhd * @create 2021-06-30 22:31 */public class Person &#123; public static String value; private String name; private int age; public String getName() &#123; return name; &#125; public static void showValue()&#123; System.out.println(&quot;value = &quot; + value); &#125; public static void main(String[] args) &#123; //情况1：只加载了类，没有实例化过对象 //此时就已经加载了类结构与，静态属性value和静态方法showValue String str = Person.value; //情况2：先进行类的加载，在进行实例化(注意此时是情况1代码不存在时) Person person = new Person(); &#125;&#125; 完整的加载流程 由父及子，静态先行 静态资源加载顺序：静态默认初始化、显式初始化、静态代码块初始化。按声明顺序初始化 非静态资源加载顺序为：默认初始化、显式初始化、代码块初始化、构造器初始化。按声明顺序初始化 先进行父类的静态资源加载顺序：静态属性、静态代码块。按声明顺序初始化 后进行子类的静态资源加载顺序：静态属性、静态代码块。按声明顺序初始化 再进行父类的非静态资源加载顺序：属性、代码块、构造器。按声明顺序初始化 再进行子类的非静态资源加载顺序：属性、代码块、构造器。按声明顺序初始化 测试题值传递机制值传递机制 不仅是java，大部分的编译性语言方法的参数转递机制都是值传递机制 值传递机制指，方法调用实参传入形参的总是“数值” 基本数据类型：值内容本身 引用数据类型：地址值 局部变量的形参 当外部传入参数调用方法时，系统首先会创建一份传入实参的副本，赋值给新参 形参是一个局部变量，在方法调用时创建，方法执行完毕后释放 方法体内部操作的实际是实参的副本——形参的值 带返回值覆盖调用 由于方法可以声明带返回值，外部调用后若将其返回的结果对某个变量进行重新赋值，是可以改变外部的参数的值。毫无疑问，是绝对可以改变值得。即等同于在外部重新为其参数赋值的操作而已 因此主要讨论的是无返回值函数调用的情况 无返回值调用基本数据类型 任何语言，在无返回值方法调用中，传入基本数据类型实参，是无法修改外部值的 示例代码： 123456789101112131415161718@Testpublic void test10()&#123; int i = 1; change1(i);//不能修改 System.out.println(&quot;i = &quot; + i);//1 i = change2(i);//只能重新赋值 System.out.println(&quot;i = &quot; + i);//2&#125;public void change1(int i)&#123; i++;&#125;public int change2(int i)&#123; i++; return i;&#125; 原理：由于基本数据类型传入数据的本体，仅操作形参这个局部变量没有用，方法执行完就回收掉了，无法对外部调用者产生任何修改，属于空操作。 引用数据类型对于无返回值函数调用，当引用的类型创建副本后 结论：只能修改引用指向的内容，无法修改引用本身 java不同于C，C能对任意数据类型(含指针类型)，再创建指向它的一个指针/引用(取地址&amp;) 而java不能，对一个引用类型不存在再创建引用它的引用，若想调用方法修改最外层的引用，则只能通过返回值方法重新赋值引用。 示例代码： 123456789101112131415161718192021222324@Testpublic void test9()&#123; Person person = new Person(&quot;Tom&quot;);//一级引用 changePerson1(person);//引用类型的第一级引用无法通过方法内部直接改变引用值 System.out.println(&quot;Name: &quot; + person.getName());//Tom person = changePerson2(person);//引用类型的第一级引用只能通过返回值赋值来改变引用值 System.out.println(&quot;Name: &quot; + person.getName());//Jack changeName(person);//可以改变引用指向的本体内容 System.out.println(&quot;Name: &quot; + person.getName());//Tom-&#125;public void changePerson1(Person person)&#123; person = new Person(&quot;Jack&quot;);//尝试改变其引用，不行&#125;public Person changePerson2(Person person)&#123; person = new Person(&quot;Jack&quot;);//尝试改变其引用，不行 return person;//仅能返回引用进行修改&#125;public void changeName(Person person)&#123; person.setName(&quot;Tom-&quot;);//修改一级引用的本体，可以&#125; 原理： 同基本数据类型，修改引用的本身存储在形参，形参局部变量在方法执行完后就会自动回收，因此修改形参值本身是无效的，是个空操作， 而修改其引用指向的内容，就可以在局部变量有限的生命周期中造成对外界永久的修改。 核心总结 基本数据类型： 任何语言都，只能通过返回值覆盖的方式修改其内容 C语言可以修改是因为传入的是&amp;取指后的指针类型 无返回值方法调用，是无法修改外部的值 引用数据类型： 无返回值方法调用，只能修改引用指向的内容，无法修改引用本身，即对引用的赋值(=)操作均无效。 若想修改引用本身(地址)，只能通过返回值覆盖的方式修改","categories":[],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/tags/JavaSE/"}]},{"title":"数据库原理 第二章 关系数据库","slug":"数据库原理 第二章 关系数据库","date":"2020-10-30T10:38:32.000Z","updated":"2021-08-25T15:27:11.750Z","comments":true,"path":"2020/10/30/数据库原理 第二章 关系数据库/","link":"","permalink":"http://yoursite.com/2020/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"关系数据库 基本概念 定义：关系数据库是采用关系模型的数据库系统，而关系模型的数据结构(数据模型三部曲之一)就是关系本身。即现实世界的实体与实体间的联系都用关系来表示，其逻辑结构表现为一张二维表 相关术语： 关系术语 一般表格术语 关系（relation） 表 元组（tuple） 行或记录 属性（attribute） 列 分量 列值/属性值 域（domain） 列值/属性值给定的取值范围(非数据类型上的范围) 基数 一个域允许的不同取值个数 关系模式 关系型，即对表格结构的描述 [关系]关系的类型：三种，基本关系(基本表/基表)、查询表、视图表 [域]笛卡儿积：从数学定义上，笛卡尔积的基数等于两个集合中各分量的组合。从数据表中，即每个表的元组总数的相乘。如表1有n行数据，表2有m行数据，则表1和表2构成的笛卡尔积为n*m 关系操作 关系操作类型：分为两类，查询操作(query)与(插入、删除、修改)操作两大类型组成 查询操作：选择(select)、投影(project)、连接(join)、除(divide)、并(union)、差(except)、交(intersection)、笛卡尔积等。加粗部分为查询的五大基本操作，其他操作均可由其基本操作来实现。 关系数据语言： 定义：关系数据语言主要用于表达对数据库抽象层面的查询操作。 关系数据语言的分类：关系代数语言、关系演算语言、结构化查询语言。 关系代数语言：用对关系的运算来表达查询要求(操作)，重点掌握 关系演算语言：用谓词来表达查询要求(操作) 双重特点语言——结构化查询语言SQL(structured query language)：同时具备关系代数和关系演算双重特点的语言 关系代数语言 关系代数运算符： ​ 备注：R，relationship，关系/数据表、F，function，选择条件，逻辑表达式、A，attribute，属性列、θ，比较运算符 传统集合运算：均为二目运算，交、并、差、笛卡尔积四种 专门关系运算：选择、投影、连接、除运算等 着重解释“连接” 定义： 连接运算过程：R与S均是关系表，从R和S的笛卡尔积(广义笛卡尔积)RxS中选取R关系在A属性组上的值与S关系在B属性组上的值满足比较关系θ的元组，即，只要进行连接运算，首先生成的肯定是笛卡尔乘积 等值/非等值连接：θ为“=”等值连接，若θ为比较运算符则是非等值连接，而自然连接是一种特殊的等值连接。 连接条件F运算符： 类型 格式定义 例子 选择 ∂F(R) ∂Sage &lt; 20(Student) 投影 ∏A(R) ∏Sname，Sdept(Student) 连接 R1⋈R2 (因符号表示问题，常见上述定义) 略 关系的完整性 实体完整性（entity integrity）：主键，表唯一，非空 参照完整性（referential integrity）：外键，列唯一，可空 用户定义的完整性：为某个属性定义取值约束 注意：主键和外键如果存在则必须定义，否则就是数据库设计本身存在问题，实体完整性和参照完整性是关系的两不变性","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库原理 第一章 绪论","slug":"数据库原理 第一章 绪论","date":"2020-10-28T11:57:32.000Z","updated":"2021-08-25T15:27:11.603Z","comments":true,"path":"2020/10/28/数据库原理 第一章 绪论/","link":"","permalink":"http://yoursite.com/2020/10/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%20%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/","excerpt":"","text":"绪论 数据库基本概念 数据（data）：描述事物的符号记录称为数据 数据库（DB，DataBase）：长期存储在计算机内、有组织的、可共享的大量数据的集合 数据库管理系统（DBMS，Data Base Management System）：用于科学高效地存取、维护数据的计算机基础软件，是一个大小复杂的软件系统(如操作系统般)。其最主要的功能如下： 数据定义功能（DDL，Data Definition Language）：如对库、表、字段等数据对象的定义(创建,修改,删除等) 数据操纵功能（DML，Data Manipulation Language）：对数据的增删改查等操作 数据库系统（DBS，DataBase System）：DB + DBMS(相关tool) + Program + DBA组成的存储、管理、处理和维护数据的系统 数据模型 两类数据模型：概念模型(信息模型)、逻辑模型与物理模型 概念模型：以用户角度对数据进行信息建模，不依赖于具体DBMS，是概念级的模型。其他相关概念如下： 实体(entity)：客观存在且相互区别的事物。如，一条具体的信息，类对象的一个实例 实体型(entity type)：用实体名及其属性名的集合来抽象同类实体。如，面向对象中的类 实体集(entity set)：同类型的实体的集合，如全体学生，一些对象的集合、表等 属性(attribute)：实体具有的某一特性。如，数据表中的字段/列 码(key)：唯一标识实体的属性集，(注意是属性集) 联系(relationship)：现实世界中，实体(型/集)与实体(型/集)之间的联系，一般有一对一，一对多，多对多的联系 联系的定义与判断：在A实体集内取1个实体，而这个实体能在B实体集内对应多个实体。则称为一对多，其他类型联系以此类推。 E - R模型：概念模型的最常用的表示方法为实体-联系方法(Entity-Relationship approach)，也称E-R模型，用E-R图描述。具体设计与实现在“概念结构设计篇”讲解 逻辑模型与物理模型：以计算机系统角度对数据的建模，由DBMS。常见逻辑模型如层次、网状、关系、面向对象等模型。 模型之间的关系 数据模型的组成要素：数据模型由数据结构(对象的组成与对象间的联系)、数据操作(增删改查)、数据完整性约束条件(确保数据的完整性)组成。任何数据模型都需考虑的三个因素。 数据库系统结构 基本概念 型（type）：某一类数据的结构与属性的说明。如类的定义 值（value）：值是型的具体赋值。如某一个类的实体对象(实例) 模式（schema）：是指数据库全体数据的逻辑结构和特征的描述，属于“型”的层次，相对稳定 实例（instance）：模式对应的一个具体值称为实例，相对变动 注意，这里“一个具体值”不是只有一个值，而是一个模式的值，即刻整个数据库的数据。 二级映像下的三级结构：由模式对外(应用程序)，对内(数据存储)分别进行了模式映像。从而产生了两个二级映像，即外模式与内模式。 三级结构：外模式，模式，内模式统称数据库三级模式的结构 模式：具体概念不再赘述，强调模式是所有用户的公共数据视图 外模式：又名子模式、用户模式。它是数据库用户(开发者与最终用户)能够看见与使用的局部数据的逻辑结构和特征的描述** 内模式：又称为存储模式，一个数据库只有一个内模式，是数据在数据库内部的组织方式的描述 模式映像的作用：外模式实现了逻辑独立性，内模式实现了物理独立性。从外到内保证模式的相对稳定 数据库系统组成​ 数据库系统由：硬件平台及数据库，软件，人员(数据库管理人员)(DBA，DataBase Administrator)组成。","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库原理 第五章 数据库完整性","slug":"数据库原理 第五章 数据库完整性","date":"2020-10-28T01:11:32.000Z","updated":"2021-08-25T15:27:11.835Z","comments":true,"path":"2020/10/28/数据库原理 第五章 数据库完整性/","link":"","permalink":"http://yoursite.com/2020/10/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/","excerpt":"","text":"数据库完整性 什么是数据库完整性 数据库完整性(integrity)：数据的正确性和相容性 维护数据库完整性功能组成 完整性约束机制：实体完整性、参照完整性、用户定义完整性等 完整性检查方法：一般在增删改查或事务操作前后进行 违约处理：not action(拒绝)，cascad(级联)，nullifies (置空) 实体完整性 定义：create table 中的 primary key定义(列级/表级) 1234create table Student( Sno char(9) /*primary key*/, /*列级定义*/ primary key(Sno) /*表级定义*/); 完整性检查 检查主码值是否唯一，若不唯一拒绝插入与更新 检查主码个属性是否为空，存在一个空，则同样拒绝操作 违约处理：对于主键冲突，违约系统默认一概NOT ACTION(拒绝)处理 参照完整性 定义：create table 中的 foreign key() references定义(表级) 完整性检查与违约处理 隐式处理(默认策略)：NOT ACTION(拒绝) 显示处理(自定义违约处理方式)： 应用场景：只有被参照表(外码表)才可显示定义违约处理策略，即只允许在 foreign key 授权语句后追加，不可写在其他地方，且仅限于update与delete操作 语句格式：[表级定义权限约束 &lt;空格&gt;] ON &lt;违约操作&gt; &lt;违约处理&gt; &lt;违约操作&gt;：且限于 update、delete &lt;违约处理&gt;：拒绝(NO ACTION)，级联(CASCADE)，置空(NULLIFIES) 级联操作：若删除的参照表的数据在其他表被引用，连同删除 12345create table Student( ... primary key(Sno,Cno), /*只允许在foreign key 后追加显示违约处理*/ foreign key(Sno) references Student(Sno) on delete cascade on update cascade); 用户定义的完整性 定义：用户可对具体列(字段)进行约束，一般分为两种 属性上的约束条件：可对单个列级属性进行约束 元组上的约束条件：可对多个列级属性进行约束，完整性约束限制类型同上 完整性约束：限制类型含，not null(非空)，unique(唯一)，check&lt;条件表达式&gt;) 1234567create table SC( Sno char(9) not null, Sname varchar(10) not null, Ssex char(2) check(Ssex IN(&#x27;男&#x27;,&#x27;女&#x27;)), Sgrade samllint check(Sgrade &gt;=0 AND Sgrade &lt;= 100), CHECK(Ssex = &#x27;女&#x27; OR Sname NOT LIKE &#x27;Ms.%&#x27;)/*同时约束多个列*/) 违约处理：系统统一采取**拒绝(NOT ACTION)**处理 完整性约束命名子句概念与子句的创建 前言：上述所有约束都是在create table时设置，若需要修改约束，难道只能重新建表？ 命名子句：在create table设置约束时为每个约束操作命名，后序修改或删除约束可通过操作这个命名 子句格式：constraint &lt;完整性约束条件名&gt;&lt;完整性约束条件&gt; &lt;完整性约束条件&gt;包含：primary key、foreign key，not null、unique、check 1234create table Student( Sno int constraint c1 check(Sno &gt;= 9000 AND Sno &lt;= 9999),/*列级操作*/ constraint StudentKey primary key(Sno) /*表级操作示例*/); 修改完整性限制 使用环境：在 alter table 语句下进行修改(add、drop) 语句格式：`&lt;add | drop&gt; constraint &lt;完整性约束子句名 | 完整性约束子句&gt; 1234567alter table Student drop constraint c1; /*删除Student表中名为c1的完整性约束*/ alter table Student /*在Student表中添加新的完整性约束子句*/ add constraint Sno_domain check(Sno &gt;= 9000 AND Sno &lt;= 9999); /*若想修改约束，则只能先删除约束再添加过新的约束*/ 触发器 定义：触发器(trigger)，由事件驱动的特殊过程(事件-&gt;条件-&gt;动作) 创建触发器：[ 事件(触发时机) -&gt; 条件(触发条件) -&gt; 动作(存储过程)] 12345create trigger &lt;触发器名&gt;&lt;before | after&gt; &lt;触发事件&gt; on &lt;表名&gt; /*定义触发的时机*/referencing &lt;new|old&gt; row as&lt;变量&gt; /*通过referencing引出变量*/for each&lt;row | statement&gt; /*指明动作体执行的频率*/[when &lt;触发条件&gt;]&lt;触发动作体&gt; 只有创建表的用户才能在此表上创建触发器，而且数量有限，具体数量由数据库管理系统本身设计所定 触发器名：必须唯一 表名：只能是基本表，不能是视图 触发事件： 触发时机：可在语句执行前before，或执行后after 操作类型：可以是增删改查，事务等操作，如insert，delete，update… 事件组合：可以单一事件，可组合，insert or delete，或指定列触发 update of &lt;触发列,…&gt; 触发器类型： 语句级触发器(for each statement)：执行完这条语句后且符合触发条件才会调用触发器(有可能这条语句已经操作了若干行数 据)，因此语句级触发器是不允许通过referencing引出变量new或者old row数据的 行级触发器(for each row)：相反，行级触发器，当检查到一行数据符合触发条件就会调用触发器。因为数据行是确定的，所 以可以通过referencing 引出变量new | row的数据 触发条件：触发条件的书写即&lt;条件表达式&gt;的书写 触发动作体：匿名PL/SQL过程块，也可以是存储过程 12/*当对表SC的Grade属性进行修改时，若分数增加了10%，则将此次操作记录到另一个表SC_U(Sno、Cno、Oldgrade、Newgrade)中，其中Oldgrade是修改前的分数，Newgrade是修改后的分数。*/create trigger SC_T 触发器的激活机制： 同一表上的多个触发器按，执行before触发器—&gt; 激活sql语句 —&gt; 执行after触发器流程触发 对于相同的触发器类型的触发器，遵循“谁先创建谁先执行原则”，有些DBMS按触发器名称字母排序。 删除触发器：drop trigger &lt;触发器名&gt; on &lt;表名&gt;","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库原理 第六章  关系数据理论","slug":"数据库原理 第六章 关系数据理论","date":"2020-10-28T01:11:32.000Z","updated":"2021-08-25T15:27:11.782Z","comments":true,"path":"2020/10/28/数据库原理 第六章 关系数据理论/","link":"","permalink":"http://yoursite.com/2020/10/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%20%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/","excerpt":"","text":"关系数据理论范式与范式之间的关系 低级范式可通过分解转换为若干个高一级方式的关系模式的集合 高一级的范式必是必定是低一级范式 包含关系， 1NF 插入异常：Cno初始无，但为码 删除异常：Cno，删除，连累其他数据 修改复杂：存储冗余，修改复杂 2NF 小结：部分函数依赖 依赖定义——&gt;常见依赖特性 == 完全函数依赖，按照依赖的标准定义能体现出，现实世界必定存在依赖关系，而完全性依赖必定存在若干不同且唯一元组(即数据冗余情况最严重(这里应该就不叫冗余了…是必要的))。若让这种情况(完全性依赖)混在其非主属性中(部分函数依赖)，则必定存在一个问题——&gt;存储冗余，而这种存储的冗余而引发的一系列异常如下 存储冗余：不符合完全函数依赖的非主属性必定产生存储冗余 修改复杂化：而当对存储冗余数据本身进行修改自然会呈现出修改的复杂化 对非冗余(符合完全函数依赖/部分函数依赖中非依赖子集)进行删除操作的时候，出现删除异常(删除了同一关系下不符合完全函数依赖的属性) 角度2： 对原本就具备完全函数依赖的关系影响 删除异常：进行删除操作的时候，出现删除异常(删除了同一关系下不符合完全函数依赖的属性) 对不符合完全函数依赖(部分函数依赖)异常 存储冗余：不符合完全函数依赖的非主属性必定产生存储冗余 修改复杂化：而当对存储冗余数据本身进行修改自然会呈现出修改的复杂化 解决方案：投影分解， 3NF 在2NF基础上消除传递函数依赖 BCNF(修正/扩充的第三范式) 全是非平凡的函数依赖 小明，老1，物理 小东，老1，物理 传递函数依赖，同样是会产生存储冗余，(因为2NF不存在完全函数依赖与部分函数依赖的相互影响，因此不存在删除异常)，进而出现存储冗余与与之衍生的修改复杂化 多值依赖 判定方法：对于任意关系中，如果存在两个元组（就是行），记为A,B，如果他们的某一属性X的值相等，那么我们交换它们另外的其中一个属性Y的值后，得到的新的两个元组，这两个元组在原来的表中是可以找到的 整个小结： 劣势依赖：部分函数依赖、传递函数依赖 其实按最基本的依赖关系，去建立数据库就基本符合常规规范 出现部分函数依赖侧面表明该关系中，属性间的关系并非完全依赖，按照 Sdept、 Sloc部分函数依赖 将一个1NF关系分解为多个2NF的关系，并不能完全消除关系模式中的各种异常情况和数据冗余 不能说规范化程度越高的关系模式就越好在设计数据库模式结构时，必须对现实世界的实际情况和用户应用需求作进一步分析，确定一个合适的、能够反映现实世界的模式上面的规范化步骤可以在其中任何一步终止 规范化理论为数据库设计提供了理论的指南和工具也仅仅是指南和工具 并不是规范化程度越高，模式就越好必须结合应用环境和现实世界的具体情况合理地选择数据库模式 反规范化设计：规范化数据将导致数据库中产生更多的表，这些表的结构优化了数据变更性能，但是在有些情况却大大降低了数据查询效率。在这种情况下，通过引进额外的列或额外的表将有助于提高数据查询能力。在表格中有意识的引入一定的数据冗余以改进性能被称为反规范化。反规范化是查询效率与数据冗余的折中。","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"算法积累","slug":"算法积累","date":"2020-10-22T09:12:32.000Z","updated":"2021-08-25T15:27:11.607Z","comments":true,"path":"2020/10/22/算法积累/","link":"","permalink":"http://yoursite.com/2020/10/22/%E7%AE%97%E6%B3%95%E7%A7%AF%E7%B4%AF/","excerpt":"","text":"顺序表排序递增减序 冒泡排序 选择法 逆置 头尾交换 查找最值 暂存变量挨个比较 找子序列 BF算法思维：第二章线性表P67-8 KMP算法 删除删除所有指定数值O(n) 单数组就地过滤重塑：第二章线性表P66~P67(2,11) 题目： 123456789101112131415161718192021/*伪代码： 1.用k记录顺序表中不等于x的元素个数，即需要保存的元素个数， 2.边扫描L边统计k，并将不等于x的元素放在L.data[k]中，最后修改L的长度。 时间复杂度：O(n)，空间复杂度：O(1)函数说明： 功能：删除顺序表所有指定的数值 SeqList&lt;DataType&gt; *L : 顺序表指针变量 int x : 删除数值*/template&lt;typename DataType&gt;void deleteAll(SeqList&lt;DataType&gt; *L, int x) &#123; int i, k = 0; //k用于数组重组的下标变量(新下标) for (i = 0; i &lt; L-&gt;length; i++) &#123; if (L-&gt;data[i] != x) &#123; //非条件值，非过滤参与重组 L-&gt;data[k] = L-&gt;data[i]; k++; &#125; &#125; L-&gt;length = k;//修改顺序表长度&#125; 单链表排序1234567891011121314151617181920212223242526272829303132//三个数num1，num2，num3，通过if-else结构从小到大排序，/*伪代码： 1. 先比较两个数，如num1 &gt; num2 2. 若num1 &gt; num2，则num3的位置只能在 小__num2__num1__大 三个下划线之中。 2.1 若num3比最大(num1)的还大，则在最右(最大)，若比最小的还小(num2) 则在最左边(最小)，否则，else情况就在中间 3. 若num2 &gt; num1，则num3的位置只能在 小__num1__num2__大，后同理上*/public class BranchTest&#123; public static void main(String[]args)&#123; int num1 = -193,num2 = -23,num3 = 221; if(num1 &gt; num2)&#123; if(num3 &gt; num1)&#123; System.out.println(num2 + &quot;, &quot; + num1 + &quot;, &quot; + num3); &#125;else if(num3 &lt; num2)&#123; System.out.println(num3 + &quot;, &quot; + num2 + &quot;, &quot; + num1); &#125;else&#123; System.out.println(num2 + &quot;, &quot; + num3 + &quot;, &quot; + num1); &#125; &#125;else&#123; if(num3 &gt; num2)&#123; System.out.println(num1 + &quot;, &quot; + num2 + &quot;, &quot; + num3); &#125;else if(num3 &lt; num1)&#123; System.out.println(num3 + &quot;, &quot; + num1 + &quot;, &quot; + num2); &#125;else&#123; System.out.println(num1 + &quot;, &quot; + num3 + &quot;, &quot; + num2); &#125; &#125; &#125;&#125; 逆置O(n) 头插法： 凡会在操作过程是失去(链接/追踪)，可以用变量追随暂存 1234567891011121314151617181920212223242526/*伪代码： 1. 设定两个工作指针(用于遍历指针、用于记录遍历指针下一个指针的指针) 2. 通过遍历指针遍历每一个指针，将遍历到指针通过头插法的形式重新生成链表实现逆序 3. 在 2. 操作执行头插法之前需要先记录以下即将取出用于插入结点的下一个结点，否则会失去连接 时间复杂度：O(n)，空间复杂度：O(1);函数说明 LinkList&lt;DataType&gt; *L : 单链表指针*/template&lt;typename DataType&gt;void reverseLinkList(LinkList&lt;DataType&gt; *L) &#123; Node&lt;DataType&gt; *p, *q; p = q = L-&gt;first-&gt;next; L-&gt;first-&gt;next = nullptr; while (p!= nullptr) &#123; q = p; p = p-&gt;next; q-&gt;next = L-&gt;first-&gt;next; L-&gt;first-&gt;next = q; &#125;&#125; 递增减输出并释放 重复使用“暂存变量挨个比较” 查找删除循环链表排序查找对称性判断 头尾同步相近判断，各自到达头节点结束 12345678910111213141516171819202122232425/* 伪代码： 1. 创建两个工作指针，head指向第一个结点，rear指向尾部结点 2. 头尾向中间靠拢判断是否相等 3. 两个指针都移置头结点表示允许结束(兼容奇偶数量对称判断) 函数说明： CDulLinkList&lt;DataType&gt; *L : 循环双链表指针*/template&lt;typename DataType&gt;bool isSymmetric(CDulLinkList&lt;DataType&gt; *L) &#123; DulNode&lt;DataType&gt; *head, *rear; head = L-&gt;first-&gt;next; rear = L-&gt;first-&gt;prior; while (head != L-&gt;first &amp;&amp; rear != L-&gt;first) &#123; if (head-&gt;data != rear-&gt;data) return false; head = head-&gt;next; rear = rear-&gt;prior; &#125; return true;&#125; 删除","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"SQL总结","slug":"SQL总结","date":"2020-10-22T08:21:32.000Z","updated":"2021-08-25T15:27:11.765Z","comments":true,"path":"2020/10/22/SQL总结/","link":"","permalink":"http://yoursite.com/2020/10/22/SQL%E6%80%BB%E7%BB%93/","excerpt":"","text":"数据库操作创建数据库 12create schema &lt;数据库名&gt; authorization &lt;用户名&gt; [内嵌定义];[内嵌定义] ：[&lt;表创建子句&gt;|&lt;视图创建子句&gt;|&lt;授权定义子句&gt;] 删除数据库 1drop schema &lt;数据库名&gt; &lt;cascade|restrict&gt; 数据表操作创建表 1234567create table &lt;表名&gt;(&lt;字段定义&gt;);&lt;字段定义&gt;：( &lt;列名&gt;&lt;数据类型&gt;[列级完整性约束] [, &lt;列名&gt;&lt;数据类型&gt;[列级完整性约束] ] … [, &lt;表级完整性约束&gt;] ) 修改表 12345678alter table&lt;表名&gt; [add[column] &lt;新列名&gt;&lt;数据类型&gt;[列级完整性约束] ] [add &lt;表级完整性约束&gt;] /*ADD **UNIQUE(Name)** */ [drop [column] &lt;列名&gt;[cascade|restrict] ] [drop constraint &lt;完整性约束**名**&gt;[cascade|restrict]] [alter column &lt;已存在列名&gt;&lt;新数据类型&gt;] 删除表 1drop table &lt;表名&gt;[restrict|cascade]; DQL语言12345select [all|distinct]&lt;目标列表达式&gt; [,&lt;目标列表达式&gt;]…from &lt;表/视图名&gt;[,&lt;表/视图名&gt;…][where &lt;条件表达式&gt;][group by &lt;列名1&gt; [having&lt;条件表达式&gt;]][order by &lt;列名2&gt; [asc|desc]]; &lt;目标列表达式&gt;：控制取某字段、字段别名、’常量列’、运算式、调用函数 调用函数：count(*)、sum、avg、max、min。均可选择count( [distinct | all] &lt;列名&gt;) &lt;条件表达式&gt;： =，&gt;，&lt;，&gt;=，&lt;=，!=，&lt;&gt;，!&gt;，!&lt; ; NOT + 上述比较运算符 范围：between and、not between and： &lt;字段名&gt;between &lt;值1&gt;and&lt;值2&gt;; 集合：in，not in ：&lt;字段名&gt; in (&lt;数据集合|子查询&gt;); 字符匹配：like、not like ：&lt;字段名&gt; like ‘&lt;匹配串&gt;’; [ESCAPE ‘&lt;换转义符字符&gt;’] 空值：is null、is not null ：&lt;字段名&gt;is null; 条件：and、or、not：&lt;条件表达式&gt; AND &lt;条件表达式&gt;; DL高级查询DQL高级查询：子查询、连接查询、集合查询 子查询(嵌套查询)12select…from…where &lt;字段&gt;&lt;子查询谓词&gt;(&lt;查询块&gt;)&lt;查询块&gt;：select…from…where &lt;子查询谓词&gt;：in、比较运算符、比较运算符+any/some,all、exists any，&lt;all等…，(any：某个值、all：所有值) exists：不返回任何数据，只产生逻辑真假“true/false” 连接查询 连接查询：等值、非等值、自连接、外连接(左外右外) 连接查询：from 多表 + 表名点取字段 + 别名设计 + 连接谓词 等值连接等值连接查询：连接条件/谓词使用 “=” 符号 12from &lt;表1&gt;[,表2]…where &lt;表1&gt;.&lt;字段&gt; = &lt;表2&gt;.&lt;字段&gt;… 非等值连接查询非等值连接查询：连接条件/谓词不是使用 “=” 符号 自身连接查询自身连接查询：同一个表设置不同的别名 123select&lt;别名1&gt;.&lt;字段1&gt;,&lt;别名2&gt;.&lt;字段2&gt;from&lt;表名1&gt;.&lt;别名1&gt;,&lt;表名2&gt;.&lt;别名2&gt;where &lt;别名1&gt;.&lt;字段2&gt;=&lt;别名2&gt;.&lt;字段1&gt; 外连接查询12from &lt;表1&gt; left outer join &lt;表2&gt; on(&lt;连接条件&gt;) /*左外(保留左表数据)*/from &lt;表1&gt; right outer join &lt;表2&gt; on(&lt;连接条件&gt;) /* 右外(保留右表数据) */ 集合查询12&lt;查询块集合1&gt; &lt;集合查询谓词&gt; &lt;查询块集合2&gt;&lt;集合查询谓词&gt;：交操作intersect，并操作union，差(集)操作except DML语言：​ 插入 1insert into&lt;表名&gt;[(&lt;属性列1[,属性列2]&gt;…)] values(&lt;常量1&gt;[,&lt;常量2&gt;…); 若不写字段，则必须按序写完value参数 插入多条语句values(),(),()… 允许空的字段，value值可用null占位 若填写了属性列表，则value部分必须一一对应(数量上，类型上)。且属性列表不一定按序，可自动识别字段名，但数据要和字段名对应。 子查询插入 1insert into &lt;表名&gt;[(&lt;属性列1[,属性列2]&gt;…)] &lt;子查询&gt; 通过子查询的形式不用写value，但子查询字段同样需要对应属性列信息 ​ 修改 12update &lt;表名&gt; set &lt;列名&gt; = &lt;表达式&gt;[,&lt;列名&gt; = &lt;表达式&gt;][where &lt;条件&gt;] ​ 删除 1delete from &lt;表名&gt; [where &lt;条件&gt;]; 视图123create view &lt;视图名&gt; [(&lt;列名&gt;[,&lt;列名&gt;]…)]as &lt;子查询&gt;[with check option] ​ # 数据库安全性 以下均为自主存储控制方法 授予权限1234grant &lt;权限/操作类型&gt;[,权限]...on &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]... /*一般为： Table &lt;表名&gt;*/to &lt;用户&gt;[,&lt;用户&gt;]... /*注意：授予权限给用户前需存在这个用户(新建或原本存在)*/[with grant option] example： 1234/*把查询Student表的权限授给用户U1*/grant SELECTon TABLE Studentto U1; &lt;权限/操作类型&gt;：即为用户授予哪些操作 可控制操作权限类型 具体语句 数据库 create schema 数据表 create table，alter table 视图 create view 索引 create index 基本表和视图 select，insert，update，delete，references，all privileges(所有权限) 属性列 select，insert，update，references，all privileges &lt;对象类型&gt; &lt;对象名&gt;：一般最大是表级限制。即 Table &lt;表名&gt; &lt;用户&gt;：若不存在指定用户需要先建立用户才能进行对应的授权操作，sql server2008 R2 环境下创建新用户步骤如下： 创建指定数据库的用户需要与这个用户的登录用户绑定：即想建立用户，必须先建立这个用户对应的登录用户 创建新登录用户 打开sql server，连接数据库后。找到根目录下的“安全性”文件夹。 选中“登录名”文件夹并右键点击“新建登录名” 设置登录名，并选择“sql server 身份验证”，设置密码(自己记住)。 最后把“强制密码过期(x)**”的勾选去除**，最后点击右下加确认按钮保存即可 创建用户 进入到需创建用户的数据库文件夹内，找到指定数据库目录下的“安全性”文件夹 此时在选中“安全性”文件夹后右键——&gt;新建——&gt;用户(U) 输入用户名，可自定义(但一般与对应的登录用户名一致) 点击在“登录名”输入栏最右边的“**[…]”按钮，展开后右边点击“浏览”，勾选刚刚建立的新登录用户名**，最后点击左下角确认按钮保存即可。 [with grant option]：若使用该子句，获得权限的用户可以将次权限传递授予给其他用户，默认不允许。且SQL标准不允许循环授权 实操备注： 有别于教材，当前环境添加&lt;对象类型&gt;即table关键字会报错 当前环境grant语句一次性只允许向一个表授权，可同时向多个用户授权 收回权限数据库完整性数据库完整性指：数据的正确性与相容性","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"}]},{"title":"数据结构 第五章 树、森林&与二叉树的转换","slug":"数据结构 第五章 树、森林&与二叉树的转换","date":"2020-10-21T07:16:32.000Z","updated":"2021-08-25T15:27:11.781Z","comments":true,"path":"2020/10/21/数据结构 第五章 树、森林&与二叉树的转换/","link":"","permalink":"http://yoursite.com/2020/10/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97&%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲二叉树、树、森林之间转换树、森林的结构类似复杂多样，不方便设计统一的算法。因此转换为二叉树统一处理 树转换为二叉树树“加兄保子调层次” 加线：所有兄弟节点之间加一条线 去线：对于树中每个结点，只保留 firstchild的连线，其余均删除 层次调整： 文字概述：以原树结构为基准，从根结点开始，第一个孩子为根结点的左孩子，而其余兄弟结点(以原树结构为基准)均为这个左孩子的右孩子(孙子…反之一直右下衍生) 图形化理解：从上到下以原树为基准每个子树除第一个孩子为左孩子外，其余均为这个左孩子的右孩子延续 红色为根节点 蓝色为根节点下第一个孩子 绿色为以原树基准的非首孩子的其他孩子 二叉树转换为树完全倒序操作：加兄保子调层次，调层次保子加兄，再逆序，保子(不保子：加次子/加右孩)，加兄(去兄：去右孩子) “加子去右调层次” 加线：若某个左孩子结点存在，则将这个左孩子的所有右孩子结点都与该左孩子的双亲结点相连 去线：去除所有结点的右孩子结点的连线 层次调整：外貌调整 森林转换为二叉树“森林变树，依次连根” 把森林的每颗树都转换为二叉树 第一颗树不动，其余树依次为上一课树的根节点的右孩子。 二叉树转换为森林“有右即分转森林，无右二叉只变树” 二叉树有可能转换成一棵树也有可能转换成森林 “有右即分”：若二叉树存在右孩子，则将其分离出来，若分离后的二叉树还存在右孩子则继续分离，直至不存在有右孩子的二叉树。 再把每一颗二叉树都转换为树即可。 赫夫曼树(哈夫曼)及其应用赫夫曼树(哈夫曼)树又称为最优二叉树 赫夫曼树的优化思想赫夫曼树的定义赫夫曼树编码 树、森林复杂，转换为二叉树处理 树转换为二叉树 二叉树转换为树 森林(森林-&gt;树)转换为二叉树 二叉树转换为森林 树与森林的遍历：先根、后根。前序，后序 二叉树的应用，赫夫曼树(最优二叉树) 引入：让单一线性的区分结构——&gt;通过权/频率——&gt;用二叉树来体现权的表示，从而实现路径长度上的优化。 而这种路径的优化，在代码执行上缩短总的执行次数。而在存储空间上可以应用在设计长短不等的编码，在通过编码的层面上实现无损的数据压缩(赫夫曼编码) 基本概念：路径长度、树的路径长度、带权路径长度 二叉树转换为赫夫曼树(最优二叉树) 赫夫曼编码(赫夫曼编码转换过程) 材料：字符集，权 画出最优二叉树 左分支代表0，右分支代表1，并实现其前缀编码。","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 第六章 树","slug":"数据结构 第六章 树","date":"2020-10-21T07:11:32.000Z","updated":"2021-08-25T15:27:11.818Z","comments":true,"path":"2020/10/21/数据结构 第六章 树/","link":"","permalink":"http://yoursite.com/2020/10/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%A0%91/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲 树的定义 树的相关概念 树的存储结构 二叉树 二叉树的性质 树的定义 树(Tree)是n(n ≥ 0)个结点的有限集，n = 0则为空树 在任意一颗树中，有且仅有一个称为根(Root)的结点 当结点 n &gt; 1，其余结点可分为m个互不相交的有限集T1、T2、…Tm 其中每个互不相交的有限集本身又是一颗树，并称为根的子树(SubTree) 核心：有且仅有一个称为根**整个树的根结点唯一，子树互不相交 树的相关概念结点类型度(Degree)：结点 拥有的子树的数量，所有结点最大的度称为该数的度 叶结点(Leaf)或终端节点：度 = 0； 非终端结点或分支结点：度 ≠ 0；，此类结点除根结点外，也可称为内部结点 结点间的关系 孩子(Child) 与 双亲(Parent) ：结点的子树的根称为该结点的孩子(Child)，相应地，该节点称为孩子的双亲 兄弟(Sibling)：同一个双亲的孩子之间互称兄弟 祖先：结点的祖先是从根到该结点所经历分支上的所有结点 子孙：以某结点为根，的子树中的任一结点都称为该结点的子孙 其他概念 层次(Level)：从根开始定义，根为第一层 堂兄弟：双亲在同一层结点 深度(Depth)或高度：树种结点最大的层次，称为树的深度 宽度：每一层结点个数的最大值 路径：略 树的类型 森林(forest)：是m颗(m≥0)颗互不相交的树的集合。对树种的每个结点而言，其子树的集合即为森林 有序树 与 无序树： 树的存储结构有别于线性表，树是一对多的结构，无论哪一种顺序存储结构的不能体现出这个关系，所以必须与链式存储结构结合起来表示。 双亲表示法 孩子表示法 孩子兄弟表示法 双亲表示法实现12345678910111213141516/* 树的双亲表示法结点结构定义 */#define MAX_TREE_SIZE 100/* 树结点的数据类型，目前暂定为整型 */typedef int TElemType; /* 结点结构 */typedef struct PTNode&#123; TElemType data; /* 结点数据 */ int parent; /* 双亲位置 */ &#125; PTNode;/* 树结构 */typedef struct&#123; PTNode nodes[MAX_TREE_SIZE]; /* 结点数组 */ int r, n; /* 根的位置和结点数 */ &#125; PTree; 孩子表示法实现12345678910111213141516171819/* 树的孩子表示法结构定义 */#define MAX_TREE_SIZE 100/* 孩子结点 */typedef struct CTNode&#123; int child; struct CTNode *next;&#125; *ChildPtr;/* 表头结构 */typedef struct&#123; TElemType data; ChildPtr firstchild;&#125; CTBox;/* 树结构 */typedef struct&#123; CTBox nodes[MAX_TREE_SIZE]; /* 结点数组 */ int r,n; /* 根的位置和结点数 */ &#125; CTree; 孩子兄弟表示法实现12345/* 树的孩子兄弟表示法结构定义 */typedef struct CSNode&#123; TElemType data; struct CSNode *firstchild,*rightsib;&#125; CSNode, *CSTree; 树的遍历树的遍历：按照某种次序，访问树中所有结点，且每个结点有且只有一次被访问。若规定从左到右遍历，树的遍历一般存在三种 前序(根)遍历 后序(根)遍历 层序(跟)遍历 tips：若树为二叉树，则还有一种中序遍历 注意： 前提规定“从左到右”表示，无论哪种遍历，都是决定从左子树，到右子树 前序遍历​ 从根节点开始遍历，从上到下，按先左子树，后右子树的顺序遍历每一颗子树 后序遍历​ 从根结点出发(不遍历)，从下到上，同样按先左子树，后右子树的顺序遍历每一颗子树。最后再遍历每颗子树的根结点 层序遍历/广度遍历​ 从根结点开始，自上而下，从左到右，逐层遍历 ### 前序遍历 访问树的根结点 从左到右的顺序前序遍历(从上到下)，遍历分别为根结点的每一颗子树 访问根结点，从左到右遍历根结点的孩子，若孩子又存在子树(即根节点)，从1开始循环 后序遍历 从左到右的顺序后序遍历(从下到上)，遍历分别为根结点的每一颗子树 最后访问根结点 从左到右，从下到上，即从最下底层左子树开始，从左到右遍历。每颗子树的根结点总是最后遍历 二叉树二叉树的定义 二叉树(Binary Tree)的每个结点最多只有两颗子树(即可以没有子树，或者有一颗也行，即树的度最大为2) 左子树和右子树是有顺序的，注意区别。因此二叉树存在五种基本状态 空二叉树 只有一个根节点 根结点只有左子树 根结点只有右子树 根结点既有左子树又有右子树 特殊二叉树 斜树 满二叉树 完全二叉树 斜树 左斜树：所有结点都只有左子树 右斜树：所有结点都只有左子树 斜树特点总结：每一层都只有一个结点，结点的个数与二叉树的深度相同。 满二叉树 所有分支结点都存在左子树和右子树 所有叶结点都在同一层 完全二叉树判断方法1： 一颗具有n个结点的二叉树按层序编号(从上到下，从左到右，) 每个结点按照满二叉树的结构逐层顺序编号，如果编号出现空挡，就说明不是完全二叉树，否则就是 判单方法2： 如果二叉树中除去最后一层节点为满二叉树，且最后一层的每个结点依次从左到右分布，则此二叉树被称为完全二叉树。 特点：满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树 二叉树的性质注意：以下二叉树性质，均以1开始从上到下，从左到右编号 二叉树性质1性质1：在二叉树的第 i 层上至多有 2i-1个结点 ( i ≥ 1)，即单层上的至多节点数。 解析：纯数量关系推导 二叉树的性质2性质2：深度为k的二叉树至多有 2k-1 个结点( k ≥ 1) 解析：纯数量关系推导 二叉树的性质3性质3：对于任何一颗二叉树T，如果其终端结点数为n0，度为2的结点数为n2。则n0 = n2 +1 即，所有叶结点数 = 所有根节点数 + 1 二叉树的性质4性质4：具有n个结点得完全二叉树的深度为 |_ log2n _| + 1 (|__ x _|)表示不大于x的最大整数 解析：暂时略《数据结构》从概念到C++的实现，王红梅 P137 二叉树的性质5性质5：具有n个结点完全二叉树存在如下性质 如果 i = 1，则结点 i 是二叉树的根；如果 i &gt; 1，则双亲结点是 i/2」 如果 2i &gt; n，则结点 i 无左孩子，即结点i为叶结点。反之 2i &lt; n 则i结点的左孩子是2i 如果 2i + 1 &gt; n，则结点 i 无右孩子，反之其右孩子是结点 2i + 1 正序的先左到底后右 也是先左到底，但是从左到底处出发，先左后右 二叉树的存储结构顺序存储结构设计由于二叉树定义严格，是一种特殊的树，所以可以仅使用顺序存储结构实现，仅通过数组下标的数量关系就能体现结点之间的逻辑关系 将二叉树从根节点编号为1开始，从上到小，左到右全部编号。直接按序存入数组，若是非完全二叉树，缺少部分填入空指针，但序号依然按照完全二叉树的顺序编号。 对于完全二叉树，数组下标的数量关系足够体现结点的所有逻辑关系(双亲，孩子，兄弟) 对于非完全二叉树/一般二叉树，按完全二叉树顺序编号，空缺部分均填入空指针 性能若二叉树表现出一条深度为k的 左/右斜树，则需开辟 2k-1 个空间存储，造成大量空间的浪费，因此二叉树的顺序存储结构一般只用于完全二叉树 链式存储结构 二叉链表：由于二叉表每个结点最多只有两个孩子，则一个数据域 + 两个 指针域(左右孩子)的存储结构 三叉链表：data + parent + lchild + rchild 12345/* 二叉树的二叉链表结点结构定义 */typedef struct BiTNode&#123; TElemType data; /* 数据域*/ struct BiTNode *lchild,*rchild; /* 左右孩子指针 */&#125;BiTNode,*BiTree; 遍历二叉树前言二叉树的遍历不同于线性表，即使确保“从根结点出发，依次访问二叉树的所有结点”，对于每个结点都可以有不同的选择，从而遍历的次序完全不一样。因此，可得出两个角度： 鉴于二叉树存在多种遍历次序，通常将其限制从左到右的习惯方式遍历。 鉴于可存在多种遍历次序，且处理困难，而计算机只能处理线性序列(循环,判断)**，通常利用与树的递归定义相同的递归方式来遍历。某种意义上将树的结点遍历变成线性序列** 二叉树的遍历方法限制按从左到右遍历的，会存在四种遍历方式，前序遍历、中序遍历、后序遍历、层序遍历。 “限制从左到右”，即调用左子树的递归操作一定在，调用右子树的递归操作之前！ 前、中、后序遍历的意思是，输出语句相对在左右子树递归调用的前、中、后位置 注意：无论前、中、后、层序遍历都是从根节点开始。但，从根节点开始，不等于先输出根节点！ 前序(根)遍历 访问根结点 前序遍历根结点的左子树 前序遍历根结点的右子树 中序(根)遍历 中序遍历根结点的左子树 访问根结点 中序遍历根结点的右子树 后序(根)遍历 后序遍历根结点的左子树 后序遍历根结点的右子树 访问根结点 理解的演变： 大话数据结构代码版，通过递归代码去推演：复杂，慢，易错。唯一好处，更加理解递归-回推 课堂聆听1，上下左右顺序描述更加复杂，无效 课堂聆听2，教材描述。纯文字理解(内含递归) 关键： 除“从根结点开始”这个根结点特指root这一个结点外，其他描述中的“根结点”均指每一颗子树的根结点 xxx遍历法下的描述“xxx遍历根节点的x子树”，其实表示后面的子树用于定位，可以把文字中xxx的描述递归函数的调用，即回到定义的本身，重头开始执行。即把概念描述，和递归理念结合在一起 技巧： 前根遍历： 方式1：根左、根左…根右、根左… 方式2(快)：每一棵树都是先根再输出左右(结点嵌套根) 中序遍历： 技巧是，直接从root结点深度最大的左子数开始。遍历完root结点左子孙后再从右子孙中从深度最大左子树开始。直至遍历中序遍历全部结点 每一棵树都是左到底后，访问根，再去到下一个右结点(结点嵌套，即又每一颗数左道底后，访问根…)… 后序遍历： 根结点肯定是最后访问的，找到深度大，先左输出后右输出。然后依次嵌套重复 方式2(快)：从最底层开始，从下往上推。每一棵树都是根结点最后访问，先左后右(结点嵌套根) 遍历次序记忆关键： 优先采取“树的遍历”中对三种遍历次序的文字主观描述 其次结合三行代码的顺序，结合递归执行思想，去记忆 前序遍历算法12345678910/* 二叉树的前序遍历递归算法 *//* “前”序遍历，输出语句在左子树递归和右子树递归之前，即第一行 */void PreOrderTraverse(BiTree T)&#123; if(T == NULL) return; printf(&quot;%C&quot;,T-&gt;data); //先输出 PreOrderTraverse(T-&gt;lchild);//再左子树递归 PreOrderTraverse(T-&gt;rchild);//最后右边子树递归&#125; 前序遍历算法，遍历次序如下图所示：ABDGHCEIF 中序遍历12345678910/* 二叉树的中序遍历递归算法 *//* “中”序遍历，输出语句在左子树递归和右子树递归之“中”，即第二行 */void InOrderTraverse(BiTree T)&#123; if(T == NULL) return; InOrderTraverse(T-&gt;lchild);//先左子树递归 printf(&quot;%C&quot;,T-&gt;data); //再输出 InOrderTraverse(T-&gt;rchild);//最后右子树递归&#125; 中序遍历，遍历次序如下图所示：GDHBAEICF 后序遍历12345678910/* 二叉树的后序遍历递归算法 *//* “后”序遍历，输出语句在左子树递归和右子树递归之“后”，即最后行 */void PostOrderTraverse(BiTree T)&#123; if(T == NULL) return; PostOrderTraverse(T-&gt;lchild);//先左子树递归 PostOrderTraverse(T-&gt;rchild);//再右子树递归 printf(&quot;%C&quot;,T-&gt;data); //最后才输出&#125; 后序遍历，遍历次序如下图所示：GHDBIEFCA 层序遍历与前三种遍历方式不同，层序遍历更多是由人的主观遍历次序，到对应的代码的实现。而其他三种更倾向于代码的递归逻辑设计到实际的遍历次序。 实现逻辑 初始化：创建队列，根结点入队 若队列不为空，队头出队。让队头的左右孩子入队 以此循环第2步即可 推导二叉树的遍历结果推导逻辑：(具体案例细节可参详P184~P186) 确定根节点：从前序遍历(首位)，或后序遍历(尾) 循环推导 从某一遍历推导出的某一条件出发 使用上一轮得出的条件，与上一轮不同的遍历方式结合再推出一个新条件，以此循环 注意：一般每一轮会都要利用孩子集范围，缩减孩子集范围，作为判断的条件之一 经验总结： 必须含中序遍历的条件则才能唯一确定一颗二叉树 前序遍历，用于确定根后与中序遍历占位后，来确定左孩子(同时也确定子树的根，再中序域划分…) 中序遍历，主要用于，范围划分，且占位！ 后序遍历，只要用于，被划分范围后，确定根结点(范围尾部) 实战演示 二叉树的建立扩展二叉树为了能让每个结点确认是否有左右孩子，在二叉树建立前，将其每个结点的空指针处引出一个虚结点。这种扩展后的二叉树称为扩展二叉树 二叉树的建立二叉树的建立步骤如下 画出拟建立二叉树 画出对应的扩展二叉树 以某种遍历方式写出扩展二叉树的遍历次序 以同类型的遍历方式创建按次序输入实现二叉树的建立 123456789101112131415161718192021/* 按前序输入二叉树中结点的值（一个字符） *//* #表示空树，构造二叉链表表示二叉树T。 */void CreateBiTree(BiTree *T)&#123; TElemType ch = null; /* scanf(&quot;%c&quot;,&amp;ch); */ ch=str[index++]; if(ch==&#x27;#&#x27;) *T=NULL; else &#123; *T=(BiTree)malloc(sizeof(BiTNode)); if(!*T) exit(OVERFLOW); (*T)-&gt;data=ch; /* 生成根结点 */ CreateBiTree(&amp;(*T)-&gt;lchild); /* 构造左子树 */ CreateBiTree(&amp;(*T)-&gt;rchild); /* 构造右子树 */ &#125; &#125; **C++**实现： 12345678910111213141516template&lt;typename DataType&gt;BiNode&lt;DataType&gt;* BiTree&lt;DataType&gt;::Creat()&#123; //声明一个新结点 BiThrNode&lt;DataType&gt; *btn = nullptr; char ch; cin &gt;&gt; ch; if (ch != &#x27;#&#x27;)&#123; btn = new BiThrNode&lt;DataType&gt;; btn-&gt;data = ch; btn-&gt;lchild = Creat(); btn-&gt;rchild = Creat(); &#125; return btn;&#125; 线索二叉树 二叉树的链式存储会存在大量空指针域，n个结点的二叉树就会存在 n+1个空指针域。 可以利用这些空指针域存储以某种次序创建的二叉树结点之间的前驱后继指针信息。 指向前驱和后继的指针称为线索。加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树 二叉树以某种次序遍历使其变为线索二叉树的过程称做线索化**。 线索二叉树的存储结构为区分，rchild/lchild是指向线索还是指向树结构的指针，通过两个Tag枚举变量标志，Thread为线索指针，Link为树指针 123456789typedef enum &#123;Link,Thread&#125; PointerTag; /* Link==0表示指向左右孩子指针, */ /* Thread==1表示指向前驱或后继的线索 */typedef struct BiThrNode /* 二叉线索存储结点结构 */&#123; TElemType data; /* 结点数据 */ struct BiThrNode *lchild, *rchild; /* 左右孩子指针 */ PointerTag LTag; PointerTag RTag; /* 左右标志 */&#125; BiThrNode, *BiThrTree; 中序线索化通过中序遍历实现中序线索化。代码如下，需注意： 全局变量 pre 在外初始化为 root 线索二叉树初始化需把结点置为Link，因为中序线索化只修改Thread； 令某种次序序列中的第一个结点其lchild指向二叉树的根结点 12345678910111213141516171819202122232425262728293031323334//必须以全局变量的方式参与递归操作BiThrNode&lt;char&gt; *pre = nullptr;//中序线索化void InThreading(BiThrNode&lt;char&gt; *p) &#123; //左子树递归至最后结点(非null结点) if (p) &#123; InThreading(p-&gt;lchild); //(!p-&gt;lchild)：表若当前结点左孩子为null，则lchild(前驱)线索化， //即为pre结点 if (!p-&gt;lchild) &#123;//为null p-&gt;LTag = PoinTerTag::Thread; p-&gt;lchild = pre; &#125; //(!pre-&gt;rchild)：表，若当前结点遍历的上一个结点的rchild(后继)为null， //则线索化的后继结点，为当前结点p if (!pre-&gt;rchild) &#123;//为null pre-&gt;RTag = PoinTerTag::Thread; pre-&gt;rchild = p; &#125; pre = p;//存储以某种递归次序线索化(遍历)的上一个结点位置 //因为固定从左到右，所以pre用于LTag的lchild,也用于pre结点本身的有孩子线索化 InThreading(p-&gt;rchild); &#125;&#125;void main()&#123; BiThrTree&lt;char&gt; btt&#123;&#125;; //P189二叉树 ABDH##I##EJ###CF##G## //pre全局遍历的变量环境是 pre = root; pre = btt.root; InThreading(btt.root);&#125; 遍历线索二叉树线索二叉树与双向链表线索二叉树的结构类似双链表结构，因此为了方便线索二叉树的遍历等操作，对线索二叉树添加一个头结点。添加头结点这个操作常常在线索化的时候实现，因此要对上面的中序线索化代码的基础上稍作修改——添加一个头结点，并设定初始状体如下： 头结点的lchild域指向二叉树的根结点，rchild域指向遍历时访问的最后一个结点。 遍历的第一个元素的lchild域指向头结点，最后一个结点的rchild域同样指向头结点 123456789101112131415161718192021222324/* 备注：遍历代码是重点，而对线索化的改进代码。这个是次要，还未分析学习 *//* 中序遍历二叉树T,并将其中序线索化,Thrt指向头结点 */Status InOrderThreading(BiThrTree *Thrt,BiThrTree T)&#123; *Thrt=(BiThrTree)malloc(sizeof(BiThrNode)); if(!*Thrt) exit(OVERFLOW); (*Thrt)-&gt;LTag=Link; /* 建头结点 */ (*Thrt)-&gt;RTag=Thread; (*Thrt)-&gt;rchild=(*Thrt); /* 右指针回指 */ if(!T) /* 若二叉树空,则左指针回指 */ (*Thrt)-&gt;lchild=*Thrt; else &#123; (*Thrt)-&gt;lchild=T; pre=(*Thrt); InThreading(T); /* 中序遍历进行中序线索化 */ pre-&gt;rchild=*Thrt; pre-&gt;RTag=Thread; /* 最后一个结点线索化 */ (*Thrt)-&gt;rchild=pre; &#125; return OK;&#125; 中序遍历线索二叉树(非递归版) BiThrTree T 表示头结点，则按带头结点的线索化，p = T-&gt;lchild; 则表示p等于根结点 1234567891011121314151617181920/* 中序遍历二叉线索树T(头结点)的非递归算法 */Status InOrderTraverse_Thr(BiThrTree T)&#123; BiThrTree p; p=T-&gt;lchild; /* p指向根结点 */ while(p!=T)&#123; /* 空树或遍历结束时,p==T */ while(p-&gt;LTag==Link) p=p-&gt;lchild; if(!visit(p-&gt;data)) /* 访问其左子树为空的结点 */ return ERROR; while(p-&gt;RTag==Thread&amp;&amp;p-&gt;rchild!=T)&#123;//防空树操作 p=p-&gt;rchild; visit(p-&gt;data); /* 访问后继结点 */ &#125; p=p-&gt;rchild; &#125; return OK;&#125; 代码分析 这段代码相当于一个链表的扫描，所以时间复杂度O(n) 小结： 线索二叉树充分利用了二叉树链式存储结构的空指针域空间(节省空间)，仅需创建时的一次遍历就可终生受用的前驱后继信息(节省时间)。 若二叉树需要经常遍历或查找结点时需要某种遍历序列的前驱和后继，则线索二叉树的存储结构是非常不错的选择。","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2020-09-25T13:42:32.000Z","updated":"2021-08-25T15:27:11.587Z","comments":true,"path":"2020/09/25/冒泡排序/","link":"","permalink":"http://yoursite.com/2020/09/25/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","excerpt":"","text":"冒泡排序分析 每一轮交替比较把最值往**后排(下沉)**，能得出参与这次轮次所有数中的最值 首次交替次数：最后一个数无需交替比较。即循环下标结构 for(j = 0;j &lt; len - 1; j ++ ) 接下来继续开始若干次从头开始的交替，逐一把“第2最值”，“第3最值”…排到最后(下沉) 剩余轮次交替次数：每一次交替比较后的最值无需参与下一次交替比较，剩下轮次的交替比较次数呈递减1状态 总比较轮次：每一个数都需走一遍轮次。，最后交替(数组最前的数)只需一个轮次完成，即总论次为：len - 1 总结：理论支持每一轮交替比较把最值往**后排(下沉)**，能得出参与这次轮次所有数当中的最值 核心部分 把最值往后排(下沉) 从大到小，降序，后排下沉最小值，a[ j ] &lt; a[ j + 1 ] 从小到大，升序，后排下沉最大值，a[ j ] &gt; a[ j + 1 ] 数组内部比较交替次数： 首次比较交替次数：len - 1 即for(j = 0;j &lt; len - 1;j++) 剩下轮次比较交替次数：每经一个轮次，交替比较次数减1 整个完整排序的比较轮次：最后交替比较两个数(数组最前的两个数)只需一个轮次完成，len - 1。 代码表示 比较轮次属于外循环：len - 1 内部比较交替次数属于内循环：(首次)len - 1，(剩余)每一轮次，次数减1 从大到小，降序，则后排下沉最小值(a[j] 到 a[j + 1])比较 12345678910//外循环：比较轮次for(i = 0;i &lt; len - 1;i++)&#123; //数组遍历写法 i = 0; i &lt; len; i++ 正常遍历，len-1则少一次 //内循环：交替比较次数，递减1通过i增1来实现 for(j = 0;j &lt; len - 1 - i;j++)&#123; //实现从大到小，降序，后排下沉最小值，a[ j ] &lt; a[ j + 1 ] if(a[j] &lt; a[j + 1])//边界分析：i = 0，判断上溢d = j + 1，因为“&lt;”，所以j = (len-1) - 1，所以d = len - 1(没上溢) //交换位置 &#125;&#125; 时间复杂度分析 参考：https://zhuanlan.zhihu.com/p/66768445","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"mysql基础总结","slug":"mysql基础总结","date":"2020-09-17T03:40:32.000Z","updated":"2021-08-25T15:27:11.858Z","comments":true,"path":"2020/09/17/mysql基础总结/","link":"","permalink":"http://yoursite.com/2020/09/17/mysql%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/","excerpt":"","text":"本单元目标12345678910111213141516171819202122232425262728293031323334353637一、为什么要学习数据库二、数据库的相关概念 DBMS、DB、SQL三、数据库存储数据的特点四、初始MySQL MySQL产品的介绍 MySQL产品的安装 ★ MySQL服务的启动和停止 ★ MySQL服务的登录和退出 ★ MySQL的常见命令和语法规范 五、DQL语言的学习 ★ 基础查询 ★ 条件查询 ★ 排序查询 ★ 常见函数 ★ 分组函数 ★ 分组查询 ★ 连接查询 ★ 子查询 √ 分页查询 ★ union联合查询 √ 六、DML语言的学习 ★ 插入语句 修改语句 删除语句 七、DDL语言的学习 库和表的管理 √ 常见数据类型介绍 √ 常见约束 √ 八、TCL语言的学习 事务和事务处理 九、视图的讲解 √十、变量 十一、存储过程和函数 十二、流程控制结构 数据库的好处121.持久化数据到本地2.可以实现结构化查询，方便管理 数据库相关概念1231、DB：数据库，保存一组有组织的数据的容器2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据3、SQL:结构化查询语言，用于和DBMS通信的语言 数据库存储数据的特点123451、将数据放到表中，表再放到库中2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”5、表中的数据是按行存储的，每一行类似于java中的“对象”。 MySQL产品的介绍和安装MySQL服务的启动和停止1234方式一：计算机——右击管理——服务方式二：通过管理员身份运行net start 服务名（启动服务）net stop 服务名（停止服务） MySQL服务的登录和退出123456789方式一：通过mysql自带的客户端只限于root用户方式二：通过windows自带的客户端登录：mysql 【-h主机名 -P端口号 】-u用户名 -p密码退出：exit或ctrl+C MySQL的常见命令12345678910111213141516171819202122232425261.查看当前所有的数据库show databases;2.打开指定的库use 库名3.查看当前库的所有表show tables;4.查看其它库的所有表show tables from 库名;5.创建表create table 表名( 列名 列类型, 列名 列类型， 。。。);6.查看表结构desc 表名;7.查看服务器的版本方式一：登录到mysql服务端select version();方式二：没有登录到mysql服务端mysql --version或mysql --V MySQL的语法规范12345671.不区分大小写,但建议关键字大写，表名、列名小写2.每条命令最好用分号结尾3.每条命令根据需要，可以进行缩进 或换行4.注释 单行注释：#注释文字 单行注释：-- 注释文字 多行注释：&#x2F;* 注释文字 *&#x2F; SQL的语言分类12345678DQL（Data Query Language）：数据查询语言 select DML(Data Manipulate Language):数据操作语言 insert 、update、deleteDDL（Data Define Languge）：数据定义语言 create、drop、alterTCL（Transaction Control Language）：事务控制语言 commit、rollback SQL的常见命令1234567891011show databases； 查看所有的数据库use 库名； 打开指定 的库show tables ; 显示库中的所有表show tables from 库名;显示指定库中的所有表create table 表名( 字段名 字段类型, 字段名 字段类型); 创建表desc 表名; 查看指定表的结构select * from 表名;显示表中的所有数据 DQL语言的学习进阶1：基础查询12345678语法：SELECT 要查询的东西【FROM 表名】;类似于Java中 :System.out.println(要打印的东西);特点：①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数 进阶2：条件查询1234567891011121314151617181920212223242526条件查询：根据条件过滤原始表的数据，查询到想要的数据语法：select 要查询的字段|表达式|常量值|函数from 表where 条件 ;分类：一、条件表达式 示例：salary&gt;10000 条件运算符： &gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D; !&#x3D; &lt;&gt;二、逻辑表达式示例：salary&gt;10000 &amp;&amp; salary&lt;20000逻辑运算符： and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false or(||)：两个条件只要有一个成立，结果为true，否则为false not(!)：如果条件成立，则not后为false，否则为true三、模糊查询示例：last_name like &#39;a%&#39; 进阶3：排序查询123456789语法：select 要查询的东西from 表where 条件order by 排序的字段|表达式|函数|别名 【asc|desc】 进阶4：常见函数1234567891011121314151617181920212223242526272829303132333435363738一、单行函数1、字符函数 concat拼接 substr截取子串 upper转换成大写 lower转换成小写 trim去前后指定的空格和字符 ltrim去左边空格 rtrim去右边空格 replace替换 lpad左填充 rpad右填充 instr返回子串第一次出现的索引 length 获取字节个数2、数学函数 round 四舍五入 rand 随机数 floor向下取整 ceil向上取整 mod取余 truncate截断3、日期函数 now当前系统日期+时间 curdate当前系统日期 curtime当前系统时间 str_to_date 将字符转换成日期 date_format将日期转换成字符4、流程控制函数 if 处理双分支 case语句 处理多分支 情况1：处理等值判断 情况2：处理条件判断5、其他函数 version版本 database当前库 user当前连接用户 二、分组函数 123456789101112131415sum 求和max 最大值min 最小值avg 平均值count 计数特点：1、以上五个分组函数都忽略null值，除了count(*)2、sum和avg一般用于处理数值型 max、min、count可以处理任何数据类型3、都可以搭配distinct使用，用于统计去重后的结果4、count的参数可以支持： 字段、*、常量值，一般放1 建议使用 count(*) 进阶5：分组查询1234567891011121314151617语法：select 查询的字段，分组函数from 表group by 分组的字段特点：1、可以按单个字段分组2、和分组函数一同查询的字段最好是分组后的字段3、分组筛选 针对的表 位置 关键字分组前筛选： 原始表 group by的前面 where分组后筛选： 分组后的结果集 group by的后面 having4、可以按多个字段分组，字段之间用逗号隔开5、可以支持排序6、having后可以支持别名 进阶6：多表连接查询12笛卡尔乘积：如果连接条件省略或无效则会出现解决办法：添加上连接条件 一、传统模式下的连接 ：等值连接——非等值连接 12341.等值连接的结果 &#x3D; 多个表的交集2.n表连接，至少需要n-1个连接条件3.多个表不分主次，没有顺序要求4.一般为表起别名，提高阅读性和性能 二、sql99语法：通过join关键字实现连接 123456789101112131415161718含义：1999年推出的sql语法支持：等值连接、非等值连接 （内连接）外连接交叉连接语法：select 字段，...from 表1【inner|left outer|right outer|cross】join 表2 on 连接条件【inner|left outer|right outer|cross】join 表3 on 连接条件【where 筛选条件】【group by 分组字段】【having 分组后的筛选条件】【order by 排序的字段或表达式】好处：语句上，连接条件和筛选条件实现了分离，简洁明了！ 三、自连接 案例：查询员工名和直接上级的名称 sql99 123SELECT e.last_name,m.last_nameFROM employees eJOIN employees m ON e.&#96;manager_id&#96;&#x3D;m.&#96;employee_id&#96;; sql92 123SELECT e.last_name,m.last_nameFROM employees e,employees m WHERE e.&#96;manager_id&#96;&#x3D;m.&#96;employee_id&#96;; 进阶7：子查询含义： 12一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询 特点： 123456789101112131415161、子查询都放在小括号内2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧3、子查询优先于主查询执行，主查询使用了子查询的执行结果4、子查询根据查询结果的行数不同分为以下两类：① 单行子查询 结果集只有一行 一般搭配单行操作符使用：&gt; &lt; &#x3D; &lt;&gt; &gt;&#x3D; &lt;&#x3D; 非法使用子查询的情况： a、子查询的结果为一组值 b、子查询的结果为空② 多行子查询 结果集有多行 一般搭配多行操作符使用：any、all、in、not in in： 属于子查询结果中的任意一个就行 any和all往往可以用其他查询代替 进阶8：分页查询应用场景： 1实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句 语法： 1234567select 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 【起始的条目索引，】条目数; 特点： 123456781.起始条目索引从0开始2.limit子句放在查询语句的最后3.公式：select * from 表 limit （page-1）*sizePerPage,sizePerPage假如:每页显示条目数sizePerPage要显示的页数 page 进阶9：联合查询引入： union 联合、合并 语法： 12345select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】.....select 字段|常量|表达式|函数 【from 表】 【where 条件】 特点： 1231、多条查询语句的查询的列数必须是一致的2、多条查询语句的查询的列的类型几乎相同3、union代表去重，union all代表不去重 DML语言插入语法： insert into 表名(字段名，…) values(值1，…); 特点： 123451、字段类型和值类型一致或兼容，而且一一对应2、可以为空的字段，可以不用插入值，或用null填充3、不可以为空的字段，必须插入值4、字段个数和值的个数必须一致5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致 修改修改单表语法： 12update 表名 set 字段&#x3D;新值,字段&#x3D;新值【where 条件】 修改多表语法： 1234update 表1 别名1,表2 别名2set 字段&#x3D;新值，字段&#x3D;新值where 连接条件and 筛选条件 删除方式1：delete语句 单表的删除： ★ delete from 表名 【where 筛选条件】 多表的删除： delete 别名1，别名2 from 表1 别名1，表2 别名2 where 连接条件 and 筛选条件; 方式2：truncate语句 1truncate table 表名 两种方式的区别【面试题】 12345678#1.truncate不能加where条件，而delete可以加where条件#2.truncate的效率高一丢丢#3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始#delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始#4.truncate删除不能回滚，delete删除可以回滚 DDL语句库和表的管理库的管理： 1234一、创建库create database 库名二、删除库drop database 库名 表的管理： #1.创建表 12345678910111213141516171819202122232425262728293031CREATE TABLE IF NOT EXISTS stuinfo( stuId INT, stuName VARCHAR(20), gender CHAR, bornDate DATETIME);DESC studentinfo;#2.修改表 alter语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;#①修改字段名ALTER TABLE studentinfo CHANGE COLUMN sex gender CHAR;#②修改表名ALTER TABLE stuinfo RENAME [TO] studentinfo;#③修改字段类型和列级约束ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;#④添加字段ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;#⑤删除字段ALTER TABLE studentinfo DROP COLUMN email;#3.删除表DROP TABLE [IF EXISTS] studentinfo; 常见类型12345678整型：小数： 浮点型 定点型字符型：日期型：Blob类型： 常见约束123456NOT NULLDEFAULTUNIQUECHECKPRIMARY KEYFOREIGN KEY 数据库事务含义1通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态 特点12345（ACID）原子性：要么都执行，要么都回滚一致性：保证数据的状态操作前和操作后保持一致隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改 相关步骤： 1231、开启事务2、编写事务的一组逻辑操作单元（多条sql语句）3、提交事务或回滚事务 事务的分类：隐式事务，没有明显的开启和结束事务的标志 12比如insert、update、delete语句本身就是一个事务 显式事务，具有明显的开启和结束事务的标志 1234567891、开启事务取消自动提交事务的功能2、编写事务的一组逻辑操作单元（多条sql语句）insertupdatedelete3、提交事务或回滚事务 使用到的关键字12345678set autocommit&#x3D;0;start transaction;commit;rollback;savepoint 断点commit to 断点rollback to 断点 事务的隔离级别:事务并发问题如何发生？ 1当多个事务同时操作同一个数据库的相同数据时 事务的并发问题有哪些？ 123脏读：一个事务读取到了另外一个事务未提交的数据不可重复读：同一个事务中，多次读取到的数据不一致幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据 如何避免事务的并发问题？ 12345通过设置事务的隔离级别1、READ UNCOMMITTED2、READ COMMITTED 可以避免脏读3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读4、SERIALIZABLE可以避免脏读、不可重复读和幻读 设置隔离级别： 1set session|global transaction isolation level 隔离级别名; 查看隔离级别： 1select @@tx_isolation; 视图含义：理解成一张虚拟的表 视图和表的区别： 12345 使用方式 占用物理空间视图 完全相同 不占用，仅仅保存的是sql逻辑表 完全相同 占用 视图的好处： 121、sql语句提高重用性，效率高2、和表实现了分离，提高了安全性 视图的创建1234语法：CREATE VIEW 视图名AS查询语句; 视图的增删改查1234567891011121314151、查看视图的数据 ★SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name&#x3D;&#39;Partners&#39;;2、插入视图的数据INSERT INTO my_v4(last_name,department_id) VALUES(&#39;虚竹&#39;,90);3、修改视图的数据UPDATE my_v4 SET last_name &#x3D;&#39;梦姑&#39; WHERE last_name&#x3D;&#39;虚竹&#39;;4、删除视图的数据DELETE FROM my_v4; 某些视图不能更新123456包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union all常量视图Select中包含子查询joinfrom一个不能更新的视图where子句的子查询引用了from子句中的表 视图逻辑的更新123456789101112#方式一：CREATE OR REPLACE VIEW test_v7ASSELECT last_name FROM employeesWHERE employee_id&gt;100;#方式二:ALTER VIEW test_v7ASSELECT employee_id FROM employees;SELECT * FROM test_v7; 视图的删除1DROP VIEW test_v1,test_v2,test_v3; 视图结构的查看12DESC test_v7;SHOW CREATE VIEW test_v7; 存储过程含义：一组经过预先编译的sql语句的集合 好处： 1231、提高了sql语句的重用性，减少了开发程序员的压力2、提高了效率3、减少了传输次数 分类： 1234561、无返回无参2、仅仅带in类型，无返回有参3、仅仅带out类型，有返回无参4、既带in又带out，有返回有参5、带inout，有返回有参注意：in、out、inout都可以在一个存储过程中带多个 创建存储过程语法： 12345create procedure 存储过程名(in|out|inout 参数名 参数类型,...)begin 存储过程体end 类似于方法： 1234修饰符 返回类型 方法名(参数类型 参数名,...)&#123; 方法体;&#125; 注意 1234567891011121314151617181、需要设置新的结束标记delimiter 新的结束标记示例：delimiter $CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)BEGIN sql语句1; sql语句2;END $2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end3、参数前面的符号的意思in:该参数只能作为输入 （该参数不能做返回值）out：该参数只能作为输出（该参数只能做返回值）inout：既能做输入又能做输出 调用存储过程1call 存储过程名(实参列表) 函数创建函数学过的函数：LENGTH、SUBSTR、CONCAT等 语法： 12345CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型BEGIN 函数体END 调用函数1SELECT 函数名（实参列表） 函数和存储过程的区别123 关键字 调用语法 返回值 应用场景函数 FUNCTION SELECT 函数() 只能是一个 一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个存储过程 PROCEDURE CALL 存储过程() 可以有0个或多个 一般用于更新 流程控制结构系统变量一、全局变量 作用域：针对于所有会话（连接）有效，但不能跨重启 123456789查看所有全局变量SHOW GLOBAL VARIABLES;查看满足条件的部分系统变量SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;查看指定的系统变量的值SELECT @@global.autocommit;为某个系统变量赋值SET @@global.autocommit&#x3D;0;SET GLOBAL autocommit&#x3D;0; 二、会话变量 作用域：针对于当前会话（连接）有效 12345678910查看所有会话变量SHOW SESSION VARIABLES;查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;查看指定的会话变量的值SELECT @@autocommit;SELECT @@session.tx_isolation;为某个会话变量赋值SET @@session.tx_isolation&#x3D;&#39;read-uncommitted&#39;;SET SESSION tx_isolation&#x3D;&#39;read-committed&#39;; 自定义变量一、用户变量 声明并初始化： 123SET @变量名&#x3D;值;SET @变量名:&#x3D;值;SELECT @变量名:&#x3D;值; 赋值： 123456789方式一：一般用于赋简单的值SET 变量名&#x3D;值;SET 变量名:&#x3D;值;SELECT 变量名:&#x3D;值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表; 使用： 1select @变量名; 二、局部变量 声明： 1declare 变量名 类型 【default 值】; 赋值： 123456789方式一：一般用于赋简单的值SET 变量名&#x3D;值;SET 变量名:&#x3D;值;SELECT 变量名:&#x3D;值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表; 使用： 1select 变量名 二者的区别： 1作用域 定义位置 语法 用户变量 当前会话 会话的任何地方 加@符号，不用指定类型 局部变量 定义它的BEGIN END中 BEGIN END的第一句话 一般不用加@,需要指定类型 分支一、if函数 语法：if(条件，值1，值2) 特点：可以用在任何位置 二、case语句 语法： 123456789101112131415情况一：类似于switchcase 表达式when 值1 then 结果1或语句1(如果是语句，需要加分号) when 值2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）情况二：类似于多重ifcase when 条件1 then 结果1或语句1(如果是语句，需要加分号) when 条件2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要） 特点： 可以用在任何位置 三、if elseif语句 语法： 12345if 情况1 then 语句1;elseif 情况2 then 语句2;...else 语句n;end if; 特点： 只能用在begin end中！！！！！！！！！！！！！！！ 三者比较： 应用场合 if函数 简单双分支 case结构 等值判断 的多分支 if结构 区间判断 的多分支 循环语法： 123【标签：】WHILE 循环条件 DO 循环体END WHILE 【标签】; 特点： 12345只能放在BEGIN END里面如果要搭配leave跳转语句，需要使用标签，否则可以不用标签leave类似于java中的break语句，跳出所在循环！！！ 引用：尚硅谷—mysql基础语法总结","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"数据结构 第三章 静态链表","slug":"数据结构 第三章 静态链表","date":"2020-09-09T13:38:32.000Z","updated":"2021-08-25T15:27:11.747Z","comments":true,"path":"2020/09/09/数据结构 第三章 静态链表/","link":"","permalink":"http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲 基本概念 静态链表的初始化 静态链表的插入操作 小结 基本概念 静态链表：用数组描述的链表叫做静态链表。 如Basic、Fortran等早期编程语言，没有指针，就可通过数组实现链表结构(游标实现法)。 静态链表使用两个数据域组成，分别叫data、cur，cur类似单链表中的next。不记录指针，而是记录后继元素的数组下标。 123456/*线性表的静态链表存储结构*/#define MAXSIZE 1000typedef struct&#123; ElemType data; int cur; /*游标(Cursor)，为0时表示无指向*/&#125; 静态链表的第一个和最后一个元素作为特殊处理，不存数据。 未被使用的数组元素称为备用链表。 下标为0的第一个元素cur称为头指针，用于存放备用链表的下标。 数组最后一个元素的cur，存放第一个有数值元素的下标(相当于头结点)。 静态链表初始化123456789/*将一维数组space中各个分量链成一备用链表*/Status InitList(StaticLinkList space)&#123; int i; for(i = 0; i &lt; MAXSIZE - 1; i++)/*为链表所有元素cur赋值，将其中各个分量链成一备用链表*/ space[i] = i + 1; space[MAXSIZE - 1].cur = 0; /*目前链表为空，最后一个元素的cur为0*/ return OK;&#125; 静态链表的插入操作链表的插入/删除操作都需要调用存储空间的申请/释放函数。标准定义的malloc，free函数直接调用就可自动申请或释放空间。对于通过数组实现链表功能的静态链表实现插入/删除操作首先要解决的问题：如何用**静态模拟动态链表对存储空间的分配/管理(申请/释放)**。需要时申请、无用时释放。 Malloc_SSL 因此静态链表需要自己实现单链表的malloc函数功能。 功能描述：若备用空间链表非空，则返回可分配的结点下标(类似向内存申请空间，返回地址值)，否则返回0。 实现思路： 静态链表设计本身然下标为0的元素存放备用链表的下标，所以直接返回下标0的cur即可。 同时，需要把即将返回的备用链表的cur值重新填充到下标为0的cur，为下次分配使用。 12345678910/*若备用空间链表非空，则返回可分配的结点下标，否则返回0*/int Malloc_SSL(StaticLinkList space) &#123; int i = space[0].cur; /* 当前数组第一个元素的cur存的值 */ /* 就是要返回的第一个备用空闲的下标 */ if (space[0]. cur) space[0]. cur = space[i].cur; /* 由于要拿出一个分量来使用了， */ /* 所以我们就得把它的下一个 */ /* 分量用来做备用 */ return i;&#125; ListInsert思路： 基本插入错误过滤 获取空闲分量下标 填充数据域 定位前继结点 头插法 12345678910111213141516171819202122Status ListInsert(StaticLinkList L, int i, ElemType e) &#123; if (i &lt; 1 || i &gt; ListLength(L) + 1) //若链表已满 return ERROR; int j = Malloc_SLL(L); //获得空闲分量的下标 if (j) &#123; L[j].data = e;//将数据赋值给此分量的data int k = MAXSIZE -1,l; //找到插入位置的前继元素，(计数器+while+工作指针后移) //静态链表的头结点在尾部 for (l = 1; l &lt;= i - 1; l++) k = L[k].cur; L[j].cur = L[k].cur;//改变游标指向(头插法) L[k].cur = j; //先把前继节点的后继游标传给新节点的后继游标 return OK; &#125; return ERROR; //若获取分量失败则返回错误 &#125; 注意： 获取头结点下标：int k = MAXSIZE -1 Free_SSL同样，静态链表实现删除操作也要先实现free函数 1234567/*将下标为k的空闲结点回收到备用链表*/void Free_SSL(StaticLinkList space, int k) &#123; space[k].cur = space[0].cur; //让即将要删除的位置成为第一个优先的空位 space[0].cur = k; //即删除节点与备用链表交换两个参数&#125; ListDelete12345678910111213141516Status ListDelete(StaticLinkList L, int i) &#123; if (i &lt; 1 || i &gt; ListLength(L))//删除索引过滤 return ERROR; int k = MAXSIZE - 1; int l; for (l = 1; l &lt;= i -1; l++) //定位前继节点 k = L[k].cur; int d = L[k].cur;//创建临时变量存储欲删除cur L[k].cur = L[d].cur; Free_SSL(L,d); return OK;&#125; 小结静态链表其实为了给没有指针的高级语言设计的一种实现单链表能力的方法。特性与单链表类似，尽管以后这种方法不一定用上，但这样的思考方式是非常巧妙的。","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"图床解决方案","slug":"图床解决方案","date":"2020-08-29T00:11:02.000Z","updated":"2021-08-25T15:27:11.854Z","comments":true,"path":"2020/08/29/图床解决方案/","link":"","permalink":"http://yoursite.com/2020/08/29/%E5%9B%BE%E5%BA%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"参考链接 本人解决方案：https://www.jianshu.com/p/b69950a49ae2 markdown各种解决方案：https://www.jianshu.com/p/ea1eb11db63f picgo连接gitee： https://www.jianshu.com/p/b69950a49ae2 https://blog.csdn.net/disILLL/article/details/104944710 https://www.cnblogs.com/qtzd/p/12554902.html 软件关系简要说明 Typora 作为markdown编辑器本身具备的优势 最新版支持 picgo自动上传功能呢 picgo(图床工具) 主要功能：与各大图床存储平台对接，实现快捷本地上传，返回各种需求的连接服务(markdown、html、svg链接等) gitee：作为一个免费图床存储平台，无防盗链设置","categories":[],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"Hexo在Gitee平台部署过程","slug":"Hexo在Gitee平台部署过程","date":"2020-08-28T23:09:02.000Z","updated":"2021-08-25T15:27:11.861Z","comments":true,"path":"2020/08/29/Hexo在Gitee平台部署过程/","link":"","permalink":"http://yoursite.com/2020/08/29/Hexo%E5%9C%A8Gitee%E5%B9%B3%E5%8F%B0%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B/","excerpt":"","text":"前提 已经安装hexo，并且能够通过hexo d命令推送到GitHub实现远程推送。 实现方案具体可参考《基于Hexo框架的博客搭建及其GitHub部署》 已经注册Gitee账号并且绑定手机。 Gitee新建仓库 新建仓库时名称最好是保持跟你注册时的个人空间地址是一样的。因为这样你就不会生成二级域名了。如果不跟注册时的个人空间地址一样的话，到时候自己的网站就会有二级域名的存在了。 输入仓库名称与路径后会在“归属”一栏下生成一个仓库链接，记录下来为之后的_config.yml文件配置做准备 _config.yml文件配置修改配置文件中repo 属性为：{仓库地址} .git 仓库地址在创建仓库的时候会显示，或者在刚创建完的时候浏览器的url就是仓库地址 仓库地址一般组成： https://gitee.com/{个人空间名}/{仓库名称} 123456# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deploymentdeploy: type: &#39;git&#39; repo: &#123;仓库地址&#125;.git branch: master repo: https://gitee.com/yihangdeng/yihangdeng.git 修改配置保存后，可以像推送到GitHub上那样，通过hexo d命令上传到gitee。刷新gitee仓库查看是否有内容 开启仓库page服务 进入页面后直接点击启动即可。 启动完成后会生成网站地址，这个网站地址就是访问你博客的地址。 gitee page 只有付费版才能自动更新，免费版只能手动点击 “设置” 中的更新按钮，来更新部署。 参考链接 gitee：https://www.cnblogs.com/chaojilaoshi/p/13266271.html gitee：https://www.jianshu.com/p/5014133ba61a page更新：https://www.jianshu.com/p/6460df84a099","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"Gitee","slug":"Gitee","permalink":"http://yoursite.com/tags/Gitee/"}]},{"title":"基于Hexo框架的博客搭建及其GitHub部署","slug":"基于Hexo框架的博客搭建及其GitHub部署","date":"2020-08-28T01:09:02.000Z","updated":"2021-08-25T15:27:11.562Z","comments":true,"path":"2020/08/28/基于Hexo框架的博客搭建及其GitHub部署/","link":"","permalink":"http://yoursite.com/2020/08/28/%E5%9F%BA%E4%BA%8EHexo%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%85%B6GitHub%E9%83%A8%E7%BD%B2/","excerpt":"","text":"Hexo简介 Hexo 是一个快速、简洁且高效的静态博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo受众面较广，对应的问题、扩展等内容在网上均有成熟解决方案，推荐安装使用。 安装安装前提安装Hexo之前需要先安装Node.js与Git。 ps：本文所有安装过程基于Windows环境下操作 Git安装 官网下载地址：https://git-scm.com/downloads 默认自动弹出适配版本，若没有则在“Git for Windows Setup”选择对应电脑位数下载 安装过程一直next直到完成即刻。 设置Git用户名 ps:Windows终端(cmd)内操作,不设置用户名和密码在安装hexo的过程中会报错 设置用户名git config --global user.name &quot;username&quot; 设置邮箱git config --global user.email useremail@qq.com 修改后可以检查一下，查看用户名和密码 git config user.name git config user.email 查看其他配置信息 git config --list Node.js安装 官方下载地址：https://nodejs.org/en/ 一般选择左边的 XX.XX.X LTS (长期支持版) 安装过程简单，直接操作即可。 安装完成后存在两个组件，一个是Node.js本身，另一个是npm(包管理器) hexo下载与安装 以管理员身份进入Windows终端。 检查node.js的安装结果node –vnpm –v 通过npm或cnpm安装hexo npm是外国的镜像源速度很慢，用淘宝的cnpm比较快 npm install -g cnpm --registry=http://registry.npm.taobao.org 通过cnpm下载安装hexocnmp install -g hexo cli 安装完成后通过命令可查看版本表示安装成功hexo –v hexo博客初始化 以下操作均在”总文件”路径下完成，且实例说明以名为”myblog”的文件夹表示hexo总文件夹。 若接下来的操作出现什么错误，直接把这个总文件夹删除重新来过即可 在想要安装博客的路径下创建一个总文件夹，如“myblog” 通过终端进入到这个总文件夹路径下 初始化博客 hexo init 常用组成文件功能介绍 ├_config.yml├&lt;source&gt;&emsp;&emsp;├&lt;_posts&gt;├&lt;themes&gt; _config.yml：配置文件，用于配置博客的重要属性 &lt;source&gt;：用于存放各种类型的md文件 &lt;_posts&gt; ：hexo new命令生成的md文件存位置 &lt;themes&gt;：存放不同的主题 启动博客，通过浏览器尝试访问 hexo s 终端会提示本地端口访问，一般为：localhost:4000 基本操作 ps：所有hexo命令操作都需要在安装hexo的总文件夹路径下操作 创建一篇文章， 新建的文章即md文件存放在/source/_posts hexo new &quot;My New Post&quot; 停止运行hexoctrl + c 清理之前生成的内容 hexo clean 校验并生成新的内容 hexo g GitHub部署仓库设置 登录github，创建仓库：repository name设置为：username.github.io 您github账号中的username,如博主账号username为yihangdeng则repository name 设置为：yihangdeng.github.io 其他保持默认即可，点击“Create repository”完成仓库创建 生成的链接结构为： https://github.com/username/username.github.io.git如：https://github.com/yihangdeng/yihangdeng.github.io.git Git远程部署插件安装cnpm install --save hexo-deployer-git 配置_config.yml设置总文件夹下的配置文件_config.yml，在配置信息的最底部修改并添加内容如下 123456# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deploymentdeploy: type: ‘git’ repo: (仓库创建后生成的链接) branch: master 123456# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deploymentdeploy: type: git repo: https:&#x2F;&#x2F;github.com&#x2F;yihangdeng&#x2F;yihangdeng.github.io.git branch: master 内容推送 通过命令远程部署到GitHub仓库hexo d 在远程部署的过程中有时要求输入GitHub的用户名和密码，如：Username for &quot;https://github.com\\&quot; 输入用户名Password for &quot;https://username@github.com\\&quot; 输入密码(密码默认不显示，直接输入后回车即可)若出错请检查是否有配置git的用户名和邮箱 刷新GitHub仓库可查看生成内容已部署到GitHub中 通过浏览器访问你的博客 url：username.github.io 如：yiahngdeng.github.io 若访问不了，请先尝试访问博主的博客(yiahngdeng.github.io)进而确认是部署出错还是访问GitHub的网络出现问题，具体参加博文《GitHub访问及其下载问题解决方案》。 常见错误 建议每次修改内容后都执行“hexo g”命令校验生成一下，报错的内容会显示在终端上。 标明错误行数：一般是配置文件中的“键值对”敲错，记住是英文冒号加空格，“: ” Git错误提示之：fatal: Not a git repository (or any of the parent directories): .git 提示说没有.git这样一个目录，在命令行 输入 git init 然后回车就好了 参考链接 codesheep：https://www.bilibili.com/video/BV1Yb411a7ty","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"}]}],"categories":[],"tags":[{"name":"应用框架","slug":"应用框架","permalink":"http://yoursite.com/tags/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/"},{"name":"ORM框架","slug":"ORM框架","permalink":"http://yoursite.com/tags/ORM%E6%A1%86%E6%9E%B6/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"},{"name":"视频播放","slug":"视频播放","permalink":"http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/tags/JavaSE/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"MVC","slug":"MVC","permalink":"http://yoursite.com/tags/MVC/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"xml","slug":"xml","permalink":"http://yoursite.com/tags/xml/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"项目构建","slug":"项目构建","permalink":"http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"},{"name":"个人文档","slug":"个人文档","permalink":"http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%96%87%E6%A1%A3/"},{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"Gitee","slug":"Gitee","permalink":"http://yoursite.com/tags/Gitee/"}]}