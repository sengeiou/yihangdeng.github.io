<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="yhd">
    
    <title>
        
            Java集合 |
        
        DyhBlog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/MyLogo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"yoursite.com","root":"/","language":"en","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.jpg","favicon":"/images/MyLogo.svg","article_img_align":"left","left_side_width":"230px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.jpeg"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.1"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.1.1"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                DyhBlog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Java集合</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">yhd</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-06-13 22:03:12
    </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/JavaSE/">JavaSE</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>20.3k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>83 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p><strong>引言</strong>：本文主要包含的内容有集合框架概述、Collection接口常用方法、及其子接口List、Set，及其实现类ArrayList、LinkList原理。iterator迭代器原理与使用，Map接口及其实现类、HashMap、TreeMap原理，以及工具类Collections常用的方法。</p>
<h1 id="集合框架概述"><a href="#集合框架概述" class="headerlink" title="集合框架概述"></a>集合框架概述</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li>编程中，经常需要将多个对象进行进行存储操作。使用传统的<strong>Array存储对象方面具有一些弊端</strong>：<ul>
<li>数组初始化以后，<strong>长度就不可变了</strong>，<strong>不便于扩展</strong> </li>
<li>数组中提供的<strong>属性和方法少</strong>，不便于进行添加、删除、插入等操作，且效率不高。 </li>
<li>同时<strong>无法直接获取实际存储元素的个数</strong>(length属性是数组长度，是固定的)</li>
<li>存储<strong>数据的特点单一</strong>：数组存储的数据只能是有序的、且允许可以重复的</li>
<li>数组声明的类型，就<strong>决定了进行元素初始化时的类型</strong></li>
<li>….</li>
</ul>
</li>
<li>Java集合如同<strong>数据结构</strong>中的<strong>线性表，集合</strong>这样的<strong>数据结构</strong></li>
<li>Java 集合类可以用于<strong>存储数量不等的多个对象</strong>(List&amp;Set)，还可用于保存<strong>具有映射关系的关联数组</strong>(Map)</li>
<li>Java 集合就像一种容器，可以<strong>动态地把多个对象的引用放入容器中</strong></li>
</ul>
<h2 id="概念体系"><a href="#概念体系" class="headerlink" title="概念体系"></a>概念体系</h2><ul>
<li>Java集合总的来说可分为<strong>Collection和Map两种系</strong>，均为接口，用于规范操作。</li>
</ul>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><ul>
<li><strong>Collection</strong>接口：译为“<strong>集合</strong>”，<strong>单列数据</strong>，定义存储一组对象的方法的集合，包含<strong>子接口</strong>如下：<ul>
<li><strong>List</strong>子接口：译为“<strong>线性表</strong>”，指<strong>有序、可重复</strong>的集合。同数据结构<em>线性表</em>定义。<ul>
<li><strong>实现类</strong>：ArrayList、LinkedList、Vector…</li>
</ul>
</li>
<li><strong>Set</strong>子接口：译为“<strong>集合</strong>”，指<strong>无序、不可重复</strong>的集合，同数学上<em>集合</em>的定义(无序、互斥、确定)。<ul>
<li><strong>实现类</strong>：HashSet、LinkedHashSet、TreeSet…</li>
</ul>
</li>
<li>……</li>
</ul>
</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li><strong>Map</strong>接口：译为“<strong>映射</strong>”，<strong>双列数据</strong>，保存具有<strong>映射关系</strong>“key-value对”的集合，同数学<em>函数 y=f(x)</em><ul>
<li><strong>实现类</strong>：HashMap、LinkedHashMap、TreeMap、Hashtable、Properties….</li>
</ul>
</li>
</ul>
<h3 id="概念示意图"><a href="#概念示意图" class="headerlink" title="概念示意图"></a>概念示意图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210610112313.png"
                     
                ></p>
<h2 id="API体系"><a href="#API体系" class="headerlink" title="API体系"></a>API体系</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/JavaCollectionsFramework.jpg"
                     
                ></p>
<h1 id="Collection-1"><a href="#Collection-1" class="headerlink" title="Collection"></a>Collection</h1><ul>
<li>Collection是一个<strong>接口</strong>，List和Set都是继承与该接口的子接口，对应衍生出去的实现类也众多。<strong>它们都会具备Collection的特性</strong>，因此<strong>首当其冲学习Collection接口</strong>。</li>
<li>由于接口的数学都是全局静态属性，没有什么可以展开说明，因此忽略。</li>
<li><strong>主要掌握Collection的方法</strong>，以Collection声明其子类的多态方式就可以只测试Collection方法了<ul>
<li><code>Collection testMethod = new ArrayList();</code></li>
</ul>
</li>
</ul>
<h2 id="AbstractMethods"><a href="#AbstractMethods" class="headerlink" title="AbstractMethods"></a>AbstractMethods</h2><ul>
<li><em>JDK 8.0 - API</em></li>
</ul>
<table>
<thead>
<tr>
<th>Abstract Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>boolean <strong>add</strong>(E e)</td>
<td>将指定元素添加到集合内</td>
</tr>
<tr>
<td>boolean <strong>addAll</strong>(Collection&lt;? extends E&gt; c)</td>
<td>将指定集合中的所有元素添加到此集合</td>
</tr>
<tr>
<td>void <strong>clear</strong>()</td>
<td>从此集合中删除所有元素</td>
</tr>
<tr>
<td>boolean <strong>contains</strong>(Object o)</td>
<td>如果此集合包<strong>含指定的元素</strong>，则返回 true</td>
</tr>
<tr>
<td>boolean <strong>containsAll</strong>(Collection&lt;?&gt; c)</td>
<td>如果此集<strong>合包含指定集合中的所有元素</strong>，则返回true</td>
</tr>
<tr>
<td>boolean <strong>equals</strong>(Object o)</td>
<td>将指定的<strong>对象/集合</strong>(对象)与此集合进行比较以获得相等性</td>
</tr>
<tr>
<td>int <strong>hashCode</strong>()</td>
<td>返回<strong>此集合</strong>的哈希码值</td>
</tr>
<tr>
<td>boolean <strong>isEmpty</strong>()</td>
<td>如果此集合为空，则返回 true</td>
</tr>
<tr>
<td>Iterator&lt;E&gt; <strong>iterator</strong>()</td>
<td>返回此集合中的元素的迭代器。</td>
</tr>
<tr>
<td>boolean <strong>remove</strong>(Object o)</td>
<td>从该集合中删除指定元素的单个实例</td>
</tr>
<tr>
<td>boolean <strong>removeAll</strong>(Collection&lt;?&gt; c)</td>
<td>删除指定集合中包含的此集合的元素(<strong>删除交集</strong>=this的差集)</td>
</tr>
<tr>
<td>boolean <strong>retainAll</strong>(Collection&lt;?&gt; c)</td>
<td>仅<strong>保留</strong>此集合中包含在指定集合中元素(删差集=<strong>算交集</strong>)</td>
</tr>
<tr>
<td>int <strong>size</strong>()</td>
<td>返回此集合中的元素数。</td>
</tr>
<tr>
<td>Object[] <strong>toArray</strong>()</td>
<td>返回一个包含此集合中所有元素的数组。<br/>逆操作常用Arrays.<strong>asList</strong>(T…a);方法</td>
</tr>
<tr>
<td>&lt;T&gt; T[] <strong>toArray</strong>(T[] a)</td>
<td>返回包含此集合中所有元素的数组;  <br/>返回的数组的运行时类型是指定数组的运行时类型。</td>
</tr>
</tbody></table>
<h3 id="contain-amp-remove"><a href="#contain-amp-remove" class="headerlink" title="contain&amp;remove"></a>contain&amp;remove</h3><p><code>contain</code>与``containAll<code>方法还是</code>remove<code>或</code>removeAll`方法，都是调用equals方法</p>
<ul>
<li><strong>判断依据均是</strong>：调用<strong>传入对象的equals</strong>()方法<strong>与集合元素逐一比较</strong>。</li>
<li>一般调用equals方法有两种情况：    <ol>
<li><strong>重写了equals方法</strong>：则<strong>调用对象重写的equals</strong>方法，<strong>一般比较属性内容</strong></li>
<li><strong>没有重写equals方法</strong>：调用”终极父类“<strong>Object的equals</strong>方法，此时<strong>比较地址值</strong></li>
</ol>
</li>
</ul>
<p><strong>结论</strong>：一般使用集合的contain方法时都先重写对象的equals方法。</p>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>以contain方法测试为例说明</p>
<ul>
<li>测试类：<strong>Person</strong>.java，没有重写equals方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.collectiontest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码1：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.collectiontest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection&lt;Object&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        coll.add(<span class="keyword">new</span> String(<span class="string">&quot;str123&quot;</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于String重写了equals方法</span></span><br><span class="line">        System.out.println(coll.contains(<span class="keyword">new</span> String(<span class="string">&quot;str123&quot;</span>)));<span class="comment">//true</span></span><br><span class="line">        System.out.println(coll.contains(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">10</span>)));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重写Person类equals方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.collectiontest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">if</span> (age != person.age) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name.equals(person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重新测试：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(coll.contains(<span class="keyword">new</span> String(<span class="string">&quot;str123&quot;</span>)));<span class="comment">//true</span></span><br><span class="line">System.out.println(coll.contains(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">10</span>)));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><ul>
<li><p>这里指的equals方法指Collection接口的equals方法</p>
</li>
<li><p>Collection的equals方法集合与对象比较，对象也可以是集合，因此即可比较单个对象，也可以比较集合。</p>
<hr>
</li>
<li><p>无论是集合比较单一对象，还是集合比较集合。<strong>内部还是调用对象的<code>equals</code>方法</strong></p>
</li>
<li><p><strong>重点</strong>：当调用Collection的equals方法<strong>比较两个集合的时候</strong>，但由于接口方法的<strong>功能细节取决于实现类</strong>，对于<strong>不同的实现类，相等的要求也不一致</strong>，常见两种要求如下：</p>
<ul>
<li><strong>List</strong>：不仅元素对象从<strong>equals层面要相等</strong>，对象<strong>在集合中的顺序也要一致</strong></li>
<li><strong>Set</strong>：仅元素对象从<strong>equals层面相等即可</strong>，<strong>无顺序要求</strong></li>
</ul>
</li>
</ul>
<h2 id="DefaultMethods"><a href="#DefaultMethods" class="headerlink" title="DefaultMethods"></a>DefaultMethods</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><table>
<thead>
<tr>
<th>Default Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>default Stream&lt;E&gt; <strong>parallelStream</strong>()</td>
<td>返回可能并行的Stream与此集合作为其来源</td>
</tr>
<tr>
<td>default boolean <strong>removeIf</strong>(Predicate&lt;? super E&gt; filter)</td>
<td>删除满足给定谓词的此集合的所有元素</td>
</tr>
<tr>
<td>default <strong>Spliterator</strong>&lt;E&gt; spliterator()</td>
<td>创建一个Spliterator在这个集合中的元素</td>
</tr>
<tr>
<td>default <strong>Stream</strong>&lt;E&gt; stream()</td>
<td>返回以此集合作为源的顺序 Stream</td>
</tr>
</tbody></table>
<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>iterator译为”<strong>迭代器</strong>“，是一个<strong>接口</strong>，<strong>本质是一种设计模式</strong>。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>迭代器模式，拟提供一种方法<strong>访问</strong>一个<strong>容器</strong>(container)对象中<strong>各个元素</strong>，而<strong>又不需暴露该对象的内部细节</strong>。迭代器模式，就是为容器而生。</li>
<li><strong>Collection接口继承了java.lang.Iterable接口</strong>，该Iterable接口<strong>有一个iterator</strong>()方法</li>
<li>因此所有Collection接口实现类<strong>都有一个iterator</strong>()方法，用以<strong>返回一个实现了Iterator接口的对象</strong>。</li>
<li>Iterator <strong>仅用于遍历集合</strong>，Iterator 本身并<strong>不提供承装对象的能力</strong>。如果需要创建 Iterator 对象，则必须有一个被迭代的集合。</li>
<li>集合对象<strong>每次调用iterator</strong>()方法都得到一个<strong>全新的迭代器对象</strong>，<strong>默认游标</strong>都在集合的第一个元素<strong>之前</strong></li>
</ul>
<hr>
<ul>
<li><p>迭代器设计模式理念</p>
<ul>
<li><p>不同底层存储原理的集合，定位下一个元素的原理是不一样的</p>
<ul>
<li>顺序存储结构的ArrayList，底层用数组存储，<strong>下一个元素的定位</strong> = (数组下标索引值+1)</li>
<li>链式存储结构的LinkedList，底层用元素对象链接存储，<strong>下一个元素的定位</strong> = (当前元素next引用)</li>
</ul>
</li>
<li><p>迭代器的设计就在于，把”<strong>下一个元素的定位</strong>“实现的<strong>操作封装起来</strong>(next()方法)</p>
</li>
<li><p>用户通过直接调用一个封装好的”下一个元素的定位“方法 <strong>next</strong>()，即可返回当前元素的下一个元素。</p>
<hr>
</li>
<li><p>想完整地对数据集合进行遍历操作，仅有”返回下一个元素“的操作还不能完全实现</p>
</li>
<li><p>因为数据遍历操作是有边界的，同样不同的存储结构，对数据边界的判断也不一致</p>
<ul>
<li>如顺序存储结构，数据的边界就是元素的个数，即索引值</li>
<li>而链式存储结构，则是判断next的引用是否为null</li>
</ul>
</li>
<li><p>同理，迭代器就把对数据边界判断也封装成了一个<strong>hashNext</strong>()方法，为用户遍历提供边界检查。</p>
</li>
</ul>
</li>
<li><p>这就是迭代器中所描述的”<strong>屏蔽内部细节</strong>“而实现用户<strong>统一遍历操作</strong>的设计原理。</p>
</li>
</ul>
<h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><p><em>JDK 8.0 - API</em></p>
<table>
<thead>
<tr>
<th>Abstract &amp; Default Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>boolean <strong>hasNext</strong>()</td>
<td>如果迭代<strong>下一个元素存在</strong>，则返回 true</td>
</tr>
<tr>
<td>E <strong>next</strong>()</td>
<td><strong>返回</strong>迭代中的<strong>下一个元素</strong>。</td>
</tr>
<tr>
<td>default void <strong>remove</strong>()</td>
<td>通过迭代器方式，<strong>删除当前游标位置的元素</strong></td>
</tr>
<tr>
<td>default void <strong>forEachRemaining</strong>(Consumer&lt;? super E&gt; action)</td>
<td>对每个剩余元素执行给定的操作，直到所有元素都被处理或动作引发异常。</td>
</tr>
</tbody></table>
<h3 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h3><ul>
<li><strong>游标</strong>概念相当于<strong>头指针</strong>/<strong>引用</strong>，它的<strong>初始位置是在第一个元素<em>之前</em></strong></li>
<li><strong>next</strong>()：方法是，<strong>先将指针后移一位，再返回当前指针指向的元素</strong>，(即返回下一个元素)<ul>
<li>由于游标初始值在第一个元素<strong>之前</strong>，因此next()可<strong>等价为返回当前位置的元素</strong></li>
<li>若next调用超出数据的边界，会报<strong>NoSuchElementException</strong>异常。</li>
</ul>
</li>
<li><strong>hashNext</strong>()：该方法用于提供遍历<strong>数据边界检查的函数</strong>，<strong>若下一个元素存在则返回true，不对指向进行操作</strong></li>
<li>因此<strong>next</strong>和hashNext方法的结合就如同数组遍历中的<code>for(;i &lt; arr.length;i++)</code></li>
</ul>
<hr>
<h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection&lt;Object&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;str123&quot;</span>));</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="string">&quot;str&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代器方式遍历</span></span><br><span class="line">    Iterator&lt;Object&gt; iterator = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        Object obj = iterator.next();</span><br><span class="line">        System.out.print(obj + <span class="string">&quot; , &quot;</span>);<span class="comment">//str123 , 123 , str ,</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="错误示例"><a href="#错误示例" class="headerlink" title="错误示例"></a>错误示例</h4><ul>
<li>错误迭代器示例代码1：<strong>null判断无效，及重复调用next</strong><ul>
<li><strong>null判断无效</strong>：是先指针下移，再取值，因此下移后发现没有数据是先抛NoSuchElementException异常，因此null判断无效</li>
<li><strong>重复调用next</strong>：每<strong>一次遍历进行了两次指针</strong>移动和数据获取，即跳着遍历</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误代码</span></span><br><span class="line"><span class="keyword">while</span>(iterator.next() != <span class="keyword">null</span>)&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>错误迭代器示例代码2：<strong>匿名迭代器错误遍历</strong><ul>
<li><strong>匿名迭代器</strong>：由于迭代器<strong>每次新创建时，游标都是默认第一个元素之前</strong>，因此无论怎么遍历都是第一个元素，死循环</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误代码</span></span><br><span class="line"><span class="keyword">while</span>(coll.iterator().hasNext())&#123;</span><br><span class="line">    System.out.print(coll.iterator().next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li><p><em>JDK 5.0</em>新增了一个增强for循环，<strong>底层用迭代器底层实现</strong>，可用于<strong>遍历集合、数组</strong></p>
</li>
<li><p>格式：<code>for(集合元素的类型 局部变量 : 集合对象)&#123;&#125;</code></p>
</li>
<li><p><strong>执行原理</strong>：</p>
<ol>
<li>先从集合对象中<strong>取出一个元素</strong></li>
<li>把取出的<strong>元素赋值给局部变量</strong></li>
<li><strong>循环体中使用局部变量</strong></li>
</ol>
</li>
<li><p><strong>注意</strong>：<strong>局部变量原理</strong>！！！</p>
<ul>
<li><p><strong>基本数据类型</strong>：只能获取不能修改(赋值操作)</p>
</li>
<li><p><strong>引用数据类型</strong>：不能修改引用本身(赋值操作)，只能修改引用指向的内容</p>
<blockquote>
<p>原理还是<strong>无返回值函数方法调用原理</strong>，即内核原理是<strong>局部变量原理</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><ul>
<li><strong>示例代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection&lt;Object&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;str123&quot;</span>));</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="string">&quot;str&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object obj : coll)&#123;</span><br><span class="line">        System.out.print(obj + <span class="string">&quot; ,&quot;</span>);<span class="comment">//str123 ,123 ,str</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><ul>
<li>Iterator接口还定义了<strong>default</strong>类型的remove方法，可<strong>删除当前游标的集合中的元素</strong>。</li>
<li><strong>不能</strong>在<strong>游标起始位置</strong>或<strong>同一个游标位置</strong>已经进<strong>行了两次的remove</strong>操作，否则报<strong>IllegalStateException</strong>异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection&lt;Object&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;str123&quot;</span>));</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="string">&quot;str&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Object&gt; iterator = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        Object obj = iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;str123&quot;</span>.equals(obj))&#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意此时迭代器iterator的游标已在末尾，若想重新遍历应获取新的iterator</span></span><br><span class="line">    iterator = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.print(iterator.next() + <span class="string">&quot; , &quot;</span>);<span class="comment">//123 , str</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h2><ul>
<li>Collection还继承了一个Iterable父接口</li>
</ul>
<h3 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h3><table>
<thead>
<tr>
<th>Method</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>default void <strong>forEach</strong>(Consumer&lt;? super T&gt; action)</td>
<td>对Iterable的每个元素执行给定的操作，<br/>直到所有元素都被处理或动作引发异常。</td>
</tr>
<tr>
<td>Iterator&lt;T&gt; <strong>iterator</strong>()</td>
<td>返回类型为 T元素的迭代器。</td>
</tr>
<tr>
<td>default Spliterator&lt;T&gt; <strong>spliterator</strong>()</td>
<td>在Iterable描述的元素上创建一个Iterable  。</td>
</tr>
</tbody></table>
<h3 id="forEach遍历"><a href="#forEach遍历" class="headerlink" title="forEach遍历"></a>forEach遍历</h3><ul>
<li>forEach方法遍历集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection&lt;Object&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;str123&quot;</span>));</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="string">&quot;str&quot;</span>);</span><br><span class="line"></span><br><span class="line">    coll.forEach(System.out::println);<span class="comment">//Consumer接口,可以使用方法引入代替,JDK8新特性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><ul>
<li>API体系</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210610111814.png"
                     
                ></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>List译为“<strong>线性表</strong>”，指<strong>有序、可重复</strong>的集合，</li>
<li>List也称为”<strong>动态数组</strong>“，因为List与数组的<strong>表面特性区别</strong>就只有<strong>动态的可扩展性</strong></li>
</ul>
<h3 id="实现类概述"><a href="#实现类概述" class="headerlink" title="实现类概述"></a>实现类概述</h3><ul>
<li>List常用实现类：<strong>ArrayList</strong>、<strong>LinkedList</strong>、<strong>Vector</strong></li>
</ul>
<h4 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h4><ul>
<li><p>以ArrayList继承实现关系为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|--java.lang.Object </span><br><span class="line">|----java.util.AbstractCollection&lt;E&gt;<span class="comment">//实现Collection接口，并重写toString方法</span></span><br><span class="line">|------java.util.AbstractList&lt;E&gt;</span><br><span class="line">|---------java.util.ArrayList&lt;E&gt;<span class="comment">//实现Lsit接口</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其中：<strong>AbstractCollection重写了toString()方法</strong>，<strong>使其直接打印除集合中元素</strong>(迭代器)</p>
</li>
</ul>
<h4 id="实现类比较"><a href="#实现类比较" class="headerlink" title="实现类比较"></a>实现类比较</h4><ul>
<li><strong>相同点</strong>：<strong>都实现了List接口存储特点相同，有序，可重复</strong></li>
<li><strong>不同点</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">指标\实现类</th>
<th>ArrayList</th>
<th>LinkedList</th>
<th>TreeSet</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>背景</strong></td>
<td><em>JDK 1.2</em>，List<strong>主要实现类</strong></td>
<td><em>JDK 1.2</em></td>
<td><em>JDK 1.0</em> ，<strong>已弃用实现类</strong></td>
</tr>
<tr>
<td align="left"><strong>底层实现</strong></td>
<td>Object数组</td>
<td>双向链表</td>
<td>Object数组</td>
</tr>
<tr>
<td align="left"><strong>线程安全</strong></td>
<td>线程不安全</td>
<td>线程不安全</td>
<td>线程安全</td>
</tr>
<tr>
<td align="left"><strong>效率</strong></td>
<td>高</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td>多数存储与查询操作</td>
<td>频繁修改操作</td>
<td>线程安全</td>
</tr>
</tbody></table>
<h2 id="API-3"><a href="#API-3" class="headerlink" title="API"></a>API</h2><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><ul>
<li>List接口<strong>继承于Collection接口</strong>，<strong>默认包含</strong>Collection接口定义的<strong>所有抽象方法</strong>(默认方法)</li>
<li><strong>注意</strong>：子接口<strong>List</strong>即使继承Collection接口，也几乎<strong>把父类的抽象方法重写了一遍</strong>(除若干个default方法外)</li>
<li>由于<strong>List也是接口</strong>，接口继承接口，重写父接口的抽象方法还是抽象方法，即<strong>相当于重定义了一遍Collection接口的抽象方法</strong>而已，并没有做出实质编码。</li>
</ul>
<blockquote>
<p>为什么List接口要将从Collection父接口继承下来的抽象方法在”<strong>白重写</strong>“一遍呢？</p>
</blockquote>
<hr>
<ul>
<li>List接口”<strong>白重写</strong>“Collection父接口的方法是”<strong>在于意，而不在于形！</strong>“<ul>
<li>如Collection以集合角度定义的抽象方法<code>add(E e)</code>，的API含义并没有什么其他说明，就是”<strong>把一个元素加入到集合中</strong>“而已，没强调顺序、也没强调是否可重复。</li>
<li>但在List中，基于List独有的存储特性，同样一个<code>add(E e)</code>方法，意义确是”<strong>将元素顺序添加到有序集合中</strong>“，且允许元素重复。</li>
<li>因此<strong>表面上</strong>是<strong>同一个接口中的抽象方法</strong>，但从<strong>设计上</strong>已经<strong>不是同一个层面的意义</strong>了。</li>
</ul>
</li>
</ul>
<blockquote>
<p>也有可能是自己 一时猜想，毕竟Collection接口定义的方法已经足够抽象化、兼容化了。除了add(E e)方法，其他方法的含义均通用于任何类型的集合。</p>
</blockquote>
<h3 id="API文档"><a href="#API文档" class="headerlink" title="API文档"></a>API文档</h3><ul>
<li><p><strong>新增方法</strong>：</p>
<ul>
<li><strong>带索引操作方法</strong></li>
<li><strong>排序方法</strong>sort，(非Object类型才可排序，即排序的前提要同一数据类型)</li>
<li>新迭代器方法</li>
<li>部分重写父接口</li>
</ul>
</li>
<li><p><strong>索引要求</strong></p>
<ul>
<li><p>索引从0开始</p>
</li>
<li><p>索引合法值：0 &lt;= index &lt;= size-1</p>
</li>
<li><p>凡是带索引值方法，都需保证索引合法性，否则报IndexOutOfBoundsException异常</p>
</li>
</ul>
<hr>
</li>
<li><p><em>JDK 8.0 - List - API</em></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Abstract &amp; Default Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Collection abstract methods</strong>…</td>
<td>重定义了一遍Collection父接口的抽象方法</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>void <strong>add</strong>(int index, E element);</td>
<td>将元素<strong>插入</strong>此列表中的<strong>index位置之前</strong></td>
</tr>
<tr>
<td>boolean <strong>addAll</strong>(int index, Collection&lt;? extends E&gt; c);</td>
<td>将指定集合中的所有元素<strong>插入</strong>到此列表中的<strong>index位置之前</strong></td>
</tr>
<tr>
<td>E <strong>get</strong>(int index);</td>
<td>获取指定<strong>index位置</strong>的元素，不存在返回</td>
</tr>
<tr>
<td>E <strong>set</strong>(int index, E element);</td>
<td>设置指定index位置的元素为element</td>
</tr>
<tr>
<td>E <strong>remove</strong>(int index);</td>
<td>移除指定index位置的元素，<strong>并返回此元素</strong></td>
</tr>
<tr>
<td>int <strong>indexOf</strong>(Object obj);</td>
<td>返回obj在集合中首次出现的位置，<strong>不存在返回-1</strong></td>
</tr>
<tr>
<td>int <strong>lastIndexOf</strong>(Object obj);</td>
<td>返回obj在当前集合中末次出现的位置，<strong>不存在返回-1</strong></td>
</tr>
<tr>
<td>List&lt;E&gt; <strong>subList</strong>(int fromIndex, int toIndex);</td>
<td>返回从[ fromIndex,toIndex )<strong>左闭右开</strong>位置的子集合</td>
</tr>
<tr>
<td>ListIterator&lt;E&gt; <strong>listIterator</strong>();</td>
<td>返回列表迭代器</td>
</tr>
<tr>
<td>ListIterator&lt;E&gt; <strong>listIterator</strong>(int index);</td>
<td>返回从<strong>指定位置</strong>开始的列表迭代器</td>
</tr>
<tr>
<td>default void <strong>replaceAll</strong>(UnaryOperator&lt;E&gt; operator)</td>
<td></td>
</tr>
<tr>
<td>default void <strong>sort</strong>(Comparator&lt;? super E&gt; c)</td>
<td>基于Comparator接口实现从小到大排序</td>
</tr>
<tr>
<td>@Override <strong>default</strong> Spliterator&lt;E&gt; spliterator()</td>
<td></td>
</tr>
</tbody></table>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><strong>增</strong>：add(Object obj)</li>
<li><strong>删</strong>：<strong>remove</strong>(int index) / <strong>remove</strong>(Object obj)</li>
<li><strong>改</strong>：set(int index,Object ele)</li>
<li><strong>查</strong>：get(int index)</li>
<li><strong>插</strong>：add(int index,Object ele)</li>
<li><strong>长度</strong>：siez()</li>
<li><strong>遍历</strong>：Iterator/增强for循环、listIterator、普通循环(由于含索引方法)</li>
</ul>
<h4 id="remove-1"><a href="#remove-1" class="headerlink" title="remove"></a>remove</h4><ul>
<li>remove测试代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListRemove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    updateList(list);</span><br><span class="line">    System.out.println(list);<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateList</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">    list.remove(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解释<ul>
<li><strong>add只有一个方法</strong>add(Object obj)，Object类型需<strong>自动装箱</strong>成Integer类型传入，其实无关</li>
<li><code>list.remove(2)</code>，List含<strong>两个remove方法</strong>，remove(Object obj)与remove(int i)类型</li>
<li>此时传入的2为int类型，<strong>应优先匹配remove</strong>(<strong>int i</strong>)，方法因此操作的是索引而不是类型</li>
</ul>
</li>
<li>答案：12</li>
<li>若此时想删除对象为2的元素，则应<code>list.remove(new Integer(2));</code>调用</li>
</ul>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ul>
<li><strong>ArrayList</strong>：List主要实现类、基于Object数组实现、线程不安全，效率高</li>
<li><strong>ArrayList</strong>底层实现，<em>JDK7.0</em>和<em>JDK8.0</em>并<strong>不一致</strong>，因此需区分说明，先以<em>JDK 7.0</em>底层实现说起</li>
</ul>
<h3 id="API-4"><a href="#API-4" class="headerlink" title="API"></a>API</h3><ul>
<li>ArrayList的自身独有的API很少且几乎是一些接口default方法的重写，不常用</li>
<li><strong>List接口方法已经囊概ArrayList百分之99的使用场景需要的方法</strong>，由此<strong>称为List主要实现类</strong></li>
<li><strong>结论</strong>：可以<strong>通过多态的方式定义ArrayList</strong>，从而<strong>提高代码的兼容性</strong><ul>
<li><code>List&lt;T&gt; arrayList = new ArrayList&lt;&gt;(); </code></li>
</ul>
</li>
</ul>
<h4 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h4><table>
<thead>
<tr>
<th>Method</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>void <strong>trimToSize</strong>()</td>
<td>修改这个ArrayList实例的容量是当前元素数量(手动置满)</td>
</tr>
<tr>
<td>void <strong>ensureCapacity</strong>(int minCapacity)</td>
<td>手动请求(拟添加后总量数)，主动扩容</td>
</tr>
</tbody></table>
<h4 id="重写default方法"><a href="#重写default方法" class="headerlink" title="重写default方法"></a>重写default方法</h4><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><ul>
<li><p>default void forEach(Consumer&lt;? super T&gt; action)方法</p>
<ul>
<li><code>public void forEach(Consumer&lt;? super E&gt; action)</code></li>
</ul>
</li>
<li><p>default void forEachRemaining(Consumer&lt;? super E&gt; action)</p>
<ul>
<li><code>public void forEachRemaining(Consumer&lt;? super E&gt; consumer)</code></li>
</ul>
</li>
</ul>
<h5 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h5><ul>
<li><p>default Spliterator&lt;E&gt; spliterator()</p>
<ul>
<li><code>public Spliterator&lt;E&gt; spliterator()</code></li>
</ul>
</li>
<li><p>default void replaceAll(UnaryOperator&lt;E&gt; operator)</p>
<ul>
<li><code>public void replaceAll(UnaryOperator&lt;E&gt; operator)</code></li>
</ul>
</li>
<li><p>default void sort(Comparator&lt;? super E&gt; c)</p>
<ul>
<li><code>public void sort(Comparator&lt;? super E&gt; c)</code></li>
</ul>
</li>
</ul>
<h5 id="Collection-2"><a href="#Collection-2" class="headerlink" title="Collection"></a>Collection</h5><ul>
<li>default boolean removeIf(Predicate&lt;? super E&gt; filter)<ul>
<li><code>public boolean removeIf(Predicate&lt;? super E&gt; filter)</code></li>
</ul>
</li>
</ul>
<h3 id="JDK7源码分析"><a href="#JDK7源码分析" class="headerlink" title="JDK7源码分析"></a>JDK7源码分析</h3><ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/yihangdeng/net-resources/blob/master/Code/ArrayListOfJdk7.java" >jdk1.7 ArrayList源码<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li><p>private transient <strong>Object</strong>[] <strong>elementData</strong>：ArrayList集合存储元素的底层Objcet数组</p>
</li>
<li><p>private int <strong>size</strong>：记录集合中<strong>实际存储的元素个数</strong></p>
</li>
<li><hr>
<p><strong>ArrayList.java</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><h5 id="ArrayList-1"><a href="#ArrayList-1" class="headerlink" title="ArrayList();"></a>ArrayList();</h5><ul>
<li><p>空参构造器申请容量<strong>默认为：10</strong></p>
</li>
<li><p>this(10)，调用ArrayList(int initialCapacity)构造器实现</p>
<hr>
</li>
<li><p>new ArrayList()源码</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ArrayList-int-initialCapacity"><a href="#ArrayList-int-initialCapacity" class="headerlink" title="ArrayList(int initialCapacity)"></a>ArrayList(int initialCapacity)</h5><ul>
<li><p><strong>initialCapacity</strong>参数为<strong>传入的自定义初始化容量值</strong></p>
</li>
<li><p>initialCapacity &lt; 0 非法输入抛出异常</p>
</li>
<li><p>否则直接<strong>创建initialCapacity长度的Object类型数组</strong>，返回其引用给elementData</p>
<hr>
</li>
<li><p>new ArrayList(int initialCapacity)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><h5 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h5><ul>
<li><p>先确认当前容量是否足够，调用ensureCapacityI(size + 1)方法检测</p>
</li>
<li><p>将元素通过元素数量size作为数组下标索引的方式添加到elementData数组中</p>
</li>
<li><p>源码类似与StringBuffer/StringBuilder的源码逻辑</p>
<hr>
</li>
<li><p>add(E e)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ensureCapacityInternal-int-minCapacity"><a href="#ensureCapacityInternal-int-minCapacity" class="headerlink" title="ensureCapacityInternal(int minCapacity)"></a>ensureCapacityInternal(int minCapacity)</h5><ul>
<li><p>modCount++，用于”快速失败机制“，暂且忽略</p>
</li>
<li><p>判断是否需要调用grow(int minCapacity)方法进行扩容</p>
<hr>
</li>
<li><p>ensureCapacityInternal(int minCapacity)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="grow-int-minCapacity"><a href="#grow-int-minCapacity" class="headerlink" title="grow(int minCapacity)"></a>grow(int minCapacity)</h5><ul>
<li>将旧数组容量，扩容至<strong>原来的1.5倍</strong> == 旧容量 + 旧容量/2(右移1位)</li>
<li>若还不够，则使用当前需求的容量为最终容量</li>
<li>若还不够，则直接扩容至<strong>MAX_ARRAY_SIZE</strong>的容量(Integer.MAX_VALUE - 8)</li>
<li>若还不够，则直接调用hugeCapacity方法获取最大扩容量</li>
<li>通过调用Arrays.copyOf(T [] t，newLength)，将原有数据复制到长度为扩容容量的新数组中</li>
</ul>
<blockquote>
<ul>
<li><p>数学上几倍就是乘以几，一倍乘1，二倍乘2。一倍和两倍结果是有区别的</p>
</li>
<li><p>口语是没有太多规范的，1倍也是2倍，但准确应该是，什么比什么多倍倍 == 什么的2倍</p>
</li>
</ul>
</blockquote>
<ul>
<li>grow(int minCapacity)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="hugeCapacity-int-minCapacity"><a href="#hugeCapacity-int-minCapacity" class="headerlink" title="hugeCapacity(int minCapacity)"></a>hugeCapacity(int minCapacity)</h5><ul>
<li><p>若传入容量为<strong>负数</strong>，则表示已经出现<strong>Integer类型溢出异常</strong>(可能存在由多线程操作导致，否则单线程代码不可能出现这样的问题)，报出OutOfMemoryError异常。</p>
</li>
<li><p>若传入容量为<strong>正数</strong> &lt; MAX_ARRAY_SIZE返回MAX_ARRAY_SIZE作为最终扩容量，否则以Integer.MAX_VALUE，为最终扩容量。</p>
<hr>
</li>
<li><p>hugeCapacity(int minCapacity)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDK8源码分析"><a href="#JDK8源码分析" class="headerlink" title="JDK8源码分析"></a>JDK8源码分析</h3><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p>JDK8中的ArrayList属性在JDK7的基础上<strong>增加了三个全局静态常量属性</strong></p>
<ul>
<li><p>static final int <strong>DEFAULT_CAPACITY</strong> = 10：<strong>默认的容量</strong>常量</p>
</li>
<li><p>static final Object[] <strong>EMPTY_ELEMENTDATA</strong> = {}：<strong>实例化</strong>了一个<strong>长度为0</strong>的<strong>全局静态</strong>EMPTY_ELEMENTDATA<strong>数组</strong></p>
</li>
<li><p>static final Object[] <strong>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</strong> = {}：<strong>实例化</strong>了一个<strong>长度为0</strong>的<strong>全局静态</strong>DEFAULTCAPACITY_EMPTY_ELEMENTDATA<strong>数组</strong></p>
<hr>
</li>
<li><p>transient <strong>Object</strong>[] <strong>elementData</strong>：ArrayList集合存储元素的底层Objcet数组</p>
</li>
<li><p>int <strong>size</strong>：记录集合中<strong>实际存储的元素个数</strong></p>
<hr>
</li>
<li><p>ArrayList.java</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h4><h5 id="ArrayList-2"><a href="#ArrayList-2" class="headerlink" title="ArrayList()"></a>ArrayList()</h5><ul>
<li><p>调用空参构造器，直接返回了全局静态常量的DEFAULTCAPACITY_EMPTY_ELEMENTDATA数组的引用</p>
</li>
<li><p>DEFAULTCAPACITY_EMPTY_ELEMENTDATA使一个<strong>长度为0</strong>的Object数组的引用</p>
<hr>
</li>
<li><p>new ArrayList()</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><h5 id="add-E-e-1"><a href="#add-E-e-1" class="headerlink" title="add(E e)"></a>add(E e)</h5><ul>
<li>同jdk7.0的ArrayList源码的add(E e)方法调用逻辑</li>
</ul>
<h5 id="ensureCapacityInternal-int-minCapacity-1"><a href="#ensureCapacityInternal-int-minCapacity-1" class="headerlink" title="ensureCapacityInternal(int minCapacity)"></a>ensureCapacityInternal(int minCapacity)</h5><ul>
<li><p><strong>初始状体处理</strong>：若当前elementData的引用还是初始状态的引用则取拟申请总容量数和默认容量数(10)最大值</p>
<ul>
<li>若符合这个初始化状态进一步调用ensureExplicitCapacity方法时肯定需要扩容</li>
<li>因为初始状体的容量就是0，那怕添加一个元素，都需要进入grow函数进行扩容</li>
<li>即首次添加就需要调用扩容函数，扩容至DEFAULT_CAPACITY = 10的长度</li>
</ul>
</li>
<li><p><strong>扩容判断</strong>：调用ensureExplicitCapacity()，确定当前总数据申请量是否需要扩容</p>
<hr>
</li>
<li><p>ensureCapacityInternal(int minCapacity)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="grow-int-minCapacity-1"><a href="#grow-int-minCapacity-1" class="headerlink" title="grow(int minCapacity)"></a>grow(int minCapacity)</h5><ul>
<li>代码逻辑和JDK 7.0一致</li>
<li>初始状态调用grow时，由于oldCapacity为0，第一次拟扩容量newCapacity也为0</li>
<li>因此最终初始状态的扩容直接拿minCapacity作为扩容量，即DEFAULT_CAPACITY的值=10</li>
</ul>
<h3 id="源码分析小结"><a href="#源码分析小结" class="headerlink" title="源码分析小结"></a>源码分析小结</h3><h4 id="源码对比"><a href="#源码对比" class="headerlink" title="源码对比"></a>源码对比</h4><table>
<thead>
<tr>
<th>指标\ArrayList</th>
<th>JDK1.7/7源码</th>
<th>JDK1.8/8</th>
</tr>
</thead>
<tbody><tr>
<td><strong>new ArrayList</strong>()</td>
<td><strong>实例化并创建</strong>容量为<strong>10</strong>的Object[]数组</td>
<td><strong>仅实例化</strong>(长度为<strong>0</strong>)</td>
</tr>
<tr>
<td><strong>初始化时机</strong></td>
<td>new ArrayList()时已经初始化容量为<strong>10</strong></td>
<td>首次进行add方法调用：<br/>添加数据量L &lt; 10：扩容至 **10**<br/>添加数据量L &gt; 10：扩容至 <strong>L</strong></td>
</tr>
<tr>
<td><strong>add方法扩容</strong></td>
<td>尝试扩容为<strong>原来的容量的</strong>，<strong>1.5倍</strong> <br/>不够，扩容至<strong>需求数据容量数</strong>(装满)<br/>不够，扩容至<strong>MAX_ARRAY_SIZE</strong> <br/>不够，扩容至<strong>Integer.MAX_VALUE</strong> <br/>不够，<strong>OutOfMemoryError异常</strong>  <br/></td>
<td><strong>同JDK1.7/7扩容机制</strong></td>
</tr>
<tr>
<td><strong>小结</strong></td>
<td>类似单例的<strong>饿汉式</strong><br/><strong>在调用空参构造器时候已初始化</strong><br/>对比JDK8.0方式，一定程度上浪费内存</td>
<td>类似单例的<strong>懒汉式</strong><br/><strong>在首次进行添加操作时才初始化</strong><br/>延迟了数组创建时间，节省了内存</td>
</tr>
</tbody></table>
<h4 id="指导意义"><a href="#指导意义" class="headerlink" title="指导意义"></a>指导意义</h4><ul>
<li>无论是哪个版本的ArrayList，底层原理(数组)和扩容机制与StirngBuilder/StringBuffer类似。</li>
<li>其指导意义在于，<strong>开发中尽量让其少扩容</strong>。</li>
<li>建议开发中<strong>预先估计业务中需要的存储的对象数量</strong></li>
<li>初始化定义时<strong>使用带参的构造器</strong>：<code>ArrayList list = new ArrayList(int capacity)</code>，<strong>使其开发中尽量减少扩容的次数</strong>。</li>
</ul>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ul>
<li><p><strong>LinkedList</strong>：基于链式存储结构，<strong>双向链表</strong>实现、线程不安全，对于频繁修改操作效率高</p>
</li>
<li><p><strong>LinkedList</strong>的源码比较稳定，一直没有改变，因此以<em>JDK 8.0</em>版本为基准说明</p>
</li>
</ul>
<h3 id="API-5"><a href="#API-5" class="headerlink" title="API"></a>API</h3><ul>
<li><p>LinkedList独特的API部分并不像ArrayList的API那样”没用”</p>
</li>
<li><p>LinkedList<strong>有很多实用的新增API</strong>，若当<strong>需要实用这些新增API时</strong>，则<strong>不能以多态方式</strong>创建LinkedList。而是通过对象实例直接创建LinkedList实例，依次获得LinkedList独有的API</p>
<ul>
<li><strong>直接创建/获取更多方法</strong>：<code>LinkedList&lt;T&gt; linkedList = new LinkedList&lt;&gt;();</code></li>
</ul>
</li>
<li><p>同理，当开发中<strong>用不到这些新增API时</strong>，也应像ArrayList一样，为提高代码兼容性而<strong>使用多态方式</strong>实例化</p>
<ul>
<li><strong>多态方式/提高兼容性</strong>：<code>List linkedList = new LinkedList&lt;&gt;();</code></li>
</ul>
<hr>
</li>
<li><p><strong>新增的首尾操作-API</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Method</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>void <strong>addFirst</strong>(Object obj)</td>
<td>把obj元素添加到列表的首部</td>
</tr>
<tr>
<td>void <strong>addLast</strong>(Object obj)</td>
<td>把obj元素添加到列表的末尾</td>
</tr>
<tr>
<td>Object <strong>getFirst</strong>()</td>
<td>获取列表首位置元素</td>
</tr>
<tr>
<td>Object <strong>getLast</strong>()</td>
<td>获取列表末尾元素</td>
</tr>
<tr>
<td>Object <strong>removeFirst</strong>()</td>
<td>删除列表首位置元素</td>
</tr>
<tr>
<td>Object <strong>removeLast</strong>()</td>
<td>删除列表末尾元素</td>
</tr>
</tbody></table>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><ul>
<li><p>int <strong>size</strong> = 0：记录当前<strong>元素的个数</strong></p>
</li>
<li><p>Node&lt;E&gt; <strong>first</strong>：双向链表的<strong>头指针</strong></p>
</li>
<li><p>Node&lt;E&gt; <strong>last</strong>：双向链表的<strong>尾指针</strong></p>
</li>
<li><p>static class <strong>Node</strong>&lt;E&gt;：内部类Note，由于只有LinkedList使用，因此定义为内部类</p>
<hr>
</li>
<li><p>LinkedList.java</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h5><ul>
<li>链表是有每一个Node存储单位通过引用链接起来的数据结构</li>
<li>双向链表的Node结构定义如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;<span class="comment">//数据域</span></span><br><span class="line">    Node&lt;E&gt; next;<span class="comment">//前指指针域，</span></span><br><span class="line">    Node&lt;E&gt; prev;<span class="comment">//后指指针域</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造器-2"><a href="#构造器-2" class="headerlink" title="构造器"></a>构造器</h4><h5 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList()"></a>LinkedList()</h5><ul>
<li><p><strong>空操作</strong>，仅代表创建了LinkedList实例</p>
</li>
<li><p><strong>first和last引用初始化值均为null</strong></p>
<hr>
</li>
<li><p>LinkedList</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><h5 id="add-E-e-2"><a href="#add-E-e-2" class="headerlink" title="add(E e)"></a>add(E e)</h5><ul>
<li>调用linkLast方法，</li>
<li>直接返回true</li>
</ul>
<h5 id="linkLast-E-e"><a href="#linkLast-E-e" class="headerlink" title="linkLast(E e)"></a>linkLast(E e)</h5><ul>
<li><p>原理是数据结构中双向链表采取了尾插法</p>
</li>
<li><p>创建新的Note结点，传入前置指针为当前的last引用，后置指针为null</p>
</li>
<li><p>last引用等于null，则为当前链表为空情况，直接把新节点(第一个结点)赋值为first引用</p>
</li>
<li><p>否则常规尾插法操作</p>
<hr>
</li>
<li><p>linkLst(E e)源代码</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><ul>
<li><strong>Vector</strong>：基于顺序存储结构实现，即Object[]数组实现、<strong>线程安全</strong>，但效率低</li>
<li>API相关</li>
<li><strong>Vector</strong>的源码比较稳定，一直没有改变，因此以<em>JDK 8.0</em>版本为基准说明</li>
<li>Vector源码的扩容机制<strong>与ArrayList扩容机制不同</strong></li>
</ul>
<p><strong>注意</strong>：Vector已经是一个倍被官方弃用，套题的类。如今保留它只是为了兼容性问题。集合List框架中也<strong>不会因为Vector具有线程安全特性而独树一帜</strong>。现如今想获取线程安全的List实现类，只需要调用Collections的synchronizedList方法，将线程不安全的List实现类传入，返回的便是一个线程安全的List实现类。<strong>因此Vector纯属一个被淘汰的类</strong>。</p>
<h3 id="API-6"><a href="#API-6" class="headerlink" title="API"></a>API</h3><p>由于Vector已经是一个倍被官方弃用，因此不研究Vector的API。</p>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><ul>
<li><strong>Vector</strong>代码逻辑如JDK 7.0的ArrayList，饿汉式容量创建</li>
<li><strong>Vector</strong>源码的扩容机制与ArrayList<strong>扩容机制不同</strong><ul>
<li>Vector<strong>首次</strong>拟扩容量为，扩容至<strong>原来的1倍，即乘2</strong></li>
<li>后续扩容机制同ArrayList扩容机制</li>
</ul>
</li>
<li>其次<strong>Vector</strong>大部分操作的方法都使用了<strong>synchronized</strong>修饰为<strong>同步方法</strong>，因此<strong>线程安全</strong>。</li>
</ul>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><ul>
<li>Vector还有一个子类，Stack栈</li>
</ul>
<h2 id="实际开发"><a href="#实际开发" class="headerlink" title="实际开发"></a>实际开发</h2><ol>
<li><p><strong>List接口API，可作为所有List实现类的，顶层API参照结构</strong></p>
<ul>
<li>首先List接口继承与Collection父接口，并重定义了所有Collection方法。</li>
<li>虽然常用的List实现类并不是直接实现List接口，如下所示。但最终都间接地实现了List接口<ul>
<li>ArrayList—继承—&gt;AbstractList(实现List)—继承—&gt;AbstractCollection(实现Collection)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>ArrayList再定义的API极少使用，因此开发常以多态方式实例化</strong></p>
<ul>
<li>常以多态方式实例化：<code>List&lt;T&gt; arrayList = new ArrayList&lt;&gt;();</code></li>
</ul>
</li>
<li><p><strong>LinkedList若需使用特有的API方法</strong>(首尾操作)，<strong>则直接实例化，否则也建议使用多态方式实例化</strong></p>
<ul>
<li>使用特有API：<code>LinkedList&lt;T&gt; linkedList = new LinkedList&lt;&gt;();</code></li>
<li>不使用特有API：<code>List linkedList = new LinkedList&lt;&gt;();</code></li>
</ul>
</li>
</ol>
<hr>
<ul>
<li>以接口多态的方式实例化对象的好处：<strong>提高代码兼容性</strong><ul>
<li>因为对于一个声明List接口的方法形参，即可传入ArrayList，也可传入LinkedList实现。</li>
</ul>
</li>
</ul>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><ul>
<li>API体系</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210610111814.png"
                     
                ></p>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>Set接口：译为“<strong>集合</strong>”，指<strong>无序、不可重复</strong>的集合</li>
</ul>
<h3 id="特性解析"><a href="#特性解析" class="headerlink" title="特性解析"></a>特性解析</h3><h4 id="不可重复性"><a href="#不可重复性" class="headerlink" title="不可重复性"></a>不可重复性</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><ul>
<li><p>除去哈希表本身的综合性能而言，若想通过线性表(顺序表或链表)，如何保证添加元素的唯一性？</p>
<ul>
<li>唯一的实现方式：每添加一个元素都需要和当前集合中的所有元素对比一次。</li>
<li>因此线性表这种存储结构实现这样的功能的<strong>效率是非常低</strong>的。</li>
</ul>
</li>
<li><p>哈希表这样的存储结构，对于实现唯一性的功能，天然有着更高效率的处理方式</p>
<blockquote>
<p>我也不确定哈希表的发明是基于更理想的查找速度，还是更高效率地实现唯一性的功能而诞生的</p>
</blockquote>
</li>
</ul>
<hr>
<ul>
<li><strong>tips</strong>：以下查找过程是基础定义式哈希表的查找过程。实际HashSet即底层HashMap有两层冲突判断</li>
<li>以HashSet为例，如何保证添加的元素不可重复？</li>
</ul>
<ol>
<li><p><strong>哈希值</strong>：</p>
<ul>
<li><strong>Object</strong>中，hashCode()默认返回的是<strong>对象存储的地址</strong></li>
<li><strong>HashSet</strong>中将hashCode()<strong>重写</strong>了，返回的哈希值是<strong>以该对象所有属性值计算的</strong></li>
<li><strong>此时若所有属性都一样，哈希值也肯定是一样</strong>，但由于计算哈希值的散列函数的特性，极少机率会出现不同两个对象，计算出的哈希值也一样的现象，这种现象称为<strong>冲突</strong>，或者碰撞。存储时就会产生堆积现象。<ul>
<li>但是注意，这种生成哈希值的散列函数本身存在的冲突现象不是一般数据结构讲的散列查找技术中的冲突现象，这种是数学上的冲突，而数据结构中冲突是转化为数组下标时存在的冲突。<strong>可以说是两种独立的冲突</strong>。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>以哈希值作为存储元素的数组的下标值</strong>。</li>
<li>添加一个新元素之前，先计算该元素的hash值，后分两步判断是否重复元素<ol>
<li>定位到该hash的存储位置，若该位置<strong>没有数据</strong>，则肯定<strong>不存在重复</strong>，<strong>直接存储</strong>即可</li>
<li>若hash值定位的位置<strong>存在数据，也不能立即证明元素重复了</strong>(<strong>存在冲突现象</strong>)，此时需<strong>调用equals方法判断两者是否为同一元素</strong>，若都不同则存储( 将同义词记录，存储在开散列表中，当然若开散列表中也有逐一对比 )，若相同的则为重复元素，不添加。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h5 id="判断依据"><a href="#判断依据" class="headerlink" title="判断依据"></a>判断依据</h5><ul>
<li><strong>HashSet</strong> &amp; <strong>LinkedHashSet</strong>：<strong>重写hashCode</strong>()和<strong>equals</strong>()方法<ul>
<li>若都不重写，默认Object，hashCode打印地址值，equals比较地址值</li>
</ul>
</li>
<li><strong>TreeSet</strong>：由于存储结构不一样，TreeSet判别标准是实现<strong>Comparable或Comparator接口</strong></li>
</ul>
<h5 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h5><ul>
<li>HashSet<strong>存储逻辑终极测试经典题</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    Person p2 = <span class="keyword">new</span> Person(<span class="number">1002</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    set.add(p1);</span><br><span class="line">    set.add(p2);</span><br><span class="line">    </span><br><span class="line">    p1.name = <span class="string">&quot;CC&quot;</span>;</span><br><span class="line">    set.remove(p1);</span><br><span class="line">    System.out.println(set);</span><br><span class="line">    </span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>,<span class="string">&quot;CC&quot;</span>));</span><br><span class="line">    System.out.println(set);</span><br><span class="line">    </span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>));</span><br><span class="line">    System.out.println(set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>计算的hash值和修改后在计算出的hash值已经不一样了</li>
<li>hash值就算一样了，equals方法有不一样了</li>
<li>答案：<ul>
<li>1001,”CC”、1002,”BB” (hash值不一样)</li>
<li>1001,”CC”、1002,”BB”、1001,”CC” (hash值不一样)</li>
<li>1001,”CC”、1002,”BB”、1001,”CC”、1001,”AA” (equals不一样)</li>
</ul>
</li>
</ul>
<h4 id="无序性"><a href="#无序性" class="headerlink" title="无序性"></a>无序性</h4><ul>
<li>无序性可以说是因为不可重复性使用的数据结构而导致的一种无序性。</li>
<li>即<strong>无序性强调存储的无序性</strong>，即并非根据索引下标顺序存储的，而是根据哈希表存储的</li>
<li>无序性不等于随机性。</li>
</ul>
<h4 id="hashCode重写"><a href="#hashCode重写" class="headerlink" title="hashCode重写"></a>hashCode重写</h4><p>重写 hashCode() 方法的基本原则：”<strong>相等的对象</strong>(equals)<strong>必须具有相等的散列码</strong>！“</p>
<ul>
<li>在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值。 </li>
<li>当两个对象的 equals() 方法比较返回 true 时，这两个对象的hashCode()方法的返回值也应相等。</li>
<li>对象中用作 equals() 方法比较的 Field，都应该参与hashCode值的计算</li>
</ul>
<hr>
<p><strong>扩展</strong>：<strong>数字31</strong>，Eclipse/IDEA为例，在自定义类中可以调用工具自动重写equals和hashCode。 问题：为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？ </p>
<ul>
<li>选择系数的时候要<strong>选择尽量大的系数</strong>。因为如果计算出来的hash地址越大，所谓的 “<strong>冲突</strong>”<strong>就越少</strong>，查找起来效率也会提高。（减少冲突）</li>
<li>并且31<strong>只占用5bit</strong>，相乘造成数据<strong>溢出的概率较小</strong>。</li>
<li>31可以 由i*31== (i&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化，<strong>可移位操作得出的数据效率高</strong>。(且重要还是一个最小的素数)</li>
<li><strong>31是一个素数</strong>，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结 果只能被素数本身和被乘数还有1来整除！(减少冲突)</li>
</ul>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>以HashSet为例，使用Set集合的实现类</p>
<ul>
<li><strong>不仅需要重写equals方法，还需要重写hashCode()方法</strong></li>
<li>判断唯一性步骤是，先检查hashCode是否有数据，有再调用equals方法逐一排查</li>
</ul>
<h3 id="实现类概述-1"><a href="#实现类概述-1" class="headerlink" title="实现类概述"></a>实现类概述</h3><p><strong>实现类</strong>：HashSet、LinkedHashSet、TreeSet…</p>
<h4 id="API体系-1"><a href="#API体系-1" class="headerlink" title="API体系"></a>API体系</h4><ul>
<li>以HashSet继承实现关系为例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|--java.lang.Object</span><br><span class="line">|----java.util.AbstractCollection&lt;E&gt;<span class="comment">//实现Collection，并重写toString方法</span></span><br><span class="line">|------java.util.AbstractSet&lt;E&gt;</span><br><span class="line">|--------java.util.HashSet&lt;E&gt;<span class="comment">//实现了Set接口</span></span><br><span class="line">|-----------java.util.LinkedHashSet&lt;E&gt;<span class="comment">//LinkedHashSet是HashSet的子类</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其中：<strong>AbstractCollection重写了toString()方法</strong>，<strong>使其直接打印除集合中元素</strong>(迭代器)</li>
<li><strong>LinkedHashSet是HashSet的子类</strong></li>
</ul>
<h4 id="实现类比较-1"><a href="#实现类比较-1" class="headerlink" title="实现类比较"></a>实现类比较</h4><ul>
<li><strong>相同点</strong>：<strong>都实现了Set接口存储特点相同，无序，不可重复</strong></li>
<li><strong>不同点</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">指标\实现类</th>
<th>HashSet</th>
<th>LinkedHashSet</th>
<th>TreeSet</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>背景</strong></td>
<td>Set<strong>主要实现类</strong></td>
<td>HashSet<strong>子类</strong></td>
<td>实现SortedMap</td>
</tr>
<tr>
<td align="left"><strong>底层实现</strong></td>
<td>哈希表(哈希地址+数组)</td>
<td>带双向索引的哈希表</td>
<td>红黑树</td>
</tr>
<tr>
<td align="left"><strong>线程安全</strong></td>
<td>线程不安全</td>
<td>线程不安全</td>
<td>线程安全</td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td>一般场景</td>
<td>频繁的遍历操作</td>
<td>支持自动排序</td>
</tr>
<tr>
<td align="left"><strong>元素类型</strong></td>
<td>无限制(存储null值)</td>
<td>无限制</td>
<td><strong>仅同一类型</strong></td>
</tr>
</tbody></table>
<h2 id="API-7"><a href="#API-7" class="headerlink" title="API"></a>API</h2><ul>
<li>Set接口继承与Collection父接口</li>
<li>Set接口仅重定义了一遍Collection的所有方法，并<strong>没有提供额外的方法，等同于Collection</strong></li>
</ul>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><ul>
<li><strong>HashSet</strong>：Set主要实现类、基于哈希表实现、</li>
<li><strong>HashSet</strong>底层实现，<em>JDK7.0</em>和<em>JDK8.0</em>并<strong>不一致</strong>，因此需区分说明，先以<em>JDK 7.0</em>底层实现说起</li>
</ul>
<h3 id="API-8"><a href="#API-8" class="headerlink" title="API"></a>API</h3><ul>
<li>HashSet也仅间接实现了Set的所有方法，并没有自身的API，因此拥有的方法等同于<strong>Collection</strong></li>
</ul>
<h3 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h3><ul>
<li>HashSet底层是用HashMap实现的，因此分析HashSet的源码就是分析HashMap的源码</li>
<li>创建HashSet在底层实际创建了一个HashMap，添加一个元素到HashSet实际添加到了HashMap中</li>
</ul>
<h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><ul>
<li>HashSet(LinkedHahsSet)的整个体系都是基于HashMap实现的</li>
<li>HashSet在进行put(E e)操作时实际把想<strong>存储的数据作为Key存储到了HashMap中</strong></li>
<li>value总统一指向一个Object静态常量，避免空指针</li>
</ul>
<hr>
<ul>
<li><strong>put</strong>(E e)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>PRESENT常量</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><ul>
<li><strong>LinkedHashSet</strong>基于LinkedHashMap实现，底层存储<strong>同是哈希表</strong>(数组)，本质还是<strong>存储的无序性</strong>。</li>
<li><strong>只是在添加操作时，为每个元素额外添加了双向索引来维护其添加的顺序</strong>。</li>
<li>因此LinkedHashSet在遍历时，就可以选择通过索引的方式来遍历，因此能得到添加时顺序<ul>
<li>优点：<strong>对于频繁得遍历操作，LinkedHashSet效率高于HashSet</strong>。(因为不用判断操作，直接索引)</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210611205355.png"
                     
                ></p>
<h3 id="API-9"><a href="#API-9" class="headerlink" title="API"></a>API</h3><ul>
<li><p>LinkedHashSet<strong>仅对HashSet进行了继承操作</strong>，本身并<strong>没有声明新的方法或重写</strong>。因此<strong>等价于HashSet的API</strong>。</p>
</li>
<li><p>而HashSet又等价与Set，Set又等价与Collection的API</p>
<blockquote>
<p>这里引发出一个问题，既然LinkedHashSet仅对HashSet进行了继承操作，并没有进行任何重写操作，那么这个双向索引在什么时候添加上去的？</p>
</blockquote>
</li>
</ul>
<h3 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h3><ul>
<li>由于LinkedHashSet底层使基于LinkedHahsMap实现的，LinkedHashMap有继承与HashMap。</li>
</ul>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><ul>
<li>TreeSet由于有许多自我实现的特点，因此建议和HashSet与LinkedHashSet区分学习。</li>
<li>TreeSet底层是由<strong>红黑树</strong>实现，最大的特点是支持<strong>自动排序</strong>。<ul>
<li>红黑树是一种<strong>自平衡的平衡二叉数</strong>，平衡二叉树即最高性能的二叉排序树</li>
</ul>
</li>
<li>因为支持排序，因此TreeSet要求传入的元素必须是<strong>同一类型</strong>，<strong>不同类型元素</strong>在添加使其<strong>就会报错</strong>。</li>
</ul>
<p><strong>注</strong>：实际开发中<strong>使用泛型</strong>即可避免类型错误 <code>TreeSet&lt;String&gt; treeSet = new TreeSet&lt;&gt;();</code></p>
<h3 id="自动排序"><a href="#自动排序" class="headerlink" title="自动排序"></a>自动排序</h3><ul>
<li>TreeSet在<strong>添加元素的过程中就会自动给元素进行排序</strong>。</li>
<li>因此对于<strong>未进行排序接口实现的数据元素</strong>，<strong>连添加元素操作都无法进行，报出异常</strong>。</li>
<li>同Java比较器实现排序原理一致，都需要待排序对象首先实现自然排序或定制排序接口。</li>
</ul>
<hr>
<ul>
<li>示例代码</li>
<li>Person.java：没有进行任何排序接口的实现操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码：添加自定义类数据元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.tree;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TreeSet&lt;Person&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Priscilla&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>,<span class="number">28</span>));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        添加操作都无法进行：报出如下异常</span></span><br><span class="line"><span class="comment">         java.lang.ClassCastException: com.website.tree.Person</span></span><br><span class="line"><span class="comment">            cannot be cast to java.lang.Comparable</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自然排序"><a href="#自然排序" class="headerlink" title="自然排序"></a>自然排序</h4><p><strong>TressSet自然排序实现步骤</strong>：</p>
<ol>
<li>使用TreeSet空参构造器：<code>TreeSet&lt;T&gt; treeSet = new TreeSet&lt;&gt;();</code></li>
<li>数据元素实现Comparable接口</li>
</ol>
<h5 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h5><ul>
<li>Person：<strong>实现Comparable接口，重写compareTo()方法</strong></li>
<li>设置比较规则：以name属性从小到大排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getName().compareTo(o.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TreeSet&lt;Person&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Priscilla&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>,<span class="number">28</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Acer&quot;</span>,<span class="number">33</span>));</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Person&gt; iterator = treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.print(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历结果</span></span><br><span class="line">        <span class="comment">//Person&#123;name=&#x27;Acer&#x27;, age=33&#125;</span></span><br><span class="line">        <span class="comment">//Person&#123;name=&#x27;Jack&#x27;, age=28&#125;</span></span><br><span class="line">        <span class="comment">//Person&#123;name=&#x27;Priscilla&#x27;, age=18&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="不可重复性判断"><a href="#不可重复性判断" class="headerlink" title="不可重复性判断"></a>不可重复性判断</h5><ul>
<li><p>TreeSet<strong>判断两个元素是否相同的依据</strong>：<strong>是自然排序的compareTo</strong>()方法，不是equals和hashCode</p>
</li>
<li><p>测试代码1：</p>
<ul>
<li>以上述”自然排序“规则的Person类为基础，进行如下元素添加</li>
<li>排序规则：以name属性从小到大排序</li>
<li>由于排序规则只涉及name属性，因此age属性的差异不作为元素相同判断标准。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TreeSet&lt;Person&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Priscilla&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>,<span class="number">28</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Acer&quot;</span>,<span class="number">33</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再添加一个name相同age不同的元素</span></span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Acer&quot;</span>,<span class="number">20</span>));<span class="comment">//未能被添加进TreeSet集合中</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;size = &quot;</span> + treeSet.size());<span class="comment">//3</span></span><br><span class="line">        Iterator&lt;Person&gt; iterator = treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.print(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历结果</span></span><br><span class="line">        <span class="comment">//Person&#123;name=&#x27;Acer&#x27;, age=33&#125;</span></span><br><span class="line">        <span class="comment">//Person&#123;name=&#x27;Jack&#x27;, age=28&#125;</span></span><br><span class="line">        <span class="comment">//Person&#123;name=&#x27;Priscilla&#x27;, age=18&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码2：<ul>
<li>使<code>new Person(&quot;Acer&quot;,20);</code>元素添加进去，则需把age属性也参与compareTo()中</li>
<li>修改compareTo()方法：<strong>使其name属性相同时，以age从小到大排序</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="keyword">this</span>.getName().compareTo(o.getName());</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;<span class="comment">//二级排序条件</span></span><br><span class="line">        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.getAge(),o.getAge());<span class="comment">//age从小到大</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>打印结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">Person&#123;name&#x3D;&#39;Acer&#39;, age&#x3D;20&#125;</span><br><span class="line">Person&#123;name&#x3D;&#39;Acer&#39;, age&#x3D;33&#125;</span><br><span class="line">Person&#123;name&#x3D;&#39;Jack&#39;, age&#x3D;28&#125;</span><br><span class="line">Person&#123;name&#x3D;&#39;Priscilla&#39;, age&#x3D;18&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h4><p><strong>TressSet定制排序实现步骤</strong>：</p>
<ol>
<li>创建实现Comparator接口的实现类，作为参数传入TreeSet构造器中</li>
<li>使用TreeSet带Comparator参数构造器：<code>new TreeSet(Comparator&lt;? super E&gt; comparator);</code></li>
</ol>
<h5 id="示例代码-5"><a href="#示例代码-5" class="headerlink" title="示例代码"></a>示例代码</h5><ul>
<li>Person：不实现任何比较器接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>采用定制化比较器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定制排序，比较器(采用匿名方式创建实现类对象)</span></span><br><span class="line">        Comparator comparator = <span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> result = -(o1.getName().compareTo(o2.getName()));<span class="comment">//取反，逆序</span></span><br><span class="line">                <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;<span class="comment">//二级排序条件</span></span><br><span class="line">                    <span class="keyword">return</span> Integer.compare(o1.getAge(),o2.getAge());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定制化排序，在构造器中传入比较器接口</span></span><br><span class="line">        TreeSet&lt;Person&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;(comparator);</span><br><span class="line">        </span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Priscilla&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>,<span class="number">28</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Acer&quot;</span>,<span class="number">33</span>));</span><br><span class="line"></span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Acer&quot;</span>,<span class="number">20</span>));<span class="comment">//再添加一个name相同age不同的元素</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;size = &quot;</span> + treeSet.size());<span class="comment">//4</span></span><br><span class="line">        Iterator&lt;Person&gt; iterator = treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历结果</span></span><br><span class="line">        <span class="comment">//size = 4</span></span><br><span class="line">        <span class="comment">//Person&#123;name=&#x27;Priscilla&#x27;, age=18&#125;</span></span><br><span class="line">        <span class="comment">//Person&#123;name=&#x27;Jack&#x27;, age=28&#125;</span></span><br><span class="line">        <span class="comment">//Person&#123;name=&#x27;Acer&#x27;, age=20&#125;</span></span><br><span class="line">        <span class="comment">//Person&#123;name=&#x27;Acer&#x27;, age=33&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="不可重复性判断-1"><a href="#不可重复性判断-1" class="headerlink" title="不可重复性判断"></a>不可重复性判断</h5><ul>
<li>此时TreeSet<strong>判断两个元素是否相同的依据</strong>：<strong>是定制排序的compare</strong>()方法</li>
</ul>
<h3 id="API-10"><a href="#API-10" class="headerlink" title="API"></a>API</h3><h3 id="源码分析-4"><a href="#源码分析-4" class="headerlink" title="源码分析"></a>源码分析</h3><ul>
<li>TreeSet底层实现也是TreeMap</li>
</ul>
<h1 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h1><ul>
<li><strong>API体系</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210610111917.png"
                     
                ></p>
<h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><strong>Map</strong>接口，是和Collection并列的接口</li>
<li>Map也译为“<strong>映射</strong>”，<strong>双列数据</strong>，保存具有<strong>映射关系</strong>“key-value对”的集合，同数学<em>函数 y=f(x)</em><ul>
<li>x自变量相当于key，y因变量相当于value</li>
</ul>
</li>
<li><strong>Map中的key是不可重复的，value可重复</strong></li>
</ul>
<h3 id="实现类概述-2"><a href="#实现类概述-2" class="headerlink" title="实现类概述"></a>实现类概述</h3><h4 id="API体系-2"><a href="#API体系-2" class="headerlink" title="API体系"></a>API体系</h4><ul>
<li>以HashMap继承实现关系为例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|--java.lang.Object </span><br><span class="line">|-----java.util.AbstractMap&lt;K,V&gt; </span><br><span class="line">|--------java.util.HashMap&lt;K,V&gt;<span class="comment">//实现Map</span></span><br><span class="line">|-----------java.util.LinkedHashMap</span><br></pre></td></tr></table></figure>

<h4 id="实现类比较-2"><a href="#实现类比较-2" class="headerlink" title="实现类比较"></a>实现类比较</h4><ul>
<li><strong>相同点</strong>：<strong>都实现了Map接口存储特点相同，有序，可重复</strong></li>
<li><strong>不同点</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">指标\实现类</th>
<th>HashMap</th>
<th>LinkedHashMap</th>
<th>TreeMap</th>
<th>Hahstable</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>背景</strong></td>
<td>Map<strong>主要实现类</strong></td>
<td>HashMap子类</td>
<td>实现SortedMap</td>
<td><strong>已弃用</strong></td>
</tr>
<tr>
<td align="left"><strong>底层实现</strong></td>
<td>jdk7：哈希表(哈希地址+数组)<br>jdk8：哈希表 + 红黑树</td>
<td>带双向索引的哈希表<br>(同理jdk7，8不一样)</td>
<td>红黑树</td>
<td>哈希表</td>
</tr>
<tr>
<td align="left"><strong>线程安全</strong></td>
<td>线程不安全</td>
<td>线程不安全</td>
<td>线程不安全</td>
<td><strong>线程安全</strong></td>
</tr>
<tr>
<td align="left"><strong>效率</strong></td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td>一般场景</td>
<td>频繁遍历操作</td>
<td>支持排序(key)</td>
<td>线程安全</td>
</tr>
<tr>
<td align="left"><strong>元素类型</strong></td>
<td><strong>可存储null值</strong>(key与value)</td>
<td></td>
<td></td>
<td>不可存储null值</td>
</tr>
</tbody></table>
<ul>
<li>其他实现类补充</li>
<li><strong>Properties</strong><ul>
<li>Properties：Properties是Hashtable的子类，常用于处理属性(配置)文件</li>
<li>Properties的key和value都是<strong>String</strong>类型</li>
</ul>
</li>
<li><strong>CurrentHashMap</strong>：高并发场景使用</li>
</ul>
<h2 id="API-11"><a href="#API-11" class="headerlink" title="API"></a>API</h2><ul>
<li>Map接口是和Collection接口并列的独立的两个接口</li>
<li><em>JDK 1.8 - MAP</em></li>
<li>Map使用需要重写hashCode和equals方法，详情查看“Map存储原理”</li>
</ul>
<h3 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h3><table>
<thead>
<tr>
<th>AbstractMethod</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>V <strong>put</strong>(K key,V value)</td>
<td>将指定key-value添加到(或修改)当前map对象中，<strong>返回旧value指</strong></td>
</tr>
<tr>
<td>void <strong>putAll</strong>(Map m)</td>
<td>将m中的所有key-value对存放到当前map中</td>
</tr>
<tr>
<td>V <strong>remove</strong>(Object key)</td>
<td>移除指定key的key-value对，<strong>并返回value</strong></td>
</tr>
<tr>
<td>void <strong>clear</strong>()</td>
<td>清空当前map中的所有数据</td>
</tr>
</tbody></table>
<h3 id="元素查询"><a href="#元素查询" class="headerlink" title="元素查询"></a>元素查询</h3><table>
<thead>
<tr>
<th>AbstractMethod</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>V <strong>get</strong>(Object key)</td>
<td>获取指定key对应的value</td>
</tr>
<tr>
<td>boolean <strong>containsKey</strong>(Object key)</td>
<td>是否包含指定的key</td>
</tr>
<tr>
<td>boolean <strong>containsValue</strong>(Object value)</td>
<td>是否包含指定的value</td>
</tr>
<tr>
<td>int <strong>size</strong>()</td>
<td>返回map中key-value对的个数</td>
</tr>
<tr>
<td>boolean <strong>isEmpty</strong>()</td>
<td>判断当前map是否为空</td>
</tr>
<tr>
<td>boolean <strong>equals</strong>(Object obj)</td>
<td>判断当前map和参数对象obj是否相等</td>
</tr>
</tbody></table>
<h3 id="元视图操作"><a href="#元视图操作" class="headerlink" title="元视图操作"></a>元视图操作</h3><table>
<thead>
<tr>
<th>AbstractMethod</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>Set&lt;K&gt; <strong>keySet</strong>()</td>
<td>返回所有key构成的Set集合，遍历key</td>
</tr>
<tr>
<td>Collection&lt;V&gt; <strong>values</strong>()</td>
<td>返回所有value构成的<strong>Collection集合</strong>，遍历values</td>
</tr>
<tr>
<td>Set&lt;Map.Entry&lt;K,V&gt;&gt; <strong>entrySet</strong>()</td>
<td>返回所有key-value对构成的Set集合，遍历key-value(entry)</td>
</tr>
</tbody></table>
<ul>
<li>在hashmap中add添加相同得key起到修改功能Map存储原理</li>
</ul>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ul>
<li>Map中的遍历操作使用<strong>元视图API</strong>实现，调用任意一个方法都可以返回一个Collection或其子接口Set</li>
<li><strong>只要是Collection</strong>，遍历就可以使用：<strong>迭代器</strong>(增强for循环)</li>
</ul>
<h4 id="遍历key"><a href="#遍历key" class="headerlink" title="遍历key"></a>遍历key</h4><ul>
<li>Set&lt;K&gt; <strong>keySet</strong>()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-12 11:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;ABC&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        map.put(<span class="string">&quot;DE&quot;</span>,<span class="keyword">new</span> Double(<span class="number">3.2</span>));</span><br><span class="line">        map.put(<span class="string">&quot;SDSD&quot;</span>,<span class="string">&quot;SD&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式1：原生迭代器</span></span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        Iterator&lt;String&gt; iterator = keys.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.print(iterator.next() + <span class="string">&quot; , &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式2：增强for循环迭代器</span></span><br><span class="line">        <span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">            System.out.print(key + <span class="string">&quot; , &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历value"><a href="#遍历value" class="headerlink" title="遍历value"></a>遍历value</h4><ul>
<li>Collection&lt;V&gt; <strong>values</strong>()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-12 11:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;ABC&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        map.put(<span class="string">&quot;DE&quot;</span>,<span class="keyword">new</span> Double(<span class="number">3.2</span>));</span><br><span class="line">        map.put(<span class="string">&quot;SDSD&quot;</span>,<span class="string">&quot;SD&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式1：原生迭代器</span></span><br><span class="line">        Collection&lt;Object&gt; values = map.values();</span><br><span class="line">        Iterator&lt;Object&gt; iterator = values.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.print(iterator.next() + <span class="string">&quot; , &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方式2：增强for循环迭代器</span></span><br><span class="line">        <span class="keyword">for</span>(Object obj : map.values())&#123;</span><br><span class="line">            System.out.print(obj + <span class="string">&quot; , &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>注</strong>：values()返回的Collection接口实现类是java.util.<strong>HashMap$Values</strong> ，也是无序的，<strong>不能强转为List或Set这些子接口</strong>，不是一个体系。不能看到Collection就以为可以强转。</p>
</li>
<li><p>测试代码</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;abc&quot;</span>,<span class="number">123</span>);</span><br><span class="line">    map.put(<span class="string">&quot;cde&quot;</span>,<span class="number">112323</span>);</span><br><span class="line">    map.put(<span class="string">&quot;afasf&quot;</span>,<span class="number">323</span>);</span><br><span class="line"></span><br><span class="line">    Collection&lt;Integer&gt; values = map.values();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//java.util.HashMap$Values</span></span><br><span class="line">    System.out.println(<span class="string">&quot;values.getClass() = &quot;</span> + values.getClass());</span><br><span class="line"></span><br><span class="line">    List list = (List) values;<span class="comment">//报异常：java.lang.ClassCastException:</span></span><br><span class="line">    <span class="comment">// java.util.HashMap$Values cannot be cast to java.util.List</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历Entry"><a href="#遍历Entry" class="headerlink" title="遍历Entry"></a>遍历Entry</h4><ul>
<li>Set&lt;Map.Entry&lt;K,V&gt;&gt; <strong>entrySet</strong>()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-12 11:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;ABC&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        map.put(<span class="string">&quot;DE&quot;</span>,<span class="keyword">new</span> Double(<span class="number">3.2</span>));</span><br><span class="line">        map.put(<span class="string">&quot;SDSD&quot;</span>,<span class="string">&quot;SD&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式1：原生迭代器</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Object&gt;&gt; entries = map.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iterator = entries.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;String, Object&gt; entry = iterator.next();</span><br><span class="line">            System.out.print(entry.getKey() + <span class="string">&quot; : &quot;</span>);</span><br><span class="line">            System.out.print(entry.getValue() + <span class="string">&quot; , &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式2：增强for循环迭代器</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, Object&gt; entry : map.entrySet())&#123;</span><br><span class="line">            System.out.print(entry.getKey() + <span class="string">&quot; : &quot;</span>);</span><br><span class="line">            System.out.print(entry.getValue() + <span class="string">&quot; , &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map存储原理"><a href="#Map存储原理" class="headerlink" title="Map存储原理"></a>Map存储原理</h2><h3 id="四元组"><a href="#四元组" class="headerlink" title="四元组"></a>四元组</h3><h4 id="key-value特性"><a href="#key-value特性" class="headerlink" title="key-value特性"></a>key-value特性</h4><ul>
<li><p><strong>存储特性</strong></p>
<ul>
<li>Map中每一个key对应一个value，可以创建一个数据结构将key与value进行绑定</li>
<li>JDK1.7中每个Map元素用一个Entry结构存储，JDK1.8中声明为Node，但功能一样</li>
<li>由于Map中的key是不可重复的，value是可重复，而且两者都是无序的</li>
</ul>
</li>
<li><p>因此每一个Entry结构表现出来是<strong>不可重复、且无序的</strong></p>
</li>
<li><p><strong>数据结构</strong></p>
<ul>
<li><strong>存储特性数据结构</strong><ul>
<li>不可重复性：解决存储不可重复元素的存储的数据结构优先<strong>哈希表结构</strong>，再采用<strong>拉链法</strong>解决冲突。<ul>
<li><strong>hash</strong>：存储用于指定存储数组索引的哈希值</li>
<li><strong>next</strong>：用于通过拉链法解决冲突问题时形成链表结构</li>
</ul>
</li>
<li>无序性：哈希表存储数据本身就是无序性</li>
</ul>
</li>
<li><strong>非存储特性数据结构</strong><ul>
<li>T <strong>key</strong>：存储key值本身</li>
<li>T <strong>value</strong>：存储key值对应的数据本身</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>小结</strong>：通过哈希表，拉链法解决冲突的HashMap，<strong>每一个数据结点Entry需4个属性</strong>，<strong>hash、nextkey、value</strong>。</li>
</ul>
</li>
<li><p><strong>这正是JDK1.7之前HashMap的存储原理，示意图如下</strong></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/jdk1.7HashMap%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg"
                     
                ></p>
<h4 id="Entry源代码"><a href="#Entry源代码" class="headerlink" title="Entry源代码"></a>Entry源代码</h4><ul>
<li>Entry<strong>部分源代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates new entry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//.......忽略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDK1-8版本"><a href="#JDK1-8版本" class="headerlink" title="JDK1.8版本"></a>JDK1.8版本</h3><ul>
<li><p>相较于jdk1.7版本的HashMap使用的数据结构，<strong>jdk1.8新加入红黑树优化开散列表的查询效率</strong></p>
</li>
<li><p>当数组的开散列表元素个数 &gt; 8，且数组长度 &gt; 64时，将此时的<strong>开散列表转为红黑树存储</strong></p>
<blockquote>
<ul>
<li>唯一影响哈希表查询效率的就是冲突现象引发的数据堆积现象</li>
<li>一旦出现冲突，无论是开闭散列表都将退化为线性的顺序查找O(n)</li>
<li>由于红黑树在查找效率要比线性表查找效率高，因此当堆积现象频繁出现时，将其转存为红黑树结构能很大程度上减缓查询效率的减低。</li>
<li><strong>可以说哈希表存储(拉链法)和红黑树是绝配</strong></li>
</ul>
</blockquote>
</li>
<li><p>除加入红黑树外，<strong>Entry结点名改为Node</strong>，但<strong>属性数量和意义与1.7版本一致</strong></p>
</li>
<li><p>jdk1.8版HashMap存储结构示意图：</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/jdk1.8HashMap%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg"
                     
                ></p>
<h3 id="HashMap查找过程"><a href="#HashMap查找过程" class="headerlink" title="HashMap查找过程"></a>HashMap查找过程</h3><h4 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><p><strong>哈希值</strong>：</p>
<ul>
<li><strong>Object</strong>中，hashCode()默认返回的是<strong>对象存储的地址</strong></li>
<li><strong>HashSet</strong>中将hashCode()<strong>重写</strong>了，返回的哈希值是**以该对象所有属性值计算的</li>
<li><strong>此时若所有属性都一样，哈希值也肯定是一样</strong>，但由于计算哈希值的散列函数的特性，极少机率会出现不同两个对象，计算出的哈希值也一样的现象，这种现象称为<strong>冲突，或者碰撞</strong>。存储时就会产生堆积现象</li>
</ul>
</li>
<li><p>散列表查找技术<strong>以哈希值作为存储元素的数组的下标值</strong>，不发生冲突时候查找效率为O(1)</p>
</li>
</ul>
<h4 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h4><p>以jdk1.7，纯哈希表(拉链法解决冲突)为例：</p>
<ol>
<li><p>添加一个新元素之前，先计算<strong>key对象的hash值</strong></p>
</li>
<li><p>将hash值<strong>再经过indexFor计算</strong>后，得出一个散列表数组得<strong>下标值</strong></p>
<ul>
<li><p>注意这里有个关键的点，hash值—indexFor算法—&gt;下标值，这个过程中也会<strong>引发出新的一种冲突</strong></p>
</li>
<li><p>即存在<strong>两个不同的hash值计算出同一个下标值</strong></p>
<blockquote>
<ul>
<li>如两个不同的对象，计算出两个不同的hash值，300213，311213</li>
<li>这些庞大的hash值是不能够直接作为有限数组下标存储的(如数组初始容量为16)</li>
<li>处理的方式就是将hash值和散列表长度值(16)取模，如 300231 % 16 = [0 ~ 15]</li>
<li>如</li>
<li>源码底层实现这种取模运算更高效的算法就是：hash &amp; (length - 1)</li>
<li>与运算是所有布尔运算中计算机底层效率最高的</li>
</ul>
</blockquote>
</li>
<li><p>此时加上hash值本身存在的冲突，再加上转换为数组下标时存在的冲突，<strong>一共有两次冲突可能</strong></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210612231356.png"
                     
                ></p>
</li>
<li><p>通过下标定位到存储位置后，若该位置<strong>没有数据</strong>，则肯定<strong>不存在重复</strong>，<strong>直接存储Entry</strong>即可</p>
</li>
<li><p>若定位<strong>有数据</strong>，则有<strong>存在冲突的可能性</strong>，也可能是同一key数据添加而已</p>
<ul>
<li><p>若hash值不同则存在数组下标转换冲突</p>
</li>
<li><p>若hash值相同，则判断hash计算冲突</p>
<ul>
<li>若两者(遍历全部)key的equals不同，则存在hash值计算冲突</li>
<li>若两者(遍历全部)key的equals相同，则不属于冲突情况，属于同一key值被添加了</li>
</ul>
</li>
</ul>
<blockquote>
<p>一直以希望它是重复数据，而不是冲突数据的角度去排除判断的</p>
</blockquote>
</li>
</ol>
<h3 id="不可重复性-1"><a href="#不可重复性-1" class="headerlink" title="不可重复性"></a>不可重复性</h3><ul>
<li>HahsMap &amp; LinekdHashMap<ul>
<li>由于每一个Entry/Node<strong>采用了哈希表存储</strong>，且Map规定<strong>key值是不可重复</strong>的。</li>
<li>因此在Map中判断key是否重复的依据是：<strong>equals</strong>() 和 <strong>hashCode</strong>()</li>
</ul>
</li>
<li>TreeMap</li>
</ul>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="API-12"><a href="#API-12" class="headerlink" title="API"></a>API</h3><ul>
<li>HahsMap几乎增加新的API，如ArrayList一样，几乎完全实现与父接口。</li>
<li>即HashMao是Map接口的<strong>主要实现类</strong></li>
<li>因此一般使用多态的方式声明<code>Map&lt;T&gt; map = new HashMap&lt;&gt;();</code></li>
</ul>
<h3 id="扩容指标"><a href="#扩容指标" class="headerlink" title="扩容指标"></a>扩容指标</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li><p>HashMao底层的散列表也是由数组实现的，集合中涉及数组实现则肯定避免不了扩容机制</p>
</li>
<li><p>但由于哈希表存储与线性表底层的存储结构差异性较大，扩容机制完全不同于上文提及的StringBuffer/StringBuilder、ArrayList这些扩容机制，仅仅大于数组长度时就除法扩容。</p>
</li>
<li><p>首先，哈希表扩容的判断标准就不一样，不像线性表存储，容量为16，当第17个元素到来时即扩容的时机，由于存储数据是无序的，因为存在冲突现象，还设置了开闭散列表。即有可能散列表数组容量是16，可存储的数据不止16。因为有可能部分数据发生了冲突存储在了开散列表中，还会出现散列表中某些位置无论存多少个数据都一直没被使用，甚至出现这个散列表一直没被存满，这些情况都存在的，因此简单以散列表数组长度 &lt; 拟存储数据量，去决定扩容指标是不可取的</p>
<hr>
</li>
<li><p>首先散列表也是静态数组，容量有限。而由于存储数据是无序的，因此哈希算法尽量使不同的元素计算出的哈希值能均匀地分布在散列表中。因此减少冲突现象发生的机率</p>
</li>
<li><p>但随着数据量的增多，散列表长度不变的情况下，冲突的机率将会越来越大</p>
</li>
<li><p>此时应该设定一个标准(非数组长度)，一旦达到这个标准，就要开始扩充散列表的长度，以此将冲突机率降低下来，达到一个相对稳定的过程。</p>
</li>
</ul>
<h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><ul>
<li>因此哈希表存储不同于线性表，仅判断大于数组长度就扩容。而是需要通过一定算法计算出一个临界值比例，若比这个临界值大才扩容。</li>
<li>虽说添加数据量不能直接作为哈希表存储结构判断扩容的标准，但<strong>添加操作本身肯定是作为任意数据结构判断扩容机制的时机</strong>。</li>
</ul>
<blockquote>
<p>而这个标准就是实现中的临界值，而临界值如何计算，如何设计，又是另一个问题了</p>
</blockquote>
<h3 id="重要常量与属性"><a href="#重要常量与属性" class="headerlink" title="重要常量与属性"></a>重要常量与属性</h3><ul>
<li>在研究HashMap之前，无论是jdk7还是jdk8版本的源码，具备如下重要常量和属性</li>
</ul>
<h4 id="全局常量"><a href="#全局常量" class="headerlink" title="全局常量"></a>全局常量</h4><ul>
<li><strong>DEFAULT_INITIAL_CAPACITY</strong> : HashMap的默认容量，<strong>16</strong> </li>
<li><strong>MAXIMUM_CAPACITY</strong> ： HashMap的最大支持容量，2^30 </li>
<li><strong>DEFAULT_LOAD_FACTOR</strong>：HashMap的<strong>默认加载因子</strong>，<strong>0.75</strong></li>
<li><strong>TREEIFY_THRESHOLD</strong>：开散列表Bucket中链表长度大于该<strong>默认值8</strong>，<strong>转化为红黑树</strong> </li>
<li><strong>UNTREEIFY_THRESHOLD</strong>：Bucket中红黑树存储的Node小于该默认值，转化为链表 </li>
<li><strong>MIN_TREEIFY_CAPACITY</strong>：桶中的Node被树化时最小的hash表容量。（当桶中Node的 数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行 resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4 倍。） </li>
</ul>
<h4 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h4><ul>
<li><strong>table</strong>：存储元素的底层散列表数组，总是2^n次幂(需匹配哈希值算法) </li>
<li><strong>entrySet</strong>：存储具体元素的集 </li>
<li><strong>size</strong>：HashMap中存储的键值对的数量 </li>
<li><strong>modCount</strong>：HashMap扩容和结构改变的次数。</li>
<li><strong>threshold</strong>：<strong>扩容的临界值</strong>，=容量*填充因子</li>
<li><strong>loadFactor</strong>：<strong>填充因子</strong></li>
</ul>
<h4 id="加载因子"><a href="#加载因子" class="headerlink" title="加载因子"></a>加载因子</h4><p>加载因子又称为负载因子</p>
<ul>
<li>负载因子的大小决定了HashMap的数据密度。</li>
<li>负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长, 造成查询或插入时的比较次数增多，性能会下降。</li>
<li>负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的 几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。 </li>
<li>按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数。</li>
</ul>
<h3 id="JDK7源码分析-1"><a href="#JDK7源码分析-1" class="headerlink" title="JDK7源码分析"></a>JDK7源码分析</h3><ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://gitee.com/yihangdeng/net-resources/blob/master/Code/HashMapOfJDK7.java" >jdk1.7/7 HashMap源码<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h4 id="构造器-3"><a href="#构造器-3" class="headerlink" title="构造器"></a>构造器</h4><h5 id="HashMap-1"><a href="#HashMap-1" class="headerlink" title="HashMap()"></a>HashMap()</h5><ul>
<li>传入DEFAULT_INITIAL_CAPACITY(默认容量=<strong>16</strong>)，DEFAULT_LOAD_FACTOR(默认加载因子=0.75)</li>
<li>调用重载构造器<code>HashMap(int initialCapacity, float loadFactor)</code>进一步处理</li>
</ul>
<hr>
<ul>
<li>HashMap()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="HashMap-int-initialCapacity-float-loadFactor"><a href="#HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="HashMap(int initialCapacity, float loadFactor)"></a>HashMap(int initialCapacity, float loadFactor)</h5><ul>
<li><p>前面三个if均是对两个传入参数的合法性检查</p>
</li>
<li><p>初始化状态调用直接到<code>int capacity = 1</code>开始，下述代码是保<strong>证传入的初始化容量是2的整数倍</strong></p>
<ul>
<li>如当传入的initialCapacity==15时，最终capacity将以16的结果退出循环，后续初始化使用的变量是capacity不是传入的initialCapacity</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(capacity &lt; initialCapacity);</span><br><span class="line">    capacity &lt;&lt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>得到2的整数倍初始化容量capacity后，记录传入的加载因子，并计算出临界值threshold</p>
</li>
<li><p>以capacity(初始状态为16)的大小初始化散列表数组，Entry[capacity]</p>
</li>
<li><p><code>sun.misc.VM.isBooted</code>暂且忽略</p>
</li>
<li><p><code>init()</code>是一个空方法，给子类LinkedHahsMap重写用的，旨在初始化双向链表</p>
</li>
</ul>
<hr>
<ul>
<li>HashMap(int initialCapacity, float loadFactor)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">        capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">        (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><h5 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h5><p><strong>put</strong>(K key, V value)<strong>方法90%的代码都在过滤真正重复的key</strong>(要进行修改value操作)，而不是冲突现象。</p>
<ul>
<li><p>null判断，若为null，调用专属的null值存储方法，putForNullKey(忽略)</p>
</li>
<li><p>计算key值得hash值(除调用key对象得hashCode还进行了加工计算)</p>
</li>
<li><p>通过indexFor方法计算出hash值对应的数组下标索引位置</p>
<ul>
<li>实质是取模运算，通过与运算实现，从哈希值中取数组索引范围的比特位，h &amp; (length -1)，int会转换位二进制位，因此能取到</li>
<li><strong>注意</strong>：此时存在<strong>两个不同的hash值计算出同一个下标值</strong>的转换冲突现象</li>
<li>加上hash值计算本身存在的冲突，再加上转换为数组下标时存在的冲突，<strong>一共有两次冲突可能</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210612231356.png"
                     
                ></p>
</li>
<li><p>若此时若下标位置没有元素，e == null，则不存在重复更加不存在冲突，跳出for循环，直接调用addEntry方法</p>
</li>
<li><p>若有元素，则进入if判断，<code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code></p>
<ul>
<li><p>因为开散列表存在多个元素(链表)，因此需要逐一遍历,即在for循环内，尝试去找到那个真正重复的key而不是冲突造成的key。</p>
<hr>
</li>
<li><p>首先判断数组下标转换冲突，此时下标值已一致，</p>
<ul>
<li>若hash值却不一致则存在数组下标转换冲突现象，</li>
<li>如hash值一致，则属于正常现象，理应就是一致的hash值得出一致的数组下标</li>
</ul>
</li>
<li><p>若不存在数组下标转换冲突，则继续判断hash计算冲突，此时hash值已经一致</p>
<ul>
<li>若key内容本身不一致，即equals方法，则存在hash计算冲突</li>
<li>若key内容本身一致，则可以确定就是重复的key被添加进来了，新的value值替换原有的value值，并返回旧的value值</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><p>其实if一直以希望它是重复数据，不是冲突数据的角度去编写的</p>
</li>
<li><p>像下标相同有数据了，则如果hash值相同则下标相同也正常(希望它是重复数据)，</p>
</li>
<li><p>hash值相同了，又希望它key数据本身也相同equals(也希望它是重复数据)</p>
</li>
</ul>
</blockquote>
<ul>
<li>最后，或许跳出for循环的不重复情况，或者不满足if其中一个条件，都肯定存在冲突情况，或者for循环之后也找不到重复数据的冲突情况，这三种情况可归纳成两种：不重复数据现象和冲突现象</li>
<li>最终这两种现象都交给，addEntry函数处理。put(E e)函数旨在找到那个可能重复的key</li>
</ul>
<hr>
<ul>
<li>put(K key, V value)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="addEntry-int-hash-K-key-V-value-int-bucketIndex"><a href="#addEntry-int-hash-K-key-V-value-int-bucketIndex" class="headerlink" title="addEntry(int hash, K key, V value, int bucketIndex)"></a>addEntry(int hash, K key, V value, int bucketIndex)</h5><p><strong>tips</strong>：addEntry被调用时存在key还处于不重复数据和冲突数据的两种现象的可能性</p>
<p>虽说添加数据量不能直接作为哈希表存储结构判断扩容的标准，但<strong>添加操作本身肯定是作为任意数据结构判断扩容机制的时机</strong>。而且该<strong>addEntry</strong>()<strong>90%代码也是扩容机制的判断处理</strong>，<code>if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) </code></p>
<ul>
<li><p>进行扩容指标判断：当判断当前数据容量 ≥ 扩容临界值，且添加的数据属于冲突现象的数据，则进行扩容。即使≥扩容临界值，若添加数据不属于重复数据则也不扩容，直接存储在空的索引位置。</p>
</li>
<li><p>调用resize函数，<strong>将数组扩容到原来的2倍</strong>(table.length * 2)，<strong>并将所有元素重新计算下标值并重新存放</strong>。包括传入进来的拟添加的元素的下标值</p>
<blockquote>
<p>由于addEntry被调用的场景包括，数组下标没有数值(不重复也不冲突)，以及冲突的两种情况，</p>
<p>因此add内部还要把这两种情况判断区分一下</p>
</blockquote>
</li>
<li><p>无论扩容与否，数据重复还是数据冲突，最后统一进行createEntry()操作</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="createEntry-int-hash-K-key-V-value-int-bucketIndex"><a href="#createEntry-int-hash-K-key-V-value-int-bucketIndex" class="headerlink" title="createEntry(int hash, K key, V value, int bucketIndex)"></a>createEntry(int hash, K key, V value, int bucketIndex)</h5><p><strong>tips</strong>：addEntry被调用时存在key还处于不重复数据和冲突数据的两种现象的可能性</p>
<p>createEntry主要用于实现真正的数据添加操作，且实现了不重复数据(直接存储)，和冲突数据的<strong>统一代码处理化</strong>。</p>
<ul>
<li><strong>统一添加代码原理</strong>：博主将这种在哈希表拉链法统一处理不重复数据，及冲突现象数据的添加操作的代码称为为“<strong>积木撞击</strong>”添加方法</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210613095258.png"
                     
                ></p>
<ul>
<li><strong>源码分析</strong><ul>
<li>先将索引位置原有的数据暂存起来</li>
<li>创建Entry同时设置关键参数next的引用索引位置上原有的值(构成链表)</li>
<li>将新加入的Entry放入索引位置，并将容量参数size自增1</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>void <strong>createEntry</strong>(int hash, K key, V value, int bucketIndex)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Entry</strong>(int h, K k, V v, Entry&lt;K,V&gt; n)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">    value = v;</span><br><span class="line">    next = n;</span><br><span class="line">    key = k;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDK8源码分析-1"><a href="#JDK8源码分析-1" class="headerlink" title="JDK8源码分析"></a>JDK8源码分析</h3><h4 id="构造器-4"><a href="#构造器-4" class="headerlink" title="构造器"></a>构造器</h4><h5 id="HashMap-2"><a href="#HashMap-2" class="headerlink" title="HashMap"></a>HashMap</h5><ul>
<li>仅初始化了loadFactor(加载因子)的初始化值，并没有调用重载构造器，更没有实例化底层数组</li>
</ul>
<hr>
<ul>
<li>HashMap</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法-4"><a href="#方法-4" class="headerlink" title="方法"></a>方法</h4><h5 id="put-K-key-V-value-1"><a href="#put-K-key-V-value-1" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h5><ul>
<li><strong>计算key的hash值</strong>并调用<strong>putVal</strong>(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)方法</li>
<li>传入的末尾两个false和true参数暂且忽略</li>
</ul>
<hr>
<ul>
<li>put(K key, V value)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict"><a href="#putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict" class="headerlink" title="putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)"></a>putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)</h5><p><strong>以首次添加的情景引入源码分析</strong></p>
<ul>
<li>初始化声明底层Node数组引用tab，与Node结点</li>
<li>第一个 if 将table属性(底层数组引用)，赋值给tab引用暂存，并间接判断table是否为null，若部位null随便把当前table的长度计算并返回到具备变量n<ul>
<li>若首次添加，table肯定没有进行初始化，则为null，调用<strong>resize</strong>()方法进行扩容或初始化</li>
</ul>
</li>
<li>第二个 if ，通过hash值计算数组下标并取下标元素为p且判断是否为null，为null不存在重复和冲突直接存储到底层数组</li>
<li>elase：即下标位置有数据，声明一个Node局部变量e，p为数组下标原有数据<ul>
<li>第一个 if ：若当前数组下标数据p就是和添加的数据key完全一致，则用e暂存数据下标。<ul>
<li>若数组下标第一个数据p不能判断重复，则还需往下找，往下找就有两种情况，开散列表和红黑树</li>
</ul>
</li>
<li>第二个 else if ：若p这个头指针是红黑树</li>
<li>第三个 else：若p这个头指针不属于红黑树类型，则需要进行开散列表的遍历<ul>
<li>先看第二个 if ：常规的二重冲突判断找重复数据，若找得到，则从第二个if中break跳出循环，并暂存这个重复key的引用</li>
<li>若第二个if整个遍历过程中都没有break，则会遍历到开散列表的末尾，此时就证明肯定存在冲突了</li>
<li>此时第一个if中的<code>if(e = p.next) == null</code>就会符合要求，把要添加的冲突数据封装成一个新的Node，因为此时p已遍历到末尾是开散列表最后一个元素，通过尾插法的形式把添加的数据添加到末尾。<ul>
<li>检测到冲突现象了，还会判断一下是否需要将其开散列表转化为红黑树，即当开散列表的长度 &gt; 8时，(-1 是因为binCount数值关系，实际意义为8)，调用treeifyBin(tab,hash)方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>最后，从上属逻辑中可知e是专门用来暂存重复元素引用的，如果e不为空，则存在重复元素逻辑执行过，则将新的value替换旧的value，并返回旧的value</li>
</ul>
<hr>
<ul>
<li>putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下逻辑代码暂且忽略</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Node-lt-K-V-gt-resize"><a href="#Node-lt-K-V-gt-resize" class="headerlink" title="Node&lt;K,V&gt;[] resize()"></a>Node&lt;K,V&gt;[] resize()</h5><p>同样以table底层数组未初始化首次调用resize情景引入</p>
<ul>
<li>分配为table、threshold属性通过局部变量oldTab、oldThr暂存。并初始化oldCap局部变量<ul>
<li>(oldTab = table) == null</li>
<li>(oldThr = threshold) == 0 ，threshold在没被初始化</li>
<li>oldCap == 0</li>
</ul>
</li>
<li>初始状态的oldTab、oldThr、oldCap分别为null、0、0，直至最后的else分支，初始化容量和计算临界值<ul>
<li>newCap设置为默认初始容量DEFAULT_INITIAL_CAPACITY，16</li>
<li>newThr计算临界值，16 * 默认加载因子(0.75) = 12</li>
</ul>
</li>
<li>若newThr == 0，情况暂时忽略</li>
<li><strong>实例化一个长度为newCap名为newTab的Node[]数组，并将其引用返回给table</strong></li>
</ul>
<hr>
<ul>
<li>Node&lt;K,V&gt;[] resize()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    暂且忽略以下代码</span></span><br><span class="line"><span class="comment">    if (oldTab != null) &#123;</span></span><br><span class="line"><span class="comment">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="treeifyBin-Node-lt-K-V-gt-tab-int-hash"><a href="#treeifyBin-Node-lt-K-V-gt-tab-int-hash" class="headerlink" title="treeifyBin(Node&lt;K,V&gt;[] tab, int hash)"></a>treeifyBin(Node&lt;K,V&gt;[] tab, int hash)</h5><ul>
<li>if 此时若tab数组不为null而且当前散列表数组长度<strong>还小于</strong>MIN_TREEIFY_CAPACITY(<strong>64</strong>)，则调用resize()方法进行扩容操作，而不进行树转化。</li>
<li>else if反之，当散列表数组长度<strong>大于</strong>MIN_TREEIFY_CAPACITY(<strong>64</strong>)，则将当前开散列表转化为红黑树存储</li>
</ul>
<hr>
<ul>
<li>treeifyBin(Node&lt;K,V&gt;[] tab, int hash)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源码分析小结-1"><a href="#源码分析小结-1" class="headerlink" title="源码分析小结"></a>源码分析小结</h3><ul>
<li>HashMap从jdk1.7到1.8的变化类似ArrayList从1.7到1.8的变化，即也是从饿汉式初始化到懒加载。</li>
</ul>
<h4 id="源码对比-1"><a href="#源码对比-1" class="headerlink" title="源码对比"></a>源码对比</h4><table>
<thead>
<tr>
<th>指标\HashMap</th>
<th>JDK1.7/7源码</th>
<th>JDK1.8/8</th>
</tr>
</thead>
<tbody><tr>
<td><strong>new HahsMap</strong>()</td>
<td><strong>实例化并创建</strong>容量为<strong>16</strong>的Entry[]数组</td>
<td><strong>仅初始化了加载因子threshold</strong></td>
</tr>
<tr>
<td><strong>初始化时机</strong></td>
<td>new HashMap()时已经初始化容量为<strong>16</strong></td>
<td>首次进行put方法调用：<br/>创建<strong>长度为16的Node[]数组</strong><br/></td>
</tr>
<tr>
<td><strong>put方法扩容</strong></td>
<td>添加数据为冲突现象 &amp;&amp; <br>开散列表 &gt; 临界值16 * 0.75=12 &amp;&amp;<br/>散列表扩容为原来的2倍，即可*2</td>
<td>添加数据为冲突现象 &amp;&amp; <br/>开散列表 &gt; 8 &amp;&amp;<br/>if : 散列表数组 &lt; 64，散列表扩容<br/>else：将开散列表转存为红黑树</td>
</tr>
<tr>
<td><strong>冲突添加数据</strong></td>
<td>头插法</td>
<td>尾插法</td>
</tr>
<tr>
<td><strong>小结</strong></td>
<td>类似单例的<strong>饿汉式</strong><br/><strong>在调用空参构造器时候已初始化</strong><br/>对比JDK8.0方式，一定程度上浪费内存</td>
<td>类似单例的<strong>懒汉式</strong><br/><strong>在首次进行添加操作时才初始化</strong><br/>延迟了数组创建时间，节省了内存</td>
</tr>
</tbody></table>
<ul>
<li>将开散列表所有的数据改为红黑树存储，因为红黑树查找效率要比线性表查找效率高</li>
</ul>
<h4 id="指导意义-1"><a href="#指导意义-1" class="headerlink" title="指导意义"></a>指导意义</h4><ul>
<li>懒加载：</li>
<li>红黑树比线性查找牛多了，红黑树简直和哈希表(拉链法)天生一对</li>
<li>位运算指导意义：n % mod == n &amp;(mod -1)</li>
</ul>
<h3 id="回顾HashSet"><a href="#回顾HashSet" class="headerlink" title="回顾HashSet"></a>回顾HashSet</h3><ul>
<li>HashSet(LinkedHahsSet)的整个体系都是基于HashMap实现的</li>
<li>HashSet在进行put(E e)操作时实际把想<strong>存储的数据作为Key存储到了HashMap中</strong></li>
<li>value总统一指向一个Object静态常量，避免空指针</li>
</ul>
<hr>
<ul>
<li><strong>put</strong>(E e)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>PRESENT常量</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><h4 id="API-13"><a href="#API-13" class="headerlink" title="API"></a>API</h4><ul>
<li><strong>仅对HashMap进行了继承操作</strong>，本身并<strong>没有声明新的方法或重写</strong>。因此<strong>等价于Map的API</strong>。</li>
</ul>
<h4 id="源码分析-5"><a href="#源码分析-5" class="headerlink" title="源码分析"></a>源码分析</h4><p>只分析JDK1.8版本</p>
<ul>
<li>LinkedHashMap完全基于父类实现，只对在HashMap中的某些方法对应需要增加、删除、修改双向链表操作时候进行方法的重写操作<ul>
<li>如putVal方法，重写了newNode()方法，使用LinkedHashMap.Entry(继承与HashMap.Node)进行存储。</li>
</ul>
</li>
</ul>
<h5 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h5><ul>
<li>在<strong>继承</strong>与HashMap.Node结构的基础上，<strong>增加了before和after的双向索引</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>因此在遍历的过程中<strong>可以按添加的顺序遍历</strong>(有双向链表追踪)，而不是直接按遍历散列表进行遍历</li>
</ul>
<h2 id="Hashtale"><a href="#Hashtale" class="headerlink" title="Hashtale"></a>Hashtale</h2><ul>
<li>已弃用，忽略</li>
</ul>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><ul>
<li>Properties是Hashtable的<strong>子类</strong>，<strong>常用于处理属性</strong>(配置)<strong>文件</strong></li>
<li>Properties的key和value都是<strong>String</strong>类型</li>
</ul>
<h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ol>
<li><p><strong>创建.properties后缀文件</strong>(为方便演示，IDEA可在Project(根路径)右键新建，非Model)</p>
<ul>
<li>一行一条数据，以键值对方式存储(默认均字符串格式)，</li>
<li>等号”=”连接key和value，且<strong>等号两旁不能有空格</strong></li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">username</span>=<span class="string">admin</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">12345</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建Properties对象</strong></p>
</li>
<li><p><strong>获取配置文件的输入流对象</strong></p>
</li>
<li><p>调用Properties对象的<strong>load方法</strong>进行输入流的加载</p>
</li>
<li><p>调用Properties对象的<strong>setProperty</strong>(String key,String value)方法和 <strong>getProperty</strong>(String key)方法，存取数据时</p>
</li>
</ol>
<p><strong>注</strong>：若出现中文乱码请在IDE中设置.properties创建和编码使用UTF-8编码，且需删除原有文件重新新建。</p>
<h4 id="示例代码-6"><a href="#示例代码-6" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-12 11:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">            properties.load(fis);</span><br><span class="line">            String username = properties.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">            String password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;username = &quot;</span> + username);<span class="comment">//username = admin</span></span><br><span class="line">            System.out.println(<span class="string">&quot;password = &quot;</span> + password);<span class="comment">//password = 12345</span></span><br><span class="line"></span><br><span class="line">            properties.setProperty(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;abcde&quot;</span>);</span><br><span class="line">            System.out.println(properties.getProperty(<span class="string">&quot;password&quot;</span>));<span class="comment">//abcde</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fis != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><ul>
<li>TreeMap有别于HashMap与Hashtable，除了间接实现Map接口还实现了，SortedMap接口</li>
<li>向TreeMap添加key-value数据，要求<strong>key必须是同一个类型的数据</strong>(用泛型可以保证)</li>
<li>TreeMap的排序是<strong>只对key进行自然排序、定制排序</strong></li>
<li>操作与TreeSet一致，详情可查看”TreeSet”操作</li>
</ul>
<h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><ul>
<li>Collections 是一个操作 <strong>Set、List 和 Map</strong> 等集合的<strong>工具类</strong></li>
<li>Collections 中提供了一系列静态的方法对集合元素进行<strong>排序、查询和修改</strong>等操作， 还提供了对<strong>集合对象设置不可变</strong>、对<strong>集合对象实现同步控制</strong>等方法。</li>
</ul>
<h2 id="排序API"><a href="#排序API" class="headerlink" title="排序API"></a>排序API</h2><table>
<thead>
<tr>
<th>Static Method</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody><tr>
<td><strong>reverse</strong>(List&lt;?&gt; list)</td>
<td>反转List 中元素的顺序</td>
</tr>
<tr>
<td><strong>shuffle</strong>(List&lt;?&gt; list)</td>
<td>对 List 集合元素进行<strong>随机排序</strong></td>
</tr>
<tr>
<td><strong>sort</strong>(List&lt;?&gt; list)</td>
<td>根据元素的<strong>自然排序</strong>对指定 List 集合元素按<strong>升序排序</strong></td>
</tr>
<tr>
<td><strong>sort</strong>(List&lt;?&gt; list，Comparator&lt;? super T&gt; c)</td>
<td>根据指定的Comparator顺序对 List 集合元素进行排序</td>
</tr>
<tr>
<td>…….</td>
<td></td>
</tr>
</tbody></table>
<h2 id="查找、替换API"><a href="#查找、替换API" class="headerlink" title="查找、替换API"></a>查找、替换API</h2><table>
<thead>
<tr>
<th>Static Method</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>Object <strong>max</strong>(Collection)</td>
<td>根据元素的自然排序，返回给定集合中的最大元素</td>
</tr>
<tr>
<td>Object <strong>max</strong>(Collection，Comparator)</td>
<td>根据 Comparator 指定的顺序，返回 给定集合中的最大元素</td>
</tr>
<tr>
<td>Object <strong>min</strong>(Collection)</td>
<td>同理max</td>
</tr>
<tr>
<td>Object <strong>min</strong>(Collection，Comparator)</td>
<td>同理max</td>
</tr>
<tr>
<td>int <strong>frequency</strong>(Collection，Object)</td>
<td>返回指定集合中指定<strong>元素的出现次数</strong></td>
</tr>
<tr>
<td>void <strong>copy</strong>(List dest,List src)</td>
<td>将src中的内容复制到dest中</td>
</tr>
<tr>
<td>boolean <strong>replaceAll</strong>(List list，Object oldVal，Object newVal)</td>
<td>使用新值替换 List 对象的所有旧值</td>
</tr>
<tr>
<td><strong>swap</strong>(List&lt;?&gt; list，int， int)</td>
<td>将指定 list 集合中的 i 处元素和 j 处元素进行交换</td>
</tr>
<tr>
<td>…….</td>
<td></td>
</tr>
</tbody></table>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p><strong>copy</strong>(List dest,List src)</p>
<ul>
<li>调用copy方法易错，copy内部代码要先保证<code>dest.size &gt; src.size</code>否则就会<strong>抛出异常</strong></li>
<li>因此不能直接新建一个空的List作为dest，而是要建一个有src.size长度的dest</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> srcSize = src.size();</span><br><span class="line">    <span class="keyword">if</span> (srcSize &gt; dest.size())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Source does not fit in dest&quot;</span>);</span><br><span class="line">    <span class="comment">//....省略代码..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例代码-7"><a href="#示例代码-7" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-13 20:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="string">&quot;sbccd&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;23&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;adfa&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//正确写法</span></span><br><span class="line">        List&lt;String&gt; dest = Arrays.asList(<span class="keyword">new</span> String[arrayList.size()]);</span><br><span class="line">        Collections.copy(dest,arrayList);</span><br><span class="line">        System.out.println(<span class="string">&quot;dest = &quot;</span> + dest);<span class="comment">//dest = [sbccd, 23, adfa]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//错误写法</span></span><br><span class="line">        <span class="comment">//List&lt;String&gt; dest = new ArrayList&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//java.lang.IndexOutOfBoundsException: Source does not fit in dest</span></span><br><span class="line">        <span class="comment">//Collections.copy(dest,arrayList);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同步控制API"><a href="#同步控制API" class="headerlink" title="同步控制API"></a>同步控制API</h2><ul>
<li>Collections 类中提供了多个 <strong>synchronizedXxx</strong>() 方法</li>
<li>该方法可使<strong>将指定集合对象包装成线程同步的集合对象</strong></li>
<li>从而可以解决多线程并发访问集合时的线程安全问题</li>
</ul>
<table>
<thead>
<tr>
<th>Static Method</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody><tr>
<td><strong>synchronizedCollection</strong>(Collection&lt;T&gt; c)</td>
<td>返回由指定Collection支持的同步（线程安全）集合</td>
</tr>
<tr>
<td><strong>synchronizedList</strong>(List&lt;T&gt; list)</td>
<td>返回由指定List支持的同步（线程安全）列表。</td>
</tr>
<tr>
<td><strong>synchronizedMap</strong>(Map&lt;K,V&gt; m)</td>
<td>返回由指定Map支持的同步（线程安全）映射。</td>
</tr>
<tr>
<td><strong>synchronizedSet</strong>(Set&lt;T&gt; s)</td>
<td>返回由指定Set支持的同步（线程安全）集</td>
</tr>
<tr>
<td><strong>synchronizedSortedMap</strong>(SortedMap&lt;K,V&gt; m)</td>
<td>返回由指定的SortedMap支持的同步（线程安全）SortedMap</td>
</tr>
<tr>
<td><strong>synchronizedSortedSet</strong>(SortedSet&lt;T&gt; s)</td>
<td>返回由指定的SortedSet支持的同步（线程安全）SortedSet</td>
</tr>
<tr>
<td>……</td>
<td></td>
</tr>
</tbody></table>
<h1 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h1><h2 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h2><ul>
<li><strong>Collection</strong>：”集合“，<strong>单列数据</strong><ul>
<li><strong>List</strong>：“<strong>线性表</strong>”，指<strong>有序、可重复</strong></li>
<li><strong>Set</strong>子接口：译为“<strong>集合</strong>”，指<strong>无序、不可重复</strong></li>
</ul>
</li>
<li><strong>Map</strong>：”映射“，<strong>双列数据</strong>，<strong>无序，key不可重复，value可重复</strong></li>
</ul>
<h2 id="比较标准"><a href="#比较标准" class="headerlink" title="比较标准"></a>比较标准</h2><ul>
<li><strong>Collection</strong><ul>
<li><strong>List</strong>：重写equals方(ArrayList、LinkedList、Vector)</li>
<li><strong>Set</strong>：<ul>
<li><strong>HashSet</strong>(子类<strong>LinkedHashSet</strong>，基于Map实现)：重写hashCode()与equals()方法</li>
<li><strong>TreeSet</strong>：实现自然排序或定制排序接口</li>
</ul>
</li>
</ul>
</li>
<li><strong>Map</strong><ul>
<li><strong>HashMap</strong>(子类<strong>LinkedHashMap</strong>)、<strong>Hashtable</strong>(子类<strong>Properties</strong>)：重写hashCode()与equals()方法</li>
<li><strong>TreeMap</strong>：实现自然排序或定制排序接口</li>
</ul>
</li>
</ul>
<h2 id="实现类比较-3"><a href="#实现类比较-3" class="headerlink" title="实现类比较"></a>实现类比较</h2><h3 id="List-2"><a href="#List-2" class="headerlink" title="List"></a>List</h3><table>
<thead>
<tr>
<th align="left">指标\实现类</th>
<th>ArrayList</th>
<th>LinkedList</th>
<th>TreeSet</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>背景</strong></td>
<td><em>JDK 1.2</em>，List<strong>主要实现类</strong></td>
<td><em>JDK 1.2</em></td>
<td><em>JDK 1.0</em> ，<strong>已弃用实现类</strong></td>
</tr>
<tr>
<td align="left"><strong>底层实现</strong></td>
<td>Object数组</td>
<td>双向链表</td>
<td>Object数组</td>
</tr>
<tr>
<td align="left"><strong>线程安全</strong></td>
<td>线程不安全</td>
<td>线程不安全</td>
<td>线程安全</td>
</tr>
<tr>
<td align="left"><strong>效率</strong></td>
<td>高</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td>多数存储与查询操作</td>
<td>频繁修改操作</td>
<td>线程安全</td>
</tr>
</tbody></table>
<h3 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h3><table>
<thead>
<tr>
<th align="left">指标\实现类</th>
<th>HashSet</th>
<th>LinkedHashSet</th>
<th>TreeSet</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>背景</strong></td>
<td>Set<strong>主要实现类</strong></td>
<td>HashSet<strong>子类</strong></td>
<td>实现SortedMap</td>
</tr>
<tr>
<td align="left"><strong>底层实现</strong></td>
<td>哈希表(哈希地址+数组)</td>
<td>带双向索引的哈希表</td>
<td>红黑树</td>
</tr>
<tr>
<td align="left"><strong>线程安全</strong></td>
<td>线程不安全</td>
<td>线程不安全</td>
<td>线程安全</td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td>一般场景</td>
<td>频繁的遍历操作</td>
<td>支持自动排序</td>
</tr>
<tr>
<td align="left"><strong>元素类型</strong></td>
<td>无限制(存储null值)</td>
<td>无限制</td>
<td><strong>仅同一类型</strong></td>
</tr>
</tbody></table>
<h3 id="Map-2"><a href="#Map-2" class="headerlink" title="Map"></a>Map</h3><table>
<thead>
<tr>
<th align="left">指标\实现类</th>
<th>HashMap</th>
<th>LinkedHashMap</th>
<th>TreeMap</th>
<th>Hahstable</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>背景</strong></td>
<td>Map<strong>主要实现类</strong></td>
<td>HashMap子类</td>
<td>实现SortedMap</td>
<td><strong>已弃用</strong></td>
</tr>
<tr>
<td align="left"><strong>底层实现</strong></td>
<td>jdk7-哈希表(拉链法)<br>jdk8-哈希表 + 红黑树</td>
<td>带双向索引的哈希表<br>(同理jdk7，8不一样)</td>
<td><strong>红黑树</strong></td>
<td>哈希表</td>
</tr>
<tr>
<td align="left"><strong>线程安全</strong></td>
<td>线程不安全</td>
<td>线程不安全</td>
<td>线程不安全</td>
<td><strong>线程安全</strong></td>
</tr>
<tr>
<td align="left"><strong>效率</strong></td>
<td>高</td>
<td>高</td>
<td>高</td>
<td><strong>低</strong></td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td>一般场景</td>
<td><strong>频繁遍历操作</strong></td>
<td><strong>支持排序</strong>(key)</td>
<td>线程安全</td>
</tr>
<tr>
<td align="left"><strong>元素类型</strong></td>
<td><strong>可存储null值</strong>(key与value)</td>
<td>无限制</td>
<td><strong>同一类型</strong></td>
<td>不可存储null值</td>
</tr>
</tbody></table>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：Java集合</li>
        <li>Post author：yhd</li>
        <li>Create time：2021-06-13 22:03:12</li>
        <li>
            Post link：https://keep.xpoet.cn/2021/06/13/Java集合/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/06/17/Java%E7%9A%84File%E7%B1%BB%E5%8F%8AIO%E7%B3%BB%E7%BB%9F/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Java的File类及IO系统</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/06/10/Java%E6%9E%9A%E4%B8%BE,%E6%B3%A8%E8%A7%A3%E5%8F%8A%E6%B3%9B%E5%9E%8B/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Java枚举,注解及泛型</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">yhd</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.1</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">集合框架概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">1.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%BD%93%E7%B3%BB"><span class="nav-number">1.2.</span> <span class="nav-text">概念体系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection"><span class="nav-number">1.2.1.</span> <span class="nav-text">Collection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-number">1.2.2.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="nav-number">1.2.3.</span> <span class="nav-text">概念示意图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#API%E4%BD%93%E7%B3%BB"><span class="nav-number">1.3.</span> <span class="nav-text">API体系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Collection-1"><span class="nav-number">2.</span> <span class="nav-text">Collection</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AbstractMethods"><span class="nav-number">2.1.</span> <span class="nav-text">AbstractMethods</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#contain-amp-remove"><span class="nav-number">2.1.1.</span> <span class="nav-text">contain&amp;remove</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">示例代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#equals"><span class="nav-number">2.1.2.</span> <span class="nav-text">equals</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DefaultMethods"><span class="nav-number">2.2.</span> <span class="nav-text">DefaultMethods</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#API"><span class="nav-number">2.2.1.</span> <span class="nav-text">API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Iterator"><span class="nav-number">2.3.</span> <span class="nav-text">Iterator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">2.3.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#API-1"><span class="nav-number">2.3.2.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86"><span class="nav-number">2.3.3.</span> <span class="nav-text">迭代器遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">错误示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF"><span class="nav-number">2.3.4.</span> <span class="nav-text">增强for循环</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-2"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">示例代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove"><span class="nav-number">2.3.5.</span> <span class="nav-text">remove</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Iterable"><span class="nav-number">2.4.</span> <span class="nav-text">Iterable</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#API-2"><span class="nav-number">2.4.1.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forEach%E9%81%8D%E5%8E%86"><span class="nav-number">2.4.2.</span> <span class="nav-text">forEach遍历</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#List"><span class="nav-number">3.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">3.1.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.2.</span> <span class="nav-text">实现类概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">继承体系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%AF%94%E8%BE%83"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">实现类比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#API-3"><span class="nav-number">3.2.</span> <span class="nav-text">API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.1.</span> <span class="nav-text">体系结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#API%E6%96%87%E6%A1%A3"><span class="nav-number">3.2.2.</span> <span class="nav-text">API文档</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#remove-1"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">remove</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList"><span class="nav-number">3.3.</span> <span class="nav-text">ArrayList</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#API-4"><span class="nav-number">3.3.1.</span> <span class="nav-text">API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">新增</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99default%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">重写default方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">3.3.1.2.1.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#List-1"><span class="nav-number">3.3.1.2.2.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Collection-2"><span class="nav-number">3.3.1.2.3.</span> <span class="nav-text">Collection</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK7%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">3.3.2.</span> <span class="nav-text">JDK7源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">构造器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ArrayList-1"><span class="nav-number">3.3.2.2.1.</span> <span class="nav-text">ArrayList();</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ArrayList-int-initialCapacity"><span class="nav-number">3.3.2.2.2.</span> <span class="nav-text">ArrayList(int initialCapacity)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#add-E-e"><span class="nav-number">3.3.2.3.1.</span> <span class="nav-text">add(E e)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ensureCapacityInternal-int-minCapacity"><span class="nav-number">3.3.2.3.2.</span> <span class="nav-text">ensureCapacityInternal(int minCapacity)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#grow-int-minCapacity"><span class="nav-number">3.3.2.3.3.</span> <span class="nav-text">grow(int minCapacity)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hugeCapacity-int-minCapacity"><span class="nav-number">3.3.2.3.4.</span> <span class="nav-text">hugeCapacity(int minCapacity)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">3.3.3.</span> <span class="nav-text">JDK8源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7-1"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-1"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">构造器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ArrayList-2"><span class="nav-number">3.3.3.2.1.</span> <span class="nav-text">ArrayList()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-1"><span class="nav-number">3.3.3.3.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#add-E-e-1"><span class="nav-number">3.3.3.3.1.</span> <span class="nav-text">add(E e)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ensureCapacityInternal-int-minCapacity-1"><span class="nav-number">3.3.3.3.2.</span> <span class="nav-text">ensureCapacityInternal(int minCapacity)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#grow-int-minCapacity-1"><span class="nav-number">3.3.3.3.3.</span> <span class="nav-text">grow(int minCapacity)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%B0%8F%E7%BB%93"><span class="nav-number">3.3.4.</span> <span class="nav-text">源码分析小结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%AF%B9%E6%AF%94"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">源码对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%AF%BC%E6%84%8F%E4%B9%89"><span class="nav-number">3.3.4.2.</span> <span class="nav-text">指导意义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedList"><span class="nav-number">3.4.</span> <span class="nav-text">LinkedList</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#API-5"><span class="nav-number">3.4.1.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">3.4.2.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7-2"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Node"><span class="nav-number">3.4.2.1.1.</span> <span class="nav-text">Node</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-2"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">构造器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LinkedList-1"><span class="nav-number">3.4.2.2.1.</span> <span class="nav-text">LinkedList()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-2"><span class="nav-number">3.4.2.3.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#add-E-e-2"><span class="nav-number">3.4.2.3.1.</span> <span class="nav-text">add(E e)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#linkLast-E-e"><span class="nav-number">3.4.2.3.2.</span> <span class="nav-text">linkLast(E e)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vector"><span class="nav-number">3.5.</span> <span class="nav-text">Vector</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#API-6"><span class="nav-number">3.5.1.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="nav-number">3.5.2.</span> <span class="nav-text">源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stack"><span class="nav-number">3.5.3.</span> <span class="nav-text">Stack</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91"><span class="nav-number">3.6.</span> <span class="nav-text">实际开发</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Set"><span class="nav-number">4.</span> <span class="nav-text">Set</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="nav-number">4.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="nav-number">4.1.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90"><span class="nav-number">4.1.2.</span> <span class="nav-text">特性解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">不可重复性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-1"><span class="nav-number">4.1.2.1.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%BE%9D%E6%8D%AE"><span class="nav-number">4.1.2.1.2.</span> <span class="nav-text">判断依据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-3"><span class="nav-number">4.1.2.1.3.</span> <span class="nav-text">示例代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E5%BA%8F%E6%80%A7"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">无序性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashCode%E9%87%8D%E5%86%99"><span class="nav-number">4.1.2.3.</span> <span class="nav-text">hashCode重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">4.1.2.4.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%A6%82%E8%BF%B0-1"><span class="nav-number">4.1.3.</span> <span class="nav-text">实现类概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#API%E4%BD%93%E7%B3%BB-1"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">API体系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%AF%94%E8%BE%83-1"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">实现类比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#API-7"><span class="nav-number">4.2.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashSet"><span class="nav-number">4.3.</span> <span class="nav-text">HashSet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#API-8"><span class="nav-number">4.3.1.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2"><span class="nav-number">4.3.2.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-2"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedHashSet"><span class="nav-number">4.4.</span> <span class="nav-text">LinkedHashSet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#API-9"><span class="nav-number">4.4.1.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-3"><span class="nav-number">4.4.2.</span> <span class="nav-text">源码分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TreeSet"><span class="nav-number">4.5.</span> <span class="nav-text">TreeSet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E6%8E%92%E5%BA%8F"><span class="nav-number">4.5.1.</span> <span class="nav-text">自动排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">4.5.1.1.</span> <span class="nav-text">自然排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-4"><span class="nav-number">4.5.1.1.1.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7%E5%88%A4%E6%96%AD"><span class="nav-number">4.5.1.1.2.</span> <span class="nav-text">不可重复性判断</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">4.5.1.2.</span> <span class="nav-text">定制排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-5"><span class="nav-number">4.5.1.2.1.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7%E5%88%A4%E6%96%AD-1"><span class="nav-number">4.5.1.2.2.</span> <span class="nav-text">不可重复性判断</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#API-10"><span class="nav-number">4.5.2.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4"><span class="nav-number">4.5.3.</span> <span class="nav-text">源码分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Map-1"><span class="nav-number">5.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="nav-number">5.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="nav-number">5.1.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%A6%82%E8%BF%B0-2"><span class="nav-number">5.1.2.</span> <span class="nav-text">实现类概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#API%E4%BD%93%E7%B3%BB-2"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">API体系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%AF%94%E8%BE%83-2"><span class="nav-number">5.1.2.2.</span> <span class="nav-text">实现类比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#API-11"><span class="nav-number">5.2.</span> <span class="nav-text">API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E5%88%A0%E6%94%B9"><span class="nav-number">5.2.1.</span> <span class="nav-text">增删改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.2.2.</span> <span class="nav-text">元素查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E8%A7%86%E5%9B%BE%E6%93%8D%E4%BD%9C"><span class="nav-number">5.2.3.</span> <span class="nav-text">元视图操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86"><span class="nav-number">5.2.4.</span> <span class="nav-text">遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86key"><span class="nav-number">5.2.4.1.</span> <span class="nav-text">遍历key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86value"><span class="nav-number">5.2.4.2.</span> <span class="nav-text">遍历value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86Entry"><span class="nav-number">5.2.4.3.</span> <span class="nav-text">遍历Entry</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86"><span class="nav-number">5.3.</span> <span class="nav-text">Map存储原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E5%85%83%E7%BB%84"><span class="nav-number">5.3.1.</span> <span class="nav-text">四元组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#key-value%E7%89%B9%E6%80%A7"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">key-value特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Entry%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="nav-number">5.3.1.2.</span> <span class="nav-text">Entry源代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK1-8%E7%89%88%E6%9C%AC"><span class="nav-number">5.3.2.</span> <span class="nav-text">JDK1.8版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B"><span class="nav-number">5.3.3.</span> <span class="nav-text">HashMap查找过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-3"><span class="nav-number">5.3.3.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B"><span class="nav-number">5.3.3.2.</span> <span class="nav-text">查找过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7-1"><span class="nav-number">5.3.4.</span> <span class="nav-text">不可重复性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap"><span class="nav-number">5.4.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#API-12"><span class="nav-number">5.4.1.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9%E6%8C%87%E6%A0%87"><span class="nav-number">5.4.2.</span> <span class="nav-text">扩容指标</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90"><span class="nav-number">5.4.2.1.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA-1"><span class="nav-number">5.4.2.2.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%B1%9E%E6%80%A7"><span class="nav-number">5.4.3.</span> <span class="nav-text">重要常量与属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%B8%B8%E9%87%8F"><span class="nav-number">5.4.3.1.</span> <span class="nav-text">全局常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7"><span class="nav-number">5.4.3.2.</span> <span class="nav-text">重要属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90"><span class="nav-number">5.4.3.3.</span> <span class="nav-text">加载因子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK7%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="nav-number">5.4.4.</span> <span class="nav-text">JDK7源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-3"><span class="nav-number">5.4.4.1.</span> <span class="nav-text">构造器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap-1"><span class="nav-number">5.4.4.1.1.</span> <span class="nav-text">HashMap()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap-int-initialCapacity-float-loadFactor"><span class="nav-number">5.4.4.1.2.</span> <span class="nav-text">HashMap(int initialCapacity, float loadFactor)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-3"><span class="nav-number">5.4.4.2.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#put-K-key-V-value"><span class="nav-number">5.4.4.2.1.</span> <span class="nav-text">put(K key, V value)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#addEntry-int-hash-K-key-V-value-int-bucketIndex"><span class="nav-number">5.4.4.2.2.</span> <span class="nav-text">addEntry(int hash, K key, V value, int bucketIndex)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#createEntry-int-hash-K-key-V-value-int-bucketIndex"><span class="nav-number">5.4.4.2.3.</span> <span class="nav-text">createEntry(int hash, K key, V value, int bucketIndex)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="nav-number">5.4.5.</span> <span class="nav-text">JDK8源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-4"><span class="nav-number">5.4.5.1.</span> <span class="nav-text">构造器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap-2"><span class="nav-number">5.4.5.1.1.</span> <span class="nav-text">HashMap</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-4"><span class="nav-number">5.4.5.2.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#put-K-key-V-value-1"><span class="nav-number">5.4.5.2.1.</span> <span class="nav-text">put(K key, V value)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict"><span class="nav-number">5.4.5.2.2.</span> <span class="nav-text">putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Node-lt-K-V-gt-resize"><span class="nav-number">5.4.5.2.3.</span> <span class="nav-text">Node&lt;K,V&gt;[] resize()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#treeifyBin-Node-lt-K-V-gt-tab-int-hash"><span class="nav-number">5.4.5.2.4.</span> <span class="nav-text">treeifyBin(Node&lt;K,V&gt;[] tab, int hash)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%B0%8F%E7%BB%93-1"><span class="nav-number">5.4.6.</span> <span class="nav-text">源码分析小结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%AF%B9%E6%AF%94-1"><span class="nav-number">5.4.6.1.</span> <span class="nav-text">源码对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%AF%BC%E6%84%8F%E4%B9%89-1"><span class="nav-number">5.4.6.2.</span> <span class="nav-text">指导意义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E9%A1%BEHashSet"><span class="nav-number">5.4.7.</span> <span class="nav-text">回顾HashSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashMap"><span class="nav-number">5.4.8.</span> <span class="nav-text">LinkedHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#API-13"><span class="nav-number">5.4.8.1.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-5"><span class="nav-number">5.4.8.2.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Entry"><span class="nav-number">5.4.8.2.1.</span> <span class="nav-text">Entry</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hashtale"><span class="nav-number">5.5.</span> <span class="nav-text">Hashtale</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Properties"><span class="nav-number">5.5.1.</span> <span class="nav-text">Properties</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="nav-number">5.5.1.1.</span> <span class="nav-text">使用步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-6"><span class="nav-number">5.5.1.2.</span> <span class="nav-text">示例代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TreeMap"><span class="nav-number">5.6.</span> <span class="nav-text">TreeMap</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Collections"><span class="nav-number">6.</span> <span class="nav-text">Collections</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8FAPI"><span class="nav-number">6.1.</span> <span class="nav-text">排序API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E3%80%81%E6%9B%BF%E6%8D%A2API"><span class="nav-number">6.2.</span> <span class="nav-text">查找、替换API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#copy"><span class="nav-number">6.2.1.</span> <span class="nav-text">copy</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-7"><span class="nav-number">6.2.1.1.</span> <span class="nav-text">示例代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6API"><span class="nav-number">6.3.</span> <span class="nav-text">同步控制API</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="nav-number">7.</span> <span class="nav-text">小结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="nav-number">7.1.</span> <span class="nav-text">基本特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E6%A0%87%E5%87%86"><span class="nav-number">7.2.</span> <span class="nav-text">比较标准</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%AF%94%E8%BE%83-3"><span class="nav-number">7.3.</span> <span class="nav-text">实现类比较</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#List-2"><span class="nav-number">7.3.1.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set-1"><span class="nav-number">7.3.2.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map-2"><span class="nav-number">7.3.3.</span> <span class="nav-text">Map</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        $icon-size = 1.2rem;

.search-pop-overlay {
  position: fixed;
  display: flex;
  height: 100%;
  width: 100%;
  left: 0;
  top: 0;
  background: rgba(0, 0, 0, 0);
  visibility: hidden;
  z-index: $z-index-8;
  transition-t("visibility, background", "0, 0", "0.3, 0.3", "ease, ease");

  &.active {
    visibility: visible;
    background: rgba(0, 0, 0, 0.35);

    .search-popup {
      transform: scale(1);
    }

  }


  .search-popup {
    background: var(--background-color);
    border-radius: 5px;
    height: 80%;
    width: 70%;
    margin: auto;
    transform: scale(0);
    z-index: $z-index-6;
    transition-t("transform", "0", "0.3", "ease");

    +keep-tablet() {
      width: 80%;
    }

    +keep-mobile() {
      width: 90%;
    }

    .search-header {
      background: var(--fourth-text-color);
      border-top-left-radius: 2px;
      border-top-right-radius: 2px;
      display: flex;
      padding: 10px;

      .search-input-field-pre, .popup-btn-close {
        font-size: $icon-size;
        padding: 0 10px;
        display: flex;
        align-items: center;
      }

      .search-input-field-pre {
        cursor: pointer;
        color: var(--third-text-color);
      }

      .popup-btn-close {
        color: var(--default-text-color);
      }


      .search-input-container {

        flex-grow: 1;
        padding: 2px;

        .search-input {
          background: transparent;
          border: 0;
          outline: 0;
          width: 100%;
          font-size: 1.2rem;
          color: var(--default-text-color);

          &::-webkit-search-cancel-button {
            display: none;
          }
        }


      }


      .popup-btn-close {
        cursor: pointer;

        &:hover .fas, far, fab {
          color: var(--first-text-color);
        }
      }

    }


    #search-result {
      display: flex;
      height: calc(100% - 55px);
      overflow: auto;
      padding: 5px 25px;

      .search-result-list {
        width: 100%;
        height: 100%;
        font-size: 1rem;

        li {
          border-bottom: 1px dashed var(--border-color);
          padding: 10px 0;
          margin: 10px 0;
          box-sizing: border-box;

          &:last-child {
            border-bottom: none;
          }


          .search-result-title {
            position: relative;
            font-weight: bold;
            margin-bottom: 10px;
            padding-left: 16px;
            display: flex;
            align-items: center;

            &::after {
              content: '';
              position: absolute;
              width: 5px;
              height: 5px;
              border-radius: 50%;
              top: 50%;
              transform: translateY(-50%);
              left: 0;
              background: var(--default-text-color);
            }
          }


          .search-result {
            line-height: 2rem;
            margin: 0;
            padding-left: 16px;
            word-wrap: break-word;
          }

          a {
            &:hover {
              color: var(--default-text-color);
            }
          }

          .search-keyword {
            border-bottom: 1px dashed var(--primary-color);
            color: var(--primary-color);
            font-weight: bold;
          }

        }
      }


      #no-result {
        color: var(--third-text-color);
        margin: auto;
      }

    }
  }
}


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>



<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
