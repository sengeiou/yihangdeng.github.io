{"meta":{"title":"yhdblog","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"Repositories","date":"2020-08-25T13:03:56.000Z","updated":"2020-08-25T13:08:55.059Z","comments":true,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-08-25T12:50:00.000Z","updated":"2020-08-25T13:04:12.688Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据库原理 第一章 绪论","slug":"数据库原理 第一章 绪论","date":"2020-10-28T11:57:32.000Z","updated":"2020-10-29T12:51:50.962Z","comments":true,"path":"2020/10/28/数据库原理 第一章 绪论/","link":"","permalink":"http://yoursite.com/2020/10/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%20%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/","excerpt":"","text":"绪论 数据库基本概念 数据（data）：描述事物的符号记录称为数据 数据库（DB，DataBase）：长期存储在计算机内、有组织的、可共享的大量数据的集合 数据库管理系统（DBMS，Data Base Management System）：用于科学高效地存取、维护数据的计算机基础软件，是一个大小复杂的软件系统(如操作系统般)。其最主要的功能如下： 数据定义功能（DDL，Data Definition Language）：如对库、表、字段等数据对象的定义(创建,修改,删除等) 数据操纵功能（DML，Data Manipulation Language）：对数据的增删改查等操作 数据库系统（DBS，DataBase System）：DB + DBMS(相关tool) + Program + DBA组成的存储、管理、处理和维护数据的系统 数据模型 两类数据模型：概念模型(信息模型)、逻辑模型与物理模型 概念模型：以用户角度对数据进行信息建模，不依赖于具体DBMS，是概念级的模型。其他相关概念如下： 实体(entity)：客观存在且相互区别的事物。如，一条具体的信息，类对象的一个实例 实体型(entity type)：用实体名及其属性名的集合来抽象同类实体。如，面向对象中的类 实体集(entity set)：同类型的实体的集合，如全体学生，一些对象的集合、表等 属性(attribute)：实体具有的某一特性。如，数据表中的字段/列 码(key)：唯一标识实体的属性集，(注意是属性集) 联系(relationship)：现实世界中，实体(型/集)与实体(型/集)之间的联系，一般有一对一，一对多，多对多的联系 联系的定义与判断：在A实体集内取1个实体，而这个实体能在B实体集内对应多个实体。则称为一对多，其他类型联系以此类推。 E - R模型：概念模型的最常用的表示方法为实体-联系方法(Entity-Relationship approach)，也称E-R模型，用E-R图描述。具体设计与实现在“概念结构设计篇”讲解 逻辑模型与物理模型：以计算机系统角度对数据的建模，由DBMS。常见逻辑模型如层次、网状、关系、面向对象等模型。 模型之间的关系 数据模型的组成要素：数据模型由数据结构(对象的组成与对象间的联系)、数据操作(增删改查)、数据完整性约束条件(确保数据的完整性)组成 数据库系统结构 基本概念 型（type）：某一类数据的结构与属性的说明。如类的定义 值（value）：值是型的具体赋值。如某一个类的实体对象(实例) 模式（schema）：是指数据库全体数据的逻辑结构和特征的描述，属于“型”的层次，相对稳定 实例（instance）：模式对应的一个具体值称为实例，相对变动 注意，这里“一个具体值”不是只有一个值，而是一个模式的值，即刻整个数据库的数据。 二级映像下的三级结构：由模式对外(应用程序)，对内(数据存储)分别进行了模式映像。从而产生了两个二级映像，即外模式与内模式。 三级结构：外模式，模式，内模式统称数据库三级模式的结构 模式：具体概念不再赘述，强调模式是所有用户的公共数据视图 外模式：又名子模式、用户模式。它是数据库用户(开发者与最终用户)能够看见与使用的局部数据的逻辑结构和特征的描述** 内模式：又称为存储模式，一个数据库只有一个内模式，是数据在数据库内部的组织方式的描述 模式映像的作用：外模式实现了逻辑独立性，内模式实现了物理独立性。从外到内保证模式的相对稳定 数据库系统组成​ 数据库系统由：硬件平台及数据库，软件，人员(数据库管理人员)(DBA，DataBase Administrator)组成。","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库原理 第五章 数据库完整性","slug":"数据库原理 第五章 数据库完整性","date":"2020-10-28T01:11:32.000Z","updated":"2020-10-28T11:51:48.932Z","comments":true,"path":"2020/10/28/数据库原理 第五章 数据库完整性/","link":"","permalink":"http://yoursite.com/2020/10/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/","excerpt":"","text":"数据库完整性 什么是数据库完整性 数据库完整性(integrity)：数据的正确性和相容性 维护数据库完整性功能组成 完整性约束机制：实体完整性、参照完整性、用户定义完整性等 完整性检查方法：一般在增删改查或事务操作前后进行 违约处理：not action(拒绝)，cascad(级联)，nullifies (置空) 实体完整性 定义：create table 中的 primary key定义(列级/表级) 1234create table Student( Sno char(9) /*primary key*/, /*列级定义*/ primary key(Sno) /*表级定义*/); 完整性检查 检查主码值是否唯一，若不唯一拒绝插入与更新 检查主码个属性是否为空，存在一个空，则同样拒绝操作 违约处理：对于主键冲突，违约系统默认一概NOT ACTION(拒绝)处理 参照完整性 定义：create table 中的 foreign key() references定义(表级) 完整性检查与违约处理 隐式处理(默认策略)：NOT ACTION(拒绝) 显示处理(自定义违约处理方式)： 应用场景：只有被参照表(外码表)才可显示定义违约处理策略，即只允许在 foreign key 授权语句后追加，不可写在其他地方，且仅限于update与delete操作 语句格式：[表级定义权限约束 &lt;空格&gt;] ON &lt;违约操作&gt; &lt;违约处理&gt; &lt;违约操作&gt;：且限于 update、delete &lt;违约处理&gt;：拒绝(NO ACTION)，级联(CASCADE)，置空(NULLIFIES) 级联操作：若删除的参照表的数据在其他表被引用，连同删除 12345create table Student( ... primary key(Sno,Cno), /*只允许在foreign key 后追加显示违约处理*/ foreign key(Sno) references Student(Sno) on delete cascade on update cascade); 用户定义的完整性 定义：用户可对具体列(字段)进行约束，一般分为两种 属性上的约束条件：可对单个列级属性进行约束 元组上的约束条件：可对多个列级属性进行约束，完整性约束限制类型同上 完整性约束：限制类型含，not null(非空)，unique(唯一)，check&lt;条件表达式&gt;) 1234567create table SC( Sno char(9) not null, Sname varchar(10) not null, Ssex char(2) check(Ssex IN(&#x27;男&#x27;,&#x27;女&#x27;)), Sgrade samllint check(Sgrade &gt;=0 AND Sgrade &lt;= 100), CHECK(Ssex = &#x27;女&#x27; OR Sname NOT LIKE &#x27;Ms.%&#x27;)/*同时约束多个列*/) 违约处理：系统统一采取**拒绝(NOT ACTION)**处理 完整性约束命名子句概念与子句的创建 前言：上述所有约束都是在create table时设置，若需要修改约束，难道只能重新建表？ 命名子句：在create table设置约束时为每个约束操作命名，后序修改或删除约束可通过操作这个命名 子句格式：constraint &lt;完整性约束条件名&gt;&lt;完整性约束条件&gt; &lt;完整性约束条件&gt;包含：primary key、foreign key，not null、unique、check 1234create table Student( Sno int constraint c1 check(Sno &gt;= 9000 AND Sno &lt;= 9999),/*列级操作*/ constraint StudentKey primary key(Sno) /*表级操作示例*/); 修改完整性限制 使用环境：在 alter table 语句下进行修改(add、drop) 语句格式：`&lt;add | drop&gt; constraint &lt;完整性约束子句名 | 完整性约束子句&gt; 1234567alter table Student drop constraint c1; /*删除Student表中名为c1的完整性约束*/ alter table Student /*在Student表中添加新的完整性约束子句*/ add constraint Sno_domain check(Sno &gt;= 9000 AND Sno &lt;= 9999); /*若想修改约束，则只能先删除约束再添加过新的约束*/ 触发器 定义：触发器(trigger)，由事件驱动的特殊过程(事件-&gt;条件-&gt;动作) 创建触发器：[ 事件(触发时机) -&gt; 条件(触发条件) -&gt; 动作(存储过程)] 12345create trigger &lt;触发器名&gt;&lt;before | after&gt; &lt;触发事件&gt; on &lt;表名&gt; /*定义触发的时机*/referencing &lt;new|old&gt; row as&lt;变量&gt; /*通过referencing引出变量*/for each&lt;row | statement&gt; /*指明动作体执行的频率*/[when &lt;触发条件&gt;]&lt;触发动作体&gt; 只有创建表的用户才能在此表上创建触发器，而且数量有限，具体数量由数据库管理系统本身设计所定 触发器名：必须唯一 表名：只能是基本表，不能是视图 触发事件： 触发时机：可在语句执行前before，或执行后after 操作类型：可以是增删改查，事务等操作，如insert，delete，update… 事件组合：可以单一事件，可组合，insert or delete，或指定列触发 update of &lt;触发列,…&gt; 触发器类型： 语句级触发器(for each statement)：执行完这条语句后且符合触发条件才会调用触发器(有可能这条语句已经操作了若干行数 据)，因此语句级触发器是不允许通过referencing引出变量new或者old row数据的 行级触发器(for each row)：相反，行级触发器，当检查到一行数据符合触发条件就会调用触发器。因为数据行是确定的，所 以可以通过referencing 引出变量new | row的数据 触发条件：触发条件的书写即&lt;条件表达式&gt;的书写 触发动作体：匿名PL/SQL过程块，也可以是存储过程 12/*当对表SC的Grade属性进行修改时，若分数增加了10%，则将此次操作记录到另一个表SC_U(Sno、Cno、Oldgrade、Newgrade)中，其中Oldgrade是修改前的分数，Newgrade是修改后的分数。*/create trigger SC_T 触发器的激活机制： 同一表上的多个触发器按，执行before触发器—&gt; 激活sql语句 —&gt; 执行after触发器流程触发 对于相同的触发器类型的触发器，遵循“谁先创建谁先执行原则”，有些DBMS按触发器名称字母排序。 删除触发器：drop trigger &lt;触发器名&gt; on &lt;表名&gt;","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"算法积累","slug":"算法积累","date":"2020-10-22T09:12:32.000Z","updated":"2020-10-22T08:16:50.344Z","comments":true,"path":"2020/10/22/算法积累/","link":"","permalink":"http://yoursite.com/2020/10/22/%E7%AE%97%E6%B3%95%E7%A7%AF%E7%B4%AF/","excerpt":"","text":"顺序表排序递增减序 冒泡排序 选择法 逆置 头尾交换 查找最值 暂存变量挨个比较 找子序列 BF算法思维：第二章线性表P67-8 KMP算法 删除删除所有指定数值O(n) 单数组就地过滤重塑：第二章线性表P66~P67(2,11) 题目： 123456789101112131415161718192021/*伪代码： 1.用k记录顺序表中不等于x的元素个数，即需要保存的元素个数， 2.边扫描L边统计k，并将不等于x的元素放在L.data[k]中，最后修改L的长度。 时间复杂度：O(n)，空间复杂度：O(1)函数说明： 功能：删除顺序表所有指定的数值 SeqList&lt;DataType&gt; *L : 顺序表指针变量 int x : 删除数值*/template&lt;typename DataType&gt;void deleteAll(SeqList&lt;DataType&gt; *L, int x) &#123; int i, k = 0; //k用于数组重组的下标变量(新下标) for (i = 0; i &lt; L-&gt;length; i++) &#123; if (L-&gt;data[i] != x) &#123; //非条件值，非过滤参与重组 L-&gt;data[k] = L-&gt;data[i]; k++; &#125; &#125; L-&gt;length = k;//修改顺序表长度&#125; 单链表排序逆置O(n) 头插法： 凡会在操作过程是失去(链接/追踪)，可以用变量追随暂存 1234567891011121314151617181920212223242526/*伪代码： 1. 设定两个工作指针(用于遍历指针、用于记录遍历指针下一个指针的指针) 2. 通过遍历指针遍历每一个指针，将遍历到指针通过头插法的形式重新生成链表实现逆序 3. 在 2. 操作执行头插法之前需要先记录以下即将取出用于插入结点的下一个结点，否则会失去连接 时间复杂度：O(n)，空间复杂度：O(1);函数说明 LinkList&lt;DataType&gt; *L : 单链表指针*/template&lt;typename DataType&gt;void reverseLinkList(LinkList&lt;DataType&gt; *L) &#123; Node&lt;DataType&gt; *p, *q; p = q = L-&gt;first-&gt;next; L-&gt;first-&gt;next = nullptr; while (p!= nullptr) &#123; q = p; p = p-&gt;next; q-&gt;next = L-&gt;first-&gt;next; L-&gt;first-&gt;next = q; &#125;&#125; 递增减输出并释放 重复使用“暂存变量挨个比较” 查找删除循环链表排序查找对称性判断 头尾同步相近判断，各自到达头节点结束 12345678910111213141516171819202122232425/* 伪代码： 1. 创建两个工作指针，head指向第一个结点，rear指向尾部结点 2. 头尾向中间靠拢判断是否相等 3. 两个指针都移置头结点表示允许结束(兼容奇偶数量对称判断) 函数说明： CDulLinkList&lt;DataType&gt; *L : 循环双链表指针*/template&lt;typename DataType&gt;bool isSymmetric(CDulLinkList&lt;DataType&gt; *L) &#123; DulNode&lt;DataType&gt; *head, *rear; head = L-&gt;first-&gt;next; rear = L-&gt;first-&gt;prior; while (head != L-&gt;first &amp;&amp; rear != L-&gt;first) &#123; if (head-&gt;data != rear-&gt;data) return false; head = head-&gt;next; rear = rear-&gt;prior; &#125; return true;&#125; 删除","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"SQL总结","slug":"SQL总结","date":"2020-10-22T08:21:32.000Z","updated":"2020-10-28T11:36:42.012Z","comments":true,"path":"2020/10/22/SQL总结/","link":"","permalink":"http://yoursite.com/2020/10/22/SQL%E6%80%BB%E7%BB%93/","excerpt":"","text":"数据库操作创建数据库 12create schema &lt;数据库名&gt; authorization &lt;用户名&gt; [内嵌定义];[内嵌定义] ：[&lt;表创建子句&gt;|&lt;视图创建子句&gt;|&lt;授权定义子句&gt;] 删除数据库 1drop schema &lt;数据库名&gt; &lt;cascade|restrict&gt; 数据表操作创建表 1234567create table &lt;表名&gt;(&lt;字段定义&gt;);&lt;字段定义&gt;：( &lt;列名&gt;&lt;数据类型&gt;[列级完整性约束] [, &lt;列名&gt;&lt;数据类型&gt;[列级完整性约束] ] … [, &lt;表级完整性约束&gt;] ) 修改表 12345678alter table&lt;表名&gt; [add[column] &lt;新列名&gt;&lt;数据类型&gt;[列级完整性约束] ] [add &lt;表级完整性约束&gt;] /*ADD **UNIQUE(Name)** */ [drop [column] &lt;列名&gt;[cascade|restrict] ] [drop constraint &lt;完整性约束**名**&gt;[cascade|restrict]] [alter column &lt;已存在列名&gt;&lt;新数据类型&gt;] 删除表 1drop table &lt;表名&gt;[restrict|cascade]; DQL语言12345select [all|distinct]&lt;目标列表达式&gt; [,&lt;目标列表达式&gt;]…from &lt;表/视图名&gt;[,&lt;表/视图名&gt;…][where &lt;条件表达式&gt;][group by &lt;列名1&gt; [having&lt;条件表达式&gt;]][order by &lt;列名2&gt; [asc|desc]]; &lt;目标列表达式&gt;：控制取某字段、字段别名、’常量列’、运算式、调用函数 调用函数：count(*)、sum、avg、max、min。均可选择count( [distinct | all] &lt;列名&gt;) &lt;条件表达式&gt;： =，&gt;，&lt;，&gt;=，&lt;=，!=，&lt;&gt;，!&gt;，!&lt; ; NOT + 上述比较运算符 范围：between and、not between and： &lt;字段名&gt;between &lt;值1&gt;and&lt;值2&gt;; 集合：in，not in ：&lt;字段名&gt; in (&lt;数据集合|子查询&gt;); 字符匹配：like、not like ：&lt;字段名&gt; like ‘&lt;匹配串&gt;’; [ESCAPE ‘&lt;换转义符字符&gt;’] 空值：is null、is not null ：&lt;字段名&gt;is null; 条件：and、or、not：&lt;条件表达式&gt; AND &lt;条件表达式&gt;; DL高级查询DQL高级查询：子查询、连接查询、集合查询 子查询(嵌套查询)12select…from…where &lt;字段&gt;&lt;子查询谓词&gt;(&lt;查询块&gt;)&lt;查询块&gt;：select…from…where &lt;子查询谓词&gt;：in、比较运算符、比较运算符+any/some,all、exists any，&lt;all等…，(any：某个值、all：所有值) exists：不返回任何数据，只产生逻辑真假“true/false” 连接查询 连接查询：等值、非等值、自连接、外连接(左外右外) 连接查询：from 多表 + 表名点取字段 + 别名设计 + 连接谓词 等值连接等值连接查询：连接条件/谓词使用 “=” 符号 12from &lt;表1&gt;[,表2]…where &lt;表1&gt;.&lt;字段&gt; = &lt;表2&gt;.&lt;字段&gt;… 非等值连接查询非等值连接查询：连接条件/谓词不是使用 “=” 符号 自身连接查询自身连接查询：同一个表设置不同的别名 123select&lt;别名1&gt;.&lt;字段1&gt;,&lt;别名2&gt;.&lt;字段2&gt;from&lt;表名1&gt;.&lt;别名1&gt;,&lt;表名2&gt;.&lt;别名2&gt;where &lt;别名1&gt;.&lt;字段2&gt;=&lt;别名2&gt;.&lt;字段1&gt; 外连接查询12from &lt;表1&gt; left outer join &lt;表2&gt; on(&lt;连接条件&gt;) /*左外(保留左表数据)*/from &lt;表1&gt; right outer join &lt;表2&gt; on(&lt;连接条件&gt;) /* 右外(保留右表数据) */ 集合查询12&lt;查询块集合1&gt; &lt;集合查询谓词&gt; &lt;查询块集合2&gt;&lt;集合查询谓词&gt;：交操作intersect，并操作union，差(集)操作except DML语言：​ 插入 1insert into&lt;表名&gt;[(&lt;属性列1[,属性列2]&gt;…)] values(&lt;常量1&gt;[,&lt;常量2&gt;…); 若不写字段，则必须按序写完value参数 插入多条语句values(),(),()… 允许空的字段，value值可用null占位 若填写了属性列表，则value部分必须一一对应(数量上，类型上)。且属性列表不一定按序，可自动识别字段名，但数据要和字段名对应。 子查询插入 1insert into &lt;表名&gt;[(&lt;属性列1[,属性列2]&gt;…)] &lt;子查询&gt; 通过子查询的形式不用写value，但子查询字段同样需要对应属性列信息 ​ 修改 12update &lt;表名&gt; set &lt;列名&gt; = &lt;表达式&gt;[,&lt;列名&gt; = &lt;表达式&gt;][where &lt;条件&gt;] ​ 删除 1delete from &lt;表名&gt; [where &lt;条件&gt;]; 视图123create view &lt;视图名&gt; [(&lt;列名&gt;[,&lt;列名&gt;]…)]as &lt;子查询&gt;[with check option] ​ # 数据库安全性 以下均为自主存储控制方法 授予权限1234grant &lt;权限/操作类型&gt;[,权限]...on &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]... /*一般为： Table &lt;表名&gt;*/to &lt;用户&gt;[,&lt;用户&gt;]... /*注意：授予权限给用户前需存在这个用户(新建或原本存在)*/[with grant option] example： 1234/*把查询Student表的权限授给用户U1*/grant SELECTon TABLE Studentto U1; &lt;权限/操作类型&gt;：即为用户授予哪些操作 可控制操作权限类型 具体语句 数据库 create schema 数据表 create table，alter table 视图 create view 索引 create index 基本表和视图 select，insert，update，delete，references，all privileges(所有权限) 属性列 select，insert，update，references，all privileges &lt;对象类型&gt; &lt;对象名&gt;：一般最大是表级限制。即 Table &lt;表名&gt; &lt;用户&gt;：若不存在指定用户需要先建立用户才能进行对应的授权操作，sql server2008 R2 环境下创建新用户步骤如下： 创建指定数据库的用户需要与这个用户的登录用户绑定：即想建立用户，必须先建立这个用户对应的登录用户 创建新登录用户 打开sql server，连接数据库后。找到根目录下的“安全性”文件夹。 选中“登录名”文件夹并右键点击“新建登录名” 设置登录名，并选择“sql server 身份验证”，设置密码(自己记住)。 最后把“强制密码过期(x)**”的勾选去除**，最后点击右下加确认按钮保存即可 创建用户 进入到需创建用户的数据库文件夹内，找到指定数据库目录下的“安全性”文件夹 此时在选中“安全性”文件夹后右键——&gt;新建——&gt;用户(U) 输入用户名，可自定义(但一般与对应的登录用户名一致) 点击在“登录名”输入栏最右边的“**[…]”按钮，展开后右边点击“浏览”，勾选刚刚建立的新登录用户名**，最后点击左下角确认按钮保存即可。 [with grant option]：若使用该子句，获得权限的用户可以将次权限传递授予给其他用户，默认不允许。且SQL标准不允许循环授权 实操备注： 有别于教材，当前环境添加&lt;对象类型&gt;即table关键字会报错 当前环境grant语句一次性只允许向一个表授权，可同时向多个用户授权 收回权限数据库完整性数据库完整性指：数据的正确性与相容性","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"}]},{"title":"数据结构 第五章 树、森林&与二叉树的转换","slug":"数据结构 第五章 树、森林&与二叉树的转换","date":"2020-10-21T07:16:32.000Z","updated":"2020-10-27T06:23:09.933Z","comments":true,"path":"2020/10/21/数据结构 第五章 树、森林&与二叉树的转换/","link":"","permalink":"http://yoursite.com/2020/10/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97&%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲二叉树、树、森林之间转换树、森林的结构类似复杂多样，不方便设计统一的算法。因此转换为二叉树统一处理 树转换为二叉树树“加兄保子调层次” 加线：所有兄弟节点之间加一条线 去线：对于树中每个结点，只保留 firstchild的连线，其余均删除 层次调整： 文字概述：以原树结构为基准，从根结点开始，第一个孩子为根结点的左孩子，而其余兄弟结点(以原树结构为基准)均为这个左孩子的右孩子(孙子…反之一直右下衍生) 图形化理解：从上到下以原树为基准每个子树除第一个孩子为左孩子外，其余均为右孩子 红色为根节点 蓝色为根节点下第一个孩子 绿色为以原树基准的非首孩子的其他孩子 二叉树转换为树完全倒序操作：加兄保子调层次，调层次保子加兄，再逆序，保子(不保子：加次子/加右孩)，加兄(去兄：去右孩子) “加子去右调层次” 加线：若某个左孩子结点存在，则将这个左孩子的所有右孩子结点都与该左孩子的双亲结点相连 去线：去除所有结点的右孩子结点的连线 层次调整：外貌调整 森林转换为二叉树“森林变树，孩连根” 把森林的每颗树都转换为二叉树 第一颗树不动，其余树依次为上一课树的根节点的右孩子。 二叉树转换为森林“有右即分转森林，无右二叉只变树” 二叉树有可能转换成一棵树也有可能转换成森林 “有右即分”：若二叉树存在右孩子，则将其分离出来，若分离后的二叉树还存在右孩子则继续分离，直至不存在有右孩子的二叉树。 再把每一颗二叉树都转换为树即可。 赫夫曼树(哈夫曼)及其应用赫夫曼树(哈夫曼)树又称为最优二叉树 赫夫曼树的优化思想赫夫曼树的定义赫夫曼树编码 树、森林复杂，转换为二叉树处理 树转换为二叉树 二叉树转换为树 森林(森林-&gt;树)转换为二叉树 二叉树转换为森林 树与森林的遍历：先根、后根。前序，后序 二叉树的应用，赫夫曼树(最优二叉树) 引入：让单一线性的区分结构——&gt;通过权/频率——&gt;用二叉树来体现权的表示，从而实现路径长度上的优化。 而这种路径的优化，在代码执行上缩短总的执行次数。而在存储空间上可以应用在设计长短不等的编码，在通过编码的层面上实现无损的数据压缩(赫夫曼编码) 基本概念：路径长度、树的路径长度、带权路径长度 二叉树转换为赫夫曼树(最优二叉树) 赫夫曼编码(赫夫曼编码转换过程) 材料：字符集，权 画出最优二叉树 左分支代表0，右分支代表1，并实现其前缀编码。","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 第六章 树","slug":"数据结构 第六章 树","date":"2020-10-21T07:11:32.000Z","updated":"2020-10-24T14:08:16.815Z","comments":true,"path":"2020/10/21/数据结构 第六章 树/","link":"","permalink":"http://yoursite.com/2020/10/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%A0%91/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲 树的定义 树的相关概念 树的存储结构 二叉树 二叉树的性质 树的定义 树(Tree)是n(n ≥ 0)个结点的有限集，n = 0则为空树 在任意一颗树中，有且仅有一个称为根(Root)的结点 当结点 n &gt; 1，其余结点可分为m个互不相交的有限集T1、T2、…Tm 其中每个互不相交的有限集本身又是一颗树，并称为根的子树(SubTree) 核心：有且仅有一个称为根**整个树的根结点唯一，子树互不相交 树的相关概念结点类型度(Degree)：结点 拥有的子树的数量，所有结点最大的度称为该数的度 叶结点(Leaf)或终端节点：度 = 0； 非终端结点或分支结点：度 ≠ 0；，此类结点除根结点外，也可称为内部结点 结点间的关系 孩子(Child) 与 双亲(Parent) ：结点的子树的根称为该结点的孩子(Child)，相应地，该节点称为孩子的双亲 兄弟(Sibling)：同一个双亲的孩子之间互称兄弟 祖先：结点的祖先是从根到该结点所经历分支上的所有结点 子孙：以某结点为根，的子树中的任一结点都称为该结点的子孙 其他概念 层次(Level)：从根开始定义，根为第一层 堂兄弟：双亲在同一层结点 深度(Depth)或高度：树种结点最大的层次，称为树的深度 宽度：每一层结点个数的最大值 路径：略 树的类型 森林(forest)：是m颗(m≥0)颗互不相交的树的集合。对树种的每个结点而言，其子树的集合即为森林 有序树 与 无序树： 树的存储结构有别于线性表，树是一对多的结构，无论哪一种顺序存储结构的不能体现出这个关系，所以必须与链式存储结构结合起来表示。 双亲表示法 孩子表示法 孩子兄弟表示法 双亲表示法实现12345678910111213141516/* 树的双亲表示法结点结构定义 */#define MAX_TREE_SIZE 100/* 树结点的数据类型，目前暂定为整型 */typedef int TElemType; /* 结点结构 */typedef struct PTNode&#123; TElemType data; /* 结点数据 */ int parent; /* 双亲位置 */ &#125; PTNode;/* 树结构 */typedef struct&#123; PTNode nodes[MAX_TREE_SIZE]; /* 结点数组 */ int r, n; /* 根的位置和结点数 */ &#125; PTree; 孩子表示法实现12345678910111213141516171819/* 树的孩子表示法结构定义 */#define MAX_TREE_SIZE 100/* 孩子结点 */typedef struct CTNode&#123; int child; struct CTNode *next;&#125; *ChildPtr;/* 表头结构 */typedef struct&#123; TElemType data; ChildPtr firstchild;&#125; CTBox;/* 树结构 */typedef struct&#123; CTBox nodes[MAX_TREE_SIZE]; /* 结点数组 */ int r,n; /* 根的位置和结点数 */ &#125; CTree; 孩子兄弟表示法实现12345/* 树的孩子兄弟表示法结构定义 */typedef struct CSNode&#123; TElemType data; struct CSNode *firstchild,*rightsib;&#125; CSNode, *CSTree; 树的遍历树的遍历：按照某种次序，访问树中所有结点，且每个结点有且只有一次被访问。若规定从左到右遍历，树的遍历一般存在三种 前序(根)遍历 后序(根)遍历 层序(跟)遍历 tips：若树为二叉树，则还有一种中序遍历 注意： 前提规定“从左到右”表示，无论哪种遍历，都是决定从左子树，到右子树 前序遍历​ 从根节点开始遍历，从上到下，按先左子树，后右子树的顺序遍历每一颗子树 后序遍历​ 从根结点出发(不遍历)，从下到上，同样按先左子树，后右子树的顺序遍历每一颗子树。最后再遍历每颗子树的根结点 层序遍历/广度遍历​ 从根结点开始，自上而下，从左到右，逐层遍历 ### 前序遍历 访问树的根结点 从左到右的顺序前序遍历(从上到下)，遍历分别为根结点的每一颗子树 访问根结点，从左到右遍历根结点的孩子，若孩子又存在子树(即根节点)，从1开始循环 后序遍历 从左到右的顺序后序遍历(从下到上)，遍历分别为根结点的每一颗子树 最后访问根结点 从左到右，从下到上，即从最下底层左子树开始，从左到右遍历。每颗子树的根结点总是最后遍历 二叉树二叉树的定义 二叉树(Binary Tree)的每个结点最多只有两颗子树(即可以没有子树，或者有一颗也行，即树的度最大为2) 左子树和右子树是有顺序的，注意区别。因此二叉树存在五种基本状态 空二叉树 只有一个根节点 根结点只有左子树 根结点只有右子树 根结点既有左子树又有右子树 特殊二叉树 斜树 满二叉树 完全二叉树 斜树 左斜树：所有结点都只有左子树 右斜树：所有结点都只有左子树 斜树特点总结：每一层都只有一个结点，结点的个数与二叉树的深度相同。 满二叉树 所有分支结点都存在左子树和右子树 所有叶结点都在同一层 完全二叉树判断方法1： 一颗具有n个结点的二叉树按层序编号(从上到下，从左到右，) 每个结点按照满二叉树的结构逐层顺序编号，如果编号出现空挡，就说明不是完全二叉树，否则就是 判单方法2： 如果二叉树中除去最后一层节点为满二叉树，且最后一层的每个结点依次从左到右分布，则此二叉树被称为完全二叉树。 特点：满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树 二叉树的性质注意：以下二叉树性质，均以1开始从上到下，从左到右编号 二叉树性质1性质1：在二叉树的第 i 层上至多有 2i-1个结点 ( i ≥ 1)，即单层上的至多节点数。 解析：纯数量关系推导 二叉树的性质2性质2：深度为k的二叉树至多有 2k-1 个结点( k ≥ 1) 解析：纯数量关系推导 二叉树的性质3性质3：对于任何一颗二叉树T，如果其终端结点数为n0，度为2的结点数为n2。则n0 = n2 +1 即，所有叶结点数 = 所有根节点数 + 1 二叉树的性质4性质4：具有n个结点得完全二叉树的深度为 |_ log2n _| + 1 (|__ x _|)表示不大于x的最大整数 解析：暂时略《数据结构》从概念到C++的实现，王红梅 P137 二叉树的性质5性质5：具有n个结点完全二叉树存在如下性质 如果 i = 1，则结点 i 是二叉树的根；如果 i &gt; 1，则双亲结点是 i/2」 如果 2i &gt; n，则结点 i 无左孩子，即结点i为叶结点。反之 2i &lt; n 则i结点的左孩子是2i 如果 2i + 1 &gt; n，则结点 i 无右孩子，反之其右孩子是结点 2i + 1 正序的先左到底后右 也是先左到底，但是从左到底处出发，先左后右 二叉树的存储结构顺序存储结构设计由于二叉树定义严格，是一种特殊的树，所以可以仅使用顺序存储结构实现，仅通过数组下标的数量关系就能体现结点之间的逻辑关系 将二叉树从根节点编号为1开始，从上到小，左到右全部编号。直接按序存入数组，若是非完全二叉树，缺少部分填入空指针，但序号依然按照完全二叉树的顺序编号。 对于完全二叉树，数组下标的数量关系足够体现结点的所有逻辑关系(双亲，孩子，兄弟) 对于非完全二叉树/一般二叉树，按完全二叉树顺序编号，空缺部分均填入空指针 性能若二叉树表现出一条深度为k的 左/右斜树，则需开辟 2k-1 个空间存储，造成大量空间的浪费，因此二叉树的顺序存储结构一般只用于完全二叉树 链式存储结构 二叉链表：由于二叉表每个结点最多只有两个孩子，则一个数据域 + 两个 指针域(左右孩子)的存储结构 三叉链表：data + parent + lchild + rchild 12345/* 二叉树的二叉链表结点结构定义 */typedef struct BiTNode&#123; TElemType data; /* 数据域*/ struct BiTNode *lchild,*rchild; /* 左右孩子指针 */&#125;BiTNode,*BiTree; 遍历二叉树前言二叉树的遍历不同于线性表，即使确保“从根结点出发，依次访问二叉树的所有结点”，对于每个结点都可以有不同的选择，从而遍历的次序完全不一样。因此，可得出两个角度： 鉴于二叉树存在多种遍历次序，通常将其限制从左到右的习惯方式遍历。 鉴于可存在多种遍历次序，且处理困难，而计算机只能处理线性序列(循环,判断)**，通常利用与树的递归定义相同的递归方式来遍历。某种意义上将树的结点遍历变成线性序列** 二叉树的遍历方法限制按从左到右遍历的，会存在四种遍历方式，前序遍历、中序遍历、后序遍历、层序遍历。 “限制从左到右”，即调用左子树的递归操作一定在，调用右子树的递归操作之前！ 前、中、后序遍历的意思是，输出语句相对在左右子树递归调用的前、中、后位置 注意：无论前、中、后、层序遍历都是从根节点开始。但，从根节点开始，不等于先输出根节点！ 前序(根)遍历 访问根结点 前序遍历根结点的左子树 前序遍历根结点的右子树 中序(根)遍历 中序遍历根结点的左子树 访问根结点 中序遍历根结点的右子树 后序(根)遍历 后序遍历根结点的左子树 后序遍历根结点的右子树 访问根结点 理解的演变： 大话数据结构代码版，通过递归代码去推演：复杂，慢，易错。唯一好处，更加理解递归-回推 课堂聆听1，上下左右顺序描述更加复杂，无效 课堂聆听2，教材描述。纯文字理解(内含递归) 关键： 除“从根结点开始”这个根结点特指root这一个结点外，其他描述中的“根结点”均指每一颗子树的根结点 xxx遍历法下的描述“xxx遍历根节点的x子树”，其实表示后面的子树用于定位，可以把文字中xxx的描述递归函数的调用，即回到定义的本身，重头开始执行。即把概念描述，和递归理念结合在一起 技巧： 前根遍历： 方式1：根左、根左…根右、根左… 方式2(快)：每一棵树都是先根再输出左右(结点嵌套根) 中序遍历： 技巧是，直接从root结点深度最大的左子数开始。遍历完root结点左子孙后再从右子孙中从深度最大左子树开始。直至遍历中序遍历全部结点 每一棵树都是左到底后，访问根，再去到下一个右结点(结点嵌套，即又每一颗数左道底后，访问根…)… 后序遍历： 根结点肯定是最后访问的，找到深度大，先左输出后右输出。然后依次嵌套重复 方式2(快)：从最底层开始，从下往上推。每一棵树都是根结点最后访问，先左后右(结点嵌套根) 遍历次序记忆关键： 优先采取“树的遍历”中对三种遍历次序的文字主观描述 其次结合三行代码的顺序，结合递归执行思想，去记忆 前序遍历算法12345678910/* 二叉树的前序遍历递归算法 *//* “前”序遍历，输出语句在左子树递归和右子树递归之前，即第一行 */void PreOrderTraverse(BiTree T)&#123; if(T == NULL) return; printf(&quot;%C&quot;,T-&gt;data); //先输出 PreOrderTraverse(T-&gt;lchild);//再左子树递归 PreOrderTraverse(T-&gt;rchild);//最后右边子树递归&#125; 前序遍历算法，遍历次序如下图所示：ABDGHCEIF 中序遍历12345678910/* 二叉树的中序遍历递归算法 *//* “中”序遍历，输出语句在左子树递归和右子树递归之“中”，即第二行 */void InOrderTraverse(BiTree T)&#123; if(T == NULL) return; InOrderTraverse(T-&gt;lchild);//先左子树递归 printf(&quot;%C&quot;,T-&gt;data); //再输出 InOrderTraverse(T-&gt;rchild);//最后右子树递归&#125; 中序遍历，遍历次序如下图所示：GDHBAEICF 后序遍历12345678910/* 二叉树的后序遍历递归算法 *//* “后”序遍历，输出语句在左子树递归和右子树递归之“后”，即最后行 */void PostOrderTraverse(BiTree T)&#123; if(T == NULL) return; PostOrderTraverse(T-&gt;lchild);//先左子树递归 PostOrderTraverse(T-&gt;rchild);//再右子树递归 printf(&quot;%C&quot;,T-&gt;data); //最后才输出&#125; 后序遍历，遍历次序如下图所示：GHDBIEFCA 层序遍历与前三种遍历方式不同，层序遍历更多是由人的主观遍历次序，到对应的代码的实现。而其他三种更倾向于代码的递归逻辑设计到实际的遍历次序。 实现逻辑 初始化：创建队列，根结点入队 若队列不为空，队头出队。让队头的左右孩子入队 以此循环第2步即可 推导二叉树的遍历结果推导逻辑：(具体案例细节可参详P184~P186) 确定根节点：从前序遍历(首位)，或后序遍历(尾) 循环推导 从某一遍历推导出的某一条件出发 使用上一轮得出的条件，与上一轮不同的遍历方式结合再推出一个新条件，以此循环 注意：一般每一轮会都要利用孩子集范围，缩减孩子集范围，作为判断的条件之一 经验总结： 必须含中序遍历的条件则才能唯一确定一颗二叉树 前序遍历，用于确定根后与中序遍历占位后，来确定左孩子(同时也确定子树的根，再中序域划分…) 中序遍历，主要用于，范围划分，且占位！ 后序遍历，只要用于，被划分范围后，确定根结点(范围尾部) 实战演示 二叉树的建立扩展二叉树为了能让每个结点确认是否有左右孩子，在二叉树建立前，将其每个结点的空指针处引出一个虚结点。这种扩展后的二叉树称为扩展二叉树 二叉树的建立二叉树的建立步骤如下 画出拟建立二叉树 画出对应的扩展二叉树 以某种遍历方式写出扩展二叉树的遍历次序 以同类型的遍历方式创建按次序输入实现二叉树的建立 123456789101112131415161718192021/* 按前序输入二叉树中结点的值（一个字符） *//* #表示空树，构造二叉链表表示二叉树T。 */void CreateBiTree(BiTree *T)&#123; TElemType ch = null; /* scanf(&quot;%c&quot;,&amp;ch); */ ch=str[index++]; if(ch==&#x27;#&#x27;) *T=NULL; else &#123; *T=(BiTree)malloc(sizeof(BiTNode)); if(!*T) exit(OVERFLOW); (*T)-&gt;data=ch; /* 生成根结点 */ CreateBiTree(&amp;(*T)-&gt;lchild); /* 构造左子树 */ CreateBiTree(&amp;(*T)-&gt;rchild); /* 构造右子树 */ &#125; &#125; **C++**实现： 12345678910111213141516template&lt;typename DataType&gt;BiNode&lt;DataType&gt;* BiTree&lt;DataType&gt;::Creat()&#123; //声明一个新结点 BiThrNode&lt;DataType&gt; *btn = nullptr; char ch; cin &gt;&gt; ch; if (ch != &#x27;#&#x27;)&#123; btn = new BiThrNode&lt;DataType&gt;; btn-&gt;data = ch; btn-&gt;lchild = Creat(); btn-&gt;rchild = Creat(); &#125; return btn;&#125; 线索二叉树 二叉树的链式存储会存在大量空指针域，n个结点的二叉树就会存在 n+1个空指针域。 可以利用这些空指针域存储以某种次序创建的二叉树结点之间的前驱后继指针信息。 指向前驱和后继的指针称为线索。加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树 二叉树以某种次序遍历使其变为线索二叉树的过程称做线索化**。 线索二叉树的存储结构为区分，rchild/lchild是指向线索还是指向树结构的指针，通过两个Tag枚举变量标志，Thread为线索指针，Link为树指针 123456789typedef enum &#123;Link,Thread&#125; PointerTag; /* Link==0表示指向左右孩子指针, */ /* Thread==1表示指向前驱或后继的线索 */typedef struct BiThrNode /* 二叉线索存储结点结构 */&#123; TElemType data; /* 结点数据 */ struct BiThrNode *lchild, *rchild; /* 左右孩子指针 */ PointerTag LTag; PointerTag RTag; /* 左右标志 */&#125; BiThrNode, *BiThrTree; 中序线索化通过中序遍历实现中序线索化。代码如下，需注意： 全局变量 pre 在外初始化为 root 线索二叉树初始化需把结点置为Link，因为中序线索化只修改Thread； 令某种次序序列中的第一个结点其lchild指向二叉树的根结点 12345678910111213141516171819202122232425262728293031323334//必须以全局变量的方式参与递归操作BiThrNode&lt;char&gt; *pre = nullptr;//中序线索化void InThreading(BiThrNode&lt;char&gt; *p) &#123; //左子树递归至最后结点(非null结点) if (p) &#123; InThreading(p-&gt;lchild); //(!p-&gt;lchild)：表若当前结点左孩子为null，则lchild(前驱)线索化， //即为pre结点 if (!p-&gt;lchild) &#123;//为null p-&gt;LTag = PoinTerTag::Thread; p-&gt;lchild = pre; &#125; //(!pre-&gt;rchild)：表，若当前结点遍历的上一个结点的rchild(后继)为null， //则线索化的后继结点，为当前结点p if (!pre-&gt;rchild) &#123;//为null pre-&gt;RTag = PoinTerTag::Thread; pre-&gt;rchild = p; &#125; pre = p;//存储以某种递归次序线索化(遍历)的上一个结点位置 //因为固定从左到右，所以pre用于LTag的lchild,也用于pre结点本身的有孩子线索化 InThreading(p-&gt;rchild); &#125;&#125;void main()&#123; BiThrTree&lt;char&gt; btt&#123;&#125;; //P189二叉树 ABDH##I##EJ###CF##G## //pre全局遍历的变量环境是 pre = root; pre = btt.root; InThreading(btt.root);&#125; 遍历线索二叉树线索二叉树与双向链表线索二叉树的结构类似双链表结构，因此为了方便线索二叉树的遍历等操作，对线索二叉树添加一个头结点。添加头结点这个操作常常在线索化的时候实现，因此要对上面的中序线索化代码的基础上稍作修改——添加一个头结点，并设定初始状体如下： 头结点的lchild域指向二叉树的根结点，rchild域指向遍历时访问的最后一个结点。 遍历的第一个元素的lchild域指向头结点，最后一个结点的rchild域同样指向头结点 123456789101112131415161718192021222324/* 备注：遍历代码是重点，而对线索化的改进代码。这个是次要，还未分析学习 *//* 中序遍历二叉树T,并将其中序线索化,Thrt指向头结点 */Status InOrderThreading(BiThrTree *Thrt,BiThrTree T)&#123; *Thrt=(BiThrTree)malloc(sizeof(BiThrNode)); if(!*Thrt) exit(OVERFLOW); (*Thrt)-&gt;LTag=Link; /* 建头结点 */ (*Thrt)-&gt;RTag=Thread; (*Thrt)-&gt;rchild=(*Thrt); /* 右指针回指 */ if(!T) /* 若二叉树空,则左指针回指 */ (*Thrt)-&gt;lchild=*Thrt; else &#123; (*Thrt)-&gt;lchild=T; pre=(*Thrt); InThreading(T); /* 中序遍历进行中序线索化 */ pre-&gt;rchild=*Thrt; pre-&gt;RTag=Thread; /* 最后一个结点线索化 */ (*Thrt)-&gt;rchild=pre; &#125; return OK;&#125; 中序遍历线索二叉树(非递归版) BiThrTree T 表示头结点，则按带头结点的线索化，p = T-&gt;lchild; 则表示p等于根结点 1234567891011121314151617181920/* 中序遍历二叉线索树T(头结点)的非递归算法 */Status InOrderTraverse_Thr(BiThrTree T)&#123; BiThrTree p; p=T-&gt;lchild; /* p指向根结点 */ while(p!=T)&#123; /* 空树或遍历结束时,p==T */ while(p-&gt;LTag==Link) p=p-&gt;lchild; if(!visit(p-&gt;data)) /* 访问其左子树为空的结点 */ return ERROR; while(p-&gt;RTag==Thread&amp;&amp;p-&gt;rchild!=T)&#123;//防空树操作 p=p-&gt;rchild; visit(p-&gt;data); /* 访问后继结点 */ &#125; p=p-&gt;rchild; &#125; return OK;&#125; 代码分析 这段代码相当于一个链表的扫描，所以时间复杂度O(n) 小结： 线索二叉树充分利用了二叉树链式存储结构的空指针域空间(节省空间)，仅需创建时的一次遍历就可终生受用的前驱后继信息(节省时间)。 若二叉树需要经常遍历或查找结点时需要某种遍历序列的前驱和后继，则线索二叉树的存储结构是非常不错的选择。","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2020-09-25T13:42:32.000Z","updated":"2020-09-26T01:23:59.406Z","comments":true,"path":"2020/09/25/冒泡排序/","link":"","permalink":"http://yoursite.com/2020/09/25/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","excerpt":"","text":"冒泡排序分析 每一轮交替比较把最值往**后排(下沉)**，能得出参与这次轮次所有数中的最值 首次交替次数：最后一个数无需交替比较。即循环下标结构 for(j = 0;j &lt; len - 1; j ++ ) 接下来继续开始若干次从头开始的交替，逐一把“第2最值”，“第3最值”…排到最后(下沉) 剩余轮次交替次数：每一次交替比较后的最值无需参与下一次交替比较，剩下轮次的交替比较次数呈递减1状态 总比较轮次：每一个数都需走一遍轮次。，最后交替(数组最前的数)只需一个轮次完成，即总论次为：len - 1 总结：理论支持每一轮交替比较把最值往**后排(下沉)**，能得出参与这次轮次所有数当中的最值 核心部分 把最值往后排(下沉) 从大到小，降序，后排下沉最小值，a[ j ] &lt; a[ j + 1 ] 从小到大，升序，后排下沉最大值，a[ j ] &gt; a[ j + 1 ] 数组内部比较交替次数： 首次比较交替次数：len - 1 即for(j = 0;j &lt; len - 1;j++) 剩下轮次比较交替次数：每经一个轮次，交替比较次数减1 整个完整排序的比较轮次：最后交替比较两个数(数组最前的两个数)只需一个轮次完成，len - 1。 代码表示 比较轮次属于外循环：len - 1 内部比较交替次数属于内循环：(首次)len - 1，(剩余)每一轮次，次数减1 从大到小，降序，则后排下沉最小值(a[j] 到 a[j + 1])比较 12345678910//外循环：比较轮次for(i = 0;i &lt; len - 1;i++)&#123; //数组遍历写法 i = 0; i &lt; len; i++ 正常遍历，len-1则少一次 //内循环：交替比较次数，递减1通过i增1来实现 for(j = 0;j &lt; len - 1 - i;j++)&#123; //实现从大到小，降序，后排下沉最小值，a[ j ] &lt; a[ j + 1 ] if(a[j] &lt; a[j + 1])//边界分析：i = 0，判断上溢d = j + 1，因为“&lt;”，所以j = (len-1) - 1，所以d = len - 1(没上溢) //交换位置 &#125;&#125; 时间复杂度分析 参考：https://zhuanlan.zhihu.com/p/66768445","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构 第五章 串","slug":"数据结构 第五章 串","date":"2020-09-25T09:12:32.000Z","updated":"2020-10-24T14:09:20.450Z","comments":true,"path":"2020/09/25/数据结构 第五章 串/","link":"","permalink":"http://yoursite.com/2020/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E4%B8%B2/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲串的定义串(String)：是由零个或多个字符组成的有限序列，又名叫字符串。 记为：s = “a1a2a3…an(n ≥0)” 串中的字符数目n称为串的长度 零个字符串称为空串(null string)即，“ ‘’” ” 序列即相邻字符之间存在前驱后继关系 主串与子串：串中任意个数的连续字符组成的子序列称为该串(主串)的子串 串的比较常用字符标准编码 标准ASCII编码：用7位二进制数表示128个字符 (可表示英语为主的语言) 扩展ASCII编码：用8位二进制数表示256个字符 (可表示英语为主的语言和特殊字符) Unicode编码：用16位二进制表示216个字符，约6.5万多个字符(足以表示全世界成百上千种语言和文字) 比较原则字符串的比较在计算机中取决于挨个字母的前后顺序，靠后的字母比靠前的字母要大。如“silly” &lt; “stupid” 存在字符串 s 与 t，若 s &gt; t，则存在如下两种情况： 情况1：“单纯地多出字母(包含关系)，则多出字母的字符常大”。如：“happy” &gt; “hap”，单纯多出“py” 情况2：“无包含关系，则挨个字母比较顺序，靠后比靠前大”。如：“happy” &gt; “happen”，匹配到第5个字母‘y’ &gt; ‘e’ 小结： 等长：挨个字母前后顺序比较 不等长 完全包含关系，多字母为大，happy &gt; hap 非包含完全包含关系，挨个字母比较，happy &gt; happen 串的抽象数据类型“串”从逻辑结构上和线性表很相似，但基本操作，串更倾向于查找子串位置，替换子串等 123456789101112131415161718192021222324ADT 串(string)Data 串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。Operation StrAssign(T, *chars): 生成一个其值等于字符串常量chars的串T。 StrCopy(T, S): 串S存在，由串S复制得串T。 ClearString(S): 串S存在，将串清空。 StringEmpty(S): 若串S为空，返回true，否则返回false。 StrLength(S): 返回串S的元素个数，即串的长度。 StrCompare(S, T): 若S&gt;T，返回值&gt;0，若S=T，返回0，若S&lt;T，返回值&lt;0。 Concat(T, S1, S2): 用T返回由S1和S2联接而成的新串。 SubString(Sub, S, pos, len): 串S存在，1≤pos≤StrLength(S)， 且0≤len≤StrLength(S)-pos+1，用Sub返 回串S的第pos个字符起长度为len的子串。 Index(S, T, pos): 串S和T存在，T是非空串，1≤pos≤StrLength(S)。 若主串S中存在和串T值相同的子串，则返回它在主串S中 第pos个字符之后第一次出现的位置，否则返回0。 Replace(S, T, V): 串S、T和V存在，T是非空串。用V替换主串S中出现的所有 与T相等的不重叠的子串。 StrInsert(S, pos, T): 串S和T存在，1≤pos≤StrLength(S)+1。 在串S的第pos个字符之前插入串T。 StrDelete(S, pos, len): 串S存在，1≤pos≤StrLength(S)-len+1。 从串S中删除第pos个字符起长度为len的子串。endADT 串的存储结构串的顺序存储结构 串的顺序存储结构一般用定长数组来定义 一般将串的长度值保存数组下标0处，有的也可存储在最后一个下标位置，或在串值后添加结束标记字符如“\\0”(数据结构面向人，一般与日常数数顺序为主) 串的操作常使得，串值存储空间需要动态变化。一般通过自由存储区——堆和相关操作函数(malloc/free)动态分配空间 串的链式存储结构串的链式存储结构因为用结点存储字符序列会浪费大量的空间，除连接串与串操作有一定方便外(只是方便/不是高效)**，总的来说，不如顺序存储灵活，性能也不如顺序存储结构好** BF算法BF算法，也叫朴素的模式匹配算法 串的模式匹配：即子串在主串中的定位操作，如S=”goodgoogle”，找到T=”google”这个子串的位置 匹配思路： 用子串从主串的第一位开始逐一字符匹配 若子串中任意一个字符匹配失败，则整个子串从上一次主串开始匹配的位置的下一个位置开始匹配 以此循环，直至存在子串的每一个字符均被匹配正确的情况 匹配思路图示如下：如S=”goodgoogle”，找到T=”google”这个子串的位置 tips：“|”竖线表示匹配成功，“⚡”表示匹配失败 第一步 第二步 ​ 3. 第三步 第四步 第五步 代码案例思路： 位置变量pos合法过滤 设置主串与子串循环开始索引(下标0表串长度，下标1是第一个字符 匹配循环结构结束条件(||关系，&amp;&amp;表达)：S[0],T[0]表示串长度，子串提前匹配成功，或主串全部被匹配完。则结束循环 若字符匹配成功，则主串与子串索引分别+1，否则主串匹配索引回退，子串索引初始化 若匹配成功(子串被全部匹配)，则计算位置并返回，否则返回错误提示 12345678910111213141516171819202122232425262728293031323334/* 返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。*//* T非空，1≤ pos ≤ StrLength(S)。*/int Index(String S,String T,int pos)&#123; //位置变量pos合法过滤 if (pos &lt; 1 || pos &gt; StrLength(S)) return ERROR; //设置主串与子串循环开始索引 int i = pos; int j = 1;//下标0用于存储字符串长度，下标1即是第一个字符的数组下标 //匹配循环结构结束条件：S[0],T[0]表示串长度，子串提前匹配成功，或主串全部被匹配完。则结束循环 //因，匹配次数 = 字符串长度 = (j - 1)，所以 等于“=”时也需执行 while(j &lt;= T[0] &amp;&amp; i &lt;= S[0])&#123;//&amp;&amp; 在这里表示，有任何一个条件不符合都表示匹配完毕 //若字符匹配成功，则主串与子串索引分别+1 if(S[i] == T[j])&#123; i++; j++; &#125;else&#123; //若匹配失败，则主串匹配索引回退，子串索引初始化 i - j + 2; //i - (j - 1) + 1 &#125; &#125; //若匹配成功(子串被全部匹配)，则计算位置并返回。 //因，匹配次数 = 字符串长度 = (j - 1)，所以若全部匹配，j一定大于字符串长度 if(j &gt; T[0]) return i - T[0];//从起点减去匹配过的次数(增过的量) == 子串长度 //若匹配失败，则返回错误提示 else return ERROR; &#125; 因为当前教材是把字符串长度记录在数组下标0处，所以第一个字符的数组下标就是1。因此未开始匹配字符时，子串匹配索引 j 的初始值就是1，而匹配成功1次后，j++才变成2。即它们之间的关系是，匹配次数 = (j - 1) = 字符长度 主串索引回退代码分析(i - j + 2)：匹配成功一次，才会造成一次主串(子串)索引的自增，所以匹配次数==主串增加量，由上可知，匹配次数 == j -1，所以主串回退到原位因为，i - (j - 1)，而需要进入下一轮匹配则还需要回退原位后 + 1，则： 回退上一次匹配位置下位代码未：i - ( j - 1 ) + 1 == i - j +2 优化理解版《数据结构》从概念到C++的实现，王红梅。P104，通过增加空间复杂度O(1)，引入start变量单独存放子串匹配位置 KMP模式匹配算法KMP匹配算法原理KMP算法核心可总结为两句话：“因为不同所以不同，跳过不同。因为相同所以相同，跳过相同！” “因为不同所以不同，跳过不同”：若存在子串字符互不相同部分，当出现主串字符匹配不了时，则无需BF完全回溯，因为BF回溯后的下一个主子串匹配肯定也是不同的。因此我们应让下次匹配跳到子串首字符(除首字符位置)下一次出现的位置。 “因为相同所以相同，跳过相同”：当子串与主串出现不匹配时，靠近不匹配处的若干字符在字符前缀部分出现过，则不应该仅跳到重复字符(下一次出现位置)的首字符，而是跳过包括这一段相同部分。，即应该跳到(新的匹配位置)于后缀部分相同的前缀部分的下一个位置。 next数组next数组含义k = 子串下标 = 前缀长度 next数组的计算next 数组代码实现KMP模式匹配算法改进记住，一切能用数学公式或字母来形式化的东西，都是为了辅助我们更好的表述，它是无二义的，请不要害怕它。 我们不一定从数学公式中直接理解","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 第四章 队列","slug":"数据结构 第四章 队列","date":"2020-09-20T13:01:32.000Z","updated":"2020-09-20T12:59:20.061Z","comments":true,"path":"2020/09/20/数据结构 第四章 队列/","link":"","permalink":"http://yoursite.com/2020/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E9%98%9F%E5%88%97/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲 队列的定义 队列的抽线数据结构 队列顺序存储结构及其不足 循环队列的顺序存储结构 小结 队列的链式存储结构 总结 队列的定义队列(queue)：只允许在一端进行插入，另一端进行删除操作的线性表 队列是一种先进先出(First In First Out，FIFO)的线性表。(符合生活中的习惯) 允许插入的一端称为队尾，允许删除的一端称为队头 队列的应用十分广泛：如键盘输入到屏幕显示、操作系统、客服系统等 队列的抽象数据类型12345678910111213ADT 队列(Queue)Data 同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。Operation InitQueue(*Q): 初始化操作，建立一个空队列Q。 DestroyQueue(*Q): 若队列Q存在，则销毁它。 ClearQueue(*Q): 将队列Q清空。 QueueEmpty(Q): 若队列Q为空，返回true，否则返回false。 GetHead(Q, *e): 若队列Q存在且非空，用e返回队列Q的队头元素。 EnQueue(*Q, e): 若队列Q存在，插入新元素e到队列Q中并成为队尾元素。 DeQueue(*Q, *e): 删除队列Q中队头元素，并用e返回其值。 QueueLength(Q): 返回队列Q的元素个数endADT 队列顺序存储结构及其不足队列的顺序存储结构设计传统定义上的设计 队列插入元素：只需在队尾追加一个元素即刻，时间复杂度为O(1) 队列删除元素：把下标为0的队头元素删除后，其余所有元素均需向前移动,时间复杂度为O(n) 现今队列顺序存储结构设计因队头固定为数组起始下标0，导致删除元素效率低，O(n)，且避免只有一个元素时，队头和队尾重合使处理变得麻烦 引入两个指针，front指向队头元素，rear指向队尾元素的下一个位置，此时front = rear表示空队列 队列删除元素时，直接改变队头front的指向从而实现删除元素时间复杂度提升至O(1) 队列的顺序存储结构插入与删除元素过程如下： 队列顺序存储结构的不足若在队列未满时曾经通过可移动头指针删除过元素，会导致当rear指针移至数组末端时(表示无法再插入元素时)，数组靠前部分还有空闲空间的“假溢出”现象。 配合上述“普通队列插入图示”理解假溢出现象如下： 解决方案：采用循环队列。 循环队列的顺序存储结构循环队列的定义循环队列：把队列头尾相接的顺序存储结构(实际把rear指针变成可移动指针)，后面满了，就从头开始。 循环队列特性小结： front指向队头元素下标，rear指向队尾元素的下一个位置 front与rear指针均可独立循环移动 结构定义如下: 123456/* 循环队列的顺序存储结构 */typedef struct&#123; QElemType data[MAXSIZE]; int front; /* 头指针 */ int rear; /* 尾指针，若队列不空，指向队列尾元素的下一个位置 */&#125;SqQueue; 循环队列连续插入数据图示如下： 注意：最终队列满时，rear == front，此时与一开始定义 rear == front 表示队列为空的定义重复了。 解决方案1：设置一个标志变量flag，当front == rear，且flag=0时为队列空，当front == rear，且flag=1时为队列满。 解决方案2： 预留一个空闲空间表示队列满的状态，即队列满时，数组中还有一个空闲单元rear + 1 = front 此时队列可存储数据量为 “ MAXSIZE - 1 ” 注意：循环队列的front和rear指针均可独立循环移动，因此导致存在两种队列满的状态，即rear &gt; front 与 rear &lt; front 的两种情况。如下图所示： 显然 rear &gt; front 的情况是不能完全匹配 rear + 1 == front 这个队列满的判定条件 因此通用的队列满判别条件为： (QueueSize 为队列最大尺寸) “ (rear + 1) % QueueSize == front ” 同理两种rear与front的大小关系决定了计算队列长度通用公式为： “ (rear - front) + QueueSize % QueueSize ” 循环队列的初始化InitQueue123456/* 初始化一个空队列Q */Status InitQueue(SqQueue *Q)&#123; Q-&gt;front=0; Q-&gt;rear=0; return OK;&#125; 循环队列入队EnQueue123456789//循环队列入队操作Status EnQueue(SqQueue *Q, QElemType e) &#123; if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front)//判断队列是否已满 return ERROR; Q-&gt;data[Q-&gt;rear] = e; //队列，只能通过队尾入队，只操作rear Q-&gt;rear = (Q-&gt;rear+1) % MAXSIZE; //然rear指针符合循环队列特点，循环自增归零 return OK;&#125; 循环队列出队DeQueue123456789//循环队列出队操作Status DeQueue(SqQueue *Q, QElemType *e) &#123; if (Q-&gt;rear == Q-&gt;front)//判断队列是否为空，空则无法出队 return ERROR; *e = Q-&gt;data[Q-&gt;front];//队列，只能通过队头入队，只操作front Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE;//让front指针符合循环队列特点，循环自增归零 return OK;&#125; 要点 无论入队还是出队操作，都有一句类似的代码Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE，而这总写法是一种通用的循环自增归零写法。MAXSIZE控制自增的最大值，也是开始循环的值。 (变量 + 1) % MAXSIZE; 图示如下： 入队和出队的rear与front数值变化都是独立的循环自增，互不影响。**两者唯一有交集(关系)**部分已经解决(判读队列空与满的多种情况) 小结队列的顺序存储结构： 队列： 只能通过队尾入队，入队只操作rear，只能通过队头入队，入队只操作front front可移动化，提高删除效率 循环队列： front与rear分别独立循环移动，解决“假溢出”现象 队列满条件： (rear + 1) % QueueSize == front 注意：此时队列可存储数据量为 MAXSIZE - 1 队列长度通用公式： (rear - front) + QueueSize % QueueSize 循环自增归零写法：(变量 + 1) % MAXSIZE; 队列的链式存储结构定义队列的链式存储结构，相当于只能尾进头出的单链表，简称链队列 队头指针(front)指向头结点(不是头指针！) 队尾指针(rear)指向尾指针 front和rear都指向头结点，则表示空队列 结构定义12345678910111213//类似栈的链式存储结果设计//结点结构：QueuePtrtypedef struct QNode &#123; QElemType data; struct Qnode *next;&#125;QNode,*QueuePtr;//链表结构：LinkQueue//LinkQueue相当于一个front与rear结点管理器，存储这两个变量的指向typedef struct &#123; QueuePtr front, rear;/*队头队尾指针*/&#125;LinkQueue; LinkQueue相当于一个front与rear结点管理器，存储这两个变量的指向，front与rear独立工作。在理解上的结构关系(不完全是实际结构)如下： 队列初始化队列链式存储结构初始化关键在于：创建一个头结点，并且front 与 rear 都指向头结点(表示队列为空)，并且把头结点的指针域赋值为NULL InitQueue 123456789/*构建一个空列表Q*/Status InitQueue(LinkQueue *Q)&#123; Q-&gt;front = Q-&gt;rear = (QueuePtr)malloc(sizeof(QNode));//创建一个头结点并同时指向fornt与rear if (!Q-&gt;front)//申请失败则向系统报出异常 exit(1); -&gt;front-&gt;next = NULL;//为头结点指针域赋值NULL return OK;&#125; 初始化到数据入队过程队列的链式存储结构初始化后(空队列)到数据插入的过程理解如下图所示： EnQueue思路： 链式存储结构一般不会满 创建新结点 为新结点的数据域和指针域赋值(插入的总是队尾，所以指针域为NULL) 把新结点(尾结点)s成为原队尾结点的后继结点 修改链表结构LinkQueue的rear指向，返回OK即可 12345678910111213//入队操作Status EnQueue(LinkQueue *Q, QElemType e) &#123; QueuePtr s = (QueuePtr)malloc(sizeof(QNode)); //创建新结点 if (!s) //假如内存申请失败 exit(1); //非正常退出 s-&gt;data = e; //为新结点的数据域和指针域赋值 s-&gt;next = NULL; Q-&gt;rear-&gt;next = s; //把新结点/尾结点s成为给原队尾结点的后继结点 Q-&gt;rear = s; //修改链表结构LinkQueue的rear指向 return OK;&#125; exit() 函数：结束当前进程/当前程序/，在整个程序中，只要调用 exit ，就结束。 exit(1)表示进程异常退出 exit(0)表示进程正常退出 DeQueue关键点： front指针不是直接指向数据结点，而是指向头结点，所以待删除的结点应为Q-&gt;front-&gt;next 删除思路与单链表的删除操作思路一致 若出队的结点刚好是最后一个结点，需要重“置零”一下，否则s-&gt;next == NULL，而且rear会失去指向。 非最后一个结点出队过程示意如下： 最后一个结点出队过程示意如下： 123456789101112131415/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */Status DeQueue(LinkQueue *Q,QElemType *e)&#123; QueuePtr p; if(Q-&gt;front==Q-&gt;rear) return ERROR; p=Q-&gt;front-&gt;next; /* 将欲删除的队头结点暂存给p*/ *e=p-&gt;data; /* 将欲删除的队头结点的值赋值给e */ Q-&gt;front-&gt;next=p-&gt;next;/* 将原队头结点的后继p-&gt;next赋值给头结点后继*/ if(Q-&gt;rear==p) /* 若队头就是队尾，则删除后将rear指向头结点 */ Q-&gt;rear=Q-&gt;front; free(p); return OK;&#125; 总结 从基本单次操作中，循环队列和链队列时间上都是常数时间O(1) 若出队入队频繁，链队列会因每次申请和释放结点存在额外一些时间开销，与循环队列相比有细微差距 在空间上，循环队列会因长度的固定限制，造成空间上的浪费。链队列则不存在 总的来说：可确定长度优先选择循环队列，若无法预估则用链队列。","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 第四章 栈","slug":"数据结构 第四章 栈","date":"2020-09-19T12:01:32.000Z","updated":"2020-09-19T12:01:56.544Z","comments":true,"path":"2020/09/19/数据结构 第四章 栈/","link":"","permalink":"http://yoursite.com/2020/09/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%A0%88/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲 栈的定义 栈的抽线数据类型 栈的顺序存储结构 栈的链式存储结构 小结 栈的应用 栈的定义栈的定义如下： 栈(stack)如同弹夹一样，先进后出，后进先出(Last In First Out，LIFO)的特性。 栈而且是限定仅在表尾(栈顶)进行插入和删除的线性表。 相关术语如下： 栈顶(top)：允许插入和删除的一端 栈底(bottom)：相对于栈顶的另一端 空栈：不含任何数据元素的栈 进栈/压栈/入栈(push)：栈的元素插入操作 出栈/弹栈(pop)：栈的元素删除操作 进栈出栈变化形式 栈的抽象数据类型12345678910111213ADT 栈(stack)Data 同线性表。元素具有相同的类型，相邻元素具有前驱和后继的关系。Operation InitStack(*S)：初始化操作，建立一个空栈S DestroyStack(*S)：若栈存在，则销毁它 ClearStack(*S)：将栈清空 StackEmpty(S)：若栈为空，返回true，否则返回false GetTop(*S,e)：若栈存在且非空，用e返回S的栈顶元素 Push(*S,e)：若栈S存在，插入新元素e到栈S中，并成为栈顶元素 Pop(*S,*e)：删除栈S中的顶栈元素，并用e返回其值 StackLength(S)：返回栈S的元素个数endADT 栈的顺序存储结构顺序栈的结构定义 栈的顺序存储结构也称为 “顺序栈” 通常用数组下标为0的一端作为栈底，因为变化最小 定义一个top变量存储栈顶元素所在的位置，top &lt; StackSize， 栈存在一个元素时(对应数组下标为0)，top = 0 当top = -1 表示为空栈 顺序栈的结构定义如下： 123456#define MAXSIZE 50typedef int SElemType;struct&#123; SElemType data[MAXSIZE]; int top; //记录栈顶下标&#125;SqStack; 进栈&amp;出栈操作Push思路： 若栈已满，退出 修改栈顶top值，+1，并且作为下标存入数据e 12345678910/* 插入元素e为新的栈顶元素 */Status Push(SqStack *S,SElemType e)&#123; if(S-&gt;top == MAXSIZE -1) /* 栈满 */ return ERROR; S-&gt;top++; /* 栈顶指针增加一 */ S-&gt;data[S-&gt;top]=e; /* 将新插入元素赋值给栈顶空间 */ //这两句可写成：S-&gt;data[++S-&gt;top] = *e; return OK;&#125; pop思路： 若栈为空，则无元素出栈 以当前top为数组下标取出值并赋值给e top值自减1 123456789Status Pop(SqStack *S,SElemType *e)&#123; if(S-&gt;top==-1) return ERROR; *e=S-&gt;data[S-&gt;top]; /* 将要删除的栈顶元素赋值给e */ S-&gt;top--; /* 栈顶指针减一 */ //这两句同样可写成：*e = S-&gt;data[S-&gt;top--]; return OK;&#125; 两栈共享空间前言 通常一个程序中要用到多个栈，为了不发生上溢错误，就必须给每个栈分配一个足够大的存储空间。但实际中，很难准确地估计，若每个栈都分配过大的存储空间，势必造成系统空间紧张；若让多个栈共用一个足够大的连续存储空间，则可利用栈的动态特性使他们的存储空间互补。(关键字：’’多个栈’’) 事实上，使用这种数据结构，通常是两个栈的空间需求有相反关系，即一个栈增长时，另一个栈在缩短的情况。这样使用这种结构的意义更大。(如买卖股票，买入必定存在卖出等应用场景) 设计方案 前提是，两个栈的数据类型必须相同 让其中一个栈的栈底为数组下标0（-1），另一个栈底为n-1（n） (n表示数组的长度) 关键思路：两个栈是在数组的两端，向中间靠拢， 两盏共享空间结构1234567/*两盏共享空间结构*/typedef struct &#123; SElemType data[MAXSIZE]; int top1; /*栈1 栈顶指针 */ int top2; /*栈2 栈顶指针 */&#125;SqDoubleStack; 栈内元素存储状态 空栈：top1 = -1，top2 = MAXSIZE 栈满： 往右靠拢：top1 = n - 1，top2 = n -1 往左靠拢：top2 = 0，top1 = 0 向中间靠拢：top1+ 1= top2 通常使用top1 + 1 = top2为栈满的判别条件。 共享空间下的进栈&amp;出栈操作对于两栈共享空间的push与pop方法，除了顺序栈进出栈原有的两个参数外，还需要栈号参数stackNumber，用于判断操作的栈对象。 push思路： 判断栈的是否已经存满 分别执行类同顺序栈的进栈代码(注意：处于尾部栈的下标操作是相反的) 1234567891011/* 插入元素e为新的栈顶元素 */Status Push(SqDoubleStack *S,SElemType e,int stackNumber)&#123; if (S-&gt;top1+1==S-&gt;top2) /* 栈已满，不能再push新元素了 */ return ERROR; if (stackNumber==1) /* 栈1有元素进栈 */ S-&gt;data[++S-&gt;top1]=e; /* 若是栈1则先top1+1后给数组元素赋值。 */ else if (stackNumber==2) /* 栈2有元素进栈 */ S-&gt;data[--S-&gt;top2]=e; /* 若是栈2则先top2-1后给数组元素赋值。 */ return OK;&#125; pop思路： 首先通过stackNumber分别分支处理 判断被选中栈的是否为空 别执行类同顺序栈的出栈代码 12345678910111213/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */Status Pop(SqDoubleStack *S,SElemType *e,int stackNumber)&#123; if (stackNumber==1) &#123; if (S-&gt;top1==-1) return ERROR; /* 说明栈1已经是空栈，溢出 */ *e=S-&gt;data[S-&gt;top1--]; /* 将栈1的栈顶元素出栈 */ &#125;else if (stackNumber==2)&#123; if (S-&gt;top2==MAXSIZE) return ERROR; /* 说明栈2已经是空栈，溢出 */ *e=S-&gt;data[S-&gt;top2++]; /* 将栈2的栈顶元素出栈 */ &#125; return OK;&#125; 时间复杂度分析可知顺序栈的push和pop操作时间复杂度均为O(1) 栈的链式存储结构栈的链式存储结构，简称“链栈” 链栈没有头结点，或者说是把头结点与栈顶指针融为一体 对于链栈来说，基本不存在栈满的情况(除非内存耗尽/死机) 栈顶指针(top) = NULL时，表示空栈 栈的链式存储结构定义如下： 12345678910111213//类似单链表的结构定义：LinkStackPtr(Ptr，Pointer Recod 表指针含义)typedef struct StackNode&#123; SElemType data; struct StackNode *next;&#125;StackNode,*LinkStackPtr;//再创建一个top结点typedef struct LinkStack &#123; LinkStackPtr top;//每一个结点是否被定义为头结点 int count;//链的长度&#125;LinkStack; 链栈的进栈操作思路： 链式结构一般不用考虑插入是否已满 创建新结点 通过“头插法”(让首结点成为新结点的next，然后新结点成为首结点)即新元素只与头结点(栈顶/top)交换 修改count数值 返回OK 12345678910/* 插入元素e为新的栈顶元素 */Status Push(LinkStack *S,SElemType e)&#123; LinkStackPtr s=(LinkStackPtr)malloc(sizeof(StackNode)); s-&gt;data=e; s-&gt;next=S-&gt;top; /* 把当前的栈顶元素赋值给新结点的直接后继*/ S-&gt;top=s; /* 将新的结点s赋值给栈顶指针，见图中② */ S-&gt;count++; return OK;&#125; 链栈的出栈操作思路： 若栈为空，则无元素可出栈 创建暂存结点变量 改变top指向，释放暂存结点 返回OK 12345678910111213141516171819202122/* 若栈S为空栈，则返回TRUE，否则返回FALSE */Status StackEmpty(LinkStack S)&#123; if (S.count==0) return TRUE; else return FALSE;&#125;/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */Status Pop(LinkStack *S,SElemType *e)&#123; LinkStackPtr p; if(StackEmpty(*S)) return ERROR; LinkStackPtr p = S-&gt;top; //将栈顶结点赋值给p *e = p-&gt;data; //返回即将出栈元素值 S-&gt;top = p-&gt;next;//修改top结点指向 free(p); //释放结点 S-&gt;count--; return OK;&#125; 小结 顺序栈和链栈的时间复杂度都是O(1) 顺序栈在元素定位上相比链栈更节省内存开销，但需事先确定一个固定长度 链栈则无长度限制 因此，如果栈的使用过程中元素不可预料，有时很小，有时很大，那么最好使用栈链 反之，如果它的变化在可控范围内，使用顺序栈会更好一些 栈的应用前言栈的引入主要是将问题划分了不同的关注层次，使得思考范围进一步缩小，更加聚焦于我们解决问题的核心。从而简化了程序设计的问题，反之，使用传统“万金油”数组下标操作，则会使我们分散精力去处理一些琐碎的细节问题，反而掩盖了问题的本质。 栈的应用——递归递归的概念递归函数：直接调用自己或通过一系列调用语句间接地调用自己的函数 斐波那契数列的实现斐波那契数列(Fibonacci)：如 “1，1，2，3，5，8，13…” 这种前面相邻两项之和，构成了后一项的序列。 常规迭代方法123456789101112131415/*常规的迭代办法实现前40位Fibonacci数列 */void Fibonacci_Common() &#123; int f[40]; f[0] = 0; f[1] = 1; printf(&quot;%d \\n&quot;, f[0]);//输出首个Fibonacci数字 printf(&quot;%d \\n&quot;, f[1]);//输出第二个Fibonacci数字 int i; for (i = 2; i &lt; 40; i++) &#123; f[i] = f[i - 1] + f[i - 2]; printf(&quot;%d \\n&quot;, f[i]); &#125;&#125; 递归方式实现 从实际存在递归/重复规律的实际问题出发 递归的核心在于：每一次的结果都是需要通过函数调用的方式回退到规律的起点 通过函数return的自然机制递归出每一次的结果 将实际问题的递归规律通过数学函数表示出来(完成递归函数的百分之80) 将数学函数通过代码的形式表达出来 通过递归的方式实现代码如下： 1234567891011121314/*斐波那契的递归函数*/int Fbi(int i) &#123; if( i &lt; 2 ) return i == 0 ? 0 : 1; return Fbi(i - 1) + Fbi(i - 2); /* 这里Fbi就是函数自己，等于在调用自己 */&#125; int main()&#123; int i; for(i = 0;i &lt; 40;i++) printf(&quot;%d &quot;, Fbi(i)); return 0;&#125; 递归和迭代的区别 递归：递归使用选择结构 优点：递归能使程序结构更清晰，更简洁、容易理解，减少读代码时间 缺点：大量的递归调用回建立函数的副本，耗费大量的时间和内存 迭代：迭代使用循环结构 优点：迭代无需反复调用函数和占用额外内存 缺点：代码复杂，程序结构不利于代码的阅读 栈在递归里的应用递归函数的执行特点是： “先回退(前行)，后递归(退回)”即退回和前行两个阶段。而且这两个执行阶段互为逆序 在递归(退回)的过程中，需要不断执行且恢复前行过程中存储起来的某些数据 对于这种先不断前行执行，后又以其逆序的方式恢复这些数据的数据结构，符合栈这样的特点。因此底层的编译器常使用栈实现函数的递归操作。 简单的说，就是在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。 当然，对于现在的高级语言，这样的递归问题是不需要用户来管理这个栈的，一切都由系统代劳了。 栈的应用——四则运算表达式求值后缀表达式(逆波兰)法定义 中缀表达式：形如 “ 9 + (3 - 1) X 3 + 10 ÷ 2 ” 标准的四则运算表达式，所有运算符号都在两数字中间。 对于计算机来说，中缀表达式这种具有括号，乘除加减的复杂四则运算，计算机是不能马上识别出真确的运算顺序，而对于计算机如何实现数学表达式的求职。提出了一种新的表达法——后缀表达法。 后缀表达法(逆波兰)(Reverse Polish Notation，RPN)：是一种不需要括号,所有符号都是在要运算数字的后面出现。 如： “ 9 + (3 - 1) X 3 + 10 ÷ 2 ”的后缀表达式为， “ 9 3 1 - 3 * + 10 2 / + ” 栈的应用——中缀表达式转后缀表达式核心：栈是用来进出运算的符号 数字直接输出 入栈： 未匹配的左括号，优先级高于栈顶符号 低优先级出栈机制结束后再进栈 出栈： 右括号，出栈到与之匹配的左括号为止 低优先级符号出栈直至有比原顶栈符号优先级更低的为止，最后再将其低优先级符号入栈 中缀表达式处理完毕，则输出栈内剩下的所有符号 注意：” ( ) “括号参与出入栈，但不表示在表达式中 具体推导的图示过程，可查看本读物 p108~p110 栈的应用——后缀表达式的计算核心：栈是用来进出运算的数字 后缀表达式在计算机中的具体运算规则如下： 从左到右遍历表达式的每个数字和符号 遇到数字就进栈 遇到符号就把处于栈顶的两个数字出栈，进行运算。把运算结构进栈 直至处理完毕得到最终结果为止 具体推导的图示过程，可查看本读物 p106~p108","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 第三章 循环链表&双向链表","slug":"数据结构 第三章 循环链表&双向链表","date":"2020-09-17T09:12:32.000Z","updated":"2020-10-11T12:25:04.610Z","comments":true,"path":"2020/09/17/数据结构 第三章 循环链表&双向链表/","link":"","permalink":"http://yoursite.com/2020/09/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8&%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲 循环链表 双向链表 小结 循环链表基本概念单循环链表(circular linked)： 将单链表的终端结点指针端口由空指针改为指向头结点，是整个单链表形成一个环。 相对单链表，循环链表可以实现从任意一个结点出发，可访问到链表的全部结点的操作。 为了方便操作，循环链表为空链表时，头结点的指针域也“循环”地指向自己。如下图所示： 实际应用​ 而实际应用中，很多操作是在表的首或尾两端进行。传统单链表使用的头指针在首部操作时间复杂度为O(1)，而尾部操作时间复杂度则为O(n)。 此时，不设置头结点，而是借助”循环”本身的特性，通过设置终端结点的尾指针(rear)**，实现对首尾的高效操作**。 对于终端结点复杂度即为O(1)，对于头结点即rear-&gt;next，头指针即rear-&gt;next-&gt;next，复杂度均为O(1) 循环链表没有增加任何存储量，仅对链接方式稍作改变，因此基本操作的实现与链表相似。如ListLength、GetElem、LocateElem等这些操作只要设计一个方向的指针即可，另一个指针多了也不能提供什么帮助。 合并循环链表通过尾指针链接两个循环链表 123456p = rearA-&gt;next; /* 保存A表的头结点*/ rearA-&gt;next = rearB-&gt;next-&gt;next; /*将本是指向B表的第一个结点（不是头结点） */ /* 赋值给reaA-&gt;next，即*/q = rearB-&gt;next; rearB-&gt;next = p; /* 将原A表的头结点赋值给rearB-&gt;next，即③ */free(q); /* 释放q*/ 双向链表定义及其初始化双向链表(double linked list)**：是在单链表的每个结点中，在设置一个指向其前驱结点**的指针域。定义如下： 123456/*线性表的双向链表存储结构*/typedef struct DulNode&#123; ElemType data; struct DulNode *prior; struct DulNode *next;&#125;DulNode,*DuLinkList; 双链表的插入相对于单链表的插入操作，双链表的插入需要修改4个指针。关键修改代码如下(在结点p的后面插入一个新结点s)： 1234s-&gt;prior = p;s-&gt;next = p-&gt;next;p-&gt;next-&gt;prior = s;p-&gt;next = s; 双链表的删除因为有两个指针域，在指向调整上更加灵活。若p指向待删除结点，则删除的关键代码部分如下(未被验证)： 12p-&gt;prior-&gt;next = p-&gt;next;p-&gt;next-&gt;prior = p-&gt;prior; 小结 双向链表先对于单链表来说，更加复杂，对于对于插入和删除时，需要歌外注意 双向链表有两个指针域，因此空间上占用略多一些 由于双向链表有良好的对称性，使得对某个结点的前后结点操作带来了方便 因此总的来说，双向链表通过复杂的设计用空间效率在某种情况下换取了时间效率","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"mysql基础总结","slug":"mysql基础总结","date":"2020-09-17T03:40:32.000Z","updated":"2020-09-17T06:22:52.375Z","comments":true,"path":"2020/09/17/mysql基础总结/","link":"","permalink":"http://yoursite.com/2020/09/17/mysql%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/","excerpt":"","text":"本单元目标12345678910111213141516171819202122232425262728293031323334353637一、为什么要学习数据库二、数据库的相关概念 DBMS、DB、SQL三、数据库存储数据的特点四、初始MySQL MySQL产品的介绍 MySQL产品的安装 ★ MySQL服务的启动和停止 ★ MySQL服务的登录和退出 ★ MySQL的常见命令和语法规范 五、DQL语言的学习 ★ 基础查询 ★ 条件查询 ★ 排序查询 ★ 常见函数 ★ 分组函数 ★ 分组查询 ★ 连接查询 ★ 子查询 √ 分页查询 ★ union联合查询 √ 六、DML语言的学习 ★ 插入语句 修改语句 删除语句 七、DDL语言的学习 库和表的管理 √ 常见数据类型介绍 √ 常见约束 √ 八、TCL语言的学习 事务和事务处理 九、视图的讲解 √十、变量 十一、存储过程和函数 十二、流程控制结构 数据库的好处121.持久化数据到本地2.可以实现结构化查询，方便管理 数据库相关概念1231、DB：数据库，保存一组有组织的数据的容器2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据3、SQL:结构化查询语言，用于和DBMS通信的语言 数据库存储数据的特点123451、将数据放到表中，表再放到库中2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”5、表中的数据是按行存储的，每一行类似于java中的“对象”。 MySQL产品的介绍和安装MySQL服务的启动和停止1234方式一：计算机——右击管理——服务方式二：通过管理员身份运行net start 服务名（启动服务）net stop 服务名（停止服务） MySQL服务的登录和退出123456789方式一：通过mysql自带的客户端只限于root用户方式二：通过windows自带的客户端登录：mysql 【-h主机名 -P端口号 】-u用户名 -p密码退出：exit或ctrl+C MySQL的常见命令12345678910111213141516171819202122232425261.查看当前所有的数据库show databases;2.打开指定的库use 库名3.查看当前库的所有表show tables;4.查看其它库的所有表show tables from 库名;5.创建表create table 表名( 列名 列类型, 列名 列类型， 。。。);6.查看表结构desc 表名;7.查看服务器的版本方式一：登录到mysql服务端select version();方式二：没有登录到mysql服务端mysql --version或mysql --V MySQL的语法规范12345671.不区分大小写,但建议关键字大写，表名、列名小写2.每条命令最好用分号结尾3.每条命令根据需要，可以进行缩进 或换行4.注释 单行注释：#注释文字 单行注释：-- 注释文字 多行注释：&#x2F;* 注释文字 *&#x2F; SQL的语言分类12345678DQL（Data Query Language）：数据查询语言 select DML(Data Manipulate Language):数据操作语言 insert 、update、deleteDDL（Data Define Languge）：数据定义语言 create、drop、alterTCL（Transaction Control Language）：事务控制语言 commit、rollback SQL的常见命令1234567891011show databases； 查看所有的数据库use 库名； 打开指定 的库show tables ; 显示库中的所有表show tables from 库名;显示指定库中的所有表create table 表名( 字段名 字段类型, 字段名 字段类型); 创建表desc 表名; 查看指定表的结构select * from 表名;显示表中的所有数据 DQL语言的学习进阶1：基础查询12345678语法：SELECT 要查询的东西【FROM 表名】;类似于Java中 :System.out.println(要打印的东西);特点：①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数 进阶2：条件查询1234567891011121314151617181920212223242526条件查询：根据条件过滤原始表的数据，查询到想要的数据语法：select 要查询的字段|表达式|常量值|函数from 表where 条件 ;分类：一、条件表达式 示例：salary&gt;10000 条件运算符： &gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D; !&#x3D; &lt;&gt;二、逻辑表达式示例：salary&gt;10000 &amp;&amp; salary&lt;20000逻辑运算符： and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false or(||)：两个条件只要有一个成立，结果为true，否则为false not(!)：如果条件成立，则not后为false，否则为true三、模糊查询示例：last_name like &#39;a%&#39; 进阶3：排序查询123456789语法：select 要查询的东西from 表where 条件order by 排序的字段|表达式|函数|别名 【asc|desc】 进阶4：常见函数1234567891011121314151617181920212223242526272829303132333435363738一、单行函数1、字符函数 concat拼接 substr截取子串 upper转换成大写 lower转换成小写 trim去前后指定的空格和字符 ltrim去左边空格 rtrim去右边空格 replace替换 lpad左填充 rpad右填充 instr返回子串第一次出现的索引 length 获取字节个数2、数学函数 round 四舍五入 rand 随机数 floor向下取整 ceil向上取整 mod取余 truncate截断3、日期函数 now当前系统日期+时间 curdate当前系统日期 curtime当前系统时间 str_to_date 将字符转换成日期 date_format将日期转换成字符4、流程控制函数 if 处理双分支 case语句 处理多分支 情况1：处理等值判断 情况2：处理条件判断5、其他函数 version版本 database当前库 user当前连接用户 二、分组函数 123456789101112131415sum 求和max 最大值min 最小值avg 平均值count 计数特点：1、以上五个分组函数都忽略null值，除了count(*)2、sum和avg一般用于处理数值型 max、min、count可以处理任何数据类型3、都可以搭配distinct使用，用于统计去重后的结果4、count的参数可以支持： 字段、*、常量值，一般放1 建议使用 count(*) 进阶5：分组查询1234567891011121314151617语法：select 查询的字段，分组函数from 表group by 分组的字段特点：1、可以按单个字段分组2、和分组函数一同查询的字段最好是分组后的字段3、分组筛选 针对的表 位置 关键字分组前筛选： 原始表 group by的前面 where分组后筛选： 分组后的结果集 group by的后面 having4、可以按多个字段分组，字段之间用逗号隔开5、可以支持排序6、having后可以支持别名 进阶6：多表连接查询12笛卡尔乘积：如果连接条件省略或无效则会出现解决办法：添加上连接条件 一、传统模式下的连接 ：等值连接——非等值连接 12341.等值连接的结果 &#x3D; 多个表的交集2.n表连接，至少需要n-1个连接条件3.多个表不分主次，没有顺序要求4.一般为表起别名，提高阅读性和性能 二、sql99语法：通过join关键字实现连接 123456789101112131415161718含义：1999年推出的sql语法支持：等值连接、非等值连接 （内连接）外连接交叉连接语法：select 字段，...from 表1【inner|left outer|right outer|cross】join 表2 on 连接条件【inner|left outer|right outer|cross】join 表3 on 连接条件【where 筛选条件】【group by 分组字段】【having 分组后的筛选条件】【order by 排序的字段或表达式】好处：语句上，连接条件和筛选条件实现了分离，简洁明了！ 三、自连接 案例：查询员工名和直接上级的名称 sql99 123SELECT e.last_name,m.last_nameFROM employees eJOIN employees m ON e.&#96;manager_id&#96;&#x3D;m.&#96;employee_id&#96;; sql92 123SELECT e.last_name,m.last_nameFROM employees e,employees m WHERE e.&#96;manager_id&#96;&#x3D;m.&#96;employee_id&#96;; 进阶7：子查询含义： 12一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询 特点： 123456789101112131415161、子查询都放在小括号内2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧3、子查询优先于主查询执行，主查询使用了子查询的执行结果4、子查询根据查询结果的行数不同分为以下两类：① 单行子查询 结果集只有一行 一般搭配单行操作符使用：&gt; &lt; &#x3D; &lt;&gt; &gt;&#x3D; &lt;&#x3D; 非法使用子查询的情况： a、子查询的结果为一组值 b、子查询的结果为空② 多行子查询 结果集有多行 一般搭配多行操作符使用：any、all、in、not in in： 属于子查询结果中的任意一个就行 any和all往往可以用其他查询代替 进阶8：分页查询应用场景： 1实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句 语法： 1234567select 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 【起始的条目索引，】条目数; 特点： 123456781.起始条目索引从0开始2.limit子句放在查询语句的最后3.公式：select * from 表 limit （page-1）*sizePerPage,sizePerPage假如:每页显示条目数sizePerPage要显示的页数 page 进阶9：联合查询引入： union 联合、合并 语法： 12345select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】.....select 字段|常量|表达式|函数 【from 表】 【where 条件】 特点： 1231、多条查询语句的查询的列数必须是一致的2、多条查询语句的查询的列的类型几乎相同3、union代表去重，union all代表不去重 DML语言插入语法： insert into 表名(字段名，…) values(值1，…); 特点： 123451、字段类型和值类型一致或兼容，而且一一对应2、可以为空的字段，可以不用插入值，或用null填充3、不可以为空的字段，必须插入值4、字段个数和值的个数必须一致5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致 修改修改单表语法： 12update 表名 set 字段&#x3D;新值,字段&#x3D;新值【where 条件】 修改多表语法： 1234update 表1 别名1,表2 别名2set 字段&#x3D;新值，字段&#x3D;新值where 连接条件and 筛选条件 删除方式1：delete语句 单表的删除： ★ delete from 表名 【where 筛选条件】 多表的删除： delete 别名1，别名2 from 表1 别名1，表2 别名2 where 连接条件 and 筛选条件; 方式2：truncate语句 1truncate table 表名 两种方式的区别【面试题】 12345678#1.truncate不能加where条件，而delete可以加where条件#2.truncate的效率高一丢丢#3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始#delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始#4.truncate删除不能回滚，delete删除可以回滚 DDL语句库和表的管理库的管理： 1234一、创建库create database 库名二、删除库drop database 库名 表的管理： #1.创建表 12345678910111213141516171819202122232425262728293031CREATE TABLE IF NOT EXISTS stuinfo( stuId INT, stuName VARCHAR(20), gender CHAR, bornDate DATETIME);DESC studentinfo;#2.修改表 alter语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;#①修改字段名ALTER TABLE studentinfo CHANGE COLUMN sex gender CHAR;#②修改表名ALTER TABLE stuinfo RENAME [TO] studentinfo;#③修改字段类型和列级约束ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;#④添加字段ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;#⑤删除字段ALTER TABLE studentinfo DROP COLUMN email;#3.删除表DROP TABLE [IF EXISTS] studentinfo; 常见类型12345678整型：小数： 浮点型 定点型字符型：日期型：Blob类型： 常见约束123456NOT NULLDEFAULTUNIQUECHECKPRIMARY KEYFOREIGN KEY 数据库事务含义1通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态 特点12345（ACID）原子性：要么都执行，要么都回滚一致性：保证数据的状态操作前和操作后保持一致隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改 相关步骤： 1231、开启事务2、编写事务的一组逻辑操作单元（多条sql语句）3、提交事务或回滚事务 事务的分类：隐式事务，没有明显的开启和结束事务的标志 12比如insert、update、delete语句本身就是一个事务 显式事务，具有明显的开启和结束事务的标志 1234567891、开启事务取消自动提交事务的功能2、编写事务的一组逻辑操作单元（多条sql语句）insertupdatedelete3、提交事务或回滚事务 使用到的关键字12345678set autocommit&#x3D;0;start transaction;commit;rollback;savepoint 断点commit to 断点rollback to 断点 事务的隔离级别:事务并发问题如何发生？ 1当多个事务同时操作同一个数据库的相同数据时 事务的并发问题有哪些？ 123脏读：一个事务读取到了另外一个事务未提交的数据不可重复读：同一个事务中，多次读取到的数据不一致幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据 如何避免事务的并发问题？ 12345通过设置事务的隔离级别1、READ UNCOMMITTED2、READ COMMITTED 可以避免脏读3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读4、SERIALIZABLE可以避免脏读、不可重复读和幻读 设置隔离级别： 1set session|global transaction isolation level 隔离级别名; 查看隔离级别： 1select @@tx_isolation; 视图含义：理解成一张虚拟的表 视图和表的区别： 12345 使用方式 占用物理空间视图 完全相同 不占用，仅仅保存的是sql逻辑表 完全相同 占用 视图的好处： 121、sql语句提高重用性，效率高2、和表实现了分离，提高了安全性 视图的创建1234语法：CREATE VIEW 视图名AS查询语句; 视图的增删改查1234567891011121314151、查看视图的数据 ★SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name&#x3D;&#39;Partners&#39;;2、插入视图的数据INSERT INTO my_v4(last_name,department_id) VALUES(&#39;虚竹&#39;,90);3、修改视图的数据UPDATE my_v4 SET last_name &#x3D;&#39;梦姑&#39; WHERE last_name&#x3D;&#39;虚竹&#39;;4、删除视图的数据DELETE FROM my_v4; 某些视图不能更新123456包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union all常量视图Select中包含子查询joinfrom一个不能更新的视图where子句的子查询引用了from子句中的表 视图逻辑的更新123456789101112#方式一：CREATE OR REPLACE VIEW test_v7ASSELECT last_name FROM employeesWHERE employee_id&gt;100;#方式二:ALTER VIEW test_v7ASSELECT employee_id FROM employees;SELECT * FROM test_v7; 视图的删除1DROP VIEW test_v1,test_v2,test_v3; 视图结构的查看12DESC test_v7;SHOW CREATE VIEW test_v7; 存储过程含义：一组经过预先编译的sql语句的集合 好处： 1231、提高了sql语句的重用性，减少了开发程序员的压力2、提高了效率3、减少了传输次数 分类： 1234561、无返回无参2、仅仅带in类型，无返回有参3、仅仅带out类型，有返回无参4、既带in又带out，有返回有参5、带inout，有返回有参注意：in、out、inout都可以在一个存储过程中带多个 创建存储过程语法： 12345create procedure 存储过程名(in|out|inout 参数名 参数类型,...)begin 存储过程体end 类似于方法： 1234修饰符 返回类型 方法名(参数类型 参数名,...)&#123; 方法体;&#125; 注意 1234567891011121314151617181、需要设置新的结束标记delimiter 新的结束标记示例：delimiter $CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)BEGIN sql语句1; sql语句2;END $2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end3、参数前面的符号的意思in:该参数只能作为输入 （该参数不能做返回值）out：该参数只能作为输出（该参数只能做返回值）inout：既能做输入又能做输出 调用存储过程1call 存储过程名(实参列表) 函数创建函数学过的函数：LENGTH、SUBSTR、CONCAT等 语法： 12345CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型BEGIN 函数体END 调用函数1SELECT 函数名（实参列表） 函数和存储过程的区别123 关键字 调用语法 返回值 应用场景函数 FUNCTION SELECT 函数() 只能是一个 一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个存储过程 PROCEDURE CALL 存储过程() 可以有0个或多个 一般用于更新 流程控制结构系统变量一、全局变量 作用域：针对于所有会话（连接）有效，但不能跨重启 123456789查看所有全局变量SHOW GLOBAL VARIABLES;查看满足条件的部分系统变量SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;查看指定的系统变量的值SELECT @@global.autocommit;为某个系统变量赋值SET @@global.autocommit&#x3D;0;SET GLOBAL autocommit&#x3D;0; 二、会话变量 作用域：针对于当前会话（连接）有效 12345678910查看所有会话变量SHOW SESSION VARIABLES;查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;查看指定的会话变量的值SELECT @@autocommit;SELECT @@session.tx_isolation;为某个会话变量赋值SET @@session.tx_isolation&#x3D;&#39;read-uncommitted&#39;;SET SESSION tx_isolation&#x3D;&#39;read-committed&#39;; 自定义变量一、用户变量 声明并初始化： 123SET @变量名&#x3D;值;SET @变量名:&#x3D;值;SELECT @变量名:&#x3D;值; 赋值： 123456789方式一：一般用于赋简单的值SET 变量名&#x3D;值;SET 变量名:&#x3D;值;SELECT 变量名:&#x3D;值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表; 使用： 1select @变量名; 二、局部变量 声明： 1declare 变量名 类型 【default 值】; 赋值： 123456789方式一：一般用于赋简单的值SET 变量名&#x3D;值;SET 变量名:&#x3D;值;SELECT 变量名:&#x3D;值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表; 使用： 1select 变量名 二者的区别： 1作用域 定义位置 语法 用户变量 当前会话 会话的任何地方 加@符号，不用指定类型 局部变量 定义它的BEGIN END中 BEGIN END的第一句话 一般不用加@,需要指定类型 分支一、if函数 语法：if(条件，值1，值2) 特点：可以用在任何位置 二、case语句 语法： 123456789101112131415情况一：类似于switchcase 表达式when 值1 then 结果1或语句1(如果是语句，需要加分号) when 值2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）情况二：类似于多重ifcase when 条件1 then 结果1或语句1(如果是语句，需要加分号) when 条件2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要） 特点： 可以用在任何位置 三、if elseif语句 语法： 12345if 情况1 then 语句1;elseif 情况2 then 语句2;...else 语句n;end if; 特点： 只能用在begin end中！！！！！！！！！！！！！！！ 三者比较： 应用场合 if函数 简单双分支 case结构 等值判断 的多分支 if结构 区间判断 的多分支 循环语法： 123【标签：】WHILE 循环条件 DO 循环体END WHILE 【标签】; 特点： 12345只能放在BEGIN END里面如果要搭配leave跳转语句，需要使用标签，否则可以不用标签leave类似于java中的break语句，跳出所在循环！！！ 引用：尚硅谷—mysql基础语法总结","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"数据结构 第三章 静态链表","slug":"数据结构 第三章 静态链表","date":"2020-09-09T13:38:32.000Z","updated":"2020-09-16T08:46:29.418Z","comments":true,"path":"2020/09/09/数据结构 第三章 静态链表/","link":"","permalink":"http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲 基本概念 静态链表的初始化 静态链表的插入操作 小结 基本概念 静态链表：用数组描述的链表叫做静态链表。 如Basic、Fortran等早期编程语言，没有指针，就可通过数组实现链表结构(游标实现法)。 静态链表使用两个数据域组成，分别叫data、cur，cur类似单链表中的next。不记录指针，而是记录后继元素的数组下标。 123456/*线性表的静态链表存储结构*/#define MAXSIZE 1000typedef struct&#123; ElemType data; int cur; /*游标(Cursor)，为0时表示无指向*/&#125; 静态链表的第一个和最后一个元素作为特殊处理，不存数据。 未被使用的数组元素称为备用链表。 下标为0的第一个元素cur称为头指针，用于存放备用链表的下标。 数组最后一个元素的cur，存放第一个有数值元素的下标(相当于头结点)。 静态链表初始化123456789/*将一维数组space中各个分量链成一备用链表*/Status InitList(StaticLinkList space)&#123; int i; for(i = 0; i &lt; MAXSIZE - 1; i++)/*为链表所有元素cur赋值，将其中各个分量链成一备用链表*/ space[i] = i + 1; space[MAXSIZE - 1].cur = 0; /*目前链表为空，最后一个元素的cur为0*/ return OK;&#125; 静态链表的插入操作链表的插入/删除操作都需要调用存储空间的申请/释放函数。标准定义的malloc，free函数直接调用就可自动申请或释放空间。对于通过数组实现链表功能的静态链表实现插入/删除操作首先要解决的问题：如何用**静态模拟动态链表对存储空间的分配/管理(申请/释放)**。需要时申请、无用时释放。 Malloc_SSL 因此静态链表需要自己实现单链表的malloc函数功能。 功能描述：若备用空间链表非空，则返回可分配的结点下标(类似向内存申请空间，返回地址值)，否则返回0。 实现思路： 静态链表设计本身然下标为0的元素存放备用链表的下标，所以直接返回下标0的cur即可。 同时，需要把即将返回的备用链表的cur值重新填充到下标为0的cur，为下次分配使用。 12345678910/*若备用空间链表非空，则返回可分配的结点下标，否则返回0*/int Malloc_SSL(StaticLinkList space) &#123; int i = space[0].cur; /* 当前数组第一个元素的cur存的值 */ /* 就是要返回的第一个备用空闲的下标 */ if (space[0]. cur) space[0]. cur = space[i].cur; /* 由于要拿出一个分量来使用了， */ /* 所以我们就得把它的下一个 */ /* 分量用来做备用 */ return i;&#125; ListInsert思路： 基本插入错误过滤 获取空闲分量下标 填充数据域 定位前继结点 头插法 12345678910111213141516171819202122Status ListInsert(StaticLinkList L, int i, ElemType e) &#123; if (i &lt; 1 || i &gt; ListLength(L) + 1) //若链表已满 return ERROR; int j = Malloc_SLL(L); //获得空闲分量的下标 if (j) &#123; L[j].data = e;//将数据赋值给此分量的data int k = MAXSIZE -1,l; //找到插入位置的前继元素，(计数器+while+工作指针后移) //静态链表的头结点在尾部 for (l = 1; l &lt;= i - 1; l++) k = L[k].cur; L[j].cur = L[k].cur;//改变游标指向(头插法) L[k].cur = j; //先把前继节点的后继游标传给新节点的后继游标 return OK; &#125; return ERROR; //若获取分量失败则返回错误 &#125; 注意： 获取头结点下标：int k = MAXSIZE -1 Free_SSL同样，静态链表实现删除操作也要先实现free函数 1234567/*将下标为k的空闲结点回收到备用链表*/void Free_SSL(StaticLinkList space, int k) &#123; space[k].cur = space[0].cur; //让即将要删除的位置成为第一个优先的空位 space[0].cur = k; //即删除节点与备用链表交换两个参数&#125; ListDelete12345678910111213141516Status ListDelete(StaticLinkList L, int i) &#123; if (i &lt; 1 || i &gt; ListLength(L))//删除索引过滤 return ERROR; int k = MAXSIZE - 1; int l; for (l = 1; l &lt;= i -1; l++) //定位前继节点 k = L[k].cur; int d = L[k].cur;//创建临时变量存储欲删除cur L[k].cur = L[d].cur; Free_SSL(L,d); return OK;&#125; 小结静态链表其实为了给没有指针的高级语言设计的一种实现单链表能力的方法。特性与单链表类似，尽管以后这种方法不一定用上，但这样的思考方式是非常巧妙的。","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"将hexo发布在gitee教程","slug":"将hexo发布在gitee","date":"2020-09-07T07:38:32.000Z","updated":"2020-09-08T08:36:37.251Z","comments":true,"path":"2020/09/07/将hexo发布在gitee/","link":"","permalink":"http://yoursite.com/2020/09/07/%E5%B0%86hexo%E5%8F%91%E5%B8%83%E5%9C%A8gitee/","excerpt":"","text":"前提 已经安装hexo，并且能够通过hexo d命令推送到GitHub实现远程推送。 实现方案具体可参考《基于Hexo框架的博客搭建及其GitHub部署》 已经注册Gitee账号并且绑定手机。 Gitee新建仓库 新建仓库时名称最好是保持跟你注册时的个人空间地址是一样的。因为这样你就不会生成二级域名了。如果不跟注册时的个人空间地址一样的话，到时候自己的网站就会有二级域名的存在了。 输入仓库名称与路径后会在“归属”一栏下生成一个仓库链接，记录下来为之后的_config.yml文件配置做准备 _config.yml文件配置修改配置文件中repo 属性为：{仓库地址} .git 仓库地址在创建仓库的时候会显示，或者在刚创建完的时候浏览器的url就是仓库地址 仓库地址一般组成： https://gitee.com/{个人空间名}/{仓库名称} 123456# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deploymentdeploy: type: &#39;git&#39; repo: &#123;仓库地址&#125;.git branch: master repo: https://gitee.com/yihangdeng/yihangdeng.git 修改配置保存后，可以像推送到GitHub上那样，通过hexo d命令上传到gitee。刷新gitee仓库查看是否有内容 开启仓库page服务 进入页面后直接点击启动即可。 启动完成后会生成网站地址，这个网站地址就是访问你博客的地址。 gitee page 只有付费版才能自动更新，免费版只能手动点击 “设置” 中的更新按钮更新部署。 参考链接 gitee：https://www.cnblogs.com/chaojilaoshi/p/13266271.html gitee：https://www.jianshu.com/p/5014133ba61a page更新：https://www.jianshu.com/p/6460df84a099","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"数据结构 第三章 单链表","slug":"数据结构 第三章 单链表","date":"2020-09-05T14:38:32.000Z","updated":"2020-09-29T08:06:30.394Z","comments":true,"path":"2020/09/05/数据结构 第三章 单链表/","link":"","permalink":"http://yoursite.com/2020/09/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%8D%95%E9%93%BE%E8%A1%A8/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲 线性表链式存储结构定义 单链表的创建 单链表的读取 单链表的插入和删除 总结 线性表链式存储结构定义基本概念为保持线性结构“前驱后继，一对一”逻辑结构前提下，同时避免顺序存储结构中对相邻关系的依赖性。链式结构，除了要存数据元素信息外，还要存储它的后继元素的存储地址。 数据域：存储数据元素信息的域 指针域：存储直接后继位置的域，其中存储的信息称做指针或链 结点(Node)：数据域和指针域组成数据元素ai的存储映像 链表：由n个结点链成的一个链表 单链表：链表中的每个结点只包含一个指针域 单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起，如图所示： 线性表链式存储结构代码描述 相关规定，线性链表的最后一个结点为“空”(用NULL或“^”符号表示) 头结点：在单链表的第一个结点前附设的一个结点，指针域指向第一个结点，若指针域为“空”，表示线性表为空 头结点主要作用是为便于对链表进行统一操作，头结点的数据域可不存储信息，或者存储线性表长度等附加信息。 单链表的定义123456//线性表的单链表存储结构typedef struct Node &#123; ElemType data; struct Node *next;&#125;Node;typedef struct Node *LinkList;//定义LinkList，指针变量的typedef typedef struct Node &#123;...&#125;Node;中的Node同名对象(实例)Node的作用：常用于为sizeof()函数传参。 typedef struct Node *LinkList; 语法理解：如typedef int Status; ‘Status‘等价于int，在这里可以看作类似变量的声明，即 声明一个int类型变量Status int Status，而int *Status表示定义一个int型的指针变量。同样类比在typedef中，“*”表示typedef的对象是Node 结构体的指针变量，即LinkList 等价于 struct Node *linkList; (不过写法上确实有点新颖，有点融合着写) 单链表的读取工作指针：对于链表的元素定位操作，常常需要通过计数器从头到尾遍历计数而确定某一元素位置的指针，而“从头”不能直接用头结点直接指针后移遍历的，因为这样会失去了头结点原本的意义与功能。 因此常声明一个变量p存储头结点指针域来完成之后的指针偏移遍历操作，一般将这个从头开始复杂遍历的指针称为工作指针 “工作指针后移”则是工作指针通常的工作状态。 GetElem思路： 声明一个工作指针 p，指向链表的第一个结点(查询不查头结点)。 设置计时器变量 j，并初始化为1，通过重新数数的方式找到序号位置。 当j&lt;i时，遍历链表，让p的指针向后移动，称为“工作指针后移”，计时器j累加1. 若到链表末尾p为空，则说明第i个结点不存在。 否则查找成功，返回结点p的数据。 123456789101112131415161718/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) *//* 操作结果：用e返回L中第i个数据元素的值 */Status GetElem(LinkList L,int i,ElemType *e)&#123; //--------------查询部分--------------- int j; LinkList p; /* 声明工作指针p */ p = L-&gt;next; /* 让p指向链表L的第一个结点 */ j = 1; /* j为计数器 */ while (p &amp;&amp; j&lt;i)&#123; /* p不为空或者计数器j还没有等于i时，循环继续 */ p = p-&gt;next; /* 让p指向下一个结点 */ ++j; &#125; if ( !p || j&gt;i ) //注意这里是 大于 &gt; 符号 return ERROR; /* 第i个元素不存在 */ //--------------查询部分--------------- *e = p-&gt;data; /* 取第i个元素的数据 */ return OK;&#125; 链式存储没有表长，更加没有序号。事先不知循环次数，只能设置计数器，使用while循环解决; 最坏情况复杂度是O(n); 单链表的创建单链表的初始化单链表的初始化，即空表的建立 InitList123456789/* 初始化顺序线性表 */Status InitList(LinkList *L) &#123; *L=(LinkList)malloc(sizeof(Node)); /* 产生头结点(向内存申请一个结点的空间),并使L指向此头结点 */ if(!(*L)) /* 存储分配失败 */ return ERROR; (*L)-&gt;next=NULL; /* 指针域为空 */ return OK;&#125; malloc函数：void *malloc(long NumBytes)向内存申请NumBytes个字节的空间，并返回了指向这块内存的指针。若分配失败，则返回一个空指针(NULL）,如系统空间不足等失败情况。使用malloc函数需注意如下几点： 申请了内存空间后，必须检查是否分配成功。 当不需要再使用申请的内存时，记得释放；并把这块内存的指针指向NULL，防止程序后面不小心使用了它。 malloc与free这两个函数应该是配对使用。如果申请后不释放就是内存泄露；如果无故释放那就是什么也没有做。释放只能一次，如果释放两次及两次以上会出现错误（释放空指针例外，释放空指针其实也等于啥也没做，所以释放空指针释放多少次都没有问题）。 虽然malloc()函数的类型是(void *)，任何类型的指针都可以转换成(void *),但是最好还是在前面进行强制类型转换，因为这样可以躲过一些编译器的检查。 参考链接：malloc()和free()的基本概念以及基本用法 LinkList *L形参的理解： Status InitList(LinkList *L)注意，此时传入形参L已是二级指针(指针的指针)。 一级指针与二级指针的区别与使用： 形参传递永远是值传递(临时变量)，想要通过调用函数去改变传入实参的内容，则需要至少传入欲修改参数类型基础上的一级指针，并且通过“*” 调用实体内容进行修改。而并不能仅修改传入新参的内容，因为新参内容本身怎么修改都不会影响传入的实参。(值传递原则) 当传值时，只可以引用值而不可以改变值， 当你传指针时，只可以改变指针所指的内容，不可以改变指针本身 但传指针的指针时，即可以改变指针所指的内容，又可以改变指针本身 LinkList *L二级指针的用处：回归目的本身，很明确。即想要LinkList L;这个指针变量L最终指向通过malloc函数申请空间后返回的地址值(即地址的赋值)。理应L=malloc(sizeof(Node));即可，从一条语句操作上是完全正确的，类型也是一致的。但问题在于如今想要通过调用函数且把L作为实参传入修改其地址值。这样的前提下，若只传入想要修改内容类型的本身(这里就是指针变量/一级指针)，安装值传递原则是达不到效果的，代码如下所示： 12345678910111213Status InitList(LinkList L) &#123; //形参修改成一级指针 L = (LinkList)malloc(sizeof(Node)); if (!(L)) return ERROR; L-&gt;next = NULL; &#125;void main() &#123; LinkList L = NULL; InitList(L); if (L == NULL) printf(&quot;L=NULL&quot;);//最终L还是NULL被打印出来，没有被改变 getchar();&#125; “想要通过调用函数去改变传入实参的内容，则需要至少传入欲修改参数类型基础上的一级指针”，即先要修改指针值本身，则至少需要传入该参数类型上的一级指针，即指针的指针，这就是Status InitList(LinkList L) &#123;...&#125; 二级指针形参的意义。 参考链接： (C++)函数参数传递中的一级指针和二级指针 引用传递和值传递以及链表中的LinkList L、LinkList *L、LinkList &amp;L 单链表的整表创建单链表的整表创建又分为“头插法”，“尾插法”两种。 CreateListHead“头插法”即新结点的指针域通过修改i - 1结点的后继节点指向完成结点的插入。 123456789101112131415/* 随机产生n个元素的值，建立带表头结点的单链线性表L（头插法） */void CreateListHead(LinkList *L, int n) &#123; LinkList s;//初始化一个即将插入新结点 int i; srand(time(0)); /* 初始化(修改)随机数种子 */ *L = (LinkList)malloc(sizeof(Node)); (*L)-&gt;next = NULL; /* 先建立一个带头结点的单链表 */ for (i=0; i&lt;n; i++) &#123; s = (LinkList)malloc(sizeof(Node)); /* 生成新结点 */ s-&gt;data = rand()%100+1; /* 随机生成100以内的数字填充数据域 */ s-&gt;next = (*L)-&gt;next; (*L)-&gt;next = p; /* 插入到表头 */ &#125;&#125; srand函数与rand函数使用(stdio.h) void srand(unsigned int seed)：设置随机数种子 srand函数用来设置rand函数产生随机数时的随机数种子，参数seed必须是整数，通常可以用time(0)的返回值作为seed。如果每次seed都设置相同的值，rand()产生 一系列 随机数值每次都一样。当计算机正常开机后，随机种子的值是定了的，除非你破坏了系统，或者通过srand函数修改。 int rand(void)：生成随机数 在0到RAND_MAX之间的整数值生成一个随机数，rand的内部是用线性同余法做的，不是真的随机数，只不过因为其周期特别长，所以在一定范围内可以看成是随机的。(RAND_MAX的范围最少在32767之间（int），即双字节（16位）。若unsigned int双字节是65535) 参考链接：C语言的srand与rand函数浅谈 time函数的使用 函数原型：time_t time(time_t *seconds) time函数用于返回格林尼治时间(1970年1月1日00:00:00到当前时刻的时长)，单位是秒。存在与&lt;time.h&gt;库，一般使用方式t1=time(NULL) 或 t1=time(0)来获取当前格林尼治时间。 CreateListTail“尾插法”，符合日常排队思维，后到的排在后。为了方便操作，需要引入尾指针概念 尾指针： 功能：用于指向当前链表的终端结点 初始化：与头结点一致，均指向头指针。(类似队列初始化) 基于尾指针功能的插入逻辑： 12r-&gt;next = s;//英文尾指针就是指向链表的终端结点，而实现向后插入，则直接插入在尾结点后即可r = s; //而从尾指针后面插入的新元素必将是新的尾结点，所以把它定义为新的尾指针即可 CreateListTail尾插法实现代码如下： 123456789101112131415/* 随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */void CreateListTail(LinkList *L, int n) &#123; LinkList s,r; int i; srand(time(0)); /* 初始化随机数种子 */ *L = (LinkList)malloc(sizeof(Node)); /* L为整个线性表 */ r=*L; /* 尾指针初始化 */ for (i=0; i&lt;n; i++) &#123; s = (Node *)malloc(sizeof(Node)); /* 生成新结点 */ s-&gt;data = rand()%100+1; /* 随机生成100以内的数字 */ r-&gt;next=s; /* 将表尾终端结点的指针指向新结点 */ r = s; /* 将当前的新结点定义为表尾终端结点 */ &#125; r-&gt;next = NULL; /* 表示当前链表结束 */&#125; 除了首次循环r是头结点，其余r成为了永远的尾结点。 r = p;功能是，注意这里没有真正修改了地址值，而是局部变量顺应循环设计的循环变换，变换内容是将最新插入的结点成为下次循环的尾结点。 删除内容说明： 通过学习“《数据结构》——从概念到C++实现(第3版)” 认识实现结点从后面插入的逻辑实现原理是基于到对尾插法是利用尾指针功能的本身。—— 2020年9月26日 GetElem与链式插入操作小结工作指针： 常表定位指针，定位方式通常为工作指针后移 p = p-&gt;next; GetElem 头插法 尾插法 删除 初始为头指针，同步定位 i 初始为头结点，定位 i 的前继结点 同左 同左 LinkList p = L-&gt;next LinkList p = *L 同左 同左 tip：i 表示顺序表的位置 头插法实质：头插法：利用头指针“插入逻辑”进行插入的方法 插入逻辑：“逆序操作”，防止与当前操作结点的后继结点失去联系的操作 123s-&gt;next = p-&gt;next; //p表示工作指针，在插入操作，p是定位到i-1位置，即插入位置的前继结点。 //s表示即将插入的新结点p-&gt;next = s; 尾插法实质：尾插法：基于尾指针“功能”的插入逻辑进行插入的方法 功能：用于指向当前链表的终端结点 初始化：与头结点一致，均指向头指针。(类似队列初始化) 12r-&gt;next = s;//英文尾指针就是指向链表的终端结点，而实现向后插入，则直接插入在尾结点后即可r = s; //而从尾指针后面插入的新元素必将是新的尾结点，所以把它定义为新的尾指针即可 单链表的整表删除思路： 声明一结点p和q； 将第一个结点赋值给p； 循环： 将下一个结点赋值给q； 释放p； 将q赋值给p 123456789101112/* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */Status ClearList(LinkList *L)&#123; LinkList p,q; p=(*L)-&gt;next; /* p指向第一个结点 */ while(p)&#123; /* 没到表尾 */ q=p-&gt;next; free(p); p=q; &#125; (*L)-&gt;next=NULL; /* 头结点指针域为空 */ return OK;&#125; free函数，它的作用就是让系统回收一个Node结点，释放内存。 单链表的插入和删除ListInsert思路： 按照插入原理，首先需定位到i -1结点位置，即插入位置的前继结点，调整GetElem函数查询部分代码即可； 创建空节点s，并把数据元素e填充到数据域； 插入原理(头插法)：s-&gt;next = p-&gt;next; P-&gt;next=s;； 返回成功； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， *//* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */Status ListInsert(LinkList *L,int i,ElemType e)&#123; int j; LinkList p,s; p = *L; j = 1; while (p &amp;&amp; j &lt; i)&#123; /* 寻找第i-1个结点 */ p = p-&gt;next; ++j; &#125; if (!p || j &gt; i) return ERROR; /* 第i个元素不存在 */ s = (LinkList)malloc(sizeof(Node)); /* 生成新结点(C语言标准函数) */ s-&gt;data = e; s-&gt;next = p-&gt;next; /* 将p的后继结点赋值给s的后继 */ p-&gt;next = s; /* 将s赋值给p的后继 */ return OK;&#125;**要点**：- ListInsert函数巧妙将p赋值为**头结点地址**`p = *L;`来实现定位**i - 1**结点位置功能(插入位置的前继结点)。有别于GetElem函数`p = (*L)-&gt;next;`。- 插入原理：新结点的指针域通过**修改i - 1结点的后继节点指向**完成结点的插入。- 插入原理的两条语句**不能颠倒执行顺序**。## ListDelete**思路**：1. 按照删除原理，同样需定位到**i -1 **结点位置，并且**不能删除头结点**；1. 定位成功后，创建一个用于临时存放的节点指针q，将欲删除的节点p-&gt;next赋值给q；1. 将q节点中的数据赋值给e，作为返回；1. 释放q节点；1. 返回成功；```C/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) *//* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */Status ListDelete(LinkList *L,int i,ElemType *e) &#123; int j; LinkList p,q; p = *L; j = 1; while (p-&gt;next &amp;&amp; j &lt; i)&#123; /* 遍历寻找第i个元素 */ p = p-&gt;next; ++j; &#125; if (!(p-&gt;next) || j &gt; i) return ERROR; /* 第i个元素不存在 */ q = p-&gt;next; p-&gt;next = q-&gt;next; /* 将q的后继赋值给p的后继 */ *e = q-&gt;data; /* 将q结点中的数据给e */ free(q); /* 让系统回收此结点，释放内存 */ return OK;&#125; 要点： 有别于GetElem与ListInsert函数while或if条件p，ListDelete函数的条件改为p-&gt;next。 GetElem条件判断p是否为NULL，是因为p的初始值就定义成 p = (*)L-&gt;next，不存在对头结点操作的可能性; ListInsert条件判断p是否为NULL，是因为插入数据是允许空表插入; ListDelete条件判断p是否为NULL，是因为删除不允许空表删除。 与整表删除要点一致，均需要通过一个变量q去记录将要删除的结点地址，不然会丢失地址，造成内存泄漏。 插入和删除复杂度分析 当不知第i个结点指针位置(首次插入/删除)，时间复杂度为O(n)； 若需要在i个位置插入若干个结点，则除了第一次外其余结点插入或删除的时间复杂度为O(1)； 结论：插入或删除数据越频繁的操作，单链表的效率优势就越明显。 总结单链表各方法实现思路 GetEelm：计数器 + while循环匹配 + 工作指针后移 p-&gt;next = p;； ListInsert / CreateListHead：均采用了插入的方法，`s-&gt;next=p-&gt;next; p-&gt;next=s;； ListInsert/ ListDelete：均需要定位到欲操作位置的前继结点，通过初始赋值头结点地址p=(*L)； ListDelete： “绕指针删除”q=p-&gt;next; p-&gt;next=q-&gt;next;； ListDelete / ClearList：均需将欲删除结点用另一个变量暂存后再删除，不然会丢失地址，造成内存泄漏； CreateListTail / ClearList：同样在循环内通过局部变量直接交换节点地址实现，节点操作按序进行(从前到后)，如尾插法r-&gt;next=p; r =p;或整表删除q=p-&gt;next; free(p); p=q; 不同操作中指针类型的要求原理：形参传递永远是值传递(临时变量)，想要通过调用函数去改变传入实参的内容必须： 至少传入欲修改参数类型基础上的一级指针 *通过“” 调用实体内容进行修改。 结论： 当传值时，只可以引用值而不可以改变值， 当你传指针时，只可以改变指针所指的内容，不可以改变指针本身 但传指针的指针时，即可以改变指针所指的内容，又可以改变指针本身 初始化链表需要用二级指针； 销毁链表(头结点也销毁)需要用到二级指针； 插入、删除、遍历、清空结点用一级指针即可； 单链表结构与顺序存储结构优缺点 存储结构 存储分配方式 时间性能 空间性能 顺序存储 连续存储单元 查找：O(1)，插删：O(n) 需预定分配存储空间，而大小不好掌握 链式存储 任意存储单元 查找：O(n)，插删：O(n) 或 O(1) 无需事先预定，内存有空间即可，不限数量 若线性表需要频繁查找且很少进行插入和删除操作，宜采用顺序存储结构； 如用户注册的个人信息，除了注册时插入数据外，绝大多数都是读取而且 若线性表需要频繁增加和删除，宜采用链式存储结构； 如游戏中玩家的武器装备仓库列表等 若线性表元素个数变化较大，或者根本不知道有多大时，最好用单链表结构不用考虑空间分配问题；","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 第三章 线性表及其顺序存储结构","slug":"数据结构 第三章 线性表及其顺序存储结构","date":"2020-09-03T04:40:32.000Z","updated":"2020-09-25T14:55:10.604Z","comments":true,"path":"2020/09/03/数据结构 第三章 线性表及其顺序存储结构/","link":"","permalink":"http://yoursite.com/2020/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%8F%8A%E5%85%B6%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲 线性表的定义 线性表的抽象数据类型 线性表的顺序存储结构 地址计算方法 顺序存储结构的存入与取出 顺序存储结构的插入与删除 线性表顺序存储结构的优缺点 线性表的定义线性表（List）：零个(空表)或多个数据元素的有限序列。即线性表的长度n≧0。关键点如下： 序列：表示元素之间是有严格的顺序。元素之间的关系是一对一的关系。 若线性表记为(a1，…ai-1，ai，ai+1，…，an)，称ai-1是ai的直接前驱元素，ai+1则是ai的直接后继元素 第一个元素无前驱，最后一个元素无后继，其他元素有且只有一个前驱和后继 有限 元素类型相同 线性表的抽象数据类型线性表的抽象数据类型定义如下： 1234567891011121314ADT 线性表（List）Data &#123;a1,a2,…,an&#125;Operation InitList(*L): 初始化操作，建立一个空的线性表L。 ListEmpty(L): 判断线性表是否为空表，若线性表为空，返回true，否则返回false。 ClearList(*L): 将线性表清空。 GetElem(L,i,*e): 将线性表L中的第i个位置元素值返回给e。 LocateElem(L,e): 在线性表L中查找与给定值e相等的元素，如果查找成功， 返回该元素在表中序号表示成功；否则，返回0表示失败。 ListInsert(*L,i,e): 在线性表L中第i个位置插入新元素e。 ListDelete(*L,i,*e): 删除线性表L中第i个位置元素，并用e返回其值。 ListLength(L): 返回线性表L的元素个数。endADT ps：上述为最基本操作，其他更复杂的操作完全可以通过这些基本操作组合实现。 线性表的顺序存储结构线性表的顺序存储定义线性表的顺序存储结构：指的是用一段地址连续的存储单元依次存储线性表的数据元素。 最常见的就是用一维数组来实现顺序存储结构 线性表的顺序存储结构代码如下： 123456#define MAXSIZE 20 //存储空间处时分配量typedef int ElemType //数据类型根据实际情况而定，这里假设为inttypedef strcuct&#123; ElemType data [MAXSIZE]; int length; //线性表当前长度&#125;SqList; 据上述可知，描述顺序存储结构需要三个属性： 存储空间的起始位置：其实就是数组data(首地址) 线性表的最大存储容量：数组长度MaxSize 线性表的当前长度：length 顺序线性表的初始化12345/* 初始化顺序线性表 */Status InitList(SqList *L) &#123; L-&gt;length=0; return OK;&#125; 地址计算方法数组长度与线性表长度的区别 数组长度：是指存放线性表存储空间的长度，一般是固定值。int data[3]={1,2,3}长度为3。 线性表长度：线性表中存在数据元素个数，是经常变化的。 数组下标从“0”开始，线性表是从“1”数起的。 地址计算方法数据元素的序号和存放它的数组下标之间对应关系如下图所示： 对于第i个数据元素ai的存储地址可由a1推算出： LOC(ai) = LOC(a1)+(i-1)*c LOC表示获得存储位置的函数，c表示数据元素的类型的存储单元 对于第 i 个数据元素ai的存取位置关系： ai = data[i - 1] 顺序存储结构的存入与取出GetElem思路： 线性表必须存在数据; i 的数值在数组下标范围内; 返回数组的第 i-1 下标的值即可; 123456789101112131415#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;//基本说明：Status是函数的类型，其值是函数结果状态代码，如OK等//初始条件(输入条件)：线性表L已存在，位置参数i范围应处于： 1 ≤ i ≤ ListLength(L)//操作结果：用e返回L中的第i个元素Status GetElem(SqList L,int i,ElemType *e) &#123; if (L.length == 0 || i &lt; 1 || i &gt; L.length) return ERROR; *e = L.data[i - 1]; return OK;&#125; 任意位置的存取时间复杂度都为O(1)**，即存取性能为O(1)，称为“随机存取结构**”。 “存取”，不等于“插删” 顺序线性表的存取仅需要知道存入的位置逻辑即可，因此查询位置的复杂度决定了存取的复杂度 顺序存储结构的插入与删除存在线性表定义如下： 1234567#define MAXSIZE 20typedef int ElemType;typedef struct &#123; ElemType data[MAXSIZE]; int length;&#125;SqList; ListInsert思路： 如果线性表的长度等于数组长度，则抛出异常或者动态增加容量; 如果插入位置不合理，抛出异常; 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置; 将要插入元素填入位置 i 中; 1234567891011121314151617181920212223/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， *//* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */Status ListInsert(SqList *L,int i,ElemType e)&#123; int k; if (L-&gt;length==MAXSIZE) /* 顺序线性表已经满 */ return ERROR; if (i&lt;1 || i&gt;L-&gt;length+1)/* 当i比第一位置小或者比最后一位置后一位置还要大时 */ return ERROR; if (i&lt;=L-&gt;length)&#123; /* 若插入数据位置不在表尾 */ for(k=L-&gt;length-1;k&gt;=i-1;k--) /* 将要插入位置之后的数据元素向后移动一位 */ L-&gt;data[k+1]=L-&gt;data[k]; &#125; /*索引改良 for (k = L-&gt;length; k &gt;= i; k--) &#123; L-&gt;data[k] = L-&gt;data[k - 1]; &#125; */ L-&gt;data[i-1]=e; /* 将新元素插入 */ L-&gt;length++; return OK;&#125; ListDelete思路： 线性表必须存在数据; 如果删除位置不合理，抛出异常; 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置; 表的长度减少1; 12345678910111213141516171819/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) *//* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */Status ListDelete(SqList *L,int i,ElemType *e) &#123; if (L-&gt;length==0) /* 线性表为空 */ return ERROR; if (i&lt;1 || i&gt;L-&gt;length) /* 删除位置不正确 */ return ERROR; *e=L-&gt;data[i-1]; int k; if (i&lt;L-&gt;length)&#123; /* 如果删除不是最后位置 */ for(k=i;k&lt;L-&gt;length;k++)/* 将删除位置后继元素前移 */ L-&gt;data[k-1]=L-&gt;data[k]; &#125; L-&gt;length--; return OK;&#125; 线性表顺序存储结构的优缺点时间复杂度分析存入与取出查询任意位置可由公式直接查出，从而决定存取的时间复杂度**均为O(1)**。 插入与删除 最优情况复杂度：插入与删除位置为最后一个元素，复杂度为O(1) 最坏情况复杂度：插入与删除位置为第一个位置，复杂度为O(n) 平均情况复杂度：位置靠前，移动元素多。位置靠后，移动元素少。平均为(n-1)/2，复杂度即为O(n) 优缺点总结优点： 无须为表示表中元素之间的逻辑关系而增加额外的存储空间(即可由公式直接关联) 可以快速地存取表中任意位置的元素 缺点： 插入和删除操作需要移动大量的元素 当线性表长度变化较大时，难以确定存储空间的容量。即难以确定MAXSIZE属性的大小 造成存储空间的“碎片” 小结 顺序存储结构的线性表，适合于元素个数不太需要变化，更多用于存取数据的应用。 插入和删除效率低的原因在于，相邻两元素之间的存储位置也依赖于邻居关系本身。","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 第二章 算法基础","slug":"数据结构 第二章 算法基础","date":"2020-09-01T03:40:32.000Z","updated":"2020-10-22T12:21:10.624Z","comments":true,"path":"2020/09/01/数据结构 第二章 算法基础/","link":"","permalink":"http://yoursite.com/2020/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲 算法的定义 算法的特性 算法设计的要求 算法效率的度量方法 函数的渐进增长 算法时间复杂度 算法空间复杂度 最坏情况与平均情况 算法的定义算法：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 算法的特性算法具有的五个基本特性：输入、输出、有穷性、确定性、可行性。 输入与输出 算法具有零个或多个输入。 算法至少有一个或多个输出。 有穷性 算法在执行有限步骤之后，自动结束而不会出现无限循环。 每一个步骤在可接受的时间内完成。即实际意义。 确定性确定性：算法的每一步骤都具有确定的含义，不会出现二义性，类似函数。 可行性 算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。 可行性意味着算法可转换为程序上机运行。 算法设计的要求算法设计的要求包含：正确性、可读性、健壮性、时间效率高和存储量低。 正确性正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。大体分为以下四个层次： 没有语法错误 对于合法的输入数据能够产生满足要求的输出结果 对于非法的输入数据能够得出满足规格说明的结果 对于精心选择的，甚至刁难的测试数据都有满足要求的输出结构。 一般情况下，我们把层次3作为一个算法是否正确的标准 可读性可读性：算法设计的另一个目的是为了便于阅读、理解和交流。 健壮性健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名奇妙的结果。 时间效率高和存储量低设计算法应该尽量满足时间效率高和存储量(占用内存与外部硬盘存储空间)低的需求。 算法效率的度量方法ps：这里指的效率大都是指算法的执行时间。 事后统计方法事后统计方法：这种方法主要是通过事先设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。 但这种方法显然存在很大的缺陷： 必须依据算法事先编制对应的测试程序，费时费力，工作量可能翻倍。 计时器的计时效果比较依赖计算机硬件和软件等环境因素。 算法的测试数据设计困难。 事前分析估算方法事前分析估算方法：在计算机程序编程前，依据统计方法对算法提前进行估算。 事前分析一个程序在计算机运行所消耗的时间取决于下列因素： 算法采用的策略、方法。 编译产生的代码质量。 问题的输入规模。 机器执行指令的速度。 结论： 一个程序的运行时间，依赖于算法的好坏和问题的**输入规模(输入变量的值)**。 测定运行时间最可靠的方法就是依据输入规模计算语句的执行次数。 执行次数，也成为基本操作数量，记作 f(n)，n表示输入规模。 函数的渐进增长ps：判断两个算法效率的高低，会存在因不同量级的输入规模而得出相反的结果。 因此给出定义，输入规模n在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，我们称函数是渐进增长快的。 函数渐进增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐进快于g(n)。 结论：判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而**更应该关注主项(最高阶项)**的阶数。 算法时间复杂度时间复杂度的定义算法时间复杂度，记作T(n)=O(f(n))，通过大写O( )**来体现时间复杂度的记法，也称之为大O记法**。 在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)= O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。 推导大O阶方法 写出每一条语句的执行次数。 把所有语句的执行次数相加并且进行基本的数学化简。 用常数1取代运行时间中的所有加法常数。 只保留最高阶项。 若最高阶项存在且不是1，则去除与这个项相乘的常数。 123456789int i,j; //执行1次for(i = 0; i &lt; n; i++)&#123; //执行n次 for(j = i; j &lt; n; j++)&#123; /*时间复杂度O(1)的程序步骤序列*/ //执行n-2次...n-1,n,执行1次 //执行n-2次...n-1,n,执行1次 &#125; &#125;printf(&quot;end&quot;); //执行1次 总执行次数为：1+n+(n-1)+(n-2)+…+1 + 1= n(n+1)/2 +2 = n2/2+n/2 + 2 去除常数： n2/2+n/2 保留最高阶项： n2/2 最高阶项存在且不等于1，去除相乘常数：n2，即最终时间复杂度为 O(n2) 可看作等差数列求和：na1 + n(n-1)/2 * d 首项a1=1，公差d=1，项数n=n 常见时间复杂度 阶 非正式术语 常见结构 例 O(1) 常数阶 顺序结构、无循环分支结构 12 O(n) 线性阶 无内嵌循环结构 2n+3 O(n2) 平方阶 二层内嵌循环结构 3n2+2n+1 O(log n) 对数阶 非1线性增长的循环索引 log2n+20 O(n log n) nlog n阶 2n+3nlog2n O(n3) 立方阶 三层内嵌循环 n3+2 2n 指数阶 2n 常用时间复杂度所耗费得时间从小到大依次是： O(1) &lt; O(log⁡n) &lt; O(n) &lt; O(nlog⁡n) &lt; O(n2) &lt; O(n3) &lt; O(an) &lt; O(n!) &lt; O(nn) 对数阶补充说明 123456int count =1;while(count &lt; n)&#123; count = count * 2; /*时间复杂度O(1)的程序步骤序列*/&#125; 每次count乘2之后，就距离n更接近一分，而需要乘多少次？接需要执行多少次，才能跳出循环？ 把需要乘的次数设为x，则2x=n，得到执行次数x=log2n 算法的空间复杂度空间复杂度：算法的空间复杂度即算法所需的存储空间，记作：S(n)=O(f(n)，此时n为问题的规模，f(n)为语句关于n所占存储空间函数。 当不用限定词地使用“复杂度”，则通常指时间复杂度。 时间复杂度和空间复杂度一般情况下可以相互转换。 最坏情况与平均情况最坏情况：即一个算法存在的最低执行效率情况。 在应用中，最坏情况是一种重要的需求，通常，除非特别指定，提及的运行时间都是指最坏情况的运行时间 平均运行时间是所有情况中最有意义的，它属于期望的运行时间。","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 第一章 绪论","slug":"数据结构 第一章 绪论","date":"2020-08-29T14:03:32.000Z","updated":"2020-09-26T08:45:58.868Z","comments":true,"path":"2020/08/29/数据结构 第一章 绪论/","link":"","permalink":"http://yoursite.com/2020/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 知识大纲 数据结构的起源 基本概念和术语 逻辑结构与物理结构 抽象数据类型 数据结构的起源早期认知人们都把计算机理解为数值计算工具。解决问题方式如下： 分析问题 抽像其数据模型 设计数据模型对应算法 编写程序 实际环境现实中，更多是解决非数值型问题，因此需要更加有效的科学手段。**(比如表、树图等数据结构)。 基本概念和术语数据数据的基本概念数据：是描述客观事物的符号，是计算机中可操作的对象，是能被计算机识别，并能够输入给计算机处理的符号集合。 比如编程所用到的数据类型，还包括字符、声音、图像、视频等这里所描述的数据，其实就是符号 数据的基本特性 可输入到计算机中 能被计算机程序处理 数据元素数据元素：组成数据的，有一定意义的基本单位，在及算你中通常作为整体处理。也被称为记录。 数据项数据项：一个数据元素可以由若干个数据项组成。 比如人这样的数据元素，可以有眼、耳、口、鼻，姓名、年龄、性别这些数据项 数据项是数据的最小单位 在研究数据结构问题时，数据元素才是建立数据模型的着眼点 数据对象数据对象：是性质相同的数据元素的集合，是数据的子集。 小结 数据：就是符号，数值型和非数值型集合 数据元素：组成数据有意义的基本单位，即java中的“类” 数据项：组成数据元素的基本单位，即类里面的“属性” 数据对象：是数据的子集。即类里面的“对象/实例” 数据结构数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。结构即关系！ 一个“好”的程序，必须分析待处理对象的特性及其**各处理对象之间存在的关系**这就是研究数据结构的意义所在。 “分析待处理对象的特性”，即以前接触高级语言的“面向对象编程” 博主如今缺乏的，即是学习“各处理对象之间存在的关系” 数据结构实际涵盖三个主要内容：逻辑结构(表,队,树,图…)、存储结构(顺序存储,链式存储)、基本操作(ADT)组成 逻辑结构与物理结构逻辑结构逻辑结构：是指数据对象中数据元素之间的相互关系，也是今后讨论的重点。主要类型包含如下 集合结果 线性结构 树形结构 图像结构 集合结构集合结构：集合结构中的数据元素除了同一个集合外，它们之间没有其他关系。 它们相互平等，唯一且共同的属性就是“同属一个集合”，类似数学的集合，形如“鱼塘” 线性结构线性结构：线性结构中的数据元素之间是一对一的关系，类似“火车，项链”。 树形结构树形结构：树形结构中的数据元素之间存在一种一对多的的层次关系。形如“大树”分支。 图形结构图像结构：图形结构的数据元素是多对多的关系，类似“人际关系”，交错复杂。 小结用示意图表示数据的逻辑结构时，要注意两点 将每一个数据元素看做一个结点，用圆圈表示 元素之间的逻辑关系用结点之间的连线表示，如果这个关系是有方向的，必须标明箭头 物理结构/存储结构物理结构：是指数据的逻辑结构在计算机中的存储形式。 即数据元素如何存储到计算机的存储器中，这里的存储器主要针对内存而言 数据的存储结构应正确反映数据元素之间的逻辑关系，这才是重点 存储结构形式有两种：顺序存储和链式存储 顺序存储结构顺序存储结构：是把数据元素存放在地址连续的存储单元里。此时，其数据间的逻辑关系和物理关系是一致的。 形如理想状态下的排队，又如编程中的数组存储/开辟空间机制 链式存储结构链式存储结构：是把数据元素存放在任意的存储单元里，而这组存储单元可以是连续的，也可以是不连续的。 形如去银行、医院等地方，设置了“叫号排序”的机制。实际，把变量的地址存储在一个指针变量中，通过指针变量找到对应的数据 小结 逻辑结构是面向问题的，而物理结构就是面向计算机的 顺序存储：连续开辟-按序对应 链式存储：任意开辟-叫号对应 抽象数据类型数据类型数据类型：是指一组性质相同的值的集合,及定义在此集合上的一些操作的总称。 在计算机中，内存也不是无限大的，计算机的研究者们就考虑，要对数据类型进行分类，分出多种数据类型来适合各种不同的计算条件差异，同时节省内存 C语言中数据类型可以分为两类 原子类型：不可以再分解的基本类型，例如整型、浮点型、字符型等。 结构类型：由若干种数据类型组合而成，是可再分解。如整型数组由若干整型数据组成的 抽象数据类型抽象抽象：抽象是指抽取出事物具有的普遍性的本质。即抽出问题的特征而忽略非本质的细节。 抽象数据类型抽象数据类型(Abstract Data Type，ADT)：是指一个数学模型及定义在该模型上的一组操作。 抽象数据类型不仅仅指那些已经定义并实现的数据类型(int、char等)，还可以是计算机编程者在设计软件程序时自己定义的数据类型，即如同高级语言的即“类”一样。而“及定义在该模型上的一组操作”即如同定义类，及其基本“方法” 比如，无论在PC、平版电脑、只能手机上都拥有“整数”这个类型，那么可以说“整型”其实就是一个抽象的数据类型，而且“抽象”的意义在于数据类型的数学抽象特征。 抽象数据类型体现了程序设计中，问题分解、抽线、信息隐藏的特性。 抽象数据类型的标准格式ADT 抽象数据类型名 Data 数据元素之间逻辑关系的定义 Operation 操作1 初始条件 操作结构描述 操作2 ... endADT 总结 现实问题中更需要解决的是非数值运算问题。 数据 数据即符号 数据元素即“类” 数据对象即可“实例” 数据项即“属性” 结构即关系 数据结构定义：是相互之间存在一种或多种特定关系的数据元素的集合 逻辑结构与物理结构，即面向问题，与面向存储。 四大逻辑结构(“四形”) 集合结构 线性结构 树形结构 图形结构 两大物理结构 顺序存储(数组) 链式存储(指针) 抽象数据类型 数据类型 原子类型(不可分割/int，char) 结构类型(组合而成) 抽象数据类型 已定义数据类型抽象，即int，char 自定义数据类型抽象，即struct，类 抽象数据类型规范:ADT、Data、Operation、endADT 作者建议研读方法 复习c语言的基础知识。 第一遍阅读，建议从头至尾进行通读。 阅读时，摘抄/笔记是非常好的习惯。“最淡的墨水也胜于最强的记忆” 阅读每一章时，特别是阅读****算法的推导过程，一定要在电脑中运行代码和进行调试，设置断点和逐行执行，参照书的讲解，观察变量的变化情况来理解算法的编写原理。 阅读完每一章时，一定要在理解基础上记忆一些关键东西，最佳效果就是不看书也可以一点不错的默写相关的算法。 阅读完每一章时，一定要适当练习。 在之后的学习或工作中，尽量把学到的数据结构和算法运用到现实开发中。 《大话数据树结构》初读后有感教材和自学读物，所面向的读者是完全不同的教材特性 好的教材应试是提纲挈领、重点突出。 一定要留出思考空间，否则就没必要再听老师上课了。教材很多内容的讲解都是由老师在课堂上完成的。 教材中必定有练习、课后习题、思考题等，而这些大多可以通过老师来解答。 比如我们中学时的语文、数学课本，很薄的一本书通常要用一个学期、甚至一年的时间来学，这就是因为它们是教材而不是自学读物。如果小说,可能一两天就读完了。 读物——隔空交流的介质作者角度 作者认为，读者拿到的虽然只是一本没有表情、不会说话的书，但其实也是在隔空与另一个朋友交流。 人与人的交流不可能只是就事论事，一定会有情感的沟通，这种情感如果能产生共鸣、达成互信，就会让沟通的事情本身更容易理解和接受。 博主理解 读物本是以内容第一为原则。但其作者的表诉方式，引用，感受等情感会附带许多作者本人的价值观。即情感交流，也是阅读的影响之一。 对于技术类读物，除技术内外，最明显的就是学习读者的编书方式，从编书结构从而建立更全面，深刻，有效的知识的架构。 如本书最明显的其中一个特征就是会对每一个小知识群进行小结提炼。这也会影响到我摘抄笔记的录入结构。","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"基于Hexo框架的博客搭建及其GitHub部署","slug":"基于Hexo框架的博客搭建及其GitHub部署","date":"2020-08-28T01:09:02.000Z","updated":"2020-09-02T09:50:08.071Z","comments":true,"path":"2020/08/28/基于Hexo框架的博客搭建及其GitHub部署/","link":"","permalink":"http://yoursite.com/2020/08/28/%E5%9F%BA%E4%BA%8EHexo%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%85%B6GitHub%E9%83%A8%E7%BD%B2/","excerpt":"","text":"Hexo简介 Hexo 是一个快速、简洁且高效的静态博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo受众面较广，对应的问题、扩展等内容在网上均有成熟解决方案，推荐安装使用。 安装安装前提安装Hexo之前需要先安装Node.js与Git。 ps：本文所有安装过程基于Windows环境下操作 Git安装 官网下载地址：https://git-scm.com/downloads 默认自动弹出适配版本，若没有则在“Git for Windows Setup”选择对应电脑位数下载 安装过程一直next直到完成即刻。 设置Git用户名 ps:Windows终端(cmd)内操作,不设置用户名和密码在安装hexo的过程中会报错 设置用户名git config --global user.name &quot;username&quot; 设置邮箱git config --global user.email useremail@qq.com 修改后可以检查一下，查看用户名和密码 git config user.name git config user.email 查看其他配置信息 git config --list Node.js安装 官方下载地址：https://nodejs.org/en/ 一般选择左边的 XX.XX.X LTS (长期支持版) 安装过程简单，直接操作即可。 安装完成后存在两个组件，一个是Node.js本身，另一个是npm(包管理器) hexo下载与安装 以管理员身份进入Windows终端。 检查node.js的安装结果node –vnpm –v 通过npm或cnpm安装hexo npm是外国的镜像源速度很慢，用淘宝的cnpm比较快 npm install -g cnpm --registry=http://registry.npm.taobao.org 通过cnpm下载安装hexocnmp install -g hexo cli 安装完成后通过命令可查看版本表示安装成功hexo –v hexo博客初始化 以下操作均在”总文件”路径下完成，且实例说明以名为”myblog”的文件夹表示hexo总文件夹。 若接下来的操作出现什么错误，直接把这个总文件夹删除重新来过即可 在想要安装博客的路径下创建一个总文件夹，如“myblog” 通过终端进入到这个总文件夹路径下 初始化博客 hexo init 常用组成文件功能介绍 ├_config.yml├&lt;source&gt;&emsp;&emsp;├&lt;_posts&gt;├&lt;themes&gt; _config.yml：配置文件，用于配置博客的重要属性 &lt;source&gt;：用于存放各种类型的md文件 &lt;_posts&gt; ：hexo new命令生成的md文件存位置 &lt;themes&gt;：存放不同的主题 启动博客，通过浏览器尝试访问 hexo s 终端会提示本地端口访问，一般为：localhost:4000 基本操作 ps：所有hexo命令操作都需要在安装hexo的总文件夹路径下操作 创建一篇文章， 新建的文章即md文件存放在/source/_posts hexo new &quot;My New Post&quot; 停止运行hexoctrl + c 清理之前生成的内容 hexo clean 校验并生成新的内容 hexo g GitHub部署仓库设置 登录github，创建仓库：repository name设置为：username.github.io 您github账号中的username,如博主账号username为yihangdeng则repository name 设置为：yihangdeng.github.io 其他保持默认即可，点击“Create repository”完成仓库创建 生成的链接结构为： https://github.com/username/username.github.io.git如：https://github.com/yihangdeng/yihangdeng.github.io.git Git远程部署插件安装cnpm install --save hexo-deployer-git 配置_config.yml设置总文件夹下的配置文件_config.yml，在配置信息的最底部修改并添加内容如下 123456# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deploymentdeploy: type: ‘git’ repo: (仓库创建后生成的链接) branch: master 123456# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deploymentdeploy: type: git repo: https:&#x2F;&#x2F;github.com&#x2F;yihangdeng&#x2F;yihangdeng.github.io.git branch: master 内容推送 通过命令远程部署到GitHub仓库hexo d 在远程部署的过程中有时要求输入GitHub的用户名和密码，如：Username for &quot;https://github.com\\&quot; 输入用户名Password for &quot;https://username@github.com\\&quot; 输入密码(密码默认不显示，直接输入后回车即可)若出错请检查是否有配置git的用户名和邮箱 刷新GitHub仓库可查看生成内容已部署到GitHub中 通过浏览器访问你的博客 url：username.github.io 如：yiahngdeng.github.io 若访问不了，请先尝试访问博主的博客(yiahngdeng.github.io)进而确认是部署出错还是访问GitHub的网络出现问题，具体参加博文《GitHub访问及其下载问题解决方案》。 常见错误 建议每次修改内容后都执行“hexo g”命令校验生成一下，报错的内容会显示在终端上。 标明错误行数：一般是配置文件中的“键值对”敲错，记住是英文冒号加空格，“: ” Git错误提示之：fatal: Not a git repository (or any of the parent directories): .git 提示说没有.git这样一个目录，在命令行 输入 git init 然后回车就好了 参考链接 codesheep：https://www.bilibili.com/video/BV1Yb411a7ty","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-08-25T09:05:12.504Z","updated":"2020-08-25T09:05:12.504Z","comments":true,"path":"2020/08/25/hello-world/","link":"","permalink":"http://yoursite.com/2020/08/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]}