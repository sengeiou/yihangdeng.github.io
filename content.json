{"meta":{"title":"yhdblog","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"Repositories","date":"2020-08-25T13:03:56.000Z","updated":"2020-08-25T13:08:55.059Z","comments":true,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-08-25T12:50:00.000Z","updated":"2020-08-25T13:04:12.688Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaSE进阶核心积累","slug":"JavaSE进阶核心积累","date":"2021-04-05T01:51:32.000Z","updated":"2021-04-05T14:41:22.184Z","comments":true,"path":"2021/04/05/JavaSE进阶核心积累/","link":"","permalink":"http://yoursite.com/2021/04/05/JavaSE%E8%BF%9B%E9%98%B6%E6%A0%B8%E5%BF%83%E7%A7%AF%E7%B4%AF/","excerpt":"","text":"引言：本文主要基于JDK8介绍JavaSE中多线程、常用类、枚举与注解、集合、泛型与File、IO流与网络编程、反射与动态代理、以及Java8、9、10、11等新特性。 [TOC] 多线程基础概念程序程序(programm)：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。(如软件安装的物理位置中的文件) 进程进程(process)：程序的一次执行过程，或是正在运行的一个程序。 进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域。(如软件启动后在任务管理器”进程”看到的状态) 有其自身产生、存在合消亡的过程——生命周期 每一个进程占用内存区域中的方法区与堆结构 线程线程(thread)：进程可进一步细化为线程，是一个程序内部的一条执行路径。 若一个进程同一时间并行执行多个线程，就是支持多线程的 线程作为调度和执行的单位，每个线程拥独立的运行栈和程序计数器(pc)，线程切换的开销小。 一个进程中的多个线程共享相同的内存单元/内存地址空间，使得线程间通信更简便、高效。但多个线程操作共享的系统资 源可能就会带来安全的隐患。 单核与多核CPU 单核CPU：其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。只是CPU主频非常高，在快速切换地执行不同的线程。使其感觉像并行的多线程。 多核CPU：若是多核的CPU，才能真正更好的发挥多线程的效率 一个Java应用程序java.exe至少有三个线程：main主线程、GC垃圾回收线程、异常处理线程。 并行与并发 并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。 并发：一个CPU(采用时间片)同时执行多个任务。比如：多个人做同一件事。 多线程的优势 背景：以单核CPU为例，只使用单个线程先后完成多个任务（调用多个方 法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？ 多线程程序的优点： 提高应用程序的响应。对图形化界面更有意义，可增强用户体验。 提高计算机系统CPU的利用率。 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。 多线程的常见需求场景： 程序需要同时执行两个或多个任务。 程序需要实现一些需要等待的任务时，如用户输入、文件读写 操作、网络操作、搜索等。 需要一些后台运行的程序时。 线程的创建Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread 类来体现。最原始创建线程的方式有如下两种。 通过继承Thread类来实现 实现Runnable接口的方式 继承Thread实现方式实现步骤 创建一个基础于Thread类的子类 重写Thread类的run()方法，并将执行的代码写在run方法中 创建Thread类的子类的对象 调用start()方法启动线程 123456789101112131415161718192021222324//如下创建一个线程打印100以内的偶数class MyThread extends Thread&#123; @Override public void run() &#123; //打印100以内的偶数 for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 == 0) System.out.println(&quot;MyThread-run()：&quot; + i); &#125; &#125;&#125;public class ThreadTest &#123; //多次尝试运行可以发现两个线程存在交替执行 public static void main(String[] args) &#123; Thread t1 = new MyThread(); t1.start(); //主线程 main，也打印100以内的偶数 for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 == 0) System.out.println(&quot;main()：&quot; + i); &#125; &#125;&#125; 说明 start方法的作用：①启动当前线程、②让 JVM 去调用当前线程的run()方法 启动一个线程，必须调用start()**，不能调用run()**的方式启动线程。 若直接调用run()方法执行代码。则只是在当前线程调用子类重写父类的一个方法而已，属于单线程。 若想再启动一个线程，不能连续调用两次start()方法，否则报出IllegalThreadStateException异常 在必须重新创建一个新的Thread子类的对象，调用此**对象的start()**方法。 1234567891011public class ThreadTest &#123; //多次尝试运行可以发现两个线程存在交替执行 public static void main(String[] args) &#123; Thread t1 = new MyThread(); t1.start(); //t1.start();错误写法 Thread t2 = new MyThread();//正确写法，重新创建 t2.start(); &#125;&#125;","categories":[],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/tags/JavaSE/"}]},{"title":"考试网油猴代码","slug":"考试网油猴代码","date":"2021-03-27T09:16:32.000Z","updated":"2021-03-28T15:04:43.988Z","comments":true,"path":"2021/03/27/考试网油猴代码/","link":"","permalink":"http://yoursite.com/2021/03/27/%E8%80%83%E8%AF%95%E7%BD%91%E6%B2%B9%E7%8C%B4%E4%BB%A3%E7%A0%81/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// ==UserScript==// @name 考试资料网跳转显示答案// @namespace https://github.com/cuifeiran/ppkao/// @version 0.1.7// @description 对单个题目进行跳转，使得跳转后的页面显示题目的答案。期间可能需要验证,遇到问题可以在GitHub issue我～// @author Dave// @match *://www.ppkao.com/tiku/shiti/*// @match *://www.ppkao.com/kaoti/*// @include *://www.ppkao.com/tiku/shiti/*// @include *://www.ppkao.com/shiti/*// @include *://www.ppkao.com/kaoti/*// @include *://www.ppkao.com/daan/*//@contributionURL// @grant none// ==/UserScript==(function() &#123; &#x27;use strict&#x27;; //清除限制题目访问数量的cookie var Days = 30; var exp = new Date(); exp.setTime(exp.getTime() + Days*24*60*60*1000); document.cookie=&quot;PPKAO=PPKAOSTID=&amp;PPKAOCEID=&amp;PPKAOSJID=&amp;UserName=&amp;EDays=; domain=ppkao.com;expires=&quot;+exp.toGMTString()+&quot;;path=/&quot;; //获取当前页面URL var iSite = window.location.href; var reg = /[1-9][0-9]*/g; var numList = iSite.match(reg); var isKaoti =new RegExp(&quot;kaoti&quot;).test(iSite); var isTiku =new RegExp(&quot;tiku&quot;).test(iSite); var isShiti =new RegExp(&quot;shiti&quot;).test(iSite); var isDaan =new RegExp(&quot;daan&quot;).test(iSite); var sUrl=&quot;&quot;; if (isKaoti===true)&#123;sUrl=&#x27;https://api.ppkao.com/mnkc/kaoti/?id=&#x27;+ numList;window.location.href =sUrl;&#125; else&#123; if(isTiku===true)&#123;sUrl=&#x27;https://api.ppkao.com/mnkc/tiku/?id=&#x27;+ numList;window.location.href =sUrl;&#125; else&#123; if(isShiti===true)&#123;sUrl=&#x27;https://newapi.ppkao.com/mnkc/shiti/?id=&#x27;+ numList;window.location.href =sUrl;&#125; else&#123; if(isDaan===true)&#123; var html = &#x27;&lt;div id=&quot;showQRcode&quot; style=&quot;position: fixed;right:30px;bottom: 0px;&quot;&gt;&lt;a style=&quot;font-size:14px;color:red;background-color: white;display:block;&quot; href=&quot;https://raw.githubusercontent.com/cuifeiran/ppkao/master/donations&quot;&gt;[捐助名单]我在考研二战,愁于房租,致谢捐助者！&lt;/a&gt;&lt;a style=&quot;font-size: 14px;display:block;color:black;background-color: white;&quot; onclick=&quot;$(this).parent().remove();&quot; hidden=&quot;javascripe:void(0)&quot; &gt;[不想捐助点击这里]&lt;/a&gt;&lt;img width=&quot;420&quot; height=&quot;210&quot; src=&quot;https://s1.ax1x.com/2018/12/11/FJ47an.jpg&quot;&gt;&lt;/img&gt;&lt;/div&gt;&#x27; var div = document.createElement(&#x27;div&#x27;); div.setAttribute(&#x27;id&#x27;, &#x27;showQRcode&#x27;); div.innerHTML = html; document.body.appendChild(div); &#125; &#125; &#125; &#125;&#125;)();","categories":[],"tags":[{"name":"娱乐","slug":"娱乐","permalink":"http://yoursite.com/tags/%E5%A8%B1%E4%B9%90/"}]},{"title":"JavaWeb总结","slug":"JavaWeb总结","date":"2021-03-24T11:54:32.000Z","updated":"2021-04-22T07:24:21.885Z","comments":true,"path":"2021/03/24/JavaWeb总结/","link":"","permalink":"http://yoursite.com/2021/03/24/JavaWeb%E6%80%BB%E7%BB%93/","excerpt":"","text":"JavaWeb技术概述万维网 WWW是World Wide Web简称，目的为了实现全世界能利用因特网进行文档交换，是一个大规模、分布式、联机式的信息储藏所。 Web是基于客户/服务器的一种B/S体系结构，其基本工作原理为，客户使用浏览器向Web服务器发出请求，服务器响应客户请求，向客户送回所请求的网页，客户在浏览器窗口上显示网页的内容。 组成Web体系的三大结构 Web服务器 Web客户端 通信协议 Web服务器基本概念 Web服务器是向浏览器提供服务器的程序 Web服务器应用层使用HTTP协议，信息内容采用HTML，信息定位使用URL 最常用的Web服务器是Apache服务器，开源、免费、Linux/Windows。另一种较为流行的Web服务器为Microsoft公司专门为Windows平台开发的IIS服务器 Tomcat也是一种常用的Web服务器，它具有Web服务器功能同时也是Web容器，可允许Servlet和JSP Tomcat&amp;Sevlet/JSP/JDK版本对应关系 当前企业常用Tomcati的版本 7、8 Servlet2.5版本是现在世面使用最多的版本**(xml 配置**) Servlet3.0 之后就是注解版本的 Servlet 使用。 其他Web服务器 Jboss：是一个遵从 JavaEE 规范的、开放源代码的、纯 Java 的 EJB 服务器，它支持所有的 JavaEE 规范（免费）学习门槛高，不适合入门 GlassFish： 由 Oracle 公司开发的一款 JavaWeb 服务器，是一款强健的商业(收费)服务器，达到产品级质量（应用很少） Resin：是 CAUCHO 公司的产品，是一个非常流行的服务器，对 servlet 和 JSP 提供了良好的支持， 性能也比较优良，resin 自身采用 JAVA 语言开发（收费，应用比较多）。 WebLogic：是 Oracle 公司的产品，是目前应用最广泛的 Web 服务器，支持 JavaEE 规范， 而且不断的完善以适应新的开发要求，适合大型项目（收费，用的不多，适合大公司） Web客户端​ 浏览器主要功能想服务器发送请求与对响应信息进行解析、并正确显示出来 通讯协议HTTP HTTP协议成为超文本传输协议，规定了Web客户与服务器之间如何通信 是一个基于请求-响应的协议，是无状态的 主要通信流程 在浏览器输入网址，按下Enter键 浏览器建立一个HTTP请求信息，使用DNS获得网址的IP地址 通过IP地址与服务器建立一条TCP连接 通过这条TCP连接将HTTP信息发送给服务器，并从服务器接收回一条信息 URL&amp;URIURL称为统一资源定位符，用于在Internet中定位某个主机的资源，主要四部分组成 协议名称：如HTTP、FTP、TELNET、MAIL等 主机域名或IP地址：www.baidu.com、localhos、127.0.0.1等 [端口号]：Web应用的80端口等，可忽略不写 资源名称：资源在服务器上的相对路径和名称，如/index.html 12https:&#x2F;&#x2F;www.baidu.com&#x2F;https:&#x2F;&#x2F;www.baidu.com&#x2F;helloweb&#x2F;hello.jsp URI，URN URL：https://www.baidu.com/helloweb/hello.jsp URI：helloweb/hello.jsp 服务器资源资源类型Web服务器处理客户端请求有两种方式 静态请求：客户端所需请求的资源不需要进行任何处理，直接作为HTTP响应返回。对应的资源称之为静态资源 动态请求：客户端所需请求的资源需要在服务器委托给一些服务器端技术进行处理，如CGI、JSP、ASP等，然后将处理结果作为HTTP响应返回，对应地也成为动态资源 动态文档技术动态文档是指文档的内容可根据需要动态生成，同时又分以下两种技术： 服务器端动态文档技术： 模块化技术：CGI、Servlet—java解决方案 Web文档嵌入式脚本：ASP、PHP、JSP 客户端动态文档技术 JavaScript Tomcat安装 下载Tomcat，官方链接 将下载的安装包直接解压到指定目录即可 找到Tomcat目录下的bin目录，双击startup.bat文件即可启动 在浏览器输入输入地址 http://localhost:8080 ，若出现tomcat首页则表示安装成功 目录介绍 bin：用与存放Tomcat 服务器的可执行程序 conf：用与存放Tocmat 服务器的配置文件 lib：用与存放Tomcat 服务器的jar 包，对应javaEE的实现规范的实现类 logs ：用与存放Tomcat 服务器运行时输出的日志信息 temp：用与存放Tomcdat 运行时产生的临时数据 webapps：用与存放部署的Web工程，根目录下，一个文件夹一个Web工程 work：是Tomcat工作时的目录，用来存放 Tomcat 运行时 jsp 翻译为 Servlet 的源码，和 Session 钝化的目录 启动与关闭启动方式 Tomcat目录下的bin目录，双击startup.bat文件即可启动，或以命令行方式在路径下执行命令startup 用命令行方式在路径下执行命令catalina run startup命令的源码解析：为了可以在任意目录下启动 Tomcat 服务器，可以选择把bin目录添加到 path下，此时在任意目录下通过startup命令启动Tomcat服务器会提示如下错误，即要求设置 CATALINA_HOME 这个环境变量 12The CATALINA_HOME environment variable is not defined correctlyThis environment variable is needed to run this program 阅读startup.bat批处理文件源码可知，CATALINA_HOME环境变量指向为Tomcat安装的根目录(bin目录的上一级目录) startup.bat 文件，实际调用的是catalina.bat文件 通过命令行窗口直接输入catalina, 提示如下，表示catalina命令的可选参数 12345678910commands:debug Start Catalina in a debuggerdebug -security Debug Catalina with a security managerjpda start Start Catalina under JPDA debuggerrun Start Catalina in the current windowrun -security Start in the current window with security managerstart Start Catalina in a separate windowstart -security Start in a separate window with security managerstop Stop Catalinaversion What version of tomcat are you running? 常用的catalina命令选项如下 run：在 catalina 同一个命令行窗口下启动服务器. start：开启一个新窗口启动服务器 stop：关闭服务器 关闭方式 方式一：点击tomcat 服务器窗口右上角X关闭 方式二：把Tomcat 服务器窗口置为当前窗口，然后按快捷键 Ctrl+C 方式三：找到Tomcat的bin目录下的 shutdown.bat 双击，或cmd进入该目录执行shutdown，就可以停止 Tomcat 服务器 常见错误首先，建议通过CMD命令行的方式进入到bin目录下，通过命令行的方式执行catalina run命令，则会有错误提示信息显示 双击startup.bat出现黑窗口一闪而过，JAVA_HOME环境变量没有配置正确 修改默认端口号 找到Tomcat目录下的conf目录，找到 server.xml 修改如下标签下的port属性端口号信息即可 123&lt;Connector port=&quot;7777&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 修改后需重启Tomcat服务器才能生效 Web工程部署Tomcat目录下的webapps目录：存放部署的Web工程，一个文件夹一个Web工程。如默认tomcat含以下5个web应用。 无论静态还是动态资源，Tomcat中web工程部署均有两种 拷贝到webapps下的指定工程目录中 通过配置tomcat xml文件实现映射式的部署 静态资源部署 方式一：把 web 工程的目录拷贝到 Tomcat的webapps/web目录下 在webapps目录下新建web应用的文件夹，如helloWeb 将web应用内容拷贝的该文件夹内 http://localhost:8888 对应webapps的根目录，url与webapps目录的路径关系如下 稍等十几秒后，一般tomcat会自动重新部署。若没有效果，则可以尝试重启tomcat服务器 方式二：配置文件映射部署，即项目任意路径部署 找到Tomcat下的 conf目录\\Catalina\\localhost\\ 根目录下,创建如下xml配置文件，一般一个工程一个xml文件。(旧版本的tomcat可能不存在上述目录，没有就自己建立这个目录结构即可) 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Context path=&quot;/abc&quot; docBase=&quot;E:\\book&quot; /&gt; .xml文件的文件名：tomcat9测试，xml文件名才是决定访问(url)根路径 path：表示工程的访问(url)路径，如/abc docBase：表示你的工程目录在磁盘下的路径 一般修改添加或删除，tomcat中的web应用内容，稍等十多秒会自动重新部署。若没有效果，则可以重启tomcat服务器使其部署 动态资源部署Web工程目录Servlet 规范中定义了 web 应用程序的目录层次 1234567891011121314|--Web开发项目 |----src &#x2F;&#x2F;存放源代码 ---------------------以上为常见IDE开发时提供的目录结构---- ---------------------以下为Servlet规范目录结构---------- |----WEB资源根目录 &#x2F;&#x2F;约定：但不规定目录名(eclipse WebContent,IDEA web) |-------WEB-INF &#x2F;&#x2F;约定：存放供服务器访问的资源(浏览器无法直接访问) classes &#x2F;&#x2F;约定：存放编译后.class文件 web.xml &#x2F;&#x2F;约定：整个动态web工程的配置部署描述文件，配置如(servlet、filter...)组件 [apache-tomcata安装根目录]\\webapps\\docs\\WEB-INF 中复制过来 lib &#x2F;&#x2F;约定：存放web应用程序用到的jar文件 |----css |----img ... |----index.html 步骤如下tips：以下以eclipse环境下，手动创建普通java项目，并手动拷贝部署到tomcat的过程，很少使用。拟在突出web工程目录的结构与作用。 在 src下新建一个 Person 12345public class Person &#123; public String getPersonInfo()&#123; return &quot;person info...&quot;; &#125;&#125; 手工的 Person 类对应的编译后的.class 文件(在工程的bin目录下，含包目录结构均需复制)复制到 classes 目录下 在 WebContent 目录下新建一个 JSP 文件 1234567&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=ISO-8859-1&quot; pageEncoding=&quot;ISO-8859-1&quot;%&gt;&lt;% Person person = new Person(); System.out.print(person.getPersonInfo()); %&gt; 把 WebContent 目录复制到 Tomcat 的 webapps 目录下, 并改名为: helloworld 在浏览器的地址栏中输入: http://localhost:8080/helloworld/hello.jsp 即可看到命令行的打印信息 半自动化工程部署tips：基于eclipse开发环境 可以通过修改src默认的输出目录达到自动把编译好的 class 放到 classes 目录下 通过方式二，实现开发目录与实际部署目录的映射 默认工程及首页 当地址栏输入访问地址没有工程名地址：http://ip:port/ ，默认访问的是 ROOT 工程。 当地址栏输入访问地址只有工程名地址： http://ip:port/工程名/，默认访问工程内的 index.html 页面 IDEA整合Tomcat整合Tomcat服务器 进入IDEA如下设置 配置你的 Tomcat 安装目录，可以添加多个不同版本的tomcat 创建动态Web工程 2020版本后的IDEA，建立非Maven管理的web项目需先建立一个普通的java Model。右键Add Framework Support (若选择使用maven则可以在建立model时选择java enterprise) 勾选Web Application ，勾选Create web.xml 创建成功如下图，(一般手动di在WEB-INF目录下建立一个lib目录) 启动Web工程 每当创建一个web工程时，IDEA会对应Web工程创建一个Tomcat实例 确认你的 Tomcat 实例中有你要部署运行的 web 工程模块 为了方便使用，一般将tomcat name、URL、Application context三者设置为与项目名称一致。则能实现启动项目后，自动调用浏览器且访问的就是Web工程 Server窗口下的URL与Deployement窗口下的Application context的区别 Server — URL：web应用启动后，IDEA自动调用浏览器访问的地址(不一定是web工程访问地址) Deployement — Application context：当前web工程的根目录访问地址，即在web.xml配置servlet的隐射地址时候斜杠/就是指该路径 如下图显示设置 URL设置为：http://localhost:8080/abc Application context设置为：http://localhost:8080/06_helloServlet/ 当项目启动后，IDEA自动调用浏览器访问的地址是：http://localhost:8080/abc。因为实际web应用的访问地址是application context决定的，所以找不到页面如下提示 当访问application context 设置的url即可访问到web应用 IDEA中、启动、debug启动、停止、与重启按钮说明 IDEA中默认启动web项目的效果 重启选项说明 IDEA中修改端口号 配置资源热部署热部署：正在运行状态的应用,修改了他的源码之后,在不重新启动的情况下能够自动把增量内容编译并部署到服务器上 IDEA创建Servlet 检查项目是否添加了servlet-api.jar与jsp-api.jar 在指定包下右键—&gt;New—&gt;Servlet创建即可 IDEA的部署逻辑IDEA整合Tomcat后部署逻辑 tips：一般的整合Tomcat的IDE，如eclipse、IDEA逻辑都类似 编写如下测试代码 12345678public class TestGetRealPath implements Servlet &#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; String path = servletConfig.getServletContext().getRealPath(&quot;/&quot;); System.out.println(&quot;path = &quot; + path); &#125; //@Override method....&#125; 在整合了Tomcat的IDEA中启动Web工程，可以从service信息打印窗口看到如下信息 getRealPath(“/“)输出的内容其实是web部署的实际物理位置，IDEA会将部署的Web应用下的根目录(web目录)的所有内容拷贝到 创建项目物理机地址\\out\\artifacts\\项目工程名目录下，这个目录就是被IDEA认为的web应用部署后源代码的真实路径(非运行路径)**，并非开发目录。因此getRealPath(“/“)输出就是这个路径。并且是与开发代码时web下目录结构是完全对应**的。 Web项目编译后真正运行.class文件则被复制到C:\\Users\\[用户名]\\AppData\\Local\\JetBrains\\[IntelliJIdea版本]\\tomcat\\...目录下。 含Web应用源码编译后的.class文件 含.jsp文件对应的_jsp.java源码，以及编译后的.class文件 含用于Tomcat中完整的配置与项目部署映射所有需要的配置文件。目的是使能在IDEA中直接设置一些有关Tomcat的配置生效，如设置端口号，IDEA自定义的项目映射部署等…. ServletServlet及其容器 Servlet：Servlet是用Java编写的服务器端程序，主要功能在于交互式地浏览和生成动态Web内容。 狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。 Servlet是 JavaEE 规范之一，规范就是接口。 Servlet是JavaWeb 三大组件之一。(Servlet 程序、Filter 过滤器、Listener 监听器) Servlet是运行在服务器上的一个 java 小程序，可以接收客户端发送过来的请求，并响应数据给客端。 Servlet 容器: Servlet容器为JavaWeb应用提供运行时环境，它负责管理Servlet和JSP的生命周期，以及管理它们的共享数据 运行 Servlet、JSP、Filter 等的软件环境. 创建 Servlet, 并调用 Servlet 的相关生命周期方法。 Servlet接口实现 编写一个类去实现 Servlet 接口 编写实现service方法，处理请求，并响应数据 在web.xml中设置Servlet接口映射 &lt;servlet&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt;&lt;/servlet-mapping&gt; tips：任何web.xml的修改都需重新部署才会生效 实现接口：tips，IDEA若无法识别Servlet接口则需要手动导入servlet-api.jar包，一般在tomcat安装路径下lib目录中可以找到 12345678910111213141516171819202122232425262728293031323334public class HelloServlet implements Servlet &#123; //建立一个空参构造器 public HelloServlet()&#123; System.out.println(&quot;HelloServlet实例化成功&quot;); &#125; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(&quot;init...&quot;); &#125; @Override public ServletConfig getServletConfig() &#123; System.out.println(&quot;getServletConfig&quot;); return null; &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(&quot;hello service&quot;); &#125; @Override public String getServletInfo() &#123; System.out.println(&quot;getServletInfo&quot;); return null; &#125; @Override public void destroy() &#123; System.out.println(&quot;destroy&quot;); &#125;&#125; 设置web.xml接口映射：&lt;servlet&gt;标签与&lt;servlet-mapping&gt;映射标签 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;!--servlet-name 标签为Servlet程序自定义一个别名(一般是类名) --&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!--servlet-class 是 Servlet 程序的全类名--&gt; &lt;servlet-class&gt;com.test.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!--servlet-mapping 标签给 servlet 程序配置映射的访问地址--&gt; &lt;servlet-mapping&gt; &lt;!--servlet-name 标签指定设置映射的Servlet程序别名--&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!--url-pattern 标签配置访问地址 --&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;!-- &lt;url-pattern&gt;标签内容必须以斜杠打头 / 斜杠 ：表示地址为：http://ip:port/工程路径 /hello : 表示地址为：http://ip:port/工程路径/hello --&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 小结： &lt;url-pattern&gt;标签内容必须以斜杠打头 若使用通配符只有两种使用方式 .扩展名，如.html表示所有html结尾的文件均由该servlet受理 /*，所有接口调用都受理 常见错误： url-pattern 中配置的路径没有以斜杠打头 servlet-name 配置的值不存在 servlet-class 标签的全类名配置错误 最终效果 Servlet生命周期Servlet 生命周期：以下方法均由Serlvet容器负责调用. 构造器: 只被调用一次，对指定Servle进行首次访问时创建 Servlet 的实例 (Serlvet 的单实例) init：只被调用一次，在创建好Servlet实例后立即被调用，用于初始化当前 Servlet. service：被多次调用，每次请求都会调用 service 方法. 实际用于响应请求的. destroy：只被调用一次，在当前 Servlet所在的 WEB 应用被卸载前调用，用于释放当前 Servlet 所占用的资源. Servlet引擎检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第④步，否则，执行第2步。 装载并创建该Servlet的一个实例对象：调用该 Servlet 的构造器 调用Servlet实例对象的init()方法。 创建一个用于封装请求的ServletRequest对象和一个代表响应消息的ServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。 WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。 load-on-startup标签: 可以设置Serlvet被创建的时机，若为负数, 则在如上普通生命周期般，要被调用，才会实例化与初始化，若为0或正数, 则在当前 WEB 应用被Serlvet 容器加载时(启动web应用时，不用调用)就会创建实例，且数组越小越早被创建。 1234&lt;servlet&gt; &lt;!-- .... --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 相关接口与类 init()：ServletConfig service()：ServletRequest , ServletResponse 以讲解实现servlet接口后出现的相关接口与类展开学习servlet ServletConfig基本概念 每个 Servlet 程序创建时，就创建一个对应的 ServletConfig 对象。 Servlet 程序默认是第一次访问的时在init()中创建 作用 获取Servlet程序的别名，即获取标签&lt;servlet-name&gt;的值 获取初始化参数，即获取标签&lt;init-param&gt;的键值信息 获取 ServletContext API由服务器供应商提供实现，封装Servlet 程序的配置信息，并可获取ServletContext对象 javax.servlet Interface ServletConfig All Known Implementing Classes: GenericServlet, HttpServlet Method Summary String getInitParameter(String name) ：获取初始化参数，即标签&lt;init-param&gt;内配置的键值对 Enumeration getInitParameterNames() ：获取所有参数名组成的Enumeration对象 String getServletName() ：获取Servlet程序的别名，即获取标签&lt;servlet-name&gt;的值 ServletContext getServletContext()：获取ServletContext对象 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;!-- Servlet别名 --&gt; &lt;servlet-name&gt;ServletConfitTestName&lt;/servlet-name&gt; &lt;servlet-class&gt;com.test.servlet.ServletConfigTest&lt;/servlet-class&gt; &lt;!-- 配置初始化参数，可定义多个 --&gt; &lt;init-param&gt; &lt;param-name&gt;usn&lt;/param-name&gt; &lt;param-value&gt;username&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;psw&lt;/param-name&gt; &lt;param-value&gt;password&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletConfitTestName&lt;/servlet-name&gt; &lt;url-pattern&gt;/testConfig&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 12345678910111213141516171819202122232425public class ServletConfigTest implements Servlet &#123; @Override public void init(ServletConfig config) throws ServletException &#123; //1、获取当前Servlet的别名，即标签&lt;servlet-name&gt;的值 String name = config.getServletName(); System.out.println(&quot;servlet-name: &quot; + name); //2、获取初始化参数，即标签&lt;init-param&gt;内配置的键值对 String userName = config.getInitParameter(&quot;usn&quot;); String passWord = config.getInitParameter(&quot;psw&quot;); System.out.println(&quot;usn: &quot; + userName); System.out.println(&quot;psw: &quot; + passWord); //2.1、获取所有参数名组成的Enumeration 对象 Enumeration&lt;String&gt; names = config.getInitParameterNames(); while(names.hasMoreElements())&#123; System.out.println(names.nextElement()); &#125; //3、获取servletContext ServletContext servletContext = config.getServletContext(); System.out.println(servletContext); &#125; //@Override Method...&#125; 1234567&#x2F;&#x2F;打印结果如下servlet-name: ServletConfitTestNameusn: usernamepsw: passwordusnpsworg.apache.catalina.core.ApplicationContextFacade@5a298b72 ServletContext基本概念ServletContext称为“servlet上下文”，一个Web应用对应一个ServletContext，封装了Web诸多信息 ServletContext对象由**servletConfig.getServletContext();**获取 一个 web 工程，只有一个 ServletContext 对象 ServletContext 是在 web 工程部署启动的时候创建。在 web 工程停止的时候销毁 作用 获取当前WEB 应用的初始化参数，即&lt;context-param&gt;的值 &lt;context-param&gt;可以被所有的Servlet 所获取, 而Servlet的初始化参数&lt;init-param&gt;只有对应的 Serlvet 可获取 获取当前 WEB 应用的某一个文件在服务器上部署后的绝对路径 获取当前WEB 应用的工程路径 获取当前WEB应用的某一个文件对应的输入流 作为application域范围的属性(后续补充说明) APIjavax.servlet Interface ServletContext Method Summary String getInitParameter(String name) ：获取初始化参数，即标签&lt;context-param&gt;内配置的键值对 Enumeration getInitParameterNames()：获取所有参数名组成的Enumeration 对象 String getRealPath(String path) 获取当前 WEB 应用的某一个文件在服务器上部署后的绝对路径 输入参数/file.suffix，/对应Web应用的根目录(部署后) 同时getRealPath(“/”)映射到IDE代码开发目录中的根目录(web或webcontent) String getContextPath() ：获取当前WEB 应用的工程路径 InputStream getResourceAsStream(String path) 获取当前WEB应用的某一个文件对应的输入流 输入参数/file.suffix，/对应Web应用的根目录(IDEA-web) Attribute相关方法后续补充 Object getAttribute(String name) Enumeration getAttributeNames() void removeAttribute(String name) void setAttribute(String name, Object object) web.xml 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- 配置当前Web应用的初始化参数 --&gt; &lt;context-param&gt; &lt;param-name&gt;driver&lt;/param-name&gt; &lt;param-value&gt;com.mysql.jdbc.Driver&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;jdbcUrl&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql....&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;ServletContextTest&lt;/servlet-name&gt; &lt;servlet-class&gt;com.test.servlet.ServletContextTest&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletContextTest&lt;/servlet-name&gt; &lt;url-pattern&gt;/contextTest&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; ServletContextTest.java 1234567891011121314151617181920212223242526272829303132public class ServletContextTest implements Servlet&#123; @Override public void init(ServletConfig config) throws ServletException &#123; //获取ServletContext对象 ServletContext servletContext = config.getServletContext(); //1、获取当前Web应用的初始化参数，即&lt;context-param&gt;值 String driver = servletContext.getInitParameter(&quot;driver&quot;); String jdbcUrl = servletContext.getInitParameter(&quot;jdbcUrl&quot;); System.out.println(&quot;driver: &quot; + driver); System.out.println(&quot;jdbcUrl: &quot; + jdbcUrl); Enumeration&lt;String&gt; names = servletContext.getInitParameterNames(); while(names.hasMoreElements())&#123; System.out.println(&quot;names&quot; + names.nextElement()); &#125; //2、获取当前 WEB 应用的某一个文件在服务器上部署后的绝对路径 String realPath = servletContext.getRealPath(&quot;/test.txt&quot;); System.out.println(&quot;test.txt realPath&quot; + realPath); //3、获取当前WEB 应用的工程路径 String contextPath = servletContext.getContextPath(); System.out.println(&quot;contextPath: &quot; + contextPath); //4、获取当前WEB应用的某一个文件对应的输入流 InputStream resourceAsStream = servletContext.getResourceAsStream(&quot;/WEB-INF/jdbc.properties&quot;); System.out.println(&quot;resourceAsStream: &quot; + resourceAsStream); &#125; //@Override Method...&#125; 工程目录与打印结果 ServletRequest基本概念Servlet 的 service方法用于应答请求，每次请求都会调用 service() 方法。服务器并给予ServletRequest与ServletRsponse接口实现，将请求与响应的信息封装到这两个接口中，并在服务器调用 service 方法时传入实现类对象。 作用 ServletRequest: 封装了请求信息，可以从中获取到任何的请求信息. APIjavax.servlet Interface ServletRequest All Known Subinterfaces: HttpServletRequest/Respone (tips：重要的子接口) Method Summary：方法众多，以下为当前常用的方法，有需要查询API ServletRequest获取请求参数相关 String getParameter(String name)：根据html标签的name属性, 返回value. 若请求参数有多个值(例如 checkbox), 该方法只能获取到第一个提交的值 String[] getParameterValues(String name)：根据html标签的name属性, 返回对应的值的字符串数组 Enumeration getParameterNames()：返回所有请求参数名names对的Enumeration 对象 Map getParameterMap()：返回所有请求参数的键值对, String 数组类型 Attribute相关的方法，暂时略，后续补充说明 …… HttpServletRequest：以下功能需使用功能更强大的HTTP相关的(扩展)子接口 String getRequestURI()：获取请求的URI(URL除站点外的字符串) String getMethod()：获取请求方式 String getQueryString()**：获取URL中的请求字符串**(如GET请求?后部分) String getServletPath()：获取servlet映射路径(web.xml配置的mapping路径) …… 请求参数相关 前端部分 12345678910111213&lt;form action=&quot;/06_helloweb/login&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt; interesting: &lt;input type=&quot;checkbox&quot; name=&quot;interesting&quot; value=&quot;java&quot; checked=&quot;checked&quot;&gt;java &lt;input type=&quot;checkbox&quot; name=&quot;interesting&quot; value=&quot;C++&quot;&gt;C++ &lt;input type=&quot;checkbox&quot; name=&quot;interesting&quot; value=&quot;C&quot; checked=&quot;checked&quot;&gt;C &lt;input type=&quot;checkbox&quot; name=&quot;interesting&quot; value=&quot;mysql&quot; checked=&quot;checked&quot;&gt;mysql &lt;input type=&quot;checkbox&quot; name=&quot;interesting&quot; value=&quot;php&quot;&gt;php &lt;input type=&quot;checkbox&quot; name=&quot;interesting&quot; value=&quot;go&quot;&gt;go &lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; web.xml 12345678&lt;servlet&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.test.servlet.LoginServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; LoginServlet.java 123456789101112131415161718192021222324252627282930313233343536373839public class LoginServlet implements Servlet &#123; @Override public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException &#123; //1、根据请求参数的name, 返回value. 若请求参数 //有多个值(例如 checkbox), 该方法只能获取到第一个提交的值 String user = request.getParameter(&quot;user&quot;); String password = request.getParameter(&quot;password&quot;); String interesting_one = request.getParameter(&quot;interesting&quot;); System.out.println(&quot;user = &quot; + user); System.out.println(&quot;password = &quot; + password); System.out.println(&quot;interesting_one = &quot; + interesting_one); //2、据请求参数的name, 返回对应的值的字符串数组 String[] interesting = request.getParameterValues(&quot;interesting&quot;); for (int i = 0; i &lt; interesting.length; i++) &#123; System.out.println(&quot;interest = &quot; + (i + 1) + &quot; &quot; + interesting[i]); &#125; //3、返回所有请求参数名names对的Enumeration 对象 Enumeration&lt;String&gt; parameterNames = request.getParameterNames(); while (parameterNames.hasMoreElements()) &#123; String name = parameterNames.nextElement(); String value = request.getParameter(name); System.out.println(&quot;name : value = &quot; + name + &quot; : &quot; + value); &#125; //4、返回所有请求参数的键值对, Map&lt;String,String&gt; 数组类型 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); for (Map.Entry&lt;String, String[]&gt; param : parameterMap.entrySet()) &#123; System.out.println(&quot;name : value = &quot; + param.getKey() + &quot; : &quot; + Arrays.asList(param.getValue())); &#125; &#125; // @Override...Method&#125; 打印结果如下 123456789101112user = testpassword = 123456interesting_one = javainterest = 1 javainterest = 2 Cinterest = 3 mysqlname : value = user : testname : value = password : 123456name : value = interesting : javaname : value = user : [test]name : value = password : [123456]name : value = interesting : [java, C, mysql] ServletResponse作用ServletResponse: 封装了响应信息, 如果想给用户什么响应, 具体可以使用该接口的方法实现. APIjavax.servlet Interface ServletResponse All Known Subinterfaces: HttpServletResponse (tips：重要的子接口) Method Summary ServletResponse： PrintWriter getWriter() 返回 PrintWriter 对象. 调用该对象的 print() 方法, 将把 print() 中的参数直接打印到客户的浏览器上. PrintWriter 对象还可配合setContentType响应类型，把内容输入到响应类型文件内 void setContentType(String type)： 设置响应的内容类型，如pdf类型”application/pdf”，具体其他文件类型type值可打开[tomcat安装路径]]\\conf\\web.xml文件进行查询，例如 1234&lt;mime-mapping&gt; &lt;extension&gt;pdf&lt;/extension&gt; &lt;mime-type&gt;application/pdf&lt;/mime-type&gt;&lt;/mime-mapping&gt; … HttpServletResponse： ③. void sendRedirect(String location)：请求的重定向，后续补充 GenericServlet需求驱动 在 web.xml 文件中设置两个 WEB 应用的初始化参数, user, password. 定义一个 login.html, 里边定义两个请求字段: user, password. 发送请求到 loginServlet 获取请求方式 在创建一个 LoginServlet, 在其中获取请求的 user, password. 比对其和 web.xml 文件中定义的请求参数是否一致 若一致，作出基本提示 LoginServlet.java文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 基于实现Servlet接口进行Servlet程序开发 */public class LoginServlet implements Servlet &#123; //在类内部声明一个ServletConfig属性， //用于暂存从init方法中获取的servletConfig对象 @Override public void init(ServletConfig servletConfig) throws ServletException &#123; this.servletConfig = servletConfig; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; private ServletConfig servletConfig; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //1、获取应用初始化参数username、password ServletContext servletContext = servletConfig.getServletContext(); String user = servletContext.getInitParameter(&quot;username&quot;); String psw = servletContext.getInitParameter(&quot;password&quot;); //2、获取login.html请求参数 String username = servletRequest.getParameter(&quot;username&quot;); String password = servletRequest.getParameter(&quot;password&quot;); PrintWriter writer = servletResponse.getWriter(); String mes; //3、将请求中的参数与web应用初始化参数信息进行比较 if(user.equals(username) &amp;&amp; psw.equals(password))&#123; mes = &quot;App: login succeed&quot;; &#125;else&#123; mes = &quot;App: login failed&quot;; &#125; writer.print(mes); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125;&#125; web.xml文件 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;context-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;12345&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;55555&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.test.java.LoginServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 解决思路由于WEB应用的初始化参数必须通过ServletContext对象获取，而该对象又需要ServletConfig对象获取。ServletConfig则需在init方法才能得到实体引用。因此关键实现步骤如下： 暂存从init方法中获取的ServletConfig引用 定义一个private ServletConfig servletConfig 属性，用于存储servletConfig的引用 从init方法中对servletConfig引用赋值 通过servletConfig获取ServletContext进而获取WEB应用的初始化参数 问题分析 存在的问题： 在完成上述简单功能时候为了实现Servlet接口，出现众多无需使用的空方法 想使用ServletConfig 或ServletContext每次都需创建一个属性从init方法中暂存引用 解决方案： 自定义一个Servlet实现类、尝试实现里面的方法。 在后续开发Servlet程序时通过继承的这个实现类的方式开发，以简化开发 MyGenericServlet.java 1234567891011121314151617181920212223242526272829303132333435363738/** * 在后续开发Servlet程序时通过继承的这个实现类的方式开发，以简化开发 */public abstract class MyGenericServlet implements Servlet &#123; //1、声明一个ServletConfig变量用于暂存init方法中获取到的引用 private ServletConfig servletConfig; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; this.servletConfig = servletConfig; &#125; //2、尝试实现方法：可以实现，即返回ServletConfig引用 @Override public ServletConfig getServletConfig() &#123; return this.servletConfig; &#125; /** * 3、由于service方法是开发servlet必须使用与实现的方法 * 可以将其定义未抽象方法，即强制继承的子类必须实现这个方法 * 由于该方法定义成abstract，因此MyGenericServlet需改成抽象类 */ @Override public abstract void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException; //4、尝试实现方法：无法实现 @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125;&#125; 通过继承MyGenericServlet.java实现优化后的LoginServlet开发 无需强制实现Servlet其他不需要的方法 可通过getServletConfig()，在任意位置获取到ServletConfig()对象 123456789101112131415161718192021222324252627/* * 基于自实现的GenericServlet——MyGenericServlet进行Servlet开发 */public class LoginServlet2 extends MyGenericServlet &#123; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //1、获取应用初始化参数username、password ServletContext servletContext = getServletConfig().getServletContext(); String user = servletContext.getInitParameter(&quot;username&quot;); String psw = servletContext.getInitParameter(&quot;password&quot;); //2、获取login.html请求参数 String username = servletRequest.getParameter(&quot;username&quot;); String password = servletRequest.getParameter(&quot;password&quot;); PrintWriter writer = servletResponse.getWriter(); String mes; //3、将请求中的参数与web应用初始化参数信息进行比较 if(user.equals(username) &amp;&amp; psw.equals(password))&#123; mes = &quot;App2: login succeed&quot;; &#125;else&#123; mes = &quot;App2: login failed&quot;; &#125; writer.print(mes); &#125;&#125; GenericServletGenericServlet是实现Servlet的一个抽像类，上述自实现的MyGenericServlet要解决的问题与思路和GenericServlet一致。不过官方的GenericServlet除了实现Servlet接口，还实现了ServletConfig接口，意义使继承GenericServlet的Servlet能够直接调用ServletConfig的所有方法(ServletConfig是对标一个Servlet的)，进而更一步提高了GenericServlet的功能。提高了开发Servlet的效率。GenericServlet一些其他细节如下所示： 源码中ServletConfig接口方法的实现，是使用从init方法中获取的ServletConfig对象直接调用对应方法来间接实现的。 123456789101112public abstract class GenericServlet implements Servlet, ServletConfig, Serializable &#123; //..... public String getInitParameter(String name) &#123; return this.getServletConfig().getInitParameter(name);//间接实现 &#125; public Enumeration&lt;String&gt; getInitParameterNames() &#123; return this.getServletConfig().getInitParameterNames();//间接实现 &#125; //.....&#125; GenericServlet在实现的Servlet接口中原生的init(ServletConfig servletConfig)方法的同时调用了一个自定义的**空参init()**方法。作用如下说明： **空参init()**方法用于给继承GenericServlet开发的子类想通过init方法进行一些初始化操作 由于GenericServlet关键在于声明了一个ServletConfig类型成员变量，在原生带参的init(ServletConfig)方法中进行了初始化。 若子类直接重写GenericServlet的带参init(ServletConfig)方法进行初始化操作。则会导GenericServlet对ServletConfig初始化失败，系统默认调用了子类重写的init方法。因此当子类在调用GenericServlet封装好且涉及ServletConfig参与实现的方法时，就会出现空指针异常。 小结： 若子类想使用初始化init方法，建议重写空参的init()方法，不建议重写init(ServletConfig) 若子类有必要重写init(ServletConfig)，则必须在init方法中super.init(ServletConfig)显式调用一下父类的带参init方法，使父类的ServletConfig能顺利被初始化 因此，严格来说，GenericServlet定义的空参init()方法并非Servlet的生命周期方法，init(ServletConfig)才是。 12345678910111213public abstract class GenericServlet implements Servlet, ServletConfig, Serializable &#123; //..... public void init(ServletConfig config) throws ServletException &#123; this.config = config; this.init(); &#125; public void init() throws ServletException &#123; &#125; //.....&#125; HTTP请求处理HTTP请求GET请求格式 请求行 请求的方式 GET 请求的资源路径[+?+请求参数] 请求的协议的版本号 HTTP/1.1 请求头：key : value 组成多个不同的键值对，表示不同的含义。 传递参数格式http://www.xxx.com/index.jsp?name=lc&amp;password=123 ? 隔开URL与参数列表 每个参数有键值对 name=value组成 多个简直对之间用 &amp; 相隔 GET请求类型操作 form 标签method=get 超链接 a标签或img标签 在浏览器地址栏中输入地址后敲回车 特点POST请求格式 请求行 请求的方式 POST 请求的资源路径[+?+请求参数] 请求的协议的版本号 HTTP/1.1 请求头：key : value组成多个不同的请求头，有不同的含义 空行 请求体 ：发送给服务器的数据 POST请求类型操作 form 标签 method=post HTTP响应响应格式 响应行 响应的协议和版本号 响应状态码 响应状态描述符 响应头： key : value 不同的响应头，有其不同含义 空行 响应体：回传给客户端的数据 常用的响应码 200 表示请求成功 302 表示请求重定向 404 表示请求服务器已经收到了，但是你要的数据不存在（请求地址错误） 500 表示服务器已经收到请求，但是服务器内部错误（代码错误） MIME类型说明 MIME 的英文全称是”Multipurpose Internet Mail Extensions” 多功能 Internet 邮件扩充服务。 MIME 是 HTTP 协议中数据类型，用于表示某一种文件的扩展名。 MIME 类型的格式是“大类型/小类型” 具体可通过网络查询 HttpServletHttpServletRequest/Response初谈需求驱动 在通过Servlet去处理HTTP请求时，若想获取请求的方式，进而区分处理两种不同类型的请求(GET/POST)时，服务器给予的ServletRequest/Response实现类是不能满足需求的。 由于ServletReqeust与ServletResponse是基于请求—响应这个服务机制层面上的封装，严格来说没有指明使用的通信协议。而GET/POST请求时HTTP协议所特有的，因此在使用HTTP协议所涉及的相关功能时，需要使用——HttpServletRequest/Response接口 简介HttpServletRequest/Response分别是ServletRequest/Response接口基于HTTP协议的子接口，在ServletRequest/Response原有功能的基础上，规范定义许多HTTP协议特用的方法。与ServletRequest/Response类似，具体的实现类由HTTP服务器提供 获取HttpServletRequest/Response由于HttpServletRequest/Response是ServletRequest/Response的子接口。而在开发基于HTTP协议的应用时，HTTP服务器实现的肯定是HttpServletRequest/Response。而通过上层协议规范ServletRequest/Response传入 因此可以在获取ServletRequest/Response实体后通过向下转型(强制转换)**得到HttpServletRequest/Response。具体操作在service**(ServletRequest,ServletResponse)方法中实现 得到HttpServletRequest/Response实现类后，可调用request.getMethod();获取HTTP请求方式 1234567891011public class Test implements Servlet &#123; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //通过向下转型(强制类型转换)获得其实现类 HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; String requestMethod = request.getMethod(); &#125; //@Override...method，略&#125; 需求驱动即使通过继承GenericServlet开发Servlet已经方便了许多，但是当处理HTTP请求时还是需要将ServletRequest/Response手动强制转换为HttpServletRequest/Response才能更好的处理HTTP请求。而每次开发Servlet处理HTTP请求都需要书写强制类型转换语句，显然还有优化的空间。 因此，可以在GenericServlet基础上针对HTTP协议再进行优化，创建一个专门用于处理HTTP请求Servlet接口实现类。具备的基本功能如下： 如封装好将ServletRequest/Response转换为HttpServletRequest/Response的步骤。 实现GET请求、POST请求的分发处理 …. MyHttpServlet.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 自定义一个基于GenericServlet，HTTP协议的Servlet接口实现类，基本功能如下： * 1、封装好将ServletRequest/Response转换为HttpServletRequest/Response * 2、实现GET请求、POST请求的分发 */public class MyHttpServlet extends GenericServlet &#123; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //1、封装好将ServletRequest/Response转换为HttpServletRequest/Response //1.1、通过instanceof检查实现类的实际类型 if(servletRequest instanceof HttpServletRequest)&#123; HttpServletRequest request = (HttpServletRequest)servletRequest; if(servletResponse instanceof HttpServletResponse)&#123; HttpServletResponse response = (HttpServletResponse) servletResponse; //1.2、创建一个重载service(HttpServletRequest,HttpServletResponse) //传入转换后的HttpServletRequest/Response 实体引用。 //子类通过重写service(HttpServletRequest,HttpServletResponse)方法 //进而实现直接使用HttpServletRequest/Response service(request,response); &#125; &#125; &#125; //1.2、创建一个重载service(HttpServletRequest,HttpServletResponse) public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //2、实现GET请求、POST请求的分发处理 //2.1、通过HttpServletRequest获取当前HTTP请求类型，并进行判断 String requestMethod = request.getMethod(); if(&quot;GET&quot;.equals(requestMethod))&#123; doGet(request,response);//2.2、模仿service方法，创建专门处理GET请求的方法doGet &#125; if(&quot;POST&quot;.equals(requestMethod))&#123; doPost(request,response);//2.2、模仿service方法，创建专门处理POST请求的方法doPost &#125; &#125; //开发的时候，可以针对HTTP协议对不同的请求重写对应的doGet或doPost实现更方便的处理 //2.2、模仿service方法，创建专门处理GET请求的方法doGet public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; //2.2、模仿service方法，创建专门处理POST请求的方法doPost public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; 基于MyHttpServlet的servlet开发，更加有针对性，简洁，有效 123456789101112131415161718192021222324252627/** * 基于自实现的HttpServlet——MyHttpServlet进行Servlet开发 * @author yhd * @create 2021-04-06 8:10 */public class LoginServlet4 extends MyHttpServlet &#123; @Override public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1、获取应用初始化参数username、password String user = getServletContext().getInitParameter(&quot;username&quot;); String psw = getServletContext().getInitParameter(&quot;password&quot;); //2、获取login.html请求参数 String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); PrintWriter writer = response.getWriter(); String mes; //3、将请求中的参数与web应用初始化参数信息进行比较 if(user.equals(username) &amp;&amp; psw.equals(password))&#123; mes = &quot;App4: login succeed&quot;; &#125;else&#123; mes = &quot;App4: login failed&quot;; &#125; writer.print(mes); &#125;&#125; HttpServletHttpServlet继承与GenericServlet，上述自实现的MyHttpServlet要解决的问题思路以及功能与HttpServlet类似。在真正的Servlet开发中，是通过继承HttpServlet方式进行开发，根据请求方式重写doXxx()方法即可。 (了解)其中如果我们对一个请求没有进行任何doXxx()方法的重写，其实源码内部已经对该请求进行了一定程度的受理 Servlet体系结构优化Servlet开发层面 请求处理层面 ServletRequest/Response 接口 —— &gt; 针对HTTP协议HttpServletRequest/Response接口 均有服务器提供实现类 HttpServletRequesttips：概念介绍请转至标题HttpServlet下的HttpServletRequest/Response初谈 API getRequestURI() ：获取请求的资源路径 getRequestURL() ：获取请求的统一资源定位符（绝对路径） getRemoteHost() ：获取客户端的 ip 地址 getHeader() ：获取请求头（User-Agent的值） getMethod()： 获取请求的方式 GET 或 POST – ServletRequest – 来自父接口的方法 getParameter()： 获取请求的参数 getParameterValues()： 获取请求的参数（多个值的时候使用） setAttribute(key, value)：设置域数据 getAttribute(key)：获取域数据 getRequestDispatcher()： 获取请求转发对象 … 请求中文乱码问题GET请求后端获取带中文的请求参数时，打印显示?????，由于传输默认编码为iso-8859-1 方式1：先正确解码，再对应编码 1234//获取请求参数String username = req.getParameter(&quot;username&quot;);//先以iso8859-1 解码，再以utf-8进行编码username = new String(username.getBytes(&quot;iso-8859-1&quot;), &quot;UTF-8&quot;); 方式2：修改tomcat收到请求时url参数的编码方式 打开tomcat安装目录中的conf\\server.xml，修改成如下内容 1&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot; useBodyEncodingForURI=&quot;true&quot;/&gt; POST请求12//在获取请求参数前设置request.setCharacterEncoding(&quot;UTF-8&quot;); HttpServletResponseAPIServletResponse接口定义 PrintWriter getWriter()：字符流，常用于回传字符串（常用） 返回 PrintWriter 对象. 调用该对象的 print() 方法, 将把 print() 中的参数直接打印到客户的浏览器上. PrintWriter 对象还可配合setContentType响应类型，把内容输入到响应类型文件内 OutputStream getOutputStream()：字节流，常用于下载（传递二进制数据） 注意：两个流同时只能获取一个，否则就会报错。 响应中文乱码问题当通过字符流PrintWriter getWriter()向浏览器直接传送中文字符时，常见显示?????乱码情况。 乱码的原因 乱码问题终归就是：发送方的编码字符集与接收方的编码字符集不兼容导致 可通过调用response.getCharacterEncoding();获取当前服务器的默认编码集(ISO-8859-1) 一般浏览器默认是GBK编码，因此服务器与浏览器字符集不匹配因此。这是造成乱码的首要原因 因此最直接的解决方案(不推荐！)：response.setCharacterEncoding(&quot;GBK&quot;); GBK编码：一个汉字占用两个字节，此编码为中国专用的汉字编码而形成之解决方案。 UTF-8编码：一个汉字占用3个字节。是全世界统一的编码结构。外国网站看的话不会乱码。 Unicode是「字符集」：为每一个「字符」分配一个唯一的 ID(学名为码位 / 码点 / Code Point） UTF-8 是「编码规则」：将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程） 小结：因此在选择中文编码集时，由于国际化问题，优先选用UTF-8。 若为了国际化将服务器编码设置为response.setCharacterEncoding(&quot;UTF-8&quot;);又会因为浏览器默认GBK编码而又导致了乱码。此时可以通过将浏览器的编码设置为UTF-8来解决问题，但不推荐，由于不可能让用户每次访问该网页时都手动设置一下编码。而且有些浏览器设置困难 推荐解决方案 方式1：设置响应头，告诉浏览器接收到数据时，采用UTF-8解析网页内容 1response.setHeader(&quot;Content-Type&quot;,&quot;text/html;charset=UTF-8&quot;); 方式2：设置内容类型，同时设置了服务器和客户端都使用UTF-8字符集，还设置了响应头。注意：此方法一定要在获取流对象之前调用才有效 1resp.setContentType(&quot;text/html;charset=UTF-8&quot;); Web中路径相关问题IDE项目与站点目录http://ip:port/工程路径 == WEB资源根目录(IDEA web，eclipse WebContent) 绝对与相对路径基本概念 相对路径： 符号 含义 . 表示当前目录 .. 表示上一级目录 资源名 表示当前目录/资源名 绝对路径：http://ip:port/工程路径/资源路径 Web路径常见问题场景驱动base标签base标签的作用 tips：原生javaweb阶段可以使用 base+相对路径 这个解决方案，但涉及框架参与的开发建议使用绝对路径 base页面只对当前页面有效 相对路径工作时默认是参照当前页面路径进行跳转，通过设置base标签可以是相对路径工作时的参照base标签设置的路径进行跳转。base标签默认省略末尾属于资源部分的路径信息，因此末尾是目录的话斜杠不能省，省了就不是目录，而是资源了 注意：一般设置base后，页面原本使用相对路径引入的资源一般都会失效了，如js、css、图片资源等，需对应的进行引入路径修改,(若之前加载过请清楚缓存后再查看)，或者F12查看Console错误提示 &lt;base href=&quot;&quot;&gt; 动态组成base64 123456789101112&lt;% //http:// StringBuffer basePath = new StringBuffer(); basePath.append(request.getScheme()); basePath.append(&quot;://&quot;); basePath.append(request.getServerName()); basePath.append(&quot;:&quot;); basePath.append(request.getServerPort()); basePath.append(request.getContextPath()); basePath.append(&quot;/&quot;);%&gt;&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt; ‘/‘ 斜杠的不同含义在 web 中 / 斜杠是一种绝对路径 / 若被浏览器解析（前端代码）： http://ip:port/ 1&lt;a href=&quot;/&quot;&gt;斜杠&lt;/a&gt; / 若被服务器解析（Servlet、web.xml、JSP）： http://ip:port/工程路径 特殊情况，重定向：response.sendRediect(“/”); 把斜杠发送给浏览器解析 http://ip:port JSP需求驱动前端想通过发送一个请求返回整个java处理过的HTML页面(动态页面)，而非PrintWriter返回的几个字符串，则传统的方式只能通过PrintWriter逐一打印出整个html代码，如下所示。 ReturnHtml.java 123456789101112131415161718/** * @author yhd * @create 2021-04-07 21:33 */public class ReturnHtml extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; StringBuilder result = new StringBuilder(); Date date = new Date();//获取当前时间 result.append(&quot;&lt;form&gt;&quot;); result.append(&quot;当前时间：&lt;input type=\\&quot;text\\&quot; name=\\&quot;username\\&quot; value=\\&quot; &quot; + date + &quot; \\&quot;&gt;&lt;br/&gt;&quot;); result.append(&quot;&lt;/form&gt;&quot;); resp.setContentType(&quot;text/html;charset=UTF-8&quot;); PrintWriter writer = resp.getWriter(); writer.print(result.toString()); &#125;&#125; index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;/08_JSP/getHTML&quot; &gt;获取HTML页面&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 最终效果 小结：只能通过这种方式返回经过java处理过的页面，编写和维护都将非常困难，实在效率太低了 JSP基本概念 为弥补 Servlet 的缺陷，SUN公司在Servlet的基础上推出了JSP（Java Server Pages）技术作为解决方案。 JSP是简化Servlet编写的一种技术，它将Java代码和HTML语句混合在同一个文件中编写，只对网页中的要动态产生的内容采用Java代码来编写，而对固定不变的静态内容采用普通静态HTML页面的方式编写。 JSP文件就像普通的HTML文件一样，可以放置在WEB应用程序中的除了WEB-INF及其子目录外的其他任何目录中，JSP页面的访问路径与普通HTML页面的访问路径形式也完全一样。 HelloWorld 在IDEA 或 eclipse中右键新建一个JSP文件 在&lt;body&gt;标签内写入&lt;% %&gt; 在&lt;% %&gt;内可以编写Java代码 index.jsp 123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 我是JSP页面 &lt;% System.out.println(&quot;JSP：在前端页面编写后台打印语句！&quot;); %&gt; &lt;/body&gt;&lt;/html&gt; 最终效果 JSP运行原理运行原理 WEB容器（Servlet引擎）收到以.jsp为扩展名的URL的访问请求时，会把该访问请求交给JSP引擎去处理。 每个JSP页面在第一次被访问时，JSP引擎将它翻译成一个Servlet源程序(.java文件)， 接着再把这个Servlet源程序编译成Servlet的.class类文件 然后再由WEB容器（Servlet引擎）像调用普通Servlet程序一样的方式来装载和解释执行这个由JSP页面翻译成的Servlet程序。 JSP的Servlet源程序源程序路径 IDEA存放位置：C:\\Users\\[用户名]\\AppData\\Local\\JetBrains\\IntelliJIdea2020.3\\tomcat\\[XXXX-XX-标识符-XXXX-XXXX]\\work\\Catalina\\localhost\\[项目名称]\\org\\apache\\jsp目录下 JSP本质 观察JSP源程序：可以发现index_jsp这个类继承了HttpJspBase 通过观察HttpJspBase源码发现HttpJspBase继承HttpServlet 结论：因此可知JSP源程序是间接继承了HttpServlet的，即JSP本质上就是Servlet index_jsp.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 package org.apache.jsp; import javax.servlet.*; import javax.servlet.http.*; import javax.servlet.jsp.*; public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent, org.apache.jasper.runtime.JspSourceImports &#123; //....省略部分代码.... //类似Servlet的Init方法 public void _jspInit() &#123; &#125; //类似Servlet的destroy方法 public void _jspDestroy() &#123; &#125; //类似Servlet的service方法 public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException &#123; //..... &#125; //类似Servlet相关的一些类，ServletContext、ServletCondig等... //这些其实就是后面所说的JSP隐函对象 final javax.servlet.jsp.PageContext pageContext; javax.servlet.http.HttpSession session = null; final javax.servlet.ServletContext application; final javax.servlet.ServletConfig config; javax.servlet.jsp.JspWriter out = null; final java.lang.Object page = this; javax.servlet.jsp.JspWriter _jspx_out = null; javax.servlet.jsp.PageContext _jspx_page_context = null; try &#123; response.setContentType(&quot;text/html;charset=UTF-8&quot;); pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out; out.write(&quot;\\n&quot;); out.write(&quot;\\n&quot;); out.write(&quot;&lt;html&gt;\\n&quot;); out.write(&quot; &lt;head&gt;\\n&quot;); out.write(&quot; &lt;title&gt;$Title$&lt;/title&gt;\\n&quot;); out.write(&quot; &lt;/head&gt;\\n&quot;); out.write(&quot; &lt;body&gt;\\n&quot;); out.write(&quot; 我是JSP页面\\n&quot;);//自编写的HTML元素 out.write(&quot; &quot;); //自编写的java代码 System.out.println(&quot;JSP：在前端页面编写后台打印语句！&quot;); out.write(&quot;\\n&quot;); out.write(&quot; &lt;/body&gt;\\n&quot;); out.write(&quot;&lt;/html&gt;\\n&quot;); &#125; catch (java.lang.Throwable t) &#123; //....省略部分代码.... &#125; &#125;&#125; HttpJspBase：继承了HttpServlet，里面的init、service等Servlet生命周期方法都对应调用了jsp源程序的相关Servlet生命周期代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 public abstract class HttpJspBase extends HttpServlet implements HttpJspPage &#123; private static final long serialVersionUID = 1L; protected HttpJspBase() &#123; &#125; @Override public final void init(ServletConfig config) throws ServletException &#123; super.init(config); jspInit(); _jspInit(); &#125; @Override public String getServletInfo() &#123; return Localizer.getMessage(&quot;jsp.engine.info&quot;, Constants.SPEC_VERSION); &#125; @Override public final void destroy() &#123; jspDestroy(); _jspDestroy(); &#125; /** * Entry point into service. */ @Override public final void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; _jspService(request, response); &#125; @Override public void jspInit() &#123; &#125; public void _jspInit() &#123; &#125; @Override public void jspDestroy() &#123; &#125; protected void _jspDestroy() &#123; &#125; @Override public abstract void _jspService(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException;&#125; 9大隐含对象 从JSP运行原理中看到JSP对应的Servlet源程序时可发现，自编写的java代码在void _jspService()方法内，而该方法的首部，还定义了许多对象。这些便是JSP的隐函对象，可供我们在JSP编写java代码时不用声明(已经帮我们声明)直接使用使用。 JSP的9个隐函对象：request、response、pageContext、session、application、config、out、page、exception request：HttpServletRequest对象. response(了解)：HttpServletResponse 对象(在 JSP 页面中几乎不会调用 response 的任何方法.) pageContext: 页表示面的上下文，PageContext的一个对象封装了当前页面的一切信息(学习自定义标签时使用它) 可以从该对象中获取到其他 8 个隐含对象. 也可以从中获取到当前 session：代表浏览器和服务器的一次会话, 是 HttpSession 的一个对象. 后面详细学习 application: 代表当前 WEB 应用，是ServletContext对象. config(了解)：当前 JSP 对应的 Servlet 的 ServletConfig 对象(几乎不使用). 若需要访问当前 JSP页面。配置的初始化参数, 需要配置jsp页面的映射的地址才可以。 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;hellojsp&lt;/servlet-name&gt; &lt;jsp-file&gt;/hello.jsp&lt;/jsp-file&gt; &lt;init-param&gt; &lt;param-name&gt;test&lt;/param-name&gt; &lt;param-value&gt;testValue&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hellojsp&lt;/servlet-name&gt; &lt;url-pattern&gt;/hellojsp&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; out：JspWriter对象. 调用 out.println() 可以直接把字符串打印到浏览器上 page(几乎不使用))：指向当前 JSP 对应的Servlet 对象的引用, 但为 Object 类型, 只能调用 Object 类的方法 exception：在声明了 page 指令的 &lt;%@ page isErrorPage=&quot;true&quot; %&gt; 时, 才可以使用。 JSP基本语法模板元素静态HTML内容称之为JSP模版元素，在静态的HTML内容之中可以嵌套JSP的其他各种元素来产生动态内容和执行业务逻辑。 注释123&lt;!-- html注释：会被翻译导java源代码中，通过out.writer方式输出 --&gt;// 或 /* java注释，也会被翻译导java源代码中 */&lt;%-- JSP注释,真正的注释，不会被翻译 --%&gt; JSP脚本JSP小脚本语法格式：&lt;% %&gt; 12345&lt;!-- 打印当前时间 --&gt;&lt;% Date date = new Date();%&gt;&lt;% System.out.println(date); %&gt; 每次访问含小脚本的页面，小脚本都会被重头执行。 只能编写方法内语句。 原理：由于JSP小脚本内编写的代码时直接移植到jsp对应Servlet源程序的_jspService()方法内，因此像声明一个java方法的这些语句是不能够写在JSP小脚本内的(java中方法内不能定义方法)。 123456789public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent, org.apache.jasper.runtime.JspSourceImports &#123; public void _jspService(final javax.servlet.http.HttpServletRequest request , final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException &#123; //&lt;% %&gt;JSP小脚本代码移植的位置 &#125; &#125; JSP声明语法格式：&lt;%! %&gt; 12&lt;!-- 声明一个名为date的Date类型变量 --&gt;&lt;%! Date date = null; %&gt; 只能编写声明，定义类型的java语句。不能直接编写java代码 使用&lt;%! %&gt;声明变量仅在页面第一次加载时由容器只初始化一次，后续再访问页面不再执行。 若使用&lt;% %&gt;小脚本声明变量，由于小脚本每次访问页面时都被执行。因此每次都是重新声明变量。 原理：JSP声明的内容是移植到jsp对应Servlet源程序的类中，是属于类的成员的一部分。因此只能编写书写属性、方法声明语句。 tips：几乎不怎么使用 12345678public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent, org.apache.jasper.runtime.JspSourceImports &#123; //&lt;%! %&gt;JSP声明代码移植的位置(类成员) public void _jspService(/*...省略...*/)&#123; //&lt;% %&gt;JSP小脚本代码移植的位置(方法内) &#125;&#125; JSP表达式语法格式：&lt;%= %&gt; 12&lt;!-- 输出当前时间 --&gt;&lt;%= new Date() %&gt; 可直接输出任何对象(null)或任何基本数据类型、表达式、方法调用返回值等 JSP表达式的百分号%和等号=之间不能有空格 JSP表达式内的语句不用写分号，原理(out.print(翻译语句**;**));，若加了分号则导致 ));语句多出，语法错误 原理：与jsp小脚本一样，翻译在_jspService()方法内，通过调用PrintWrite，print方法打印，因此还可以获取request，response对象 JSP与HTML互嵌123456789101112&lt;% int i = 10; if(i &gt; 10)&#123;%&gt; &lt;a href=&quot;/08_JSP/index.jsp&quot;&gt;大于10&lt;/a&gt;&lt;% &#125;else&#123;%&gt; &lt;a href=&quot;/08_JSP/index.jsp&quot;&gt;小于10&lt;/a&gt;&lt;% &#125;%&gt; JSP指令用于向容器提供关于JSP页面的总体信息，并不产生任何输出，语法格式为&lt;%@ 指令 属性名 = &quot;值&quot; %&gt;。一般写在JSP首部。指令有三种类型： page include taglib page指令 描述JSP页面的总体特性，如输出内容类型、字符集编码等信息 配置多个属性可以用空格隔开，或使用多条指令语句单独设置 123&lt;!--返回的内容类型及返回内容的编码、翻译后语言、及JSP页面本身编码的字符集--&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot; %&gt; 其他属性：常用为加粗表示 language：表示jsp翻译后是什么语言，暂时只支持java extends=”package.class”：表明当前JSP被翻译成源程序(.java)时继承哪个类 import=”package.class”：与java一样导包，导类 session=”true | false”：设置当前页面是否启用session，使用session前必须设置为true errorPage=”错误页面路径”：jsp本身代码出错时，自动转发到这个页面。 还可以通过在web.xml中配置&lt;error-page&gt;信息来实现 12345678910&lt;!-- 通过http错误代码配置错误页面 --&gt;&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/WEB-INF/error.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;!-- 通过设定的异常类跳转错误页面 --&gt;&lt;error-page&gt; &lt;exception-type&gt;java.lang.ArithmeticException&lt;/exception-type&gt; &lt;location&gt;/WEB-INF/error.jsp&lt;/location&gt;&lt;/error-page&gt; isErrorPage=”true | false” ： 默认为false，true时可使用exception隐函对象，打印出错信息。 只有出错时exception才不会null，因此不建议直接访问含该对象时候的网页。 因此推荐把调用exception对象的错误页面放入WEB-INF中，通过外部请求的转发访问。 contentType=”mimeType [ ;charset=characterSet ]” | “text/html ;charset=ISO-8859-1” ] 指定当前JSP的响应类型，实际调用response.setContentType(); 同理也可以再配置中设置响应类型的字符编码charset pageEncoding=”characterSet| ISO-8859-1”] ：指定当前JSP页面编码的字符编码，一般与上述的字符编码设置一致 isELIgnored=”true | false”：指定当前JSP页面是否可以使用EL表达式，通常取值为true autoFlush：设置当out输出缓冲区满了之后，是否自动刷新缓冲区。默认true buffer：设置out缓冲区的大小，默认8kb include指令 include指令实现把另一个文件(HTML、JSP等)的内容静态包含到当前页面中。 静态包含 静态包含其实是吧被包含得jsp页面的代码拷贝到包含的位置执行输出(out.write()) 静态包含不会翻译被包含的jsp页面，即只有一个jsp源文件 1&lt;%@ include file = &quot;copyright.html&quot; %&gt; JSP动作JSP动作JSP页面发给容器的命令，它指示容器在页面执行期间(动态)，完成的某种任务。 基本语法：&lt;前缀: 动作名称 属性列表键值对 /&gt;，如&lt;jsp:include page=&quot;copyright.html&quot;/&gt; 动作类型：JSP标准动作、标准标签库(JSTL)、用户自定义动作 常用动作： jsp:include：在当前页面中动态包含另一个页面 非源码级搬运包含，而是通过内置调用一个方法包含 JspRuntimeLibrary.include(request, response, &quot;/include/footer.jsp&quot;, out, false 生成多个servlet源文件，即包含与被包含数目。 多数使用静态包含 jsp:forward page = “”：请求转发到指定页面 可以使用 jsp:param 子标签传入一些参数，响应端可通过getParameter() 123 &lt;jsp:forward page=&quot;/include/b.jsp&quot;&gt;&lt;jsp:param value=&quot;abcd&quot; name=&quot;username&quot;/&gt; &lt;/jsp:forward&gt; jsp:useBean：查找或创建一个javaBean对象 jsp:setProperty：设置JavaBeans对象的属性值 jsp:getProperty：返回JavaBeans对象的属性值 jsp:plugin：在JSP页面中嵌入一个插件 四大域对象通用方法pageContext，request，session，application对象都含以下方法 void setAttribute(String name, Object object)：设置数据内容，键值对key : value Object getAttribute(String name)：通过key获取value Enumeration getAttributeNames() ：获取所有key组成的Enumeration对象 void removeAttribute(String name) ：删除指定key的数据 属性作用范围范围从小到大：pageContext —&gt; request —&gt; session —&gt; application pageContext：仅限于当前 JSP 页面，因此Servlet或者其他页面都获取不到。 request：仅限于同一个请求. session：限于同一次会话，浏览器打开直到关闭称之为一次会话(前提在此期间会话不失效) application：限于当前WEB 应用，是范围最大的属性作用范围。只要在一处设置属性, 在其他各处的 JSP 或 Servlet 中都可以获取到。 tips：由于这些域对象存储数据都是占用资源的，因此在业务使用中，尽量能小作用域完成的工作交给小作用域，使其资源得到最快得释放。 转发与重定向请求转发基本概念请求转发：服务器收到请求后，从一次资源跳转到另一个资源(Servlet)的操作叫请求转发。 浏览器地址栏没有变化，为初次发出请求的地址。 只有一次请求，request始终是同一个对象，因此共享Request域中的数据 可以转发到WEB-INF目录下 只能转发给当前 WEB 应用的的资源、不可以访问工程以外的资源 转发地址全程由服务器操作，/ 代表的是当前 WEB 应用的根目录http://ip:port/web应用 实现步骤 调用HttpServletReques对象getRequestDispatcher()方法并填入转发路径 通过第1步获取到RequestDispatcher对象 通过调用RequestDispatcher的forward()方法进行请求的转发 12345678910111213public class ForwardServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //请求的转发. //1. 调用 HttpServletRequest的getRequestDispatcher()方法,需要传入要转发的地址 //获取RequestDispatcher对象 RequestDispatcher requestDispatcher = request.getRequestDispatcher(&quot;/testServlet&quot;); //2、调用 HttpServletRequest 的 forward(request, response) 进行请求的转发. requestDispatcher.forward(request, response); &#125;&#125; 请求的重定向基本概念请求重定向：指客户端给服务器发请求后，服务器告知客户端，去请求另一个地址。 浏览器地址栏会发生变化、初次发出的请求地址，地址栏为最后响应的那个地址 两次请求，request不是同一个对象，不能共享request域中的数据 不能访间WEB-INF下的资源 可以访问工程外的资源(可以重定向到任何资源，百度，淘宝等) 地址将被服务器发往浏览器进行解析，因此 / 代表 / 代表的是当前 WEB 站点的根目录. http://ip:port/ 实现步骤方式1通过设置响应头 1234// 设置响应状态码 302 ，表示重定向，（已搬迁）resp.setStatus(302);// 设置响应头，说明 新的地址在哪里resp.setHeader(&quot;Location&quot;, &quot;http://localhost:8080&quot;); 方式2直接调用HttpServletResponse的sendRedirect()方法 1response.sendRedirect(&quot;http://localhost:8080&quot;) out&amp;getWriter()当JSP页面中所有代码执行完后会做一下两个动作 执行out.flush()操作，会把out缓冲区中得数据追加写入到response缓冲区末尾 会执行response得刷新操作，吧全部数据响应给客户端 由于 jsp 翻译之后，底层源代码都是使用 out 来进行输出，所以一般情况下。我们在 jsp 页面中统一使用 out 来进行输出。避免打乱页面输出内容的顺序。 out.write() 输出字符串没有问题 out.print() 输出任意数据都没有问题（都转换成为字符串后调用的 write 输出） 深入源码，浅出结论：在 jsp 页面中，任何类型可以统一使用 **out.print()**来进行输出 EL表达式基础概念 EL 表达式的全称是：Expression Language，是表达式语言。 EL 表达式的作用：主要是代替jsp表达式脚本 ,负责jsp页面的数据输出。由于EL 表达式在输出数据时比jsp脚本更为简洁、强大、友好。 123456&lt;body&gt;&lt;% request.setAttribute(&quot;key&quot;,&quot;值&quot;); %&gt;表达式脚本输出key的值是： &lt;%=request.getAttribute(&quot;key1&quot;)==null?&quot;&quot;:request.getAttribute(&quot;key1&quot;)%&gt;&lt;br/&gt;EL 表达式输出 key 的值是：$&#123;key1&#125;&lt;/body&gt; EL表达式格式：$&#123;表达式&#125; EL表达式直接编写在JSP页面中，无需写在&lt;% %&gt;内 EL表达式在输出null值时，会自定转换为空串输出。 EL表达式所有语句输出都需要JavaBean的读方法支持(getter()、isXxxx())。 域数据的搜索顺序输出语法由于EL表达式主要用于在 jsp 页面中输出数据。 且主要是输出域对象中的数据。 格式：&lt;% request.setAttribute(&quot;key&quot;,&quot;值&quot;); %&gt; 等价于 $&#123;key&#125; 域数据的搜索顺序当四个域中都有相同的key 的数据的时，EL 表达式会按照四个域的从小到大的顺序去进行搜索，优先匹配则输出。 12345678&lt;%//往四个域中都保存了相同的 key 的数据。 request.setAttribute(&quot;key&quot;, &quot;request&quot;); session.setAttribute(&quot;key&quot;, &quot;session&quot;); application.setAttribute(&quot;key&quot;, &quot;application&quot;); pageContext.setAttribute(&quot;key&quot;, &quot;pageContext&quot;);%&gt;$&#123;key&#125; &lt;%-- 输出：pageContext --&gt; java类属性输出输出Java类中普通属性，数组属性。list 集合属性和 map 集合属性。 JSP部分 123456789101112131415&lt;% Person person = new Person(); person.setName(&quot;Denny！&quot;); person.setPhones(new String[]&#123;&quot;18610541354&quot;,&quot;18688886666&quot;,&quot;18699998888&quot;&#125;); List&lt;String&gt; cities = new ArrayList&lt;String&gt;(); cities.add(&quot;北京&quot;); cities.add(&quot;上海&quot;); cities.add(&quot;深圳&quot;); person.setCities(cities); Map&lt;String,Object&gt;map = new HashMap&lt;&gt;(); map.put(&quot;key1&quot;,&quot;value1&quot;); map.put(&quot;key2&quot;,&quot;value2&quot;); map.put(&quot;key3&quot;,&quot;value3&quot;); person.setMap(map);pageContext.setAttribute(&quot;p&quot;, person);%&gt; EL表达式部分 1234567输出 Person：$&#123; p &#125;&lt;br&#x2F;&gt;输出 Person 的 name 属性：$&#123;p.name&#125; &lt;br&gt;输出 Person 的 pnones 数组属性值：$&#123;p.phones[2]&#125; &lt;br&gt;输出 Person 的 List 集合：$&#123;p.cities&#125; &lt;br&gt;输出 Person 的 List 集合中个别元素值：$&#123;p.cities[2]&#125; &lt;br&gt;输出 Person 的 Map 集合: $&#123;p.map&#125; &lt;br&gt;输出 Person 的 Map 集合中某个 key 的值: $&#123;p.map.key3&#125; &lt;br&gt; 运算符关系运算符 逻辑运算符 算术运算符 empty运算empty 运算可以判断一个数据是否为空，若为空输出 true 输出 false几种情况 值为null值 值为空串 值是 Object 类型数组，长度为零 list、map集合，元素个数为零 三元运算符略 “.”与[]中括号运算 .点运算，可以输出 Bean 对象中某个属性的值。 []中括号运算 可以输出有序集合中某个元素的值。 并且[]中括号运算，还可以输出 map 集合中 key 里含有特殊字符的 key 的值 将key值用单引号’’ 包含 将含特殊字符的key值整个用 [ ] 中括号包含 1234567891011&lt;% Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;a.a.a&quot;, &quot;aaaValue&quot;); map.put(&quot;b+b+b&quot;, &quot;bbbValue&quot;); map.put(&quot;c-c-c&quot;, &quot;cccValue&quot;); request.setAttribute(&quot;map&quot;, map);%&gt;&lt;%-- $&#123; map.a.a.a&#125; &lt;br&gt; 输出失败--&gt;$&#123; map[&#x27;a.a.a&#x27;] &#125; &lt;br&gt;$&#123; map[&quot;b+b+b&quot;] &#125; &lt;br&gt;$&#123; map[&#x27;c-c-c&#x27;] &#125; &lt;br&gt; 11个隐函对象隐函对象列表 隐函对象 返回类型 作用 pageContext PageContextImpl 可获取 jsp 中的九大内置对象 pageScope Map&lt;Strubg,Object&gt; 获取 pageContext 域中的 requestScope Map&lt;Strubg,Object&gt; 获取 Request 域中的数 sessionScope Map&lt;Strubg,Object&gt; 获取 Session 域中的数据 applicationScope Map&lt;Strubg,Object&gt; 获取 ServletContext 域中的数据 param Map&lt;Strubg,String&gt; 获取请求参数的值 paramValues Map&lt;Strubg,String[]&gt; 同上，获取多个值的时候使用 header Map&lt;String,String&gt; 获取请求头的信息 headerValues Map&lt;Strubg,String[]&gt; 同上，获取多个值的情况使用 cookie Map&lt;Strubg,Cookie&gt; 获取当前请求的 Cookie 信息 initParam Map&lt;String,String&gt; 获取web.xml中&lt;context-param&gt;参数 域隐函对象 pageScope ——&gt; pageContext 域 requestScope ——&gt; request 域 sessionScope ——&gt; Session 域 applicationScope ——&gt; ServletContext 域 示例 1234567891011&lt;% pageContext.setAttribute(&quot;key1&quot;, &quot;pageContext1&quot;); pageContext.setAttribute(&quot;key2&quot;, &quot;pageContext2&quot;); request.setAttribute(&quot;key2&quot;, &quot;request&quot;); session.setAttribute(&quot;key2&quot;, &quot;session&quot;); application.setAttribute(&quot;key2&quot;, &quot;application&quot;);%&gt;$&#123; key2 &#125; &lt;%-- 非指定域搜索数据，默认从小到大 --&gt;&lt;%-- 指定域搜索数据 --&gt;$&#123; requestScope.key2 &#125;$&#123; applicationScope.key2 &#125; pageContextpageContext隐函对象可获取任意9大jsp隐函对象，获取后常用功能如下 协议 服务器 ip 服务器端口 获取工程路径 获取请求方式 获取客户端 ip 地址 获取会话的 id 编号 示例 123456789101112131415161718&lt;%-- 原生方法说明 request.getScheme() 它可以获取请求的协议,如 http、https request.getServerName() 获取请求的服务器ip或域名，如 127.0.0.1 request.getServerPort() 获取请求的服务器端口号，如 80 request.getContextPath() 获取当前工程路径，如 /09_EL_JSTL request.getMethod() 获取请求的方式，如（GET 或 POST） request.getRemoteHost() 获取客户端的 ip 地址 session.getId() 获取会话的唯一标识--%&gt;1.协议： $&#123; pageContext.request.scheme &#125;&lt;br&gt;2.服务器 ip：$&#123; pageContext.request.serverName &#125;&lt;br&gt;3.服务器端口：$&#123; pageContext.request.serverPort &#125;&lt;br&gt;4.获取工程路径：$&#123; pageContext.request.contextPath &#125;&lt;br&gt;5.获取请求方法：$&#123; pageContext.request.method &#125;&lt;br&gt;6.获取客户端 ip 地址：$&#123; pageContext.request.remoteHost &#125;&lt;br&gt;7.获取会话的 id 编号：$&#123; pageContext.session.id &#125;&lt;br&gt; 提高EL表达式简洁度的技巧 1234567&lt;% //如需调用request相关方法，则不通pageContext获取request对象 //而将JSP的request隐函对象存入pageContext域后直接用EL表达式调用 pageContext.setAttribute(&quot;req&quot;, request);%&gt;优化前： $&#123; pageContext.request.scheme &#125;&lt;br&gt;优化后： $&#123; req.scheme &#125;&lt;br&gt; param param Map&lt;String,String&gt;：它可以获取请求参数的值 paramValues Map&lt;String,String[]&gt;： 它也可以获取请求参数的值，获取多个值的时候使用。 示例代码 1234输出请求参数 username 的值：$&#123; param.username &#125; &lt;br&gt;输出请求参数 password 的值：$&#123; param.password &#125; &lt;br&gt;输出请求参数 hobby 的值：$&#123; paramValues.hobby[0] &#125; &lt;br&gt;输出请求参数 hobby 的值：$&#123; paramValues.hobby[1] &#125; &lt;br&gt; header header Map&lt;String,String&gt;：它可以获取请求头的信息的各种键值对 headerValues Map&lt;String,String[]&gt;： 它可以获取请求头的信息，它可以获取多个值的情况。 示例代码： 123输出请求头【User-Agent】的值：$&#123; header[&#x27;User-Agent&#x27;] &#125; &lt;br&gt;输出请求头【Connection】的值：$&#123; header.Connection &#125; &lt;br&gt;输出请求头【User-Agent】的值：$&#123; headerValues[&#x27;User-Agent&#x27;][0]&#125; &lt;br&gt; cookie cookie Map&lt;String,Cookie&gt;： 它可以获取当前请求的 Cookie 信息 示例代码 12获取 Cookie 的名称：$&#123; cookie.JSESSIONID.name &#125; &lt;br&gt;获取 Cookie 的值：$&#123; cookie.JSESSIONID.value &#125; &lt;br&gt; initParam initParam Map&lt;String,String&gt; ：它可以获取在 web.xml 中配置的上下文参数 web.xml 123456789&lt;context-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;root&lt;/param-value&gt;&lt;/context-param&gt;&lt;context-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql:///test&lt;/param-value&gt;&lt;/context-param&gt; 示例代码 12输出&amp;lt;Context-param&amp;gt;username 的值：$&#123;initParam.username&#125; &lt;br&gt;输出&amp;lt;Context-param&amp;gt;url 的值：$&#123;initParam.url&#125; &lt;br&gt; JSTL简介 JSTL 标签库全称是指 JSP Standard Tag Library，即JSP标准标签库。是一个不断完善的开放源代码的 JSP 标签库。 属于JSP动作，其开源性起始源于自定义标签库的功能。可以说JSTL是最广泛使用友好的自定义标签库典范。 EL 表达式主要是为了替换 jsp 中的表达式脚本，而标签库则是为了替换JSP小脚本。使得整个jsp 页面变得更加简洁。 本章内容不涉及自定义标签库知识，有需求时学(保留2013版JavaWeb资源即可) 标签库类型 功能范围 URI 前缀 核心标签库 http://java.sun.com/jsp/jstl/core c 格式化 http://java.sun.com/jsp/jstl/fmt fmt 函数 http://java.sun.com/jsp/jstl/functions fn 数据库(不使用) http://java.sun.com/jsp/jstl/sql sql XML(不使用) http://java.sun.com/jsp/jstl/xml x JSTL的使用步骤 先导入jstl 标签库的jar 包。 taglibs-standard-impl-1.2.1.jar taglibs-standard-spec-1.2.1.jar 使用 taglib 指令引入标签库，使用哪种类型的标签库则引入对应的URI &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; core核心库setset 标签可以往域中保存数据，**等同于setAttribute()**操作(较少使用) scope属性：设置保存到哪个域中 page 表示 PageContext 域（默认值） request 表示 Request 域 session 表示 Session 域 var属性：设置key值 value属性：设置属性值 123保存前：$&#123; sessionScope.abc &#125; &lt;br&gt;&lt;c:set scope=&quot;session&quot; var=&quot;abc&quot; value=&quot;abcValue&quot;/&gt;保存后：$&#123; sessionScope.abc &#125; &lt;br&gt; ifif标签实现if逻辑操作，单路判断，即只能if，不能if-else(if-else只能拆解成两个条件进行) test属性：表示判断的条件，使用EL表达式编写 1234567&lt;c:if test=&quot;$&#123; 12 == 12 &#125;&quot;&gt; &lt;h1&gt;12 等于 12&lt;/h1&gt;&lt;/c:if&gt;&lt;c:if test=&quot;$&#123; 12 != 12 &#125;&quot;&gt; &lt;h1&gt;12 不等于 12&lt;/h1&gt;&lt;/c:if&gt; choose-when-otherwise多路判断，类似于switch … case …. default ，区别是，当前标签一旦匹配一个则退出执行，否则执行otherwise choose标签：开始选择判断，类switch when标签：每一种判断情况，类case test属性：表示当前判断情况的值，类case value : ? otherwise标签：剩余的情况，类 default 示例代码 123456789101112131415161718&lt;% request.setAttribute(&quot;height&quot;, 180); %&gt;&lt;c:choose&gt; &lt;c:when test=&quot;$&#123; requestScope.height &gt; 190 &#125;&quot;&gt; &lt;h2&gt;小巨人&lt;/h2&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123; requestScope.height &gt; 180 &#125;&quot;&gt; &lt;h2&gt;很高&lt;/h2&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123; requestScope.height &gt; 170 &#125;&quot;&gt; &lt;h2&gt;还可以&lt;/h2&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;h2&gt;其他&lt;/h2&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt; 使用注意点： 标签里不能使用 html 注释，要使用 jsp 注释 when标签的父标签一定要是choose标签 示例代码 1234567891011121314151617&lt;%-- 例如若想在otherwise里面再细分，则需要先写一个choose标签再写when标签 --&gt;&lt;c:otherwise&gt; &lt;c:choose&gt; &lt;c:when test=&quot;$&#123;requestScope.height &gt; 160&#125;&quot;&gt; &lt;h3&gt;大于 160&lt;/h3&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;requestScope.height &gt; 150&#125;&quot;&gt; &lt;h3&gt;大于 150&lt;/h3&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;requestScope.height &gt; 140&#125;&quot;&gt; &lt;h3&gt;大于 140&lt;/h3&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; 其他小于 140 &lt;/c:otherwise&gt; &lt;/c:choose&gt;&lt;/c:otherwise&gt; forEach遍历输出普通遍历输出，等价于for(int i;i &lt;= 10;i++) begin属性：设置开始的索引 end属性：设置结束的索引，&lt;= var属性：表示循环的变量(也是当前正在遍历到的数据) 示例代码1：遍历 1 到 10，输出，类同普通for循环for(int i;i &lt;= 10;i++) 123&lt;c:forEach begin=&quot;1&quot; end=&quot;10&quot; var=&quot;i&quot;&gt; $&#123;i&#125;&lt;/c:forEach&gt; 遍历数组遍历Object类型数组，类同增强for循环for(Object obj: args) items属性：表示遍历的数据源，类同上述的 args var属性：同上，表示当前遍历到的数据 12345678&lt;% request.setAttribute(&quot;arr&quot;, new String[]&#123;&quot;18610541354&quot;,&quot;18688886666&quot;,&quot;18699998888&quot;&#125;);%&gt;&lt;c:forEach items=&quot;$&#123; requestScope.arr &#125;&quot; var=&quot;item&quot;&gt; $&#123; item &#125; &lt;br&gt;&lt;/c:forEach&gt; 遍历Map遍历Map，类同for ( Map.Entry&lt;String,Object&gt; entry : map.entrySet()) 12345678910&lt;% Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;key1&quot;, &quot;value1&quot;); map.put(&quot;key2&quot;, &quot;value2&quot;); map.put(&quot;key3&quot;, &quot;value3&quot;); request.setAttribute(&quot;map&quot;, map);%&gt;&lt;c:forEach items=&quot;$&#123; requestScope.map &#125;&quot; var=&quot;entry&quot;&gt; &lt;h1&gt;$&#123;entry.key&#125; = $&#123;entry.value&#125;&lt;/h1&gt;&lt;/c:forEach&gt; 遍历List注意：以下借助遍历List说明forEach标签各种属性结合实现的效果，并非只有遍历List才可使用。 测试Java类 12345678910public class Student &#123; //编号，用户名，密码，年龄，电话信息 private Integer id; private String username; private String password; private Integer age; private String phone; //省略构造器以及getter与setter方法...&#125; 示例代码1：普通遍历(全部遍历) 12345678910111213141516&lt;% //数据准备 List&lt;Student&gt; studentList = new ArrayList&lt;Student&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; studentList.add(new Student(i,&quot;username&quot;+i ,&quot;pass&quot;+i,18+i,&quot;phone&quot;+i)); &#125; request.setAttribute(&quot;stus&quot;, studentList);%&gt;&lt;c:forEach items=&quot;$&#123;requestScope.stus&#125;&quot; var=&quot;stu&quot;&gt; $&#123;stu.id&#125;&lt;br/&gt; $&#123;stu.username&#125;&lt;br/&gt; $&#123;stu.password&#125;&lt;br/&gt; $&#123;stu.age&#125;&lt;br/&gt; $&#123;stu.phone&#125;&lt;br/&gt;&lt;/c:forEach&gt; 示例2：指定区间、步长遍历 12345678&lt;c:forEach begin=&quot;2&quot; end=&quot;7&quot; step=&quot;2&quot; items=&quot;$&#123;requestScope.stus&#125;&quot; var=&quot;stu&quot;&gt; $&#123;stu.id&#125;&lt;br/&gt; $&#123;stu.username&#125;&lt;br/&gt; $&#123;stu.password&#125;&lt;br/&gt; $&#123;stu.age&#125;&lt;br/&gt; $&#123;stu.phone&#125;&lt;br/&gt; $&#123;status.step&#125;&lt;br/&gt;&lt;/c:forEach&gt; 示例3：varStatus对象 varStatus 属性表示当前遍历到的数据的状态，是一个实体对象。 123&lt;c:forEach varStatus=&quot;status&quot; items=&quot;$&#123;requestScope.stus&#125;&quot; var=&quot;stu&quot;&gt; $&#123;status&#125;&lt;/c:forEach&gt; 该对象所在类在源码中实现了LoopTagStatus接口，接口包含如下方法 12345678910public interface LoopTagStatus&#123; public Object getCurrent();//获取当前遍历到的数据 public int getlndex();//获取当前遍历的索引 public int getCount();//获取已遍历的个数 public boolean isFirst();//判断当前遍历的数据是否属于第一条 public boolean isLast();//判断当前遍历的数据是否属于最后一条 public Integer getBegin();//获取遍历的起始值 public Integer getEnd();//获取遍历的结束值 public Integer getStep();//获取当前设置的步长值&#125; MVC模式基础概念MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。 Model（模型） - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。 View（视图） - 视图代表模型包含的数据的可视化。 Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。 包命名规范 层次 包名 含义 web层 com.website.web/servlet/controller service层 com.website.service service接口包 service层 com.website.service.impl service接口实现类 dao持久层 com.website.dao Dao接口包 dao持久层 com.website.dao.impl Dao接口实现类 实体bean对象 com.website.pojo/entity/domain.bean JavaBean类 测试包 com.website.test/junit 测试类 工具类 com.website.utils 工具类 后端编码流程tips：这里指编码流程阶段，指后端程序员工作角度，非整个软件的开发流程(需求分析等等)。 建库建表 编写JavaBean 后续准备测试类 编写DAO 业务service 视图控制层 建库建表分析页面内容，提取需要的数据表与数据库结构 编写JavaBean为每个数据库表建立一个JavaBean 后续准备测试类 以下开始，每编写一个功能类代码类，都需对应测试一遍(XxxTest.class，testMethod())，或通过IDE快速生成junit测试类。 注意，测试不仅要测试正确的返回值情况，还要测试错误的返回值情况是否符合预期 测试要全面，正确的所有情况，错误的所有情况 com.website.test.BaseDaoTest 12345678910111213141516171819202122232425262728293031//自创建测试类public class BaseDaoTest extends BaseDao &#123; @Test public void testUpdate()&#123; String sql = &quot;insert into t_user(`username`,`password`,`email`) values(?,?,?)&quot;; int status = update(sql,&quot;priscilla&quot;,&quot;123&quot;,&quot;11111111@qq.com&quot;); System.out.println(&quot;status = &quot; + status); &#125; @Test public void testQueryForOne()&#123; String sql = &quot;select * from t_user where id = ?&quot;; User user = queryForOne(User.class, sql, 1); System.out.println(&quot;user = &quot; + user); &#125; @Test public void testQueryForList()&#123; String sql = &quot;select * from t_user&quot;; List&lt;User&gt; users = queryForList(User.class, sql); System.out.println(&quot;users.toString() = &quot; + users.toString()); &#125; @Test public void testQueryForValue()&#123; String sql = &quot;select username from t_user where id = ?&quot;; Object username = queryForValue(sql, 1); System.out.println(&quot;username = &quot; + username.toString()); &#125;&#125; com.website.test.UserServiceTest 1234567891011121314151617181920212223242526272829//IDEA自动生成的测试public class UserServiceTest &#123; private UserService service = new UserServiceImpl(); @Test public void login() &#123; User login = service.login(new User(&quot;admin&quot;, &quot;password&quot;, &quot;12345678@qq.com&quot;)); if(login == null)&#123; System.out.println(&quot;登录失败&quot;); &#125;else&#123; System.out.println(&quot;登录成功&quot;); &#125; &#125; @Test public void existsUsername() &#123; boolean flag = service.existsUsername(&quot;admin&quot;); if(flag)&#123; System.out.println(&quot;用户已存在&quot;); &#125;else&#123; System.out.println(&quot;用户不存在，可用&quot;); &#125; &#125; @Test public void registerUser() &#123; service.registerUser(new User(&quot;Jacky&quot;,&quot;333&quot;,&quot;333@qq.com&quot;)); service.registerUser(new User(&quot;Jacky&quot;,&quot;333&quot;,&quot;333@qq.com&quot;)); &#125;&#125; DAO编写DAO (DataAccessobjects 数据存取对象)是指位于业务逻辑和持久化数据之间实现对持久化数据的访问。通俗来讲，就是将数据库操作都封装起来。DAO相关类与文件操作涉及如下 jdbc.properties dbcUtils BaseDao 定制化业务Dao(XxxxDao接口及、XxxxDao实现类) .properties 创建存储jdbc连接参数的.properties文件， 编码前提准备好第三方jar包，如最基本数据库连接驱动jar包，其次有可能第三方(连接池、DbUtils等) jdbc.properties 123456username=rootpassword=rooturl=jdbc:mysql://localhost:3306/book1driverClassName=com.mysql.jdbc.DriverinitialSize=5maxActive=10 JdbcUtils编写JdbcUtils工具类，仅用于获取与回收数据库连接(一般项目经历准备好) com.website.utils.JdbcUtils.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.website.utils;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.InputStream;import java.sql.Connection;import java.util.Properties;/** * 用于获取数据库连接，通过druid数据库连接池实现 * 1、导包 * - druid-1.1.9.jar 数据库连接池 * - mysql-connector-java * @author yhd * @create 2021-04-11 11:21 */public class JdbcUtils &#123; private JdbcUtils()&#123;&#125;//私有化构造器 private static DataSource dataSource = null;//可多态，也可DruidDataSource //0、JdbcUtils均为静态方法，私有化构造器后通过static代码块实现初始化操作 static&#123; //6、处理编译异常问题 try &#123; //2、创建Properties对象， Properties properties = new Properties(); //4、获取配置文件的输入流对象 InputStream inputStream = JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); //3、已知Properties核心需调用load方法加载配置文件数据，得知需输入流 properties.load(inputStream); //1、创建通过DruidDataSourceFactory获取数据库连接池对象，得知需Properties对象 dataSource = DruidDataSourceFactory.createDataSource(properties); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取数据库连接对象，若获取失败返回null * @return */ public static Connection getConnection()&#123; //3、因处理异常而声明对象 Connection con = null; //2、处理异常问题 try &#123; //1、直接从数据库连接池获取连接对象并返回 con = dataSource.getConnection(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return con; &#125; /** * 释放数据库连接，回收到数据库连接池 * @param connection */ public static void close(Connection connection)&#123; try &#123; if(dataSource != null)&#123; connection.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; BaseDaoBaseDao：封装通用的CRUD操作类(可以基于一些工具类实现，如DbUtils)，如含以下主要方法，一般设计为抽象类，提供给别人继承使用。一般含如下方法： int update(String sql,Object…args)：执行insert、update、delete语句 T queryForOne(Class type,String sql, Object…args)：查询返回一个javaBean对象 List queryForList(Class type,String sql, Object…args)：查询返回多个JavaBean Obejct queryForSingleValue(String sql,Object…args)：查询返回单个值 com.website.dao.BaseDao.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.website.dao;import com.website.utils.JdbcUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;import java.sql.Connection;import java.util.List;/** * 封装通用的数据库操作：update、query * 基于DbUtils实现(commons-dbutils-1.3) * @author yhd * @create 2021-04-11 14:48 */public abstract class BaseDao &#123; //使用DbUtils private QueryRunner queryRunner = new QueryRunner(); /** * 查询返回一个值 * @param sql 执行的sql语句 * @param args sql语句填入的参数 * @return 执行成功返回Object，否则返回null */ public Object queryForValue(String sql,Object...args)&#123; Connection con = JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new ScalarHandler(),args); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.close(con); &#125; return null; &#125; /** * 查询返回javaBean的List集合 * @param type 返回javaBean类型 * @param sql 执行的sql语句 * @param args sql语句填充的参数 * @param &lt;T&gt; 返回类型的泛型 * @return 执行成功返回List，否则返回null */ public &lt;T&gt; List&lt;T&gt; queryForList(Class&lt;T&gt; type, String sql, Object...args)&#123; Connection con = JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new BeanListHandler&lt;T&gt;(type),args); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.close(con); &#125; return null; &#125; /** * 查询返回一个javaBean * @param type 返回的对象类型 * @param sql 执行的sql语句 * @param args sql对应参数值 * @param &lt;T&gt; 返回类型的泛型 * @return 执行成功返回JavaBean，否则返回null */ public &lt;T&gt; T queryForOne(Class&lt;T&gt; type,String sql,Object...args)&#123; Connection con = JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new BeanHandler&lt;T&gt;(type),args); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.close(con); &#125; return null; &#125; /** * 用于执行：Insert/Update/Delete操作 * @param sql 执行的sql语句 * @param args sql语句中填入参数 * @return 若成则返回受影响的行数，失败返回-1 */ public int update(String sql,Object...args)&#123; Connection con = JdbcUtils.getConnection(); try &#123; return queryRunner.update(con, sql, args); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.close(con); &#125; return -1; &#125;&#125; 定制化DAO 含interface接口，与对应的implements实现类。对应参与业务操作的JavaBean的Dao操作 方法命名要细致：如通过用户名Id查找用户信息的方法应命名为，queryUserById()，而非getUser() 一般关于update的操作，如add、delete、update都基于BaseDAO需返回受影响条数 业务service层编写XxxxService的java类程序，把每个业务涉及的所有逻辑操作封装好，供视图控制层直接创建对象调用一个方法处理内部逻辑。 java类程序，每一个业务对应一个XxxService接口及其实现类XxxServiceImpl 像对数据库进行操作时，删除、修改时一般需判断这个数据是否存在数据库先(查询一次)，这些逻辑都是在service封装好的，BaseDao无需写(也无法写出一个通用的判断方法) 视图控制层 编写Servlet程序，接收post、get请求，并调用service层进行逻辑后对应地做出响应。 编写BaseServlet程序，完成同一个业务中同一类型请求的同一分发处理 基于第三方BeanUtils工具类实现WebUtils类，完成把请求参数直接注入到bean对象的操作。 业务Servlet 一般对于service层，一个service对应一个servlet视图控制层 映射url命名：一般将XxxxServlet，映射url为首字母小写，一般将xxxxServlet 请求分发处理在IDEA这种项目结构的实际开发中，一般一个模块就一个servlet。负责一个模块，因此像LoginServlet与RegisterServlet应该和并成UserServlet 区分信息的传递 GET请求：可通过在URL传参中，添加action=login参数 POST请求：可通过在表单中添加隐藏域实现 方案1：if-else分支 让同一业务范围同一请求类型的都请求同一个Servlet程序 分别在两者表单内添加一个隐藏域，用于表示请求的业务类型 12345&lt;!-- login表单中的隐藏域 --&gt;&lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;login&quot;/&gt;&lt;!-- register表单中的隐藏域 --&gt;&lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;regist&quot;/&gt; 后端在同一接收请求前，通过获取隐藏域action-value的值来区分业务 后端对每个业务功能创建如HttpServlet原生Post方法的结构，在if-else分支语句中进行调用 1234567891011121314151617181920212223242526272829303132333435363738public class UserServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doPost(req, resp); String action = req.getParameter(&quot;action&quot;); if(&quot;login&quot;.equals(action))&#123; login(req,resp); &#125;else if(&quot;regist&quot;.equals(action))&#123; regist(req,resp); &#125; &#125; /** * 处理登录功能 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //..... &#125; /*** * 处理注册功能 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //..... &#125;&#125; 方案2：反射 注意：要求请求的区分信息与被调用方法名一致(直接反射调用) 获取到区分信息后，通过反射的方式自动调用各种方法 123456789101112131415161718192021222324252627282930313233343536373839public class UserServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doPost(req, resp); String action = req.getParameter(&quot;action&quot;); //反射方案 try &#123; Method method = this.getClass().getDeclaredMethod(action, HttpServletRequest.class, HttpServletResponse.class); method.invoke(this,req,resp); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 处理登录功能 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //..... &#125; /*** * 处理注册功能 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //..... &#125;&#125; BaseServlet由于每个业务一般都有若干个功能模块，因此如上的请求分发操作时很常见的。通过反射的方式实现请求分发的代码又极具通用性，因此可以选择把这部分的代码封装到一个父类(目的为了代码复用，设计成抽象父类)中。 把请求分发的反射代码写入BaseServlet抽象类中，让其继承HttpServlet 然业务XxxServlet继承BaseServlet 注意，访问url还是指向业务XxxServlet，BaseServlet只是起到代码复用功能 com.website.web.BaseServlet 1234567891011121314public abstract class BaseServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String action = req.getParameter(&quot;action&quot;); //反射方案 try &#123; Method method = this.getClass().getDeclaredMethod(action, HttpServletRequest.class, HttpServletResponse.class); method.invoke(this,req,resp); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; com.website.web.UserServlet 12345678910111213141516171819202122232425262728//继承BaseServletpublic class UserServlet extends BaseServlet&#123; /** * 处理登录功能 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //..... System.out.println(&quot;login method-&quot;); &#125; /*** * 处理注册功能 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //..... System.out.println(&quot;regist method-&quot;); &#125;&#125; 提示信息与数据回显对浏览器操作返回页面提醒信息、某些领域还需数据回显(用户注册失败回显已输入内容) 一般通过request域，通过请求转发的方式回传数据与提醒信息 BeanUtils在视图控制层中，还有一部分代码的工作内容是高度相似的，即从request中获取请求的参数并封装成对应的JavaBean对象，如用户的登录，注册等等…。而且较大的项目，往往可能存在数十个请求参数，封装成一个对象，若都采用一个个编写getParameter()，获取每个参数，并创建对象，把每个参数setXxxx()进去，工作量和代码可维护性都是个问题。因此可以编写一个通用的方法去处理这些代码。 123456789101112protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding(&quot;UTF-8&quot;); //1、获取请求的参数 String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); //2、将请求参数封装成对象，new User(username,password,null) User user = service.login(new User(username,password,null)); //.....&#125; BeanUtils基本使用 由于BeanUtils是第三方的jar包，使用前需要先导包 commons-beanutils-1.8.0.jar commons-logging-1.1.1.jar (依赖) 注入前提：前端页面请求参数名(name)**与JavaBean属性名一致(核心是与setter()方法一致**) BeanUtils的注入操作 12345678User user = new User();try &#123; System.out.println(&quot;注入前，user = &quot; + user); BeanUtils.populate(user,req.getParameterMap()); System.out.println(&quot;注入后，user = &quot; + user);&#125;catch (Exception e) &#123; e.printStackTrace();&#125; WebUtils封装由于每次执行注入操作都需要上述BeanUtils的注入代码与异常处理，可以选择把这些操作封装成一个静态方法 com.website.utils.WebUtils 123456789101112131415/** * 把Map中的值注入到对应的JavaBean属性中 * @param value * @param bean * @param &lt;T&gt; * @return */public static &lt;T&gt; T copyParamToBean(Map value,T bean)&#123; try &#123; BeanUtils.populate(bean,value); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; return bean;&#125; 调用测试 1User user = WebUtils.copyParamToBean(req.getParameterMap(),new User()); BeanUtils源码分析最后通常将所有页面改为jsp页面 前端相关操作 抽取前端页面相同的内容，通过引用的方式 公共样式代码部分：如导航栏，底部栏/页脚等 公共外部引用标签部分，如共同的js、css，base标签 Listener监听器什么是监听器？监听器就是实时监视一些事物状态的程序，我们称为监听器。 Listener 监听器它是 JavaWeb 的三大组件之一：Servlet 程序、Filter 过滤器、Listener监听器。 Listener它是 JavaEE 的规范，就是接口 监听器的作用是监听某种事物的变化。然后通过回调函数，反馈给客户(程序)去做一些相应的处理。 ServletContextListener随之技术的变革，绝大多数类型的监听器已经用不上了，剩下ServletContextListener有较高的使用频率。 功能 ServletContextListener它可以监听 ServletContext 对象的创建和销毁 ServletContext对象在 web 工程启动的时候创建，在 web 工程停止的时候销毁 监听到创建和销毁之后都会分别调用ServletContextListener监听器的方法反馈。 12345678910public interface ServletContextListener extends EventListener &#123; /** * 在 ServletContext 对象创建之后马上调用，做初始化 */ public void contextInitialized(ServletContextEvent sce); /** * 在 ServletContext 对象销毁之后调用 */ public void contextDestroyed(ServletContextEvent sce);&#125; 操作步骤 编写一个类去实现ServletContextListener接口 实现其两个回调方法 到 web.xml中去配置监听器 ServletContextListenerTest.java 由于接口中用的时default作为修饰符，且方法体已空实现（有大括号），所以不会提示有熟悉的红色下划线 快捷实现接口中的抽象方法 的操作，需自己在IDE中编写方法，提示重写。 12345678910public class ServletContextListenerTest implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; System.out.println(&quot;servletContext对象已被创建&quot;); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; System.out.println(&quot;servletContext对象已被销毁&quot;); &#125;&#125; web.xml 123&lt;listener&gt; &lt;listener-class&gt;com.website.test.ServletContextListenerTest&lt;/listener-class&gt;&lt;/listener&gt; 文件上传与下载文件上传基本步骤 form标签 method = post：由于get请求有长度限制因此使用post请求 encType = multiparty/form-data 表示提交的数据，以多段(每一个表单项一个数据段)的形式进行拼接，然后以二进制流的形式发送给服务器。 注意：以二进制流形式发送时，不能再用getParameter()取获取数据，结果只能为null，应该使用getInputStream()获取 在form标签中使用input type = file 添加上传文件 编写服务器代码，处理上传数据。 HTTP协议部分 前端代码 123456&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/uploadServlet&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt; 头像：&lt;input type=&quot;file&quot; name=&quot;photo&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 前端页面 后端代码：打印上传的流内容 1234567891011public class UploadServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;文件上传&quot;); ServletInputStream inputStream = req.getInputStream(); byte[] buffer = new byte[1024 * 1024]; int len = inputStream.read(buffer); System.out.println(new String(buffer,0,len)); &#125;&#125; 后端打印结果： 12345678910111213141516文件上传------WebKitFormBoundaryVldrwB6NIgx1Eq3SContent-Disposition: form-data; name&#x3D;&quot;username&quot;wzg168------WebKitFormBoundaryVldrwB6NIgx1Eq3SContent-Disposition: form-data; name&#x3D;&quot;photo&quot;; filename&#x3D;&quot;d.jpg&quot;Content-Type: image&#x2F;jpeg??? \u0010JFIF \u0001\u0001\u0001 x x ?? C\u0006\u0006\u0007\u0006\u0007\u0007\u0007 \u00182!\u001c!22222222222222222222222222222222222222222222222222?? \u0002@\u0004Q\u0003\u0001&quot; \u0002\u0011\u0001\u0003\u0011\u0001?? \u001f \u0001\u0005\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0002\u0003\u0004\u0005\u0006 ?? ?\u0010 \u0002\u0001\u0003\u0003\u0002\u0004\u0003\u0005\u0005\u0004\u0004 \u0001&#125;\u0001\u0002\u0003 \u0004\u0011\u0005\u0012!1A\u0006\u0013Qa\u0007&quot;q\u00142亼#B绷\u0015R佯$3br? \u0016\u0017\u0018\u0019\u001a%&amp;&#39;()*456789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz儎厗噲墛挀敃枟槞殺￥ウЖ┆渤吹斗腹郝媚牌侨墒矣哉肿刭卺忏溴骁栝犟蝮趱鲼?? \u001f\u0001 \u0003\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0002\u0003\u0004\u0005\u0006 ?? ?\u0011 \u0002\u0001\u0002\u0004\u0004\u0003\u0004\u0007\u0005\u0004\u0004 \u0001\u0002w \u0001\u0002\u0003\u0011\u0004\u0005!1\u0006\u0012AQ\u0007aq\u0013&quot;2\u0014B憽绷 #3R?\u0015br?攽&lt;hz噔痆?\u001dА矸宒f疇\u000f挐籘柭XU草?&gt;X龅j0猹M\u001e\u0006z裶&quot;\u0014m?8п筧P\u0017诶U廿A\u001f#\u001cR邦7f險湑弌z播堒?\u0005螶庒\u0015?#僙#6SWa匝?\u000e袈pH5\u0018晤焪z?\u001b幖?\u0004\u0010犛?:圆媕I\u0019猡_璘嶠^*&#96;Mf?\u0011d\u000fz慩儌sU崭隣躴溤 焢&gt;敼\u0019郥E?&#39;?\u0017\u001aB硘?\u001c?...... 上传文件，HTTP协议分析 上传实现当清楚了上传文件的HTTP请求头信息格式后，其实剩下的就是对服务器接收到的流数据进行解析即刻，如通过请求头的boundary获取到每段数据的分隔符，然后再分解不同表单的数据，对应处理即可…，在java开发一般这种数据解析操作常使用apache提供的commons-fileupload.jar实现。 jar包依赖 commons-fileupload-1.2.1.jar commons-io-1.4.jar 常用类说明 ServletFileUpload：用于解析上传的数据 boolean ServletFileUpload.isMultipartContent(HttpServletRequest request); 判断当前上传的数据格式是否是多段的格式，true则是多段格式，false则不是 public List&lt;FileItem&gt; parseRequest(HttpServletRequest request) ：解析上传的数据 。 FileItem：封装每一个表单项的数据。 boolean FileItem.isFormField()：判断当前表单项属于普通还是上传表单项 true：表示普通类型的表单项 false：表示上传的文件类型 String FileItem.getFieldName()： 获取表单项的name属性值 String FileItem.getString()： 获取当前表单项的值。 String FileItem.getName()：获取上传的文件名 void FileItem.write(file) ：将上传的文件写到参数file所指向抽硬盘位置 示例代码 index.jsp 123456&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/uploadServlet&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt; 头像：&lt;input type=&quot;file&quot; name=&quot;photo&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; UploadServlet.java 12345678910111213141516171819202122232425262728293031323334353637public class UploadServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1、通过静态方法判断上传的数据是否为多段数据(只有是多段数据，才是文件上传) if(ServletFileUpload.isMultipartContent(req))&#123; //3、创建FileItemFactory接口实现类对象，传入ServletFileUpload构造器中 FileItemFactory fileItemFactory = new DiskFileItemFactory(); //2、创建ServletFileUpload对象进行数据解析工作，注意空参构造器不是给我们初始化的 ServletFileUpload servletFileUpload = new ServletFileUpload(fileItemFactory); try &#123; //3、解析所有数据 List&lt;FileItem&gt; list = servletFileUpload.parseRequest(req); //4、遍历每个表单项数据 for(FileItem item : list)&#123; if(item.isFormField())&#123;//5、普通表单项目获取name-value String name = item.getFieldName();// String value = item.getString();//中文乱码可传入&quot;UTF-8&quot;形参 System.out.println(&quot;普通表单项 name = &quot; + name); System.out.println(&quot;普通表单项 value = &quot; + value); &#125;else&#123;//6、上传表单项获取name-fileName-流操作 String name = item.getFieldName(); String fieldName = item.getName(); System.out.println(&quot;上传表单项 name = &quot; + name); System.out.println(&quot;上传表单项 fieldName = &quot; + fieldName); //流操作，将上传文件写入本地磁盘 item.write(new File(&quot;d:\\\\TestFolder\\\\uploadTest\\\\&quot; + fieldName)); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 文件下载基本步骤 从客户的请求中读取要下载的文件名 设置响应类型 String servletContext.getMimeType(String filePath); String filePath：表示文件的实际存储路径，”/“ 表明当前web应用的web根目录 response.setContentType(String mimeType); 可选：设置响应头，表明数据是用于下载的(如图片，实现非直接打开，而是弹出浏览器下载) response.setHeader(“Content-Disposition”,”attachement;filename=文件名”); Content-Disposition响应头：指明收到的数据如何处理 attachement：意为附件，表示下载使用 filename=文件名：设置响应给客户时下载的文件名(可自定义) 读取下载文件的内容：获取文件的InputStream对象，获取途径可能存在多种 文件存储在web应用本身可用：servletContext.getResourceAsStream(String path); 把下载文件回传给客户端 首先获取用于响应的输出流：OutputStream response.getOutputStream(); 把文件的输入流逐一读取并传入响应的输出流 下载实现下载操作代码实现基本不用使用其他第三方jar包，IO操作中可以使用apache的commons-io-1.4.jar(也是commons-fileupload-1.2.1.jar的依赖)来简化IO代码书写。其余大部分使用源生代码实现。 项目结构：在web根目录下创建file文件夹，里面存放abc.jpg图片 downloadPage.jsp 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/downloadServlet&quot;&gt;下载文件&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; DownloadServlet.java 123456789101112131415161718192021222324252627282930313233343536373839404142package com.website.download;import org.apache.commons.io.IOUtils;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;/** * @author yhd * @create 2021-04-14 16:29 */public class DownloadServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1、从客户端请求中读取拟下载文件的文件名，(演示写死文件名) String fileName = &quot;abc.jpg&quot;; //2、设置响应类型 ServletContext servletContext = getServletContext(); String mimeType = servletContext.getMimeType(&quot;/file/&quot; + fileName); resp.setContentType(mimeType); System.out.println(&quot;mimeType = &quot; + mimeType); //3、设置响应头：指明响应数据的处理方式，调用浏览器附件下载(fileName可自定义) resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot; + fileName); //4、获取拟回传文件的输入流 InputStream resourceAsStream = servletContext.getResourceAsStream(&quot;/file/&quot; + fileName); System.out.println(&quot;resourceAsStream = &quot; + resourceAsStream); //5、获取响应输出流 ServletOutputStream outputStream = resp.getOutputStream(); //6、把数据读出并想响应输出流输出(为方便IO操作代码，使用apache，commons-io的IOUtils) IOUtils.copy(resourceAsStream,outputStream); &#125;&#125; setHeader中文乱码当通过setHeader()设置回传给浏览器附件下载时的下载明含中文时出现乱码，如下： 1resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename&#x3D;&quot; + &quot;中国.jpg&quot;); 解决方案1：URLEncoder编码，仅适用(IE，Chrome浏览器) 解决方案2：Base64编码，适用(火狐浏览器) URL编码方案URLEncoder编码，仅适用(IE，Chrome浏览器) 编码格式：把字符串转换称为%xx%xx%xx...内容，xx是十六进制 123String str = &quot;attachment;fileName=&quot; + URLEncoder.encode(&quot;中文.jpg&quot;, &quot;UTF-8&quot;);//str = %E4%B8%AD%E5%9B%BD.jpgresponse.setHeader(&quot;Content-Disposition&quot;, str); Base64编码方案Base64编码，适用(Chrome、火狐浏览器)，不适用IE base64编码与解码操作： 12345678910111213141516171819//base64解码与编码操作public class Base64Test &#123; public static void main(String[] args) throws Exception &#123; String str = &quot;这是base64编码&quot;; System.out.println(&quot;原始 str = &quot; + str); //base64编码操作 BASE64Encoder encoder = new BASE64Encoder(); str = encoder.encode(str.getBytes(&quot;UTF-8&quot;)); System.out.println(&quot;base64编码 str = &quot; + str); //base64解码操作 BASE64Decoder decoder = new BASE64Decoder(); byte[] bytes = decoder.decodeBuffer(str); //解码成字节数组后，重新以UTF-8的方式编码成字符串 str = new String(bytes,&quot;UTF-8&quot;); System.out.println(&quot;base64解码 str = &quot; + str); &#125;&#125; setHeader中的应用：火狐浏览器中文乱码问题 修改请求头部分信息 原始请求头：Content-Disposition: attachment; filename=中文名 修改请求头：Content-Disposition: attachment; filename==?charset?B?xxxxx?= =?charset?B?xxxxx?=说明 =?**：表示编码内容的开始** charset：填充字符集类型，如UTF-8 B：表示使用BASE64编码 xxxx：BASE64编码的内容，这里即表示文件名 ?=**：表示编码内容的结束** 123String downloadFileName = new BASE64Encoder().encode(&quot;中国.jpg&quot;.getBytes(&quot;UTF-8&quot;));download = &quot;=?UTF-8?B?&quot; + downloadFileName + &quot;?=&quot;;resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot; + downloadFileName); 综合解决方案 通过判断User-Agent分两种情况处理，兼容chrome、火狐、ie浏览器 若为火狐浏览器、则使用base64编码 其他浏览器则使用URL编码 12345678String downloadFileName; //若是火狐浏览器则使用base64编码，否则使用URL编码(UTF-8)if(req.getHeader(&quot;User-Agent&quot;).contains(&quot;Firefox&quot;))&#123; downloadFileName = &quot;=?UTF-8?B?&quot; + new BASE64Encoder().encode(&quot;中国.jpg&quot;.getBytes(&quot;UTF-8&quot;)) + &quot;?=&quot;;&#125;else&#123; downloadFileName = URLEncoder.encode(&quot;中国.jpg&quot;,&quot;UTF-8&quot;);&#125;resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot; + downloadFileName); Dom4j解析技术dom4j 是优秀的第三方解析XML类库。需要使用 dom4j 就需要到 dom4j 官网下载 dom4j 的 jar 包。具体操作可以查看官方文档，或者下载离线jar包后查看离线帮助文档，如下 Dom4j编程步骤 添加jar包，如 dom4j-1.6.1.jar 通过创建SAXReader对象调用read方法加载xml文件获取Document对象 通过Document对象获取对应的xml对象的根元素 通过根元素调用element(标签名)或elements(标签名)方法获取对应的xml标签对象或集合 获得标签对象后通过调用对应方法获取属性，或子标签。具体演示如下 创建实例XML文件 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;books&gt; &lt;book sn=&quot;SN12341232&quot;&gt; &lt;name&gt;effective of java&lt;/name&gt; &lt;price&gt;9.9&lt;/price&gt; &lt;author&gt;刘德华&lt;/author&gt; &lt;/book&gt; &lt;book sn=&quot;SN12341231&quot;&gt; &lt;name&gt;深入了解虚拟机&lt;/name&gt; &lt;price&gt;99.99&lt;/price&gt; &lt;author&gt;陈慧娴&lt;/author&gt; &lt;/book&gt;&lt;/books&gt; 编写标签对应的java类，并封装成java类，输出所有属性。 1234567public class Book &#123; private String book; private String name; private Double price; private String author; //....建立构造，重写toString等基操&#125; 1234567891011121314151617181920212223242526@Testpublic void test() throws DocumentException &#123; //1、通过创建SAXReader对象调用read方法加载xml文件获取Document对象 SAXReader reader = new SAXReader(); Document read = reader.read(&quot;src/books.xml&quot;); //2、通过Document对象获取对应的xml对象的根元素 Element rootElement = read.getRootElement(); //3、通过根元素获取对应的xml标签对象,主要使用element()与elements()方法 List&lt;Element&gt; books = rootElement.elements(&quot;book&quot;); for(Element book : books)&#123; //1、获取当前标签属性 String sn = book.attributeValue(&quot;sn&quot;); //2、获取book标签下name、price、author标签的值 //方式1：通过再获取子标签的element对象,再调用getText() String name = book.element(&quot;name&quot;).getText(); //方式2：直接通过 String author = book.elementText(&quot;author&quot;); Double price = Double.parseDouble(book.elementText(&quot;price&quot;)); System.out.println(new Book(sn,name,price,author)); &#125;&#125;/*输出如下Book&#123;book=&#x27;SN12341232&#x27;, name=&#x27;effective of java&#x27;, price=9.9, author=&#x27;刘德华&#x27;&#125;Book&#123;book=&#x27;SN12341231&#x27;, name=&#x27;深入了解虚拟机&#x27;, price=99.99, author=&#x27;陈慧娴&#x27;&#125;*/","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"html&css&js&jq&xml入门","slug":"html&css&js&jq&xml入门","date":"2021-03-23T11:54:32.000Z","updated":"2021-03-24T08:43:56.562Z","comments":true,"path":"2021/03/23/html&css&js&jq&xml入门/","link":"","permalink":"http://yoursite.com/2021/03/23/html&css&js&jq&xml%E5%85%A5%E9%97%A8/","excerpt":"","text":"[TOC] HTML基本规范123456789101112131415&lt;!DOCTYPE html&gt;&lt;!-- 约束,声明 --&gt;&lt;!-- html标签表示html的开始 lang=&quot;zh_CN&quot;表示中文--&gt;&lt;!-- html标签中一般分为两部分,分别是:head和body --&gt;&lt;!-- 表示头部信息,一般包含三部分内容,title标签,css样式,js代码 --&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;!-- 表示当前页面使用UTF-8字符集 --&gt; &lt;title&gt;某东&lt;/title&gt;&lt;!--表示标题--&gt;&lt;/head&gt;&lt;!--body标签是整个html页面显示的主体内容--&gt;&lt;body &gt; Hello world!&lt;/body&gt;&lt;/html&gt; HTML标签介绍 标签的格式： &lt;标签名&gt;封装的数据&lt;/标签名&gt; &lt;html&gt;Hello&lt;/html&gt; 标签名大小写不敏感 标签拥有自己的属性：基本属性、事件属性 基本属性：bgcolor=&quot;red&quot; 可以修改简单的样式效果 事件属性：onclick=&quot;alert(&#39;你好！&#39;);&quot; 可以直接设置事件响应后的代码 .标签又分为，单标签和双标签。 单标签格式： &lt;标签名 /&gt; ，如&lt;br/&gt; 换行 ，&lt;hr/&gt; 水平线 双标签格式: &lt;标签名&gt; …封装的数据…&lt;/标签名&gt; 常用标签介绍w3c手册https://www.w3school.com.cn/ 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;!-- 约束,声明 --&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;某东&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 1、标题 --&gt;&lt;h1 align=&quot;left&quot;&gt;标题 1左对齐&lt;/h1&gt;&lt;h2 align=&quot;center&quot;&gt;标题 2居中&lt;/h2&gt;&lt;h3 align=&quot;right&quot;&gt;标题 3右对齐&lt;/h3&gt;&lt;!-- 2、a标签是 超链接target属性：属性设置哪个目标进行跳转 _self 表示当前页面(默认值) _blank 表示打开新页面来进行跳转--&gt;&lt;a href=&quot;http://baidu.com&quot;&gt;百度&lt;/a&gt;&lt;a href=&quot;http://baidu.com&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt; &lt;!--div、span、p标签 div 标签 默认独占一行 span 标签 它的长度是封装数据的长度 p 段落标签 默认会在段落的上方或下方各空出一行来（如果已有就不再空）--&gt;&lt;div&gt;div 标签 1&lt;/div&gt;&lt;div&gt;div 标签 2&lt;/div&gt;&lt;span&gt;span 标签 1&lt;/span&gt;&lt;span&gt;span 标签 2&lt;/span&gt;&lt;p&gt;p 段落标签 1&lt;/p&gt;&lt;p&gt;p 段落标签 2&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 表单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!-- 7、表单 --&gt;&lt;!-- action提交服务器地址、method提交方式 --&gt;&lt;!--一、单提交的时候，数据没有发送给服务器的三种情况： 1、表单项没有 name 属性值 2、单选、复选（下拉列表中的 option 标签）都需要添加 value 属性，以便发送给服务器 3、表单项不在提交的 form 标签中二、GET 请求的特点是： 1、浏览器地址栏中的地址是：action 属性[+?+请求参数] 请求参数的格式是：name=value&amp;name=value 2、不安全 3、它有数据长度的限制三、POST 请求的特点是： 1、浏览器地址栏中只有 action 属性值 2、相对于 GET 请求要安全 3、理论上没有数据长度的限制 --&gt;&lt;form action=&quot;loginServlet/login&quot; method=&quot;post&quot;&gt; 用户名称：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;默认值&quot;/&gt;&lt;br/&gt; 用户密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;123&quot;/&gt;&lt;br/&gt; &lt;!-- 提交按钮 --&gt; &lt;input type=&quot;submit&quot; name=&quot;login&quot; value=&quot;登录&quot;/&gt; &lt;!-- 单选：name属性分组成为单选, checked=&quot;checked&quot; 默认单选--&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked=&quot;checked&quot;/&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot;/&gt;女&lt;br/&gt; &lt;!-- 复选 --&gt; &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;/&gt;Java&lt;input type=&quot;checkbox&quot;/&gt;C&lt;input type=&quot;checkbox&quot;/&gt;C++ &lt;!-- 下拉列表 selected=&quot;selected&quot; 表默认选中--&gt; &lt;select&gt; &lt;option&gt;--请选择国籍--&lt;/option&gt;&lt;!-- 选项 --&gt; &lt;option selected=&quot;selected&quot; value=&quot;China&quot;&gt;--中国--&lt;/option&gt; &lt;option&gt;--美国--&lt;/option&gt; &lt;/select&gt;&lt;br/&gt; &lt;!-- 多行文本输入框 rows 属性设置可以显示几行的高度 cols 属性设置每行可以显示几个字符宽度 --&gt; &lt;textarea&gt; 默认值 &lt;/textarea&gt;&lt;br/&gt; &lt;!-- 重置 --&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;!-- 文件上传域 --&gt; &lt;input type=&quot;file&quot; name=&quot;fileUpload&quot; value=&quot;上传&quot;&gt; &lt;!-- 隐藏域，这些信息不显示，但提交表单时会提交到后台服务器 --&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot;&gt;&lt;/form&gt; 常用特殊字符 诸如’’&lt;’’ 与’’&gt;’’符号在HTML中拥有特殊含义，若显示这些特殊含义的字符则需使用特殊字符书写 HTML会默认裁掉连续的空白字符(空格,TAB…) 特殊字符 实体字符 意义 &lt; &amp;lt less than &gt; &amp;gt great than 空格 &amp;nbsp 牛逼space 12&lt;!-- 把&lt;br&gt;换行标签变成文本输出 --&gt;&amp;lt br &amp;gt CSS语法规则三元组：选择器、属性、值 CSS和HTML的结合 html中直接使用style属性设置 style 标签专门用来定义 css 样式代码 把 css 样式写成一个单独的css 文件，再通过 link 标签引入即可复用 style属性在标签的 style 属性上设置”key:value value;”修饰 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--需求 1：分别定义两个 div、span 标签，分别修改每个 div 标签的样式为：边框 1 个像素，实线，红色。--&gt;&lt;div style=&quot;border: 1px solid red;&quot;&gt;div 标签 1&lt;/div&gt;&lt;div style=&quot;border: 1px solid red;&quot;&gt;div 标签 2&lt;/div&gt;&lt;span style=&quot;border: 1px solid red;&quot;&gt;span 标签 1&lt;/span&gt;&lt;span style=&quot;border: 1px solid red;&quot;&gt;span 标签 2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; style标签1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;/title&gt; &lt;!--style 标签专门用来定义 css 样式代码--&gt;&lt;style type=&quot;text/css&quot;&gt;/* 需求 1：分别定义两个 div、span 标签，分别修改每个 div 标签的样式为：边框 1 个像素，实线，红色。*/ div&#123; border: 1px solid red; &#125; span&#123; border: 1px solid red; &#125;&lt;/style&gt; &lt;/head&gt;&lt;body&gt;&lt;div&gt;div 标签 1&lt;/div&gt;&lt;div&gt;div 标签 2&lt;/div&gt;&lt;span&gt;span 标签 1&lt;/span&gt;&lt;span&gt;span 标签 2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; css文件&amp;ink标签 test.css文件如下 123456div&#123; border: 1px solid yellow;&#125;span&#123; border: 1px solid red;&#125; test.html文件如下 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;/title&gt;&lt;!--link 标签专门用来引入 css 样式代码--&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;test.css&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;div 标签 1&lt;/div&gt;&lt;div&gt;div 标签 2&lt;/div&gt;&lt;span&gt;span 标签 1&lt;/span&gt;&lt;span&gt;span 标签 2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; CSS选择器 标签名选择器 id选择器 class选择器 组合选择器 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;CSS选择器&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*标签选择器*/ body&#123; font-size: 30px; border: 1px yellow solid; &#125; /*id 选择器*/ #test1&#123; color: blue; &#125; /*class 选择器*/ .test2&#123; color: red; &#125; /*组合选择器*/ #test1,.test2&#123; background: green; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;test1&quot;&gt;id 001&lt;/div&gt; &lt;div class=&quot;test2&quot;&gt;class 002&lt;/div&gt; &lt;div class=&quot;test2&quot;&gt;class 002&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 常用样式 字体颜色 color : red; 颜色可以写颜色名如：black, blue, red, green 等 颜色也可以写 rgb 值和十六进制表示值：如 rgb(255,0,0)，#00F6DE，如果写十六进制值必须加# 宽度 width:19px;宽度可以写像素值：19px； 也可以写百分比值：20% 高度 height:20px; 高度可以写像素值：19px； 也可以写百分比值：20% 背景颜色 background-color:#0F2D4C; 字体样式： color：#FF0000;字体颜色红色 font-size：20px; 字体大小 红色 1 像素实线边框 border：1px solid red; DIV 居中: margin-left: auto; margin-right: auto; 文本居中： text-align: center; 超连接去下划线: text-decoration: none; 表格细线 1234567table &#123; border: 1px solid black; /*设置边框*/ border-collapse: collapse; /*将边框合并*/&#125;td,th &#123; border: 1px solid black; /*设置边框*/&#125; 列表去除修饰，兼容IE 123ul &#123; list-style: none;&#125; JavaScript基础介绍Javascript 语言诞生主要是完成页面的数据验证。因此它运行在客户端，需要运行浏览器来解析执行 JavaScript 代码。 JS 是 Netscape 网景公司的产品，最早取名为 LiveScript;为了吸引更多 java 程序员。更名为 JavaScript。 JS 是弱类型(类型可变)，Java 是强类型(定义变量已确定且不可变)。 特点： 交互性（它可以做的就是信息的动态交互） 安全性（不允许直接访问本地硬盘） 跨平台性（只要是可以解释 JS 的浏览器都可以执行，和平台无关） js和html结合方式 直接在html的head或 body 标签中， 使用 script 标签来书写JavaScript 通过script标签外部引入单独的 JavaScript 代码文件 script标签中书写12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt; // alert 是 JavaScript 语言提供的一个警告框函数。 // 它可以接收任意类型的参数，这个参数就是警告框的提示信息 alert(&quot;hello javaScript!&quot;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 通过script标签引入js文件12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;/title&gt;&lt;!--现在需要使用 script 引入外部的 js 文件来执行 src 属性专门用来引入 js 文件路径（可以是相对路径，也可以是绝对路径） script 标签可以用来定义 js 代码，也可以用来引入 js 文件 但是，一个script标签只能做一件事，作为引入则不能在里面书写JavaScript代码--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;1.js&quot;&gt;该领域书写js代码无效&lt;/script&gt;&lt;!-- 若想在当前情况下还在htmlzh写js，必须再创建一个script标签作为js代码书写 --&gt;&lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;国哥现在可以帅了&quot;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 变量变量类型 数值类型： number (对应java：byte int short long float double等) 字符串类型： string 对象类型： object 布尔类型： boolean 函数类型： function JavaScript中特殊的值： undefined：未定义，所有 js 变量未赋于初始值的时候，默认值都是 undefined. null：空值 NaN：全称是：Not a Number。”非数字,非数值”。 123var a = 12;var b = &quot;abc&quot;;alert(a * b);//输出NaN 定义变量格式 声明：var 变量名; 声明+初始化：var 变量名 = 值; 关系(比较)运算符特殊讲解 == ：等于，是简单的做字面值的比较 ===：全等于，除了做字面值的比较之外，还会比较两个变量的数据类型 1234var a = 12;var b = &quot;12&quot;;alert(a == b);//truealert(a === b);//false 逻辑运算 在 JavaScript 语言中，所有的变量，都可以做为一个 boolean 类型的变量去使用 0 、null、 undefined、””(空串) 都认为是 false 逻辑运算后返回值 &amp;&amp; 与运算：有两种情况 情况1：当表达式全为真的时候。返回最后一个表达式的值 情况2：当表达式中，有一个为假的时候。返回第一个为假的表达式的值 || 或运算： 情况1：当表达式全为假时，返回最后一个表达式的值 情况2：只要有一个表达式为真。就会把第一个为真的表达式的值 &amp;&amp; 和 ||运算有短路。 123456789101112131415var a = &quot;abc&quot;;var b = true;var d = false;var c = null;// &amp;&amp; 与运算alert( a &amp;&amp; b );//truealert( b &amp;&amp; a );//abcalert( a &amp;&amp; d ); // falsealert( a &amp;&amp; c ); // null// || 或运算alert( d || c ); // nullalert( c || d ); //falsealert( a || c ); //abcalert( b || c ); //true 数组数组的定义12var 数组名 = []; // 空数组var 数组名 = [1 , ’abc’ , true]; // 定义数组同时赋值元素 数组定义时可不指定长度、且可变长度 只要我们通过数组下标赋值(不赋值则不会扩容)，那么最大的下标值，就会自动的给数组做扩容操作 12345678910111213var arr = [true,1]; // 定义一个空数组// alert( arr.length ); // 0arr[0] = 12;alert( arr[0] );//12alert( arr.length ); // 0arr[2] = &quot;abc&quot;;alert(arr.length); //3alert(arr[1]);// undefined// 数组的遍历for (var i = 0; i &lt; arr.length; i++)&#123; alert(arr[i]);&#125; 函数格式112345678910111213141516171819//1. 无参无返回值函数function fun()&#123; alert(&quot;无参无返回值函数&quot;);&#125;fun();//函数调用//2.带形参函数function fun1(a ,b) &#123; alert(&quot;有参函数 fun2()被调用了 a=&gt;&quot; + a + &quot;,b=&gt;&quot;+b);&#125;fun1();//函数调用//3. 在 JavaScript 语言中，如何定义带有返回值的函数？//只需要在函数体内直接使用 return 语句返回值即可！function sum(num1,num2) &#123; var result = num1 + num2; return result;&#125;alert(sum(100,50) ); 格式212345//可以把函数名忽略作为var变量的引用var fun = function () &#123; alert(&quot;无参函数&quot;);&#125;fun();//调用 常用函数 函数 意义 typeof() 传入变量，返回数据类型 jQuery应用实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;script type=&quot;text/javascript&quot;&gt; //Jq、页面加载完成后执行 $(function()&#123; //给注册按钮绑定单击事件 $(&quot;#sub_btn&quot;).click(function () &#123; // 验证用户名：必须由字母，数字下划线组成，并且长度为 5 到 12 位 // 验证密码：必须由字母，数字下划线组成，并且长度为 5 到 12 位 // 验证确认密码：和密码相同 // 邮箱验证：xxxxx@xxx.com // 验证码：现在只需要验证用户已输入。因为还没讲到服务器。验证码生成 // 1、验证用户名：必须由字母，数字下划线组成，并且长度为 5 到12位 //获取用户名内容 var username = $(&quot;#username&quot;).val(); //创建正则表达式对象 var usernamePatt = /^\\w&#123;5,12&#125;$/; //调用test方法进行测试 //给非法输入进行提示 var $errorMsg = $(&quot;.errorMsg&quot;); if(!usernamePatt.test(username))&#123; $errorMsg.text(&quot;用户名非法输入&quot;); return false;//终止提交 &#125; //2、验证密码：必须由字母，数字下划线组成，并且长度为 5 到 12 位 //同理如上 var password = $(&quot;#password&quot;).val(); //创建正则表达式对象 var passwordPatt = /^\\w&#123;5,12&#125;$/; //调用test方法进行测试 //给非法输入进行提示 if(!passwordPatt.test(password))&#123; $errorMsg.text(&quot;密码非法输入&quot;); return false; &#125; //3、验证确认密码：和密码相同 // 获取确认密码 var repwd = $(&quot;#repwd&quot;).val(); if(password != repwd)&#123; $errorMsg.text(&quot;两次密码输入不一致&quot;); return false; &#125; //4、邮箱验证：xxxxx@xxx.com var emalil = $(&quot;#email&quot;).val(); var emailPatt = /^[a-z\\d]+(\\.[a-z\\d]+)*@([\\da-z](-[\\da-z])?)+(\\.&#123;1,2&#125;[a-z]+)+$/; if(!emailPatt.test(emalil))&#123; $errorMsg.text(&quot;邮箱格式非法&quot;); return false; &#125; //5、获取验证码信息，只要输入不为空(去除空格后)即可 // 验证码：现在只需要验证用户已输入。因为还没讲到服务器。验证码生成 var code = $(&quot;#code&quot;).val(); code = $.trim(code); if(code == null || code == &quot;&quot;)&#123; $errorMsg.text(&quot;验证码输入为空&quot;); return false; &#125; //错误信息清除 $errorMsg.text(&quot;&quot;); return true; &#125;)&#125;)&lt;/script&gt; XMLxml是可扩展的标记性语言 XML作用 用来保存数据，而且这些数据具有自我描述性 它还可以做为项目或者模块的配置文件 还可以做为网络传输数据的格式（现在 JSON 为主） xml 语法 文档声明 元素（标签） xml 属性 xml 注释 文本区域（CDATA 区） 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!-- xml声明 version是版本的意思(自从除了第一版每更新过) encoding是编码 --&gt;&lt;books&gt; &lt;!-- 这是xml注释,books标识多本图书 --&gt; &lt;book id=&quot;SN123123413241&quot;&gt; &lt;!-- book标签描述一本图书 id属性描述 的是图书 的编号 --&gt; &lt;name&gt;java编程思想&lt;/name&gt; &lt;!-- name标签描述 的是图书 的信息 --&gt; &lt;author&gt;华仔&lt;/author&gt; &lt;!-- author单词是作者的意思 ，描述图书作者 --&gt; &lt;price&gt;9.9&lt;/price&gt; &lt;!-- price单词是价格，描述的是图书 的价格 --&gt; &lt;/book&gt; &lt;book id=&quot;SN12341235123&quot;&gt; &lt;!-- book标签描述一本图书 id属性描述 的是图书 的编号 --&gt; &lt;name&gt;葵花宝典&lt;/name&gt; &lt;!-- name标签描述 的是图书 的信息 --&gt; &lt;author&gt;班长&lt;/author&gt; &lt;!-- author单词是作者的意思 ，描述图书作者 --&gt; &lt;price&gt;5.5&lt;/price&gt; &lt;!-- price单词是价格，描述的是图书 的价格 --&gt; &lt;/book&gt;&lt;/books&gt; XML标签对大小写敏感 每个属性的值必须使用引号引起来 XML某一种标签只能有一个顶级元素(没有父标签的元素) 12345&lt;books&gt;&lt;!-- 没有父标签，为顶级元素 --&gt; &lt;book&gt;ABC&lt;/book&gt; &lt;book&gt;ABC&lt;/book&gt;&lt;/books&gt;&lt;books&gt;出错&lt;/books&gt; &lt;!-- 与顶级元素books重复，错误 --&gt; XML中的特殊字符 123&lt;books&gt; &lt;book&gt;&amp;lt;C语言&amp;gt;&lt;/book&gt; &lt;!--显示 &lt; C语言 &gt; --&gt;&lt;/books&gt; 文本区域若XML中有大量需要转义的字符，如想显示&lt;&lt;&lt;&lt; A &gt;&gt;&gt;&gt;则可使用CDATA语法。CDATA 语法可以告诉 xml 解析器，CDATA 里的文本内容，只是纯文本，不需要 xml 语法解析 CDATA 格式：&lt;![CDATA[]]&gt;在最里面的[]内输入指定不解析文本内容 12345&lt;book&gt;&lt;!-- 正常显示&lt;&lt;&lt;&lt; A &gt;&gt;&gt;&gt; --&gt; &lt;![CDATA[ &lt;&lt;&lt;&lt; A &gt;&gt;&gt;&gt; ]]&gt;&lt;/book&gt; XML的解析技术 不管是 html 文件还是 xml 文件它们都是标记型文档，都可以使用 w3c 组织制定的 dom 技术来解析。 早期 JDK 为我们提供了两种 xml 解析技术DOM 和 Sax 简介（已经过时，但我们需要知道这两种技术） Dom ：解析技术是 W3C 组织制定的，而所有的编程语言都对这个解析技术使用了自己语言的特点进行实现。 Java 对 dom 技术解析标记也做了实现。 SAX：Sun 公司在 JDK5 版本对 dom 解析技术进行升级：SAX（ Simple API for XML ） SAX 解析，它跟 W3C 制定的解析不太一样。它是以类似事件机制通过回调告诉用户当前正在解析的内容。 它是一行一行的读取 xml 文件进行解析的。不会创建大量的 dom 对象。 所以它在解析 xml 的时候，在内存的使用上。和性能上。都优于 Dom 解析。 第三方的解析： jdom 在 dom 基础上进行了封装 dom4j 又对 jdom 进行了封装。 pull 主要用在 Android 手机开发，是在跟 sax 非常类似都是事件机制解析 xml 文件。","categories":[],"tags":[{"name":"xml","slug":"xml","permalink":"http://yoursite.com/tags/xml/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Mybatis","slug":"Mybatis","date":"2021-03-21T01:52:32.000Z","updated":"2021-03-22T14:34:39.520Z","comments":true,"path":"2021/03/21/Mybatis/","link":"","permalink":"http://yoursite.com/2021/03/21/Mybatis/","excerpt":"","text":"[TOC] 基本历史原是Apache的一个开源项目iBatis, 2010年6月这 个项目由Apache Software Foundation 迁移到了 Google Code，随着开发团队转投Google Code 旗下， iBatis3.x正式更名为MyBatis ，代码于 2013年11月迁移到Github Mybatis的优势java领域中，对比最常见的三种数据库编程。 JDBC及相关工具相关工具：JDBC—&gt;Dbutils(QueryRunner)—&gt;JdbcTemplate(Spring) SQL夹在Java代码块里，耦合度高导致硬编码，维护不易且实际开发需求中sql是有变化，频繁修改的情况多见。 若改动一下数据库或改变一下sql语句，则整个项目需要重新打包构建部署 HibernateHibernate：全自动ORM（Object Relation Mapping）框架 全黑箱操作，想优化sql，必须再学习Hibernate的HQL定制sql语句，开发者希望sql语句交给开发人员编写，不失去其灵活性。 只能全自动全映射，数据表有100个列，则即使只查询某一个字段都需要把全部列映射过来。导致数据库性能下降 Mybatis MyBatis支持通过XML方式定制化 SQL、存储过程以及高级映射的优秀的持久层框架 因此Mybatis是半自动，轻量级的框架。 MyBatis 避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。 MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO(Plain Old Java Objects，普通的Java对象)映射成数据库中的记录 Mybatis下载 GitHub网址 进入GitHub页面 选的特定版本下载 基本资料介绍 解压mybatis-3.4.1，使用mybatis只需要导入mybatis-3.4.1.jar即可，lib目录下的jar包是mybatis需要添加其他功能才需要选择性导入的包 HelloWorldhelloworld 打开，mybatis在线官方文档。操作基本按照官方文档进行 准备jar包 mybatis-3.4.1.jar：mybatis核心jar包 mysql-connector-java-5.1.37-bin.jar：数据库连接jar包 创建测试数据库：本例数据库名为 mybatis，创建测试数据表tbl_employee 新建一个java项目，并建立对应的JavaBean 依据mybatis官方文档从XML中构建SqlSessionFactory 本例是直接在类路径下创建XML文档：在项目内新建一个名为mybatis-config.xml (全局配置)文件，从官方文档中复制如下内容 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- 需修改部分--------------------------------------------------------------tips --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- 还缺少文件----------------------------------------------------------------tips --&gt; &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 修改XML中的数据源信息： 123456 &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;!-- 驱动 --&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt;&lt;!-- 数据库地址 --&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;&lt;!-- 用户名 --&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;!-- 密码 --&gt;&lt;/dataSource&gt; 从mybatis-config.xml 中构建SqlSessionFactory 123String resource = &quot;mybatis-config.xml&quot;;InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 添加如下代码从 SqlSessionFactory 中获取 SqlSession 1SqlSession session = sqlSessionFactory.openSession(); 拟执行查询操作，能查询已映射的 SQL语句 1234567//形参1：sql隐射XML文件的唯一标识符//形参2：执行sql语句的传入参数try&#123; Blog blog = (Blog) session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);&#125;finally&#123; session.close();&#125; 创建已隐射的XML文件 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!-- sql映射文件 --&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- 名称空间：暂时来说名字可以随便起，一般映射哪个实体对象就起名为 xxxMapper --&gt;&lt;mapper namespace=&quot;com.test.mybatis.bean.EmployeeMapper&quot;&gt; &lt;!-- id：唯一标识，一般起名为[操作类型 + 操作对象]selectXxx --&gt; &lt;!-- resultTupe：返回类型，若返回是一个对象，则填入这个类的全类名 --&gt; &lt;!-- #&#123;id&#125;：从传递过来的参数中取出id指，类似java占位符 ? --&gt; &lt;select id=&quot;selectEmp&quot; resultType=&quot;com.test.mybatis.bean.Employee&quot;&gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 修改第8步代码，开始执行查询操作，能查询已映射的 SQL语句 12345678910//形参1：sql映射XML文件的唯一标识符，可直接填入XML的id(若存在重名)// 但建议使用XML中 namespace.id 的方式唯一标识//形参2：执行sql语句的传入参数，如下查询id=1的员工信息try&#123; String id = &quot;com.test.mybatis.bean.EmployeeMapper.selectEmp&quot;; Employee employee = (Employee) session.selectOne(id, 1); System.out.println(employee);&#125;finally&#123; session.close();&#125; 在全局配置文件mybatis-config.xml中修改为自定义的sql隐射文件 1234&lt;mappers&gt; &lt;!-- 将写好的sql隐射文件注册到全局配置文件中，文件在全类名路径下，因此直接写即可 --&gt; &lt;mapper resource=&quot;EmployeeMapper.xml&quot;/&gt;&lt;/mappers&gt; 最终效果 小结 根据xml全局配置文件创建一个SqlSessionFactrory 创建sql映射文件，配置了每一个sql，以及sql的 封装规则等 将sql映射文件注册在全局配置文件中 代码部分 根据全局配置文件得到SqlSessionFactory 使用sqlSession工厂，获得sqlSession对象来执行增删改查 一个sqlSession就是代表和数据库的一次会话，用完关闭 使用sql的唯一标志来告诉Mybatis执行哪个sql，sqk均保存在sql映射文件中 接口式编程操作步骤对于上述的第8或12步骤的方式执行sql操作，mybatis还提供了一种更为智能，受众面更广的实现方式。即接口与配置文件进行动态绑定。以后使用mybatis均使用这种方式操作 如日常开发创建dao的接口，EmployeeMapper.java 规范化sql映射文件中的namespace与id的值，形成如下对应关系 namespace 值 == 对应dao操作的接口的全类名 id 值 == 对应dao操作接口中特定的方法名(方法返回类型与传入参数也要对应sql语句本身) 不再直接使用mybatis的session对象直接进行数据库操作，而是通过调用session.getMapper();方法，传入接口的类型，使其自动创建一个代理对象，通过这个代理对象实现类去执行增删改查。 123456789try&#123; //String id = &quot;com.test.mybatis.bean.EmployeeMapper.selectEmp&quot;; //Employee employee = (Employee) session.selectOne(id, 1); EmployeeMapper mapper = session.getMapper(EmployeeMapper.class); Employee employee = mapper.getEmpById(1); System.out.println(employee);&#125;finally&#123; session.close();&#125; 优势 代码不仅更清晰 不用担心传入类型安全(8/12步骤方式传入类型为Object)， 不用担心可能出错的字符串字面值以及返回类型需要强制类型转换 小结 接口式编程 原生： Dao ===&gt; DaoImpl mybatis：Mapper ===&gt; xxMapper.xml SqlSession代表和数据库的一次会话；用完必须关闭； SqlSession和connection一样她都是非线程安全。每次使用都应该去获取新的对象。 mapper接口没有实现类，但是mybatis会为这个接口生成一个代理对象(将接口和xml进行绑定) 1EmployeeMapper empMapper = sqlSession.getMapper(EmployeeMapper.class); 两个重要的配置文件 mybatis的全局配置文件：包含数据库连接池信息，事务管理器信息等…系统运行环境信息 sql映射文件：保存了每一个sql语句的映射信息(将sql抽取出来) config_xml相关标签标签书写提示检查若配置文件书写中无法弹出mybatis标签的提示，可以进行如下操作，一般IDE都有 准备mybatis-3-config.dtd文件 联网状态下可以点击xml文件中链接下载：http://mybatis.org/dtd/mybatis-3-config.dtd 或者在mybatis-3,4,1.jar包中ibatis.builder.xml中解压出来 进入eclipse 进行如下设置 最后在IDE中关闭所有xml文件，再打开测试即可 以下介绍均为最基本，最常用的使用方式。详细使用与功能介绍可参详官方文档 propertiesmybatis可以使用properties来引入外部 .properties配置文件的内容，主要使用在数据源信息上。 resource：引入类路径下的资源 url：引入网络路径或者磁盘路径下的资源 如在类路径下创建一个dbconfig.properties文件，用于存放数据源信息，内容如下 1234jdbc.driver&#x3D;com.mysql.jdbc.Driverjdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatisjdbc.username&#x3D;rootjdbc.password&#x3D;root 通过properties标签引入相关信息 1234567891011121314151617181920&lt;configuration&gt; &lt;!-- 若不在类路径下，则按包名定位到，如com&#x2F;test&#x2F;dbconfig.properties... --&gt; &lt;properties resource&#x3D;&quot;dbconfig.properties&quot;&gt;&lt;&#x2F;properties&gt; &lt;environments default&#x3D;&quot;development&quot;&gt; &lt;environment id&#x3D;&quot;development&quot;&gt; &lt;transactionManager type&#x3D;&quot;JDBC&quot; &#x2F;&gt; &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt; &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot; &#x2F;&gt; &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot; &#x2F;&gt; &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot; &#x2F;&gt; &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot; &#x2F;&gt; &lt;&#x2F;dataSource&gt; &lt;&#x2F;environment&gt; &lt;&#x2F;environments&gt; &lt;mappers&gt; &lt;mapper resource&#x3D;&quot;EmployeeMapper.xml&quot; &#x2F;&gt; &lt;&#x2F;mappers&gt;&lt;&#x2F;configuration&gt; settings这是 MyBatis中极为重要的调整设置，它们会改变MyBatis 的运行时行为。一般使用默认即可，不需要配置，需要再查看文档进行相应的配置。 name为要设置对应的配置信息， value就是配置的值 例如：选取官方文档其中一个设置mapUnderscoreToCamelCase 设置名 描述 有效值 默认值 mapUnderscoreToCamelCase 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn true|false False 默认是False，若开启后，数据库列名为 last_Name 可直接映射java属性名lastName，而无需使用别名修改为lastName进行映射 123&lt;settings&gt; &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;&lt;&#x2F;settings&gt; typeAliases自定义类别名为某个java类全类名起别名 type：指定要起别名的类的全类名，默认别名就是类名(不分大小写) alias：指定新的别名 1234567891011121314&lt;typeAliases&gt; &lt;!-- 方式1.1：指定被起别名类全类名，使用默认别名(类名) --&gt;&lt;!-- &lt;typeAlias type&#x3D;&quot;com.test.mybatis.bean.Employee&quot;&#x2F;&gt;--&gt; &lt;!-- 方式1.2：在方式1的基础上，使用alias标签指定自定义别名 --&gt;&lt;!-- &lt;typeAlias type&#x3D;&quot;com.test.mybatis.bean.Employee&quot; alias&#x3D;&quot;emp&quot;&#x2F;&gt; --&gt; &lt;!-- 方式2.1：为指定包下所有类起别名，此时只能使用默认别名 --&gt;&lt;!-- &lt;package name&#x3D;&quot;com.test.mybatis.bean&quot;&#x2F;&gt;--&gt; &lt;!-- 方式2.2：若指定某包名与其子包下存在两个同名的类，则可以使用@Alias(&quot;Name&quot;)注解直接为指定java类起别名 --&gt; &lt;!-- 注意：需要指明使用别名注解的包是什么，即要保留方式2.1的package标签，否则会报错 --&gt; &lt;package name&#x3D;&quot;com.test.mybatis.bean&quot;&#x2F;&gt;&lt;&#x2F;typeAliases&gt; 1234@Alias(&quot;ABC&quot;)public class Employee &#123;...&#125; 示例方式1.2效果如下 默认设置别名Mybatis官方已默认为java常用的一些基本数据类型，包装类型，集合操作等起了别名。自定义别名时注意不要于其发生冲突 基本数据类型：别名加下划线’’_’’ java类：小写 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal object Object map Map hashmap HashMap list List arraylist ArrayList collection Collection iterator Iterator typeHandlers","categories":[],"tags":[{"name":"应用框架","slug":"应用框架","permalink":"http://yoursite.com/tags/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/"},{"name":"ORM框架","slug":"ORM框架","permalink":"http://yoursite.com/tags/ORM%E6%A1%86%E6%9E%B6/"}]},{"title":"Maven","slug":"Maven","date":"2021-03-20T13:22:32.000Z","updated":"2021-03-20T13:22:36.097Z","comments":true,"path":"2021/03/20/Maven/","link":"","permalink":"http://yoursite.com/2021/03/20/Maven/","excerpt":"","text":"导言：生产环境下开发不再是一个项目一个工程，而是每一个模块创建一个工程，而多个模块整合在一起就需要 使用到像 Maven 这样的构建工具。 [TOC] 现今项目开发问题 project - package 结构的不足 若一个项目就是一个工程，当项目非常庞大时，不适合用这种二级机构管理。如一个项目多个功能模块，一个功能模块就一个MVC 推祟三层结构：engineering - project - package 则能更好的适应大工程的分工开发(如IDEA) 工程拆分后又如何进行互相调用和访问呢？这就需要用到 Maven 的依赖管理机制 项目中jar包的问题 jar包必须手动“复制”、“粘贴”到WEB-INF/lib目录下 同样的jar包文件重复出现在不同的项目工程中 jar包来源不明确，不规范 jar 包之间的依赖关系繁多，且难以得知 Maven是什么Maven基本概念​ Maven [ˈmeɪvn] 是一款服务于java平台的自动化构建工具。 java平台自动化构建工具发展历史：Make—&gt;Ant—&gt;Maven(使用面广)—&gt;Gradle 何为项目构建基本概念：以java源文件,框架配置文件,JSP,HTML,图片等资源为原材料,去生产一个可以运行的项目的过程 清理：将以前编译得到的旧的class字节码文件删除，为下一次编译做准备 编译：将Java源程序编程编译成class字节码文件 测试：自动测试，自动调用junit程序 报告：输出测试程序执行的结果 打包：动态Web工程打war包，Java工程打jar包 安装：Maven特定的概念——将打包得到的文件复制到“仓库”中的指定位置 部署：将动态Web工程生成的war包复制到Servlet容器的指定目录下，使其可以运行 安装Maven核心程序下载maven核心程序 官网 检查JAVA_HOME环境变量maven也是java编写的程序,所以运行是也需要java的虚拟机 解压Maven核心程序建议解压到一个非中文没有空格的目录下 配置Maven环境变量 新增MAVEN_HOME或者是M2_HOME 以前Maven的版本配置的变量为M2_HOME,为了向下兼容低版本,所以可以配置为M2_HOME,而且配置M2_HOME可以防止一些奇怪的错误) 添加PATH的环境变量 检查配置结果mvn -v 约定目录结构约定目录结构的意义 maven要负责我们这个项目的自动化构建，以编译为例,maven要想进行自动编译，至少需要知道java源文件保存在哪里。可采取两种方式 以配置文件的方式明确 遵守框架内部已存在的约定**. 在开发中本着能用约定解决的问题就不用配置解决，能用配置解决的就不去编写代码。 约定&gt;配置&gt;编码 凡是符合maven约定目录结构的项目都可称为Maven工程 目录结构关键：工程名—&gt;src，pom.xml，target ​ src—&gt;main，test ​ main/test —&gt; java、resources Maven常用命令常用命令 注意：执行与构建过程相关的Maven命令，必须进入pom.xml 所在的目录。 如当使用CMD命令时候必须进入到能看到pom.xml目录路径才能执行构建相关的mvn 命令 常用命令 mvn clean : 清理 mvn compile : 编译主程序 mvn test-compile : 编译测试程序 mvn test : 执行测测试 mvn package : 打包 mvn install ： 安装 mvn site ：生成站点 上述大部分命令第一次运行后都会产生一个target文件夹，之后所有构建相关产生的文件都在此目录下 mvn compile：编译后会产生一个classes文件夹，包含主程序编译的结果 mvn test-compile : 编译会产生一个test-classes文件夹，包含测试程序的编译结果 mvn package : 产生、maven-archiver、surefire-reports、XXXX.jar maven-archiver文件夹：maven一个辅助性文件 surefire-reports：内含一个.txt测试报告 XXXX.jar：打包后的jar包 关于联网问题 Maven 的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须有特定的插件来完成。而插件本身不包含在Maven核心程序中。 当我们执行的Maven命令需要用到某些插件时，Maven核心程序会首先到本地仓库中查找。 本地仓库的默认位置：[系统登陆用户的家目录] \\ .m2\\repository Maven核心程序如果在本地仓库中找不到需要的插件，那么它会自动连接外网，到中央仓库下载。如果此时无法连接外网，则构建失败。 修改默认本地仓库的位置可以让Maven核心程序到我们事先准备好(插件与jar包全有)的目录下查找插件 修改本地仓库位置 打开本地仓库位置的配置信息文件：apache-maven-3.2.2\\conf\\settings.xml 找到&lt;localRepository&gt;标签，若在注释内，请去除注释使其生效。路径设置必须设置到能看到如下图示文件内容为止 例如：应将路径配置成：&lt;localRepository&gt;D:/ManageTools/maven/repository&lt;/localRepository&gt; 对jar 包进行引用操作的先例 项目目录结构与编译后的目录结构对比 实际动态WEB项目运行是以编译后的目录结构 因此在开发过程中，所有的路径或配置文件中配置的类路径等都是以编译结果的目录结构为标准 Maven核心概念 Maven 是如何实现自动化构建的 POM 约定的目录结构 坐标 依赖管理 仓库管理 生命周期 插件和目标 继承 聚合 POM基本含义 含义：Project Object Model 项目对象模型类似：DOM ：Document Object Model 文档对象模型 pom.xml：Maven工程是核心配置文件，与构建过程相关的一切设置都在这个文件中进行配置。 POM文件简述 注意：每一个java项目(Maven项目)本身也是一个jar包的存在(打包或安装(Maven概念)) 一定程度上：Java/Maven工程 == jar包 1234567891011&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 从Maven2开始固定内容 --&gt; &lt;!-- 坐标：唯一标识当前项目/Jar --&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;Hello&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;Hello&lt;/name&gt; &lt;/project&gt; 坐标(GAV) 使用下面三个向量在仓库中唯一定位一个Maven工程：groupid、artifactid、version groupid：公司或组织域名倒序 + 项目名 &lt;groupid&gt;com.atguigu.maven&lt;/groupid&gt; artifactid：模块名 &lt;artifactid&gt;Hello&lt;/artifactid&gt; version：版本 &lt;version&gt;1.0.0&lt;/version&gt; tips：关键字，SNAPSHOT快照版、RELEASE，分离版(较成熟版本) Maven工程的坐标信息与执行mvn install命令后生成文件在仓库中路径的对应关系，以spring为例 12345&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt;&lt;version&gt;4.0.0.RELEASE&lt;&#x2F;version&gt;org&#x2F;springframework&#x2F;spring-core&#x2F;4.0.0.RELEASE&#x2F;spring-core-4.0.0.RELEASE.jar 仓库仓库的分类 本地仓库：当前电脑上部署的仓库目录，为当前电脑上所有Maven工程服务 远程仓库 私服：搭建在局域网环境中，为局域网范围内的所有Maven工程服务 以Nexus这个Maven仓库管理器来表示私服的工工作流程 中央仓库：假设在Internet上，为全世界所有Maven工程服务 中央仓库镜像：为了分担中央仓库流量，提升用户访问速度 仓库中保存的内容 Maven自身所需要的插件 第三方框架或工具的jar包 自己开发的Maven工程 不管是什么样的 jar 包，在仓库中都是按照坐标生成目录结构，所以可以通过统一的方式查询或依赖。 依赖基本概念​ 当 A jar 包用到了 B jar 包中的某些类时，A 就对 B 产生了依赖。Maven解析依赖信息时会到仓库中查找被依赖的jar包。 依赖的使用 标签的使用：&lt;dependency&gt; 坐标 + &lt;scope&gt;范围&lt;/scope&gt; &lt;/dependency&gt; &lt;dependencies&gt;内存放多个&lt;dependency&gt;标签 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; &lt;scope&gt;范围，常用取值有：compile、test、provided tips：若不添加&lt;scope&gt;标签默认是compile 范围效果\\类型 compile test provided 对主程序是否有效 有效 无效 有效 对测试程序是否有效 有效 有效 有效 是否参与打包 参与 不参与 不参与 是否参与部署 参与 不参与 不参与 示例 自定义类/jar包 junit servlet-api.jar 从开发和运行这两个阶段理解compile 和 provided 的区别 对于自己开发的Maven工程，要使用mvn install命令安装后就可以进入仓库。执行后产生如下文件 依赖的传递性tips：依赖的深入特性，首次学习建议先浏览 Eclipse中使用Maven 注意：这里描述的是工程三层结构，即一个应用工程，包含多个功能模块，每个功能模块都是一个eclipse project 基本概念eclipse项目中存在：A项目模块 —依赖—&gt; B项目模块 —依赖—&gt; C项目模块 A与B，B与C关系为直接依赖，可点击pom.xml文件底部切换为Dependency窗口查看 A与C的关系为间接依赖，可点击pom.xml文件底部切换为Dependency Hierarchy窗口查看直接与间接依赖 依赖的传递效果 传递的条件：只有compile范围的依赖才能传递 当存在：A项目模块 —依赖—&gt; B项目模块 —依赖—&gt; C项目模块 若C项目再添加某一种依赖D后，A、B模块会自动添加依赖D 传递依赖的好处：可以传递的依赖不必在每个模块工程中都重复声明，在“最下面”的工程中依赖一次即可。 依赖的排除依赖的排除相当于依赖传递的反操作 依赖排除使用场景： 添加依赖排除标签：假定当前项目的依赖是由上层的直接依赖HelloFriend项目传递过来的，则排除指定依赖操作如下 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;HelloFriend&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;!-- 依赖排除标签 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 依赖的原则路径最短者优先原则 情景：若某个项目模块受到来自两个项目模块的同jar包不同版本依赖。因为某些特殊的原因，HelloFriend使用了非Hello传递下来的jar包版本，而使用了其他的一个版本。此时MakeFreidens则会同时接收啊斗HelloFriend与Hello传递下来的不同的两个版本 就近原则：maven对这种原则默认使用就近原则，因此MakeFriends最终受到传递的是 1.2.14版本 路径相同时先声明者优先 情景：路径相同时，如下 先声明者优先：先声明指的是dependency标签的声明顺序。即MakerFriends依赖HelloFriende与OurFriends的一个相对声明顺序 统一管理依赖版本 场景：这里对Spring各个jar包的依赖版本都是4.0.0如果需要统一升级为4.1.1，怎么办？手动逐一修改不可靠。 使用properties标签： 使用properties标签内使用自定义标签统一声明版本号 123456789&lt;properties&gt; &lt;!-- 通过自定义标签统一声明版本号 --&gt; &lt;test.spring.version&gt;4.1.1.RELEASE&lt;/test.spring.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt; ...&lt;/dependencies&gt; 在需要统一版本的位置，使用$&#123;自定义标签名&#125;引用声明的版本号 12345678910111213141516171819202122232425262728&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;!-- 统一引用 --&gt; &lt;version&gt;$&#123;test.spring.version&#125;&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;test.spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;test.spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;test.spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;test.spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; 这种自定义标签和标签内容引用的方式，并不只适用于此场景，这是xml的特性，任何地方都可以通过 &lt;自定义标签&gt;&lt;/自定义标签&gt; 、 ${自定义标签} 这种方式进行声明和引用 生命周期tips：了解即可 基本概念 生命周期：各个构建环节执行的顺序，必须按照既定的正确顺序来执行。 Maven的核心程序中定义了抽象的生命周期，生命周期中各个阶段的具体任务是由插件来完成的。 为更好的实现自动化构建，不论现在要执行生命周期中的哪一阶段，都是从某一个生命周期最初的位置开始执行 即不用担心打包之前要编译，要测试，直接执行打包命令，会重头完成这些必备功能 Maven有三套相互独立的生命周期，分别是： Clean Lifecycle：在进行真正的构建之前进行一些清理工作。 Default Lifecycle：构建的核心部分，编译、测试、打包、安装、部署等等。 Site Lifecycle：生成项目报告，站点，发布站点。 他们相互独立。也可以直接运行mvn clean install site 运行所有这三套生命周期。 每套生命周期都由一组阶段(Phase)组成，平时在命令行输入的命令总会对应于一个特定的阶段。 比如，运行 mvn clean，这个clean是 Clean 生命周期的一个阶段 Clean声明周期 pre-clean 执行一些需要在clean之前完成的工作 clean 移除所有上一次构建生成的文件 post-clean 执行一些需要在clean 之后立刻完成的工作 Default声明周期Default 生命周期是 Maven 生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段： validate generate-sources process-sources generate-resources process-resources 复制并处理资源文件，至目标目录，准备打包。 compile 编译项目的源代码。 process-classes generate-test-sources process-test-sources generate-test-resources process-test-resources 复制并处理资源文件，至目标测试目录。 test-compile 编译测试源代码。 process-test-classes test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。 prepare-package package 接受编译好的代码，打包成可发布的格式，如 JAR。 pre-integration-test integration-test post-integration-test verify install 将包安装至本地仓库，以让其它项目依赖。 deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享或部署到服务器上运行。 … Site生命周期 pre-site 执行一些需要在生成站点文档之前完成的工作 site 生成项目的站点文档 post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 site-deploy 将生成的站点文档部署到特定的服务器上 这里经常用到的是 site 阶段和 site-deploy 阶段，用以生成和发布 Maven 站点，这可是 Maven 相当强大的功能，Manager 比较喜欢，文档及统计数据自动生成，很好看。命令mvn site Eclipse中使用Maven基本设置 当今版本eclipse一般已内置Maven插件 Maven插件的设置： Window-&gt;Preferences-&gt;Maven installations : 指定Maven核心程序的位置。默认是插件自带的Maven程序，一般改为我们自己解压的那个。 user settings : 指定Maven核心程序中 conf/settings.xml 文件的位置，进而获取本地仓库的位 创建Maven版java工程 创建Maven版的Java工程 创建时勾选上 Create a simple project(skip archetype selection) ，然后点击 next 输入前三行基本信息后，点击finish 即可创建 创建的Maven工程格式如下， 编写的java源程序放在，名为src/main/java的目录下，即上图的第二行 创建的Maven工程默认使用的是JDK1.5，改变方法有两种 eclipse设置中修改 (推荐)打开Maven核心程序 settings.xml 文件，找到profiles标签，在该标签内加入如下配置，即可更改 注意，若想更高版本的JDK，除了修改如下配置文件版本号外，还需注意目前maven版本是否支持 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.7&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.7&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.7&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 执行Maven命令 选中Maven工程中的pom.xml文件，右键Run As，则有一系列命令列出，点击即可执行某种命令 若在Run As 中没有找到想要执行的命令如上图中没有编译命令，则点击 Run As 列表中含三个点的命令Maven build...直接在Goals：中输入命令执行即可 创建Maven版Web工程 New Maven project时，Packaging 选择 war 调整web目录结构，在项目上点右键 -&gt; properties-&gt;Project Facets -&gt; 把Dynamic Web Module 勾选去掉，并Apply -&gt; 将Dynamic Web Module 重新勾选 -&gt; 点击Further configuration available -&gt; 修改 Content directory为src/main/webapp -&gt; Apply 即在Maven工程上生成动态Web目录结构 新建jsp文件发现报错：The superclass “javax.servlet.http.HttpServlet” was not found on the Java Build Path“。因为缺少Tomcat 运行时环境，解决方法有两种 经典的通过eclipse设置加入ServletAPI依赖依赖 以Maven方式添加：在pom.xml文件中添加 123456&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; jsp写入EL表达式时发现报错：”javax.servlet.jsp cannot be resolved to a type”，将JSPAPI导入。在pom.xml文件中添加 123456&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.1.3-b06&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 注意：像这种在部署的时候运行时环境会提供的jar包，开发阶段使用scope一定要设置成provided，不然待部署时，maven会将设置为compile的jar包一同部署到容器中，则会发生冲突，运行时会报空指针异常。 导入Maven工程 方式1：传统的项目导入方式，前提是必须是在eclipse中创建的项目(普通项目或maven项目)，即必须包含eclipse认可为java项目的.settings、.classpath、.project等文件 方式2：通用的maven项目导入，只要maven项目含pom.xml文件即可 继承应用场景​ 解决无法进行依赖传递的jar包版本统一问题。例如score为test的junit。由于test范围的依赖不能传递，所以必然会分散在各个模块工程中，很容易造成版本不一致。 如下情况 123Hello依赖的Junit：4.0HelloFriend依赖的Junit：4.0MakeFriends依赖的Junit：4.9 解决方案：​ 将Junit依赖统一提取到“父”工程中，在子工程中声明Junit依赖是不指定版本，以父工程中统一设定的为准。同时也便于修改。 创建一个新的Maven工程作为父工程。注意：打包的方式pom 对应自动生成配置文件信息如下所示 1234&lt;groupId&gt;com.test.maven&lt;/groupId&gt;&lt;artifactId&gt;Parent&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt; 所有子工程中声明对父工程的引用：适用&lt;parent&gt;&lt;/parent&gt;标签 12345678910111213&lt;!-- 子工程中声明父工程 --&gt;&lt;!-- 1. 使用parent标签进行对父工程的引用 --&gt;&lt;parent&gt; &lt;!-- 2. 将父工程中的坐标信息复制过来 --&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;Parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 3. 设置以当前文件为基准的父工程pom.xml文件的相对路径 --&gt; &lt;relativePath&gt;../Parent/pom.xml&lt;/relativePath&gt;&lt;/parent&gt;&lt;!-- 同级--&gt;&lt;dependencies&gt;&lt;/dependencies&gt; 将子工程的坐标中与父工程坐标中重复的内容删除，报出以下错误信息的内容均删除即可 在父工程中添加统一的junit的依赖 在子工程中删除junit依赖的版本标签version tips：配置集成后，执行安装命令时要先安装父工程 聚合 功能：对一个工程中的多个功能项目进行一键安装 配置方式：在一个”总的聚合工程”中配置各个参与聚合的模块 1234567&lt;!-- 在作为总的聚合工程中配置聚合(不一定是父工程) --&gt;&lt;modules&gt; &lt;!-- 指定各个子工程的相对路径 --&gt; &lt;module&gt;../HelloFriend&lt;/module&gt; &lt;module&gt;../MakeFriends&lt;/module&gt; &lt;module&gt;../Hello&lt;/module&gt;&lt;/modules&gt; 使用方式：在聚合工程的pom.xml 上点右键 -&gt; run as -&gt; maven install Web工程的自动化部署 在pom.xml 中添加如下配置： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--配置当前工程构建过程中的特殊设置 --&gt;&lt;build&gt; &lt;finalName&gt;AtguiguWeb&lt;/finalName&gt; &lt;!-- 配置构建过程中需要使用的插件 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;!-- cargo是一家专门从事启动Servlet容器的组织 --&gt; &lt;groupId&gt;org.codehaus.cargo&lt;/groupId&gt; &lt;artifactId&gt;cargo-maven2-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;!-- 针对插件进行的配置 --&gt; &lt;configuration&gt; &lt;!-- 配置当前系统中容器的位置 --&gt; &lt;container&gt; &lt;containerId&gt;tomcat6x&lt;/containerId&gt; &lt;home&gt;D:\\DevInstall\\apache-tomcat-6.0.39&lt;/home&gt; &lt;/container&gt; &lt;configuration&gt; &lt;type&gt;existing&lt;/type&gt; &lt;home&gt;D:\\DevInstall\\apache-tomcat-6.0.39&lt;/home&gt; &lt;!-- 如果Tomcat端口为默认值8080则不必设置该属性 --&gt; &lt;properties&gt; &lt;cargo.servlet.port&gt;8989&lt;/cargo.servlet.port&gt; &lt;/properties&gt; &lt;/configuration&gt; &lt;/configuration&gt; &lt;!-- 配置插件在什么情况下执行 --&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;cargo-run&lt;/id&gt; &lt;!-- 以下总的意思是，当执行install声明周期时，执行插件run目标 --&gt; &lt;!-- 生命周期的阶段 --&gt; &lt;phase&gt;install&lt;/phase&gt; &lt;goals&gt; &lt;!-- 插件的目标 --&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 执行mvn deploy 命令 tips：一般这个命令不在eclipse中使用，因为eclipse中启动后无法停止(无法输入 ctrl + c取消)，一般在命令行中使用 查找依赖信息网站搜索需要的 jar 包的基本依赖信息：http://mvnrepository.com/","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"项目构建","slug":"项目构建","permalink":"http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"}]},{"title":"网络资源库","slug":"网络资源库","date":"2021-03-14T13:11:32.000Z","updated":"2021-04-15T04:07:45.232Z","comments":true,"path":"2021/03/14/网络资源库/","link":"","permalink":"http://yoursite.com/2021/03/14/%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E5%BA%93/","excerpt":"","text":"专属下载器：复制链接后在新标签页打开","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"个人文档","slug":"个人文档","permalink":"http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%96%87%E6%A1%A3/"}]},{"title":"JavaSE基础核心积累","slug":"JavaSE基础核心积累","date":"2021-03-04T03:40:32.000Z","updated":"2021-04-13T14:32:42.182Z","comments":true,"path":"2021/03/04/JavaSE基础核心积累/","link":"","permalink":"http://yoursite.com/2021/03/04/JavaSE%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E7%A7%AF%E7%B4%AF/","excerpt":"","text":"语言概述语言历史​ 创始人：java之父James Gosling SUN(Stanford University Network，斯坦福大学网络公司 )1995推出 1991年 Green项目，开发语言最初版本命名为Oak (橡树) … 2004年，发布里程碑式版本：JDK 1.5，为突出此版本的重要性，**更名为JDK 5.0** 2005年，改名J2SE -&gt; JavaSE(桌面级)**，J2EE -&gt; **JavaEE(企业WEB)**，J2ME -&gt; **JavaME 2009年，Oracle公司收购SUN，交易价格74亿美元 … 2014年，**发布JDK 8.0**，是继JDK 5.0以来变化最大的版本** … 2018年3月，发布JDK 10.0，版本号也称为18.3(改为时间命名)号称每月一更 2018年9月，发布JDK 11.0，版本号也称为18.9 语言特点 java是一种半编译半解释型语言 面向对象：类、对象、封装、继承、多态 健壮性：垃圾回收机制(GC机制)，但仍存在内存泄漏与溢出。c通过malloc与free手动管理) 跨平台性：java虚拟(JVM)，write once,run anywhere 一次编译，到处运行 开发环境基础概念 JDK ：Java开发工具包 (Java Development Kit), 用与开发及运行 JDK = JRE+开发工具集 Java开发工具：javac.exe (编译工具) ，jar.exe(打包工具)等 JRE：Java运行环境(Java Runtime Environment)，仅用于运行java项目 JRE = JVM+Java SE标准类库 JVM：Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等 环境搭建下载安装JDK官网，一键式傻瓜安装。可自定义安装路径，但注意安装软件的路径中不能包含中文、空格。(建议安装文件夹保留JDK版本号) 配置环境变量配置path环境变量： 进入系统变量设置：(win10)计算机，右键属性，高级系统变量，环境变量 把安装JDK的bin目录路径添加到环境变量path中(若不存在path则新建) 方式1：直接把JDK下的bin目录路径添加到path变量中即可 方式2(推荐)： 在系统变量中新建名为JAVA_HOME，值为JDK目录路径的环境变量 在path中通过引用的方式添加，即在path中添加 %JAVA_HOME%\\bin; (注意win10末尾无需分号) 新建JAVA_HOME变量如下图 在Path环境变量中引用JAVA_HOME在bin目录下配置如下图 Tips：推荐使用方式2，后续tomcat运行环境需识别JAVA_HOME 验证配置注意，要重新打开一个新的cmd窗口输入javac命令显示如下内容信息则安装成功，java -version只能检查是否安装了jdk，不能检查有关环境变量的配置。 常见问题 重写打开一个新的cmd窗口测试javac 尝试把java的环境变量的位置以至最前面(防止部分功能失效) win10环境下配置环境变量，无需添加末尾的分号’;’ JDK内容概要默认安装路径：C:\\Program Files\\Java\\jdk1.8.0_144 bin – 开发工具（常用，javac.c 编译，java.exe 解析运行，javadoc.exe，生成文档） db – java 实现的数据库 include – 含c语言编写的头文件 jre – java运行时环境 lib – 存放jar包 src.zip – 存放java开源代码，一些常用的类库(IDE中查看源码可引用它) JDK主要的包(packed)介绍 java.lang(language)：包含一些Java语言的核心类，如String、Math、Integer、 System和 Thread，提供常用功能 java.net：包含执行与网络相关的操作的类和接口 java.io：包含能提供多种输入/输出功能的类 java.util：包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数 java.text：包含了一些java格式化相关的类 java.sql：包含了java进行JDBC数据库编程的相关类/接口 java.awt：包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 B/S C/S 环境变量详解 path环境变量：windows系统在cmd内执行命令时要搜寻的路径。配置path环境变量可实现在任何目录下都可以执行配置在path内容里的程序的效果。 环境变量类型：用户变量针对当前用户有效。系统变量，针对所有用户有效 cmd命令的搜索逻辑：从当前目录—&gt;path路径(从前往后) 环境变量值格式：由绝对路径组成。多个值用分号“;” (win7)隔开或(win10) 通过” 新建”的方式直接添加。 %**JAVA_HOME%\\bin;中“%%”表示获取这个环境变量的值** 一台电脑允许同时安装多个版本JDK，实际使用哪个，却决与环境变量的指定 官方JDK安装过程会弹出两个安装框，一个是JDK安装，一个是独立的JRE安装，其实理论上安装JDK已经包含JRE，这个多出来的独立安装的JRE为了方便eclipse识别而安装，建议安装。 Java程序运行逻辑执行逻辑 编译及运行命令 编译.java文件：javac XXX.java (需含.java后缀) 同目录下会编译出.class字节码文件，该字节码文件名由代码中class类名决定的 运行.class文件：java .class文件名 (无需.class后缀) 演示 新建一个HelloWorld.java结尾的文件 12345class HelloChina&#123; public static void main(String []args)&#123; System.out.println(&quot;hello,world!&quot;); &#125;&#125; 编译及运行 补充说明 javac命令因在Windows平台下执行，因此不区分大小写 java命令是涉及java中的的执行，java是严格区分大小写的 任何书写语法都没错，但还是报出“错误：找不到或无法加载主类”，有可能电脑配置了classpath的环境变量，classpath的配置表示使所有**.class文件**的执行都往该路径去寻找，导致在classpath路径下找不到对于执行的.class文件，因此提示错误。只需要删除classpath环境变量即可 在一个java源文件中可以声明多个类，但只有一个类能声明public，而且声明public的类的类名必须与源文件文件名相同 存在多个class的源文件编译会生成对应的多个字节码文件，java.exe只需执行含main方法的类即可 基本语法注释​ java包含三种注释：单行注释、多行注释、文档注释(java特有) 文档注释：通过指定的注释格式，使注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。可以进入生成的文件夹，打开index.html即可。 注释格式：javadoc 工具默认只处理以 public 或 protected 修饰的内容 123456789101112/**@author 指定java程序的作者@version 指定源文件的版本文本内容，在类头部形成对class的文档注释*/public class XXX&#123; /** 在方法头部形成对方法的一个文档注释 */ method();&#125; javadoc命令使用：javadoc –d filename –author –version javaFile.java bug： 错误提示：javadoc 编码GBK的不可映射字符 原因：由于jdk是国际版的, 在编译时, 如果没有使用-encoding参数指定java源程序的编码格式, javac.exe则会获取操作系统默认的编码格式. 解决方案： 方案1：追加指定编码命令：javadoc -d filename -author -version -encoding utf-8 HelloWorld.java ​ 关键字、保留字、标识符 关键字：被Java语言赋予了特殊含义，用做专门用途的字符串。如**int、for、class…**（小写单词） 保留字：现Java版本尚未使用，但以后版本可能会作为关键字使用。如：goto 、const 标识符(Unicode编码)**：凡是自己可以起名字的地方都叫标识符 (为了提高阅读性，要尽量意义，“见名知意**”) 规则： 由26个英文字母大小写，0-9，**_或$**组成 数字不可以开头，不可以使用关键字和保留字，但能包含关键字和保留字 Java中严格区分大小写，长度无限制。 标识符不能包含空格。 规范： 包名：多单词组成，所有字母小写，xxxyyyzzz 类名、接口名：多单词组成时，所有单词的首字母大写，XxxYyyZzz(大驼峰) 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写，xxxYyyZzz(小驼峰) 常量名：所有字母都大写。多单词时每个单词用下划线连接，XXX_YYY_zzz 数据类型类型分类 数据类型 内存空间 默认值 表示范围 byte 1 byte (20) 0 -128 ~ 127 short /char 2 byte (21) 0 -215~215-1 / 无符号整型 int 4 byte (22) 0 -231~231-1(约21亿) long 8 byte (23) 0L 或 0l -263~263-1 float 4 byte 0.0F 或 0.0f double 8 byte 0.0 补充说明 Java的整型常量默认为 int 型，因此声明long型常量须后加 ‘l’或‘L’ Java 的浮点型常量默认为double型，因此声明float型常量，须后加‘f’或‘F’ 无论是赋值语句的数字还是字面常量的数字，只要是整型数字 java就认为是int，只要浮点数字就认为double 123456789101112//编译成功，但bigValue并非long型，而是int型long bigValue = 100;/*编译失败 ，系统不会把 9999999999999 当成long类型处理所以超出 int 的表数范围，从而引起错误*/ long bigValue1 = 9999999999999;//下面代码是正确的，在巨大的整数值后使用 L 后缀 ，强制使用long 类型long bigVa1ue2 = 9223372036854775807L;//编译失败，12.3默认是double型，大类型转小类型必须加强制转换符，或改为12.3ffloat f1 = 12.3; 整数型整数值的4种表示方式 1234567891011//定义两个 8 位的二进制整数// 注意，计算机底层都是以补码的方式存储数据的int binVal1 = 0b11010100; byte bnVal2= 0B01101001;//以 0 开头的整数值是八进制的整数int octa1Va1ue = 013 ; //0~9组成的十进制整数int decValue = 10;//以 0x 或0X 开头的整数值是十六进制的整数int hexVa1uel = 0x13 ; int hexVa1ue2 = 0XaF; 字符型 字符型的3种表示方式 123456//直接指定单个字符作为字符值char aChar = &#x27;a&#x27;; //使用转义字符来作为字符值char enterChar = &#x27;\\r&#x27;; //使用 Unicode 编码值来指定字符值char ch = &#x27;\\u9999&#x27;; 常用acsii编码字符 字符 ASCII码 a ~ z 97 ~ 122 A ~ Z 65 ~ 90 0 ~ 9 48 ~ 57 常见编码积累 Windows CMD 默认编码是：ANSI编码，即GBK编码 UTF-8 是 Unicode 编码的一种形式，是国际最通用的编码浮点型 浮点型的2种表示方式 十进制数形式：如5.12 、512.0 、.512 。浮点数必须包含一个小数点 科学计数法形式：例如 5.12e2 (即 5.12x102)，5.12E2 也是5.12x102 float：单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求 虽说float只占4个字节，但因为尾数表示方式，表示数值的范围比long还大 double：双精度，精度是float的两倍。通常采用此类型。 小结：整型通常使用int类型，浮点型通常使用double 类型间转换类型间运算及其转换(不含boolean) 自动类型转换 自动类型转换发生在不同数据类型之间进行运算时，结果自动提升为容量大的数据类型。 当byte、char、short三种类型之间任何两种，包括自身两种变量做运算时，结果都转换为int型 如：byte + byte = int….、byte + short = int 、char + byte = int 、char + short = int 示例代码 123456//相关练习与测试System.out.println(&quot;* *&quot;); //* *System.out.print1n(&#x27;*&#x27; + &#x27;\\t&#x27; + &#x27;*&#x27;); //93System.out.println(&#x27;*&#x27; + &quot;\\t&quot; + &#x27;*&#x27;); //* *System.out.printin(&#x27;*&#x27; + &#x27;\\t&#x27; + &quot;*&quot;); //51*System.out.println(&#x27;*&#x27; + (&#x27;\\t&#x27; + &quot;*&quot;)); //* * 强制类型转换 自动类型转换的逆运算，加强制转换符 ()，注意精度损失，或溢出 12double d = 100.0;int i = (int)d; String与其他类型的运算：String可以和8种基本数据类型变量做+运算，且运算只能是连接运算，运算的结果仍然是String类型 123int number = 100;String numberStr = &quot;学号&quot;;System.out.println(numberStr + number);//输出 &quot;学号100&quot; 无论是自动转换还是强制转换，只能适用数值间的转换，即强制类型转换符()也只适用数值的数据类型 运算符算术运算符 前至++与后至++ 前置++：++i，先自增，后使用 后置++：i++，先使用，后自增 ++与–的特点：不改变原数据类型的情况下进行++与–，效率高 无论前置还是后置++还是–，均改变变量，i++ == i = i +1 1234short s1 = 10;s1 = s1 + 1;//编译失败，int不能直接转换为shorts1 = (short)s1 + 1 //正确写法，效率低，截断方式s1++; //编译运行均通过，正确写法，效率高 /除运算： 无论在什么地方，两个int型相除，结果一定为整型 1double result = 12 / 5; // result = 2.0; %模运算/取余： 模运算 = 前除后，求余数 java规定，结果的符号与被模数(前面的数)的符号相同 模运算式 结果 0 % 1 0 0除以任何数=0，不会存在余数 1 % 0 error 0不能作除数，作分母，溢出 2 % 1 0 整除余0 7 % 5 2 够除 1余2 2 % 3 3 不够除：0余2 12 % -5 2 符号由被模数决定 -12 % -5 -2 同上 赋值运算符 复合/扩展运算符： 基本原理：num1 +=2; 等价 num1 = num1 + 2; 特点，同++一样，复合赋值运算符同样可以在不改变原数据类型情况下运算，更加高效 12short s1 = 1; s1 += 2;//编译运行均通过int i = 1; i *= 0.1; //编译运行均通过 输出0 综合练习 12int n = 10;n += (n++) + (++n); //n = n + (n++) + (++n); n = 10 + 10 + 12 逻辑运算符 布尔 数值(按位与) &amp; if( true &amp; num++ )，全部执行 二进制按位与 &amp;&amp; 短路与：if ( true &amp;&amp; num++ )，可得出结果就停止执行，即num++不执行 注意：**&amp;，|，^这三个运算符同为逻辑运算符与位运算符，具体表示哪种，取决于参与运算对象**是数值还是布尔值 位运算符位运算类型 位运算符 含义 &amp; 按位与 | 按位或 ^ 按位异或 ~ 按位取反 &lt;&lt;n 左移n位右补零 &gt;&gt;n 按位右移n位，补最高位(正数0，负数1) &gt;&gt;&gt; 无符号右移，空缺位均补零 tips：注意，真正对计算机数值数据移位也是移动该数值的补码，如 -5 &lt;&lt; 2结果如下 位运算技巧 示例代码 12345678910111213141516171819202122232425262728//1、你能否写出最高效的2 * 8的实现方式？ 2 &lt;&lt; 3 或 8 &lt;&lt; 1//2、交换两个数值变量的几种方式int num1 = 10;int num2 = 20;System.out.println(&quot;num1 = &quot; + num1 + &quot;,num2 = &quot; + num2);//方式一：定义临时变量的方式//推荐的方式//int temp = num1;//num1 = num2;//num2 = temp;//方式二：好处：不用定义临时变量 //弊端：① 相加操作可能超出存储范围 ② 有局限性：只能适用于数值类型//num1 = num1 + num2;//num2 = num1 - num2;//num1 = num1 - num2;/*方式三：使用位运算符 num1=(numl ^ num2)^num2; num2=(num2 ^ num1)^num1;*///有局限性：只能适用于数值类型num1 = num1 ^ num2;num2 = num1 ^ num2;num1 = num1 ^ num2;//此时num2 == num1System.out.println(&quot;num1 = &quot; + num1 + &quot;,num2 = &quot; + num2); 三元/目表达式 格式：表达式1 ? 表达式2 : 表达式3 ​ 含义：若表达式1为真，整个条件表达式返回表达式2的结果反之表达式3的结果 三元运算符可以嵌套使用 若程序使用三元运算符，又可以使用if-else结构，优先选择三元运算符。原因：简洁、执行效率高。 表达式1和表达式2不要求完全一致，但必须可兼容为其中一种类型 对于数值基本数据类型，使用三元运算符还会想使用比较运算符那样进行自动类型转换 1System.out.println(true ? 3 : 4.0);//输出3.0，自动转换为double型 比较运算符 ‘==，&gt;，&lt;，&gt;=，&lt;= ‘：粗略来说，比较运算符只能用于数值类型(类型不一定完全相同，底层是数值即可) 特别说明，’==’ 也可以在引用类型中使用，但也聚焦在数值上(地址值) 流程控制顺序结构分支结构if-else结构 if：符合则执行 if - else：2选1 if - else if - else ：n选1 若if-else结构中只有一条执行语句，则可以省略{} 同时，省略{}的if语句的else总是与最近的未匹配的if匹配 switch结构 执行逻辑：根据switch表达式的值，依次匹配各个case中的常量。一旦匹配成功，则执行case结构中语句。若此时没有遇到break语句，则不判断地直接继续向下执行其他case结构中的执行语句，直到遇到break关键字或末尾结束为止。(为更好理解，表达式与case 后语句划上等号进行的判断) 表达式支持6种数据类型：byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增) 把default语句理解成为一个无条件case语句则一切明了。 1234567891011121314151617181920212223242526//例1：常见方式switch(表达式)&#123; case 常量表达式1 : 语句1;//break; … case 常量表达式n : 语句n;//break; default : 语句n+1;&#125;//输出1，2，3，4int i =1;switch(i)&#123; case 1:System.out.println(&quot;1&quot;); case 2:System.out.println(&quot;2&quot;); case 3:System.out.println(&quot;3&quot;); case 4:System.out.println(&quot;4&quot;);&#125;//例2：多个case共用一条语句//应理解为，每个case的执行语句都为空，且没有break，因此连续执行//不应该理解为内嵌case语句//值为‘A\\B\\C’都执行语句1switch(表达式)&#123; case ‘A’ : case ‘B’ : case ‘C’ : 语句1;break; …&#125; 编写经验 若多个条件表达式之间是 “互斥“关系(或没有交集的关系),哪个判断和执行语句声明在上面还是下面，无所谓 交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面 有包含的关系，通常情况下，需要将范围小的声明在范围大的上面。否则，范围小的就没机会执行了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//例1：class Person &#123;&#125;class Student extends Person &#123;&#125;class Graduate extends Student &#123;&#125;public class InstanceTest &#123; public static void main(String[] args) &#123; InstanceTest test = new InstanceTest(); test.method(new Student()); &#125; public void method(Person e)&#123; //错误写法,每次执行第一个if //if(e instanceof Person)&#123;// System.out.println(&quot;a graduated student&quot;);// System.out.println(&quot;a student&quot;);// System.out.println(&quot;a person&quot;);// &#125;else if(e instanceof Student)&#123;// System.out.println(&quot;a student&quot;);// System.out.println(&quot;a person&quot;);// &#125;else if(e instanceof Graduate)&#123;// System.out.println(&quot;a person&quot;);// &#125; //方式一，包含关系应将范围小的在范围大前判断 if(e instanceof Graduate)&#123; System.out.println(&quot;a graduated student&quot;); System.out.println(&quot;a student&quot;); System.out.println(&quot;a person&quot;); &#125;else if(e instanceof Student)&#123; System.out.println(&quot;a student&quot;); System.out.println(&quot;a person&quot;); &#125;else&#123; System.out.println(&quot;a person&quot;); &#125; //方式二 if(e instanceof Graduate)&#123; System.out.println(&quot;a graduated student&quot;); &#125; if(e instanceof Student)&#123; System.out.println(&quot;a student&quot;); &#125; if(e instanceof Person)&#123; System.out.println(&quot;a person&quot;); &#125; &#125;&#125; 循环结构相关关键字 break：结束当前循环体的循环 continue：结束当次循环体当的循环 break与continue语句后均不能声明执行语句 break与continue只作用在离关键字最近的循环体 带标签break与continue语句使用：可指定作用在哪一层循环结构 在拟作用循环体前声明标签：label : for() 在break或continue语句后追加标签民：break label; 12345678910label:for(int i=1;i&lt;=4;i++)&#123; for(int j = 1;j &lt;= 10;j++)&#123; if(j % 4 == 0)&#123; //break;//默认跳出包裹此关键字最近的一层循环。 //continue; break label;//结束指定标识的一层循环结构 //continue labe1；//结束指定标识的一层循环结构当次循环 &#125; System.out.print(j); &#125; for循环for内的变量只在for中有效 123456//首次执行：1-&gt;2-&gt;3-&gt;4//循环执行：2-&gt;3-&gt;4，2-&gt;3-&gt;4...//可输入多个语句用逗号“，”for( 1,?,? ; 2 ; 4)&#123; 3&#125; while循环123456//首次执行：1-&gt;2-&gt;3//循环执行：2-&gt;3,2-&gt;3...1while(2)&#123; 3;&#125; do-while循环do-while循环至少会执行一次循环体！ 1234567//首次执行：1 - 3 - 4 //循环执行：2 - 3 - 4 1do&#123; 3; 4;&#125;while(2); 数组一维数组基本概念 数组的类型可以是基本数据类型，也可引用数据类型 数组是引用数据类型，必须含new，含方法，含属性(常用length) 数组长度一旦确定，就不可修改 声明与初始化含静态初始化，动态初始化 静态初始化：指定数组元素的初始值，由系统决定数组长度 动态初始化：指定数组长度(可以是变量)，由系统为数组元素分配初始值 数组初始化默认值 整型：0 浮点型：0.0 char型：0或’\\u0000’，而非’0’ boolean型：false 用数据类型：null 12345int [] ids;//声明ids = new ids[]&#123;1001,1002,1003&#125;;//初始化int[] a = &#123;5,6,7,8&#125;//简化语法格式String[] names = new String[4];//动态初始化，数组长度可以是变量 数组的内存解析待补充，暂时不需要 多维数组基础概念 从数组底层的运行机制上来看(线性内存，多维映射)，没有多维数组 把多维数组看成多个一维数组的内嵌，如二维数组是一个一维数组，每个数组元素也是一个数组 二维数组使用 初始化 123456int[][] arr1 = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;//静态初始化String[][] arr2 = new String[2][3];//动态初始化String[][] arr3 = new String[3][];//动态初始化，但不能直接使用，还需指定列//指定列后才可以使用，否则报空指针异常。注意，指定哪个(实例化哪个)用哪个可用arr3[0] = new String[4]; 长度 1234int[][] arr1 = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;arr1.length;//3arr1[0].length;//3arr1[1].length;//2 内存解析12345678910111213//规定：二维数组分为外层数组的元素，内层数组的元素int[][] arr = new int[4][3];//外层元素：arr[0],arr[1]等//内层元素：arr[0][0],arr[1][2]等//数组元素的默认初始化值 int[][] arr = new int[4][3];//外层元素的初始化值为：地址值//内层元素的初始化值为：与一维数组初始化情况相同 int[][] arr = new int[4][];//外层元素的初始化值为：null//内层元素的初始化值为：不能调用，否则报错。 常见异常 ArrayIndexOutOfBoundsException：角标越界异常 NullPointerException：空指针异常 内存结构与变量JVM基本结构 虚拟机堆(heap)：存放数组、对象实例(含非static属性) 虚拟机栈(stack)：存放局部变量、对象引用 方法区(method area)：存储虚拟机已加载的、类信息、常量、静态变量、编译后的代码 本地方法栈(native method stack)： 程序计数器(PC)： 加载流程：编译 —&gt; 一个或多个字节码文件(class) —&gt; JVM类加载器和解析器进行解析运行 变量的类型变量的初始化及默认值不同变量的内存结构java中，所有局部变量，在未初始化的情况下使用均会发生编译型错误 局部变量非在所在范围内(方法)被调用时才创建，而是直到给局部变量赋值后才会创建 Java变量的类型**：局部变量，成员变量 局部变量：形参、方法内变量、代码块内变量 成员变量：类中方法外的变量 实例变量(非static修饰) 类变量(static修饰) 不同变量的内存结构 变量的默认值 声明一个变量后，必须用赋值语句对变量进行显式初始化(赋值)才能使用，使用未初始化的变量，出现编译错误 注意：对于引用数据类型，有别于基本数据类型。如初始化的数组元素，类中属性等，系统会默认给予初始值。 整型（byte、short、int、long：0） 浮点型（float、double：0.0） 字符型（char：0 （或’\\u0000’）） 布尔型（boolean：false） 引用数据类型（类、数组、接口：null） 1 变量的作用域：其定义所在的一对{ }内 ，变量只有在其作用域内才有效 ，同一个作用域内，不能定义重名的变量 掌握局部变量和全局变量： 局部变量： 定义：在函数内定义的变量，包括形式变量，程序块，都属于局部变量。只在函数内有效 存储特性：仅在需要时才开辟内存单元，使用完毕后释放。 注意：程序块是由{}构成的，它的作用范围更加小，程序块里定义的变量只在程序块{}内有效13 全局变量： 定义：函数外定义的变量属于外部变量/全局变量。有效范围从定义位置到当前源文件(.c)结束。 存储特性：在程序的全部执行过程中始终占用存储单元 注意：变量名习惯第首字母用大写 2、理解数据的存储类别含义：指数据在内存中的存储方式 1、变量存储类别的两种方式：静态存储方式和动态存储方式 (都是在内存中开辟空间) 静态存储区：在程序开始执行时就开始分配存储单元，程序执行完才释放。在程序执行过程 中始终占据固定的存储单元，而不是动态地进行分配和释放。如全局变量 动态存储区：仅在使用(函数调用，实参传入等)的时分配空间。代码功能执行完后就释放。 如：形参，自动变量(未加 static 声明的局部变量)，函数调用现场保护和返回地址 面向对象基础概念 类：对一类事物的描述，是抽象的，概念上的定义 对象：某个类的具体实体，也成为实例(instance)，创建一个对象 == 实例化 属性：类中的成员的变量(field)，调用 对象.属性; 行为：类的成员的方法(method)，调用 对象.方法() 类成员：属性、方法、构造器、代码块、内部类 类成员属性 属性与局部变量异同点 属性： 直接定义在类的一对{}内 声明属性可指明其权限：private、public、缺省(默认不写权限)、protected 局部变量： 声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量 不可使用权限修饰符 12method(&quot;Tom&quot;);//传入的为实参public void method(String name)&#123;&#125;//方法参数。形式参数 方法方法的创建 创建：public static void method(String name)&#123;&#125; 重载“两同一不同”。与权限修饰符、返回值类型、形参变量名、方法体均无关(按可区分调用角度理解即可) 同一个类、相同方法名 参数列表不同：参数个数不同，参数类型不同 可变个数形参 可变个数形参(jdk 5.0)格式：数据类型 ... 变量名,如 String...strs tips：当方法不止一个形参且含可变形参时，可变形参只能置于末尾，否则编译不通过(不可区分变量类型) 12//public void show(String...strs,int i); //错误情况，public void show(int i,String...strs);// 正确情况 内在逻辑：除与数组作为新参的实参传入格式不一样外(可变形参用逗号)，可变个数形参等价于数组 因此可与数组类型构成重写 12345678show(&quot;Tom&quot;,&quot;Wang&quot;,&quot;Deng&quot;)//可连续传入多个数据，用逗号隔开。show(new String[]&#123;&quot;Tom&quot;,&quot;Wang&quot;,&quot;Deng&quot;&#125;);//同样可以通过数组的方式传入实参public void show(String...strs)&#123; for(int i = 1;i &lt; stes.length;i++)&#123;//等价与数组 System.out.println(strs[i]); &#125; &#125;public void show(String name)&#123;&#125;//可以构成重载 return关键字 无返回值：结束当前方法 有返回值：结束当前方法且返回指定变量 匿名对象 匿名对象：new Person().run(); 匿名对象只能调用一次 方法传递机制Java方法参数传递方式只有一种，值传递！ 基本数据类型：变量值 引用数据类型：地址值 String与值传递机制 字符串是存储在字符串常量池，是不可变(特性)的字符序列 当字符串常量池中已经有相同的字符串，则直接复用执行该字符串的地址 12345String s1 = &quot;hello&quot;;System.out.println(s1);//仍输出hello public void method(String str)&#123; str = &quot;hi~&quot;;&#125; String确实是引用数据类型，值传递也确实在传递s1的地址值，但由于字符串常量池的特性(不可变序列)导致没有改变 由于字符串在java中大量使用，因此JVM特意开辟一个空间专门用于存储字符串，若同时又两个相同的字符串，常量池只记录一个 在字符串常量池创建字符串”hello”，因为字符串底层是通过char[]存储的，确定后是不可变的字符序列 把“hello”字符串与s1关联起来 调用方法时，实参传入s1的地址值，并赋值给str 由于字符串常量池不可变的特性，拟赋值的“hi~~”字符串只能新建一份 并将“hi~~”字符串与赋值语句中的str关联 值传递机制例题分析 12345678910public class Test&#123; public static void main(String[] args)&#123; int a = 10; int b = 10; //需实现调用method方法后，打印除a=100,b=200,请写出method方法代码 method(a,b); System.out.println(&quot;a=&quot; + a); System.out.println(&quot;b=&quot; + b); &#125;&#125; 由于Java基本数据类型无指针操作，若想通过方法调用实现交换两个基本数据类型的值。严格来说是不行的 1234567891011121314151617181920212223//实现方式1：方法内打印，立即终止程序public static void method(int a,int b)&#123; a = a*10; b = b*10; System.out.println(&quot;a=&quot; + a); System.out.println(&quot;b=&quot; + b); System.exit(0);//终止程序&#125;//实现方式2：方法重写/覆盖 public static void method(int a,int b)&#123; PrintStream ps = new PrintStream(System.out)&#123; @Override public void println(String x)&#123; if(&quot;a=10&quot;.equals(x))&#123; x = &quot;a=100&quot;; &#125;else if(&quot;b=10&quot;.equals(x))&#123; x = &quot;b=200&quot;; &#125; super.println(x); &#125; &#125;; System.setOut(ps); &#125; 若想通过调用一个方法实现数组两个元素值交换，则必须通过引用类型作为引导媒介进行交换 123456//例：若想通过调用一个方法的形式交换数组中某两个值，只能如下写法public void swap(int[] arr,int i,int j)&#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125; 封装 基本概念 高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉； 低耦合 ：仅对外暴露少量的方法用于使用 封装性的一些体现：具体体现在面向对象程序设计上 属性私有化(private)、公共(public)方法来调用 不对外暴露的私有方法 单例模式… 权限修饰符：private、缺省(默认不写权限)、protected、public(从小到大)，可添加到类的成员与类(class)前 类的成员(全支持)：属性、方法、构造器、内部类、代码块 注意：以下权限范围的调用对象是类的成员可以不可被调用，不是类可不可以创建 常用private与public，需注意是(缺省)与protected的对比 修饰符 类内部 同一个包 不同包的子类 同一工程 private Yes (缺省) Yes Yes(需注意) protected Yes Yes Yes(需注意) public Yes Yes Yes Yes df 类(仅public与缺省可用)：缺省情况下可通过import在不同包中调用类 构造器 12//创建类的对象：new + 构造器Person p = new Person(); //new Person()就是调用构造器 如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器 构造器不可定义返回值，其实构造器的作用就是返回引用的地址值，因此不能自定义 定义构造器的格式：权限修饰符 类名(形参列表)&#123;&#125; 一个类中定义的多个构造器，彼此构成重载 一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器 一个类中，至少会有一个构造器 属性赋值的先后顺序：默认初始化 —&gt; 显示初始化 —&gt; 构造器初始化 —&gt; 属性或方法调用赋值 1234567891011Person p = new Person(&quot;Tom&quot;);//name：null - &gt; &quot;Tom&quot;p.setName(&quot;Deng&quot;);//name: &quot;Deng&quot;class Person&#123; String name; public Person(String str)&#123; name = str; &#125; public void setName(String str)&#123; name = str; &#125;&#125; JavaBean：由java语言编写的可重用组件 类是公共的 有一个公共的无参构造器 有属性，且含属性对应的get和set方法 this关键字：this理解为“当前创建的对象”，谁掉它，谁就是this 调用的结构：适用于，属性、方法；构造器 属性、方法：解决形参与属性同名时，通过this特指类成员的属性/方法 格式：this.field; 或 this.method(); 123456class Person&#123; String name; public Person(String name)&#123; this.name = name;//同名解决 &#125;&#125; * **构造器**：用于**构造器中调用其他重载构造器**，常用于解决重载构造器代码冗余问题 * 格式：`this(); //调用空参构造器` * 构造器中**不能**通过this调用构造器产生**死循环回调** 1. 构造器中不能通过调用自己 1. 同理如类中有n个构造器，则最多有 n - 1构造器中使用了&quot;this(形参列表)&quot; * 构造器中&quot;this(形参列表)&quot;必须声明在当前**构造器的首行** * 构造器内部，**只能使用一次**this调用其他构造器 123456789101112131415161718192021222324252627//需求：&quot;Person初始化时，需要考虑如下的1,2,3,4...(共40行代码)&quot;;class Person&#123; private String name; private int age; public Person()&#123; //通过在空参构造器中书写“1,2,3,4...(共40行代码)” System.out.println(info); &#125; public Person(String name)&#123; this();//其他构造器调用空参构造器逻辑即可 this.name = name; &#125; public Person(int age)&#123; this();//其他构造器调用空参构造器逻辑即可 this.age = age; &#125; public Person(String name,int age)&#123; this(age);//还可以通过形参指定构造器调用 this.name = name; &#125;&#125; UML简述 package关键字 为了方便管理项目中的类，提供包的概念，一个包含多个类 使用package声明类或接口所属的包时，应声明在头部 MVC设计常用包定义 Model 模型层：处理数据 数据对象封装：model.bean/domain 数据库操作类：model.dao 数据库：model.db Controller 控制层：处理业务逻辑 应用界面相关：controller.activity 存放fragment：controller.fragment 显示列表的适配器：controller.adapter 服务相关的：controller.service 抽取的基类：controller.base View 视图层： 显示数据 相关工具类：view.utils 自定义view：view.ui import关键字 在源文件中显式的使用import结构导入指定包下的类、接口 声明在包的声明和类的声明之间 可以使用”xxx.*”的(通配符)方式，表示可以导入xxx包下的**所有结构 **import java.util.*; 如果使用的类或接口是java.lang包下定义的，则可以省略import结构 如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示 1234567891011//若存在com.test.java1.Account与com.test.java2.Account//想同时使用不同包下的Account类则至少一个使用全类名的方式使用import com.test.java1; class Test&#123; public static void main(String[] args)&#123; Account acct = new Account();//使用了com.test.java1 //通过全类名的方式指定使用 com.test.java2.Account acct2 = new com.test.java2.Account(); &#125;&#125; 使用”xxx.*”方式表明可以调用xxx包下的所结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入 子包：如存在存在 com.test.java1与com.test.java1.son，则son属于com.test.java1的子包 即就算import com.test.java1;若使用com.test.java1.son仍需显式导入 import static:导入指定类或接口中的静态结构(非类结构)，而是静态的属性和方法 12345//如JDK中System类import static java.lang.System.*;//此时所有System静态的书写和方法都被导入...//此时使用打印语句可以省略Systemout.println(&quot;Hello&quot;); 继承 继承的效果(extends：延展、扩展)： 若子类继承父类后，子类A中就获取了父类B中声明的所有的属性和方法(包括间接父类)。包括private私有属性和方法。 注意，子类获取父类属性和方法肯定是全部获取到了，但子类调用父类的属性和方法时受父类的权限修饰符影响。不能直接调用private修是的类成员。因此，继承应理解为子类对父类在调用角度上的扩展，而非代码的直接import，或copy。 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性和方法 继承的作用 减少了代码的冗余，提高了代码的复用性 便于功能的扩展 为之后多态性的使用，提供了前提 继承的使用 继承的格式：class A extends B&#123;&#125;，若B is A == true ，在逻辑上符合继承 A：子类、派生类、subclass B：父类、超类、基类、superclass Java的单继承性：一个类只能有一个父类，但可多层单继承。 子类直接继承的父类称为，直接父类 子类间接继承的父类称为，间接父类 Object类 若没显式的声明一个类的父类的话，则此类继承于java.lang.Object类 因此除java.lang.Object类，所有java类都直接或间接的继承于java.lang.Object类 意味着，所有java类具有java.lang.Object类声明的功能。 重写(override/overwrite)：子类继承父类以后，可以对父类中同名同参的方法，进行覆盖操作 只能重写方法，属性无重写之说 若子类与父类声明同名属性，则子类非多态实例化时，按就近原则调用自己(子类)定义的同名属性 子类重写的方法的权限修饰符 ≥ 父类被重写方法的权限修饰符 子类不能重写，父类中声明为private权限的方法 返回值类型 父类被重写的返回值类型是void，则子类重写的方法的返回值类型只能是void 父类被重写的返回值类型是A类型(引用数据类型)，则子类重写的返回值类型可以是A类或A类的子类 父类被重写的返回值类型是基本数据类型(如double)，则子类重写的返回值类型必须是相同(必需是double) 子类重写的方法抛出的异常类型 ≤ 父类被重写的方法抛出的异常类型 父类被static修饰的属性和方法不能被重写。但可以在子类中声明同名同参的static属性和方法(但此时不是重写) super关键字：指调用父类的结构 调用的结构：类this关键字，同样适用于，属性、方法；构造器 super关键字定位父类结构，默认先按直接父类到间接父类一层层往上找，一旦匹配则结束 属性，方法相关： 常用于在子类中调用父类同名的属性(属性无重写之说) 常用在子类中调用父类被重写的方法 构造器相关： 可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器 super(形参列表)”的使用，必须声明在子类构造器的首行 this与super调用构造器只能二选一，不能同时出现 在子类构造器的首行，没显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器 在类的多个构造器中，至少一个构造器中使用了”super(形参列表)”，调用父类中的构造器 子类对象实例化过程 子类对象创建时，系统一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，…直到调用了java.lang.Object类中空参的构造器为止。同时，正因为加载过所有直接或间接父类的结构，所以才可以看到内存中这些父类中的结构，子类对象也才可以调用所有父类的属性和方法 虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。 多态 何为多态：多态是一个行为具有多个不同表现形式或形态的能力 代码语法层面看，多态指，父类的引用指向子类的对象，同时对父类进行虚拟方法调用 菜鸟教程：多态就是同一个接口，使用不同的实例而执行不同操作 多态性的使用： 多态使用书写：父类的引用指向子类的对象，Person p = new Man(); 编译期，只能调用父类中声明属性和方法 运行期： 属性：父类的属性(属性无重写即无多态 ; 可通过向下转型调用子类的内容) 方法：父类声明的方法，若方法被子类重写则调用子类重写的方法(虚拟方法调用) 一般多态的使用，主要集中在虚拟方法的调用，因为一般子类继承父类都常重写父类的特定方法。因此粗略归纳多态的使用条件可以有两点 类的继承关系 方法的重写 注意，内存实际上加载了子类特有的属性和方法，但是由于变量声明为父类类型，导致编译时只能调用父类声明的属性和方法 多态的作用 消除类型之间的耦合关系 可替换性 可扩充性，(自带，归类分配控制器，减少编写重载方法) 接口性 灵活性 简化性 多态的作用与优点不仅几段文字描述，需从面向对象程序设计思想中学习多态的作用 1234567891011121314151617181920212223242526public class Animal &#123; public void eat()&#123; System.out.println(&quot;动物，在进食&quot;); &#125; public void run()&#123; System.out.println(&quot;动物，在跑&quot;); &#125;&#125;class Dog extends Animal&#123; public void eat()&#123; System.out.println(&quot;Dog，在进食&quot;); &#125; public void run()&#123; System.out.println(&quot;Dog，在跑&quot;); &#125;&#125;class Cat extends Animal&#123; public void eat()&#123; System.out.println(&quot;Cat，在进食&quot;); &#125; public void run()&#123; System.out.println(&quot;Cat，在跑&quot;); &#125;&#125; 测试类调用 123456789101112131415161718192021public class Test &#123; public static void main(String[] args) &#123; Animal a = new Dog(); active(a);//输出：Dog，在进食，Dog，在跑 &#125; //多态的使用，只需编写一个方法，减少重载方法的编写 public static void active(Animal animal)&#123; animal.eat(); animal.run(); &#125; //若不使用多态// public static void active(Dog dog)&#123;// dog.eat();// dog.run();// &#125;// // public static void active(Cat cat)&#123;// cat.eat();// cat.run();// &#125;&#125; 重载与重写的区别 重载：不表现为多态性 ​ 对于编译器而言，这些同名方法就成了不同的方法。在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；属于一个编译型行为。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。 重写：表现为多态性 ​ 对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这样的方法调用在编译时其无法确定，称为“晚绑定”或“动态绑定”。属于一个运行时行为 引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态！” 多态的向下转型 多态的Java类可通过 ()进行强制向下转型，通常情况，强转之前先用instanceof 关键字判别一下再转，否则不兼容类型强转会报出 ClassCastException 异常 向下转型后的对象是子类对象的引用与实例，此时则可调用子类特用的属性和方法 instancof关键字： a instanceof A：判断对象a是否是类A的实例。如果是，返回true；否则返回false。 若a instanceof A == true，则A类及其A类所有直接间接父类(顶级父类Object)都返回true，多态实例也是实例 12345678910111213//使用上述例子的Animal、Dog、Cat类public class Test &#123; public static void main(String[] args) &#123; Animal a = new Dog(); //强制向下转型 Dog dog = (Dog)a;//通过 Cat cat = (Cat)a;//报错 if(a instanceof Dog)&#123; System.out.println(&quot;向下转型成功，此对象为Dog&quot;);//正常输出 &#125; &#125;&#125; 练习 123456789101112131415161718192021222324252627282930313233343536373839404142434445//问题一：编译时通过，运行时不通过 //举例一：// Person p3 = new Woman();// Man m3 = (Man)p3; //举例二：// Person p4 = new Person();// Man m4 = (Man)p4; //问题二：编译通过，运行时也通过// Object obj = new Woman();// Person p = (Person)obj; //问题三：编译不通过// Man m5 = new Woman();// String str = new Date();class Base &#123; int count = 10; public void display() &#123; System.out.println(this.count); &#125;&#125;class Sub extends Base &#123; int count = 20; public void display() &#123; System.out.println(this.count); &#125;&#125;public class FieldMethodTest &#123; public static void main(String[] args) &#123; Sub s = new Sub(); System.out.println(s.count);//20 s.display();//20 Base b = s;//多态性 //==：对于引用数据类型来讲，比较的是两个引用数据类型变量的地址值是否相同 System.out.println(b == s);//true System.out.println(b.count);//10 b.display();//20 &#125;&#125; Object 基础说明 java.lang.Object类是所Java类的根父类，所有类的直接或间接地继承它 因此Object类中的功能(属性、方法)就具通用性 Object部分功能：无属性，方法 + 构造器 Object类只声明了一个空参的构造器(所有对象实例化都调用) clone()：对象克隆 finalize()：对象垃圾回收之前被系统自动调用，一般不主动调用 getClass()：获取对象的类，反射相关 hashCode()：集合相关 wait、notify、notifyAll：线程相关 … 当前重点的Object功能：equals(Object)、toString() 两者重写都可以通过eclipse快速生成 equals 与 == 的使用 Object类equals功能：与 == 的作用是相同的，比较两个对象的地址值是否相同 常重写equals后功能：比较两个引用类型实体内容是否相等 == ： 是个运算符、可以使用在基本数据类型和引用数据类型 基本数据类型：数值上的相等(类型不一定一样，底层是数值即可、因为会自动类型转换) 引用数据类型：引用的地址值是否相等，前提是比较双方类型可兼容，否则会出现编译型错误 123456789//1、基本数据类型：数值int i = 10;double d = 10.0;System.out.println(i == d);//输出true//2、引用数据类型：地址值(数值)Person p1 = new Person(&quot;小明&quot;,21);Person p2 = new Person(&quot;小明&quot;,21);System.out.println(p1 == p2);//输出false boolean equals(Object)：是个方法，只能使用在引用数据类型中，只要用于(自定义)对比引用数据类型中内容是否相等。常提供子类对equals方法进行重写来实现自定义实体内容相等判别效果 Object类中的equals()源码定义：Object原生功能与 == 的作用是相同的，比较两个对象的地址值是否相同 123public boolean equals(Object obj) &#123; return (this == obj);&#125; String、Date、File、包装类等都重写了Object类中的equals()方法：被重写成实体内容是否相等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 //1、未重写Object equals()方法：等同==，比较两个引用地址值 Person p1 = new Person(&quot;小明&quot;,21); Person p2 = new Person(&quot;小明&quot;,21); System.out.println(p1.equals(p2));//输出false //2、某java提供类重写了equals()实现了比较实体内容是否相等的功能 String s1 = new String(&quot;ABC&quot;); String s2 = new String(&quot;ABC&quot;); System.out.println(s1.equals(s2));//输出true //这里主要通过String new的方式说明源码重写了String的equals方法 //但通过 == 的方式直接创建字符串会因字符串常量池原理而出现== 为true情况 //String s3 = &quot;ABC&quot;; //String s4 = &quot;ABC&quot;; //System.out.println(s3 == s4);//输出true //3、自定义重写equals方法实现自定义类实体内容上的比较 //简陋版 @Override public boolean equals(Object obj) &#123; if(this == obj) return true; if(obj instanceof Person)&#123; Person anObj = (Person)obj; return this.name.equals(anObj.name) &amp;&amp; this.age == anObj.age; &#125;else&#123; return false; &#125; &#125; System.out.println(p1.equals(p2));//输出true //eclipse自动生成equals方法(标准高效参考)@Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Person other = (Person) obj; if (age != other.age) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true; &#125; String，equals方法重写源代码分析 12345678910111213141516171819202122232425public boolean equals(Object anObject) &#123; //1、若引用地址都一样，则内容肯定一样(重写equals通用代码) if (this == anObject) &#123; return true; &#125; //2、若与String比较的传入类型不是String，则不允许，返回false if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length;//String底层通过char [] value;数组存储 //3、若字符序列的长度都不一样，则内容肯定不一样 if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; //4、挨个字符比较 while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 1 eclipse自动生成equals重写源码分析： SSS 重写equals()方法原则 Null-false：任何情况下，x.equals(null)，永远返回是“false” 类型一致：x.equals(和x不同类型的对象)永远返回是“false” 对称性：如果x.equals(y)返回是“true” ，那么y.equals(x)也应该返回是 “true” 自反性：x.equals(x)必须返回是“true” 传递性：如果x.equals(y)返回是“true” ，而且y.equals(z)返回是“true” ， 那么z.equals(x)也应该返回是“true” 一致性：如果x.equals(y)返回是“true” ，只要x和y内容一直不变，不管你 重复x.equals(y)多少次，返回都是“true” toString： Object类toString功能：输出类名及其堆空间存储地址(虚拟地址) System.out.println(引用数据类型)输出语句，底层也是调用toString 常重写toString后功能：打印引用类型实体的内容 当输出一个对象的引用时，实际上就是调用当前对象的toString()方法 123Person p1 = new Person(&quot;ABV&quot;, 10);System.out.println(p1); //输出：com.yhd.test.Person@15db9742System.out.println(p1.toString()); //输出：com.yhd.test.Person@15db9742 源码分析 12345678910111213//PrintStream.classpublic void println(Object x) &#123; String s = String.valueOf(x); //主要通过调用了String.valueOf(); synchronized (this) &#123; print(s); newLine(); &#125;&#125;//String.classpublic static String valueOf(Object obj) &#123; return (obj == null) ? &quot;null&quot; : obj.toString();&#125; Object类中toString()的源码定义：输出类名及其堆空间存储地址(虚拟地址) 12345public String toString() &#123; //类名 + 堆空间存储地址(通过hashCode计算出来数值并转换为十六进制的) return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125;//注意：Java中的地址都是虚拟地址，操作系统之上的JVM，非真实的物理地址 String、Date、File、包装类等都重写了Object类中的toString()方法 包装类 基本含义：为了使基本数据类型的变量具有类的特征。java提供8种基本数据类型的包装类，这些包装类可以完成对应基本数据类型的所有功能操作(都含对应基本数据类型的value属性)。同时，因为封装成类，还可提供各种丰富的方法调用。 自动装箱与拆箱(JDK5.0)： 小结： 基本数据类型 &lt;—&gt; 包装类：自动/手动(构造器)装拆箱 数值(基本数据+包装) &lt;—&gt; String：调类(包装类/String类)的重载方法， ​ 1234567891011121314151617181920212223242526272829303132333435363738394041//1、基本数据类型 ——&gt; 包装类 //1、手动装箱：构造器封装/创建 int i = 1; Integer itg1 = new Integer(i); Integer itg2 = new Integer(&quot;2&quot;); //Integer itg3 = new Integer(&quot;2B&quot;);//异常：数字格式/匹配异常 System.out.println(&quot;itg1: &quot; + itg1 + &quot; , itg2：&quot; + itg2); //2、自动装箱 int j = 1; Integer j_itg1 = j; System.out.println(&quot;j_itg1: &quot; + j_itg1);//2、包装类 ——&gt; 基本数据类型(多种类型) //1、手动拆箱：调用包装类的 xxxValue();方法 Float flt = new Float(1F); float f = flt.floatValue(); //2、自动拆箱 float f2 = flt;//有了自动拆装箱的便利，基本可以成整体//3、[数值型] —— &gt; String //方式1：与空串 &quot;&quot; 进行连接运算 String s1 = i + &quot;&quot;; //方式2：调用String重载的valueOf(XXX xxx) 重载方法 String s2 = String.valueOf(i);//基本数据类型 s2 = String.valueOf(itg1);//包装类/obj多态传入 //方式3：调用包装类的toStrin方法 s2 = itg1.toString();//4、String ——&gt; [数值型] //方式1：调用包装类parseXxx()方法 String s3 = &quot;123&quot;; int num1 = Integer.parseInt(s3);//tips：除了boolean，其他有关字符串的装拆箱，与转换若存在字符匹配问题都会报错，需注意 static 可修饰结构：属性、方法、代码块、内部类 修饰属性 被static修饰的变量称为静态变量或类变量，该变量将会被同一个类多个对象共享。某个对象改变该静态变量，类中所有对象的该变量斗会被改变(因为共用一份) 静态变量随着类的加载而加载。可以直接通过类名进行调用”类.静态变量“ 静态变量的加载要早于对象的创建 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中 静态属性举例：System.out; Math.PI; 修饰方法 同样随着类的加载而加载，可以通过”类.静态方法“的方式进行调用 静态方法中，只能调用静态的方法或属性(因为静态方法和属性比对象加载的早) 同理：在静态的方法内，不能使用this关键字、super关键字(因为这些都是创建对象使用的关键字) 非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性 静态属性和方法应用场景 属性： 当属性是可以被多个对象共享的，不会随着对象的不同而不同的 类中的常量也常常声明为static 方法： 操作静态属性的方法，通常设置为static的 工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections 常见应用：单例模式，懒汉式、饿汉式 单例模式：采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。 若让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样，就不能用new操作符在类的外部产生 类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象， 静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象 的变量也必须定义成静态的。 两种单例模式编写 123456789101112131415161718192021//1、(简单/不安全)懒汉式：什么时候用，什么时候创建class Bank&#123; private Bank()&#123;&#125;//1、构造器私有化 private static Bank instance;//2、静态化 public static Bank getInstance()&#123;//2、静态化 if(instance == null) instance = new Bank(); return instance; &#125;&#125;//2、饿汉式：不管什么，先创建再说class Order&#123; private Order()&#123;&#125;//1、构造器私有化 private static Order instance = new Order();//2、直接实例化(静态只有一份) public Order getInstance()&#123; return instance; &#125;&#125; 懒汉式和饿汉式的对比 饿汉式： 缺点：对象加载时间过长 优点：线程安全 懒汉式： 缺点：目前写法线程不安全(两个线程挤入if == null) 优点：延迟对象的创建 常见单例模式应用场景 网站的计数器，一般也是单例模式实现，否则难以同步 应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志 文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库 资源 项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置 文件数据，都生成一个对象去读取 Application 也是单例的典型应用 Windows的Task Manager (任务管理器)就是很典型的单例模式 Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程 中，回收站一直维护着仅有的一个实例。 main方法基本含义： main()方法作为程序的入口 main()方法也是一个普通的静态方法 main()方法可以作为我们与控制台交互的方式（如之前使用Scanner的方式） 将控制台获取的数据传入main函数形参String[] args： eclipse交互： 1 2 ​ 控制台交互： 注意：记事本方式javac编译需把 packeage 代码去掉 运行时：java 类名 “Tom” “Jerry” “123” “true” sysout(args[0]);//“Tom”sysout(args[3]);//“true” –&gt;Boolean.parseBoolean(args[3]);sysout(args[4]);//报异常 小结：一叶知秋public static void main(String[] args){//方法体} 权限修饰符：private 缺省 protected pubilc —-&gt;封装性修饰符：static \\ final \\ abstract \\native 可以用来修饰方法返回值类型： 无返回值 / 有返回值 –&gt;return方法名：需要满足标识符命名的规则、规范；”见名知意”形参列表：重载 vs 重写；参数的值传递机制；体现对象的多态性方法体：来体现方法的功能 代码块 代码块使用：如同方法一般的声明位置，格式为&#123;&#125; 代码块的作用：用来初始化类、对象的信息 代码块的修饰：只能用static修饰 静态代码块： 随着类的加载而执行，且只执行一次 类中定义了多个静态代码块，则按照声明的先后顺序执行(一般只写一个) 非静态代码块 随着对象的创建而执行，每创建一次执行一次 多个非静态代码块，则按照声明的先后顺序执行(一般只写一个) static修饰类同性质 静态代码块随类的加载而加载一次，非静态随对象创建而加载 静态代码块的执行要优先于非静态代码块的执行 静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构 非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法 应用场景 静态代码块：常用于不以创建对象而调用方法，即为静态方法提供的看似为”静态构造器“的作用，完成一种静态的初始化(一次性初始化) 123456789101112131415161718192021222324252627282930313233//如JDBC连接池public class JDBCUtils &#123; private static DataSource dataSource = null; //一次性初始化/实例化，DataSource 数据库连接池 static&#123; InputStream is = null; try &#123; is = DBCPTest.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;); Properties pros = new Properties(); pros.load(is); //调用BasicDataSourceFactory的静态方法，获取数据源。 dataSource = BasicDataSourceFactory.createDataSource(pros); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; if(is != null)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //使用DBCP数据库连接池获取数据库的连接 public static Connection getConnection2() throws SQLException&#123; Connection conn = dataSource.getConnection(); System.out.println(conn); return conn; &#125; &#125; 再谈子类对象实例化加载顺序： 无论使静态还是非静态，代码块都在构造器前执行 由父及子，静态先行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.atguigu.java3;//总结：由父及子，静态先行class Root&#123; static&#123; System.out.println(&quot;Root的静态初始化块&quot;); &#125; &#123; System.out.println(&quot;Root的普通初始化块&quot;); &#125; public Root()&#123; super(); System.out.println(&quot;Root的无参数的构造器&quot;); &#125;&#125;class Mid extends Root&#123; static&#123; System.out.println(&quot;Mid的静态初始化块&quot;); &#125; &#123; System.out.println(&quot;Mid的普通初始化块&quot;); &#125; public Mid()&#123; super(); System.out.println(&quot;Mid的无参数的构造器&quot;); &#125; public Mid(String msg)&#123; //通过this调用同一类中重载的构造器 this(); System.out.println(&quot;Mid的带参数构造器，其参数值：&quot; + msg); &#125;&#125;class Leaf extends Mid&#123; static&#123; System.out.println(&quot;Leaf的静态初始化块&quot;); &#125; &#123; System.out.println(&quot;Leaf的普通初始化块&quot;); &#125; public Leaf()&#123; //通过super调用父类中有一个字符串参数的构造器 super(&quot;尚硅谷&quot;); System.out.println(&quot;Leaf的构造器&quot;); &#125;&#125;public class LeafTest&#123; public static void main(String[] args)&#123; new Leaf(); System.out.println(); new Leaf(); &#125;&#125;/*输出结果如下：Root的静态初始化块Mid的静态初始化块Leaf的静态初始化块Root的普通初始化块Root的无参数的构造器Mid的普通初始化块Mid的无参数的构造器Mid的带参数构造器，其参数值：尚硅谷Leaf的普通初始化块Leaf的构造器*/ 代码块属性赋值执行顺序：系统初始化 —&gt; 显示初始化 / 代码块初始化 —&gt; 构造器初始化 —&gt;外部调用初始化 final 可修饰结构：类、方法、变量 类：此类不能被其他类所继承(无子类)，如：String类、System类、StringBuffer类 方法：表明此方法不可以被重写，如：Object类中getClass() 变量：称为是一个常量 属性： 常量赋值的位置：(只能自动化初始化)显式初始化、代码块中初始化、构造器中初始化 必须初始化，只能使用，不能重新赋值 局部变量/形参：必须初始化，只能使用，不能重新赋值 可以数据类型，也可引用类型 12345678910//基本数据类型形参public void method(final int i)&#123; //i++; //报错，只能使用不能赋值&#125;//引用数据类型形参public void addOne(final Person p)&#123; p.age++;//通过 p = new Person();//错误&#125; static final 同时修饰结构交集：属性与方法 属性：全局常量(常见) 方法：静态方法且不可重写 抽像类关键字：abstract，可修饰结构，类、方法 修饰类：抽象类 此类虽不能实例化，但一定要有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程） 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 —&gt;抽象的使用前提：继承性 除此之外，抽象类可以定义一般类的成员，如，属性、方法、代码块… 修饰方法：抽象方法 抽象方法只有声明，没方法体 public abstract void eat(); 抽象方法只能声明在抽像类中。反之，抽象类中可以没有抽象方法的。 继承抽象类的子类必须强制实现(重写)所有抽象父类中的所有的抽象方法，若子类也是抽象类则不用。 补充说明 abstract不能用来修饰私有方法(子类无法重写)、静态方法、final的方法、final的类 抽线类除不能被实例化外，如下Person p = new Person();符合面向对象类的其他定义操作，如继承，多态，子类自身实例化等等 123//Person p = new Person();//不允许Person p = new Man();//允许，假设class Man extends Person Man m = new Man();//允许 创建抽象类的匿名子类： 12345678910111213141516171819202122232425262728293031//抽线类Personabstract class Person&#123; public abstract void eat(); public abstract void run(); &#125;//书写步骤：Person p = new Person()&#123;&lt;回车&gt;&#125;;//创建一个匿名子类对象(其实是通过多态的一种方式实现了匿名实例化)Person p = new Person()&#123; @Override public abstract void eat()&#123; &#125; @Override public abstract void run()&#123; &#125;&#125;;//创建一个匿名子类的匿名对象//书写：method(new Person()&#123;&lt;回车&gt;&#125;);method(new Person()&#123; @Override public abstract void eat()&#123; &#125; @Override public abstract void run()&#123; &#125; &#125;); 常见应用场景 IO流中设计到的抽象类：InputStream/OutputStream / Reader /Writer。在其内部定义了抽象的read()、write()方法。 模板方法的设计模式 抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模 板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象 类的行为方式。 解决的问题： 当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以 把不确定的部分暴露出去，让子类去实现。 换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用， 这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽 象出来，供不同子类实现。这就是一种模板模式 例1 12345678910111213141516171819202122232425262728public class TemplateTest &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub TemplateSub ts = new TemplateSub(); ts.spendTime(); &#125;&#125;//模板方法设计模式体现abstract class Template&#123; public void spendTime()&#123; long start = System.currentTimeMillis(); code();//易变部分，不确认部分 long end = System.currentTimeMillis(); System.out.println(&quot;运行时间：&quot; + (end - start) + &quot; ms&quot;); &#125; public abstract void code();&#125;class TemplateSub extends Template&#123; @Override public void code() &#123; // TODO Auto-generated method stub for(int i = 0,j=0;i &lt; 100000;i++) j+=j; System.out.println(&quot;代码执行中...&quot;); &#125;&#125; 例2 12345678910111213141516171819202122232425262728293031323334353637383940414243//抽象类的应用：模板方法的设计模式public class TemplateMethodTest &#123; public static void main(String[] args) &#123; BankTemplateMethod btm = new DrawMoney(); btm.process(); BankTemplateMethod btm2 = new ManageMoney(); btm2.process(); &#125;&#125;abstract class BankTemplateMethod &#123; // 具体方法 public void takeNumber() &#123; System.out.println(&quot;取号排队&quot;); &#125; public abstract void transact(); // 办理具体的业务 //钩子方法 public void evaluate() &#123; System.out.println(&quot;反馈评分&quot;); &#125; // 模板方法，把基本操作组合到一起，子类一般不能重写 public final void process() &#123; this.takeNumber(); this.transact();// 像个钩子，具体执行时，挂哪个子类，就执行哪个子类的实现代码 this.evaluate(); &#125;&#125;class DrawMoney extends BankTemplateMethod &#123; public void transact() &#123; System.out.println(&quot;我要取款！！！&quot;); &#125;&#125;class ManageMoney extends BankTemplateMethod &#123; public void transact() &#123; System.out.println(&quot;我要理财！我这里有2000万美元!!&quot;); &#125;&#125; 场景应用场景 模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的 影子，比如常见的有： 数据库访问的封装 Junit单元测试 JavaWeb的Servlet中关于doGet/doPost方法调用 Hibernate中模板程序 Spring中JDBCTemlate、HibernateTemplate等 接口 一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又 没有is-a的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打 印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都 支持USB连接。 另一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。 接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要…则 必须能…”的思想。继承是一个”是不是”的关系，而接口实现则是 “能不能” 的关系。 接口的本质是契约，标准，规范，就像我们的法律一样。制定好后大家都要遵守 接口聚焦点在行为，是相同的行为 同抽象类，接口也体现多态性 例1 例2 接口的使用 接口使用interface来定义 1interface Flyable&#123;&#125; 接口内可定义成员： JDK7前：只能定义全局常量与抽像方法 全局常量：public static final ，书写时，可省略不写。 public static final int MAX;等价于 int MAX 抽象方法：public abstract void method();，书写时，可省略不写。 public abstract void method();等价于 void method(); 接口中不能定义构造器的！即接口不可以实例化 接口和类是并列的两个结构，接口通过让类去实现(implements)的方式来使用 实现接口后类同继承效果，拥有了接口定义的成员 1234567891011121314151617181920212223242526//习题interface A &#123; int x = 0;&#125;class B &#123; int x = 1;&#125;/**小结：单继承与实现中出现同名属性或方法属性：编译错误方法：类优先原则，调用父类同名方法而非接口同名方法*/class C extends B implements A &#123; public void pX() &#123; //编译不通过。类与接口是并列关系，导致属性x是不明确的 // System.out.println(x); System.out.println(super.x);//1 System.out.println(A.x);//0，切勿忘记接口属性的public static final 修饰 &#125; public static void main(String[] args) &#123; new C().pX(); &#125;&#125; 同理抽象类 若实现类非抽像类，则必须实现接口所有抽象方法，才可实例化 若实现类为抽像类，则不要求实现接口的抽象方法 Java类可以实现多个接口(弥补了Java单继承性的局限性) class AA extends BB implements CC,DD,EE&#123;&#125; 接口与接口之间可以多继承 interface CC entends AA,BB&#123;&#125; 接口匿名实现类：同抽象类的匿名实现类创建方式 接口应用场景 代理模式(Proxy) 应用场景： 安全代理：屏蔽对真实角色的直接访问 远程代理：通过代理类处理远程方法调用（RMI） 延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象 比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有 100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理 模式，当需要查看图片时，用proxy来进行大图片的打开。 分类 静态代理（静态定义代理类） 动态代理（动态生成代理类） JDK自带的动态代理，需要反射等知识 工厂模式 JDK8接口特性：还可以定义静态方法、默认方法 接口中定义的静态方法，只能通过接口来调用 12345678910111213interface CompareA&#123; public static method()&#123; System.out.prnitln(); &#125;&#125;/****************************/class SubClass implements CompareA&#123; public static void main(String[] args)&#123; CompareA.method(); new SubClass().method();//错误 &#125;&#125; 应用场景： 在标准库中 找到像Collection(接口)/Collections(工具类)或者Path/Paths这样成对的接口和类 在JDK8中，可以将Collection与Collections工具类提供的静态方法合并一起 通过实现类的对象，可以调用接口中的默认方法，通过default关键字修饰(public可以省略) 123456interface CompareA&#123; //默认方法 public default void method()&#123; //public可以省略 System.out.prnitln(); &#125;&#125; 若实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法 若实现类实现了多个接口，多个接口中存在同名同参数的默认方法，且实现类没重写此方法的情况下，出现编译错误。接口冲突。这就需要我们必须在实现类中重写此方法 在子类(或实现类)的方法中调用父类、接口中被重写的方法 1234567public void myMethod()&#123; method3();//调用自己定义的重写的方法 super.method3();//调用的是父类中声明的 //调用接口中的默认方法 CompareA.super.method3(); CompareB.super.method3();&#125; ​ 内部类 使用场景：当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的结构又只为该事物提供服务，那么整个内部的完整结构最好使用内部类。 内部类的类型 12345678910111213141516171819202122232425262728293031323334353637383940/* * 内部类类型，对应变量类型 * 1、成员变量：属性(成员内部类) * 非静态成员变量：属性(非静态内部类) * 静态变量：类变量(静态内部类) * 2、局部变量：方法、构造器、代码块内 * (局部内部类) */class TestInClass&#123; //非静态成员内部类 class AA&#123; &#125; //静态成员内部类 static class BB&#123; &#125; public void testMethod()&#123; class EE&#123;//局部内部类 &#125; &#125; public TestInClass() &#123; //局部内部类 class CC&#123; &#125; &#125; &#123; //局部内部类 class DD&#123; &#125; &#125;&#125; 成员内部类 作为外部类的成员(属性理解)： 可以调用外部类的结构 可以被static修饰(外部类-普通类不可以) 可以被4种权限修饰符修饰(普通类只有缺省和public) 作为类：拥有普通类的常见情况 类内可以定义属性、方法、构造器等 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承 可以被abstract修饰 实例化成员内部类 1234567//创建静态的Dog内部类的实例(静态的成员内部类):Person.Dog dog = new Person.Dog();//创建非静态的Bird内部类的实例(非静态的成员内部类)://Person.Bird bird = new Person.Bird();//错误的Person p = new Person();Person.Bird bird = p.new Bird(); 内部类与外部类同名属性调用 12345678910111213141516class Person&#123; String name = &quot;小明&quot;; public void eat()&#123; &#125; //非静态成员内部类 class Bird&#123; String name = &quot;杜鹃&quot;; public void display(String name)&#123; System.out.println(name);//方法的形参 System.out.println(this.name);//内部类的属性 System.out.println(Person.this.name);//外部类的属性 //Person.this.eat(); &#125; &#125;&#125; 局部内部类 在局部内部类的方法中的调用方法的局部变量话,要求此局部变量声明为final的。 jdk 7及之前版本：要求此局部变量显式的声明为final的 jdk 8及之后的版本：可以省略final的声明 1234567891011public class InnerClassTest &#123; public void method()&#123; int num = 10; class AA&#123; public void show()&#123; //num = 20;//错误，num默认为final System.out.println(num); &#125; &#125; &#125; &#125; * 成员内部类和局部内部类，在编译以后，都会生成字节码文件。 成员内部类：外部类$内部类名.class 局部内部类：外部类$数字 内部类名.class 12345678910111213141516171819202122//返回一个实现了Comparable接口的类的对象 public Comparable getComparable()&#123; //创建一个实现了Comparable接口的类:局部内部类 //方式一： class MyComparable implements Comparable&#123; @Override public int compareTo(Object o) &#123; return 0; &#125; &#125; return new MyComparable(); //方式二： return new Comparable()&#123; @Override public int compareTo(Object o) &#123; return 0; &#125; &#125;; &#125; 异常处理异常概述 在Java语言中，将程序执行中发生的不正常情况称为“异常” 。 (开发过程中的语法错误和逻辑错误不是异常) 运行中所发生的异常事件可分为：Error、Exception 两种异常 ErrorJava虚拟机无法解决的严重问题。如：JVM系统内部错误、资源 耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。 1234567891011public class ErrorTest &#123; public static void main(String[] args) &#123; //1、栈溢出：java.lang.StackOverflowError //通过死循环调用方法使其申请无限个形参(局部变量)， //由于局部变量是存放在栈空间，所以会引发栈溢出错误 //main(args); //2、堆溢出：java.lang.OutOfMemoryError，new出来的内容均存放在堆空间 Integer[] arr = new Integer[1024 * 1024 * 1024]; &#125;&#125; Exception因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。(无特别说明，以下异常均指Exception) 空指针访问 试图读取不存在的文件 网络连接中断 数组角标越界等 异常分类捕获错误最理想的是在编译期间(可预知的异常)，但有的错误只有在运行时才发生。 比如：除数为0，数组下标越界等，因此可分为编译时异常和运行时异常 异常体系结构异常体系结构均为类，且均为继承关系 1234567891011121314* java.lang.Throwable* |-----java.lang.Error:一般不编写针对性的代码进行处理。* |-----java.lang.Exception:可以进行异常的处理* |------编译时异常(checked)* |-----IOException* |-----FileNotFoundException* |-----ClassNotFoundException* |------运行时异常(unchecked,RuntimeException)* |-----NullPointerException* |-----ArrayIndexOutOfBoundsException* |-----ClassCastException* |-----NumberFormatException* |-----InputMismatchException* |-----ArithmeticException 图示1 API图示1：Exception API图示2：RuntimeException 常见异常运行时异常 运行时异常 含义 NullPointerException 空指针异常 ArrayIndexOutOfBoundsException 数组角标越界 StringIndexOutOfBoundsException 字符串角标越界 ClassCastException 类型转换异常 NumberFormatException 数字格式异常 InputMismatchException 输入不匹配异常 ArithmeticException 算术异常 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//******************以下是运行时异常***************************//NullPointerException@Testpublic void test1()&#123; //int[] arr = null; //System.out.println(arr[3]); String str = &quot;abc&quot;; str = null; System.out.println(str.charAt(0));&#125;//IndexOutOfBoundsException//StringIndexOutOfBoundsException@Testpublic void test2()&#123; //ArrayIndexOutOfBoundsException //int[] arr = new int[10]; //System.out.println(arr[10]); //StringIndexOutOfBoundsException String str = &quot;abc&quot;; System.out.println(str.charAt(3));&#125;//ClassCastException@Testpublic void test3()&#123; Object obj = new Date(); String str = (String)obj;&#125;//NumberFormatException@Testpublic void test4()&#123; String str = &quot;123&quot;; str = &quot;abc&quot;; int num = Integer.parseInt(str);&#125;//InputMismatchException@Testpublic void test5()&#123; Scanner scanner = new Scanner(System.in); int score = scanner.nextInt(); System.out.println(score);//当输入非int类型时 scanner.close();&#125;//ArithmeticException@Testpublic void test6()&#123; int a = 10; int b = 0; System.out.println(a / b);&#125; 编译时异常123456789101112131415//******************以下是编译时异常***************************//如下代码逻辑合语法均没错误//但IDE会提示存在IOException、FileNotFoundException等编译时异常@Testpublic void test7()&#123; File file = new File(&quot;hello.txt&quot;); FileInputStream fis = new FileInputStream(file); int data = fis.read(); while(data != -1)&#123; System.out.print((char)data); data = fis.read(); &#125; fis.close();&#125; 异常处理机制引言：在编写程序时，经常要在可能出现错误的地方加上检测的代码， 如进行x/y运算时，要检测分母为0，数据为空，输入的不是数据 而是字符等。过多的if-else分支会导致程序的代码加长、臃肿， 可读性差。因此采用异常处理机制。 Java采用的异常处理机制是将异常处理的程序代码集中在一起， 与正常的程序代码分开，使得程序简洁、优雅，并易于维护。 抓抛模型 “抛“： 程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应的异常类的对象，并将此对象抛出。一旦抛出异常对象以后，其后的代码就不再执行。 关于异常对象的产生 系统自动生成的异常对象 手动的生成一个异常对象，并抛出（throw） “抓“：可以理解为异常的处理方式：① try-catch-finally ② throws try-catch-finally语法格式1234567891011try&#123; //可能出现异常的代码&#125;catch(异常类型1 变量名1)&#123; //处理异常的方式1&#125;catch(异常类型2 变量名2)&#123; //处理异常的方式2&#125;....finally&#123;//可选项 //一定会执行的代码&#125; 语法说明 try-catch-finally中：至少try-catch或try-finally(此时异常属于未处理状态)，至多try-catch-finally。 使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配。一旦匹配到某一个catch时则不再匹配，随之进入匹配的catch中进行异常的处理，处理完毕后继续执行其后的代码。（没有写finally的情况） catch中的异常类型如果没有子父类关系，则声明次序无关。 catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错 常用的异常对象的调用的方法 String getMessage()：打印异常基本描述信息 printStackTrace()：打印异常所涉及的整个堆栈调用信息 在try结构中声明的变量，再出了try结构以后，就不能再被调用 try-catch-finally结构可嵌套 finally结构说明： finally是可选的。 finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中return语句，catch中return语句等情况，finally都会被执行。 注意：从第2点可以看出，若try-catch中出现return语句，finally是在return之前执行的。因此若finally中出现return语句，肯定是整个方法的return结果 如像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。 小结： 使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。 相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。 开发中，运行时异常一般只能重新构造代码逻辑，不针异常编写try-catch-finally了(没用) 对于编译时异常，则一定要考虑异常的处理。 throws语法说明语法格式：throws 异常类型1,异常类型2... “throws + 异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！ throws的方式只是将异常抛给了方法的调用者。并没有真正将异常处理掉 子类重写的方法抛出的异常类型小于或等于父类被重写的方法抛出的异常类型 子类重写的方法的异常处理方式必须与父类处理异常的方式一致。 try-catch-finally真正的将异常给处理掉了。 throws方式只是将异常抛给了方法的调用者。并没真正将异常处理掉。 开发中异常处理的选择： 在执行某个方法A时，这个方法内又递归地调用的几个方法，而且这几个被调用的方法都可能存在异常。则建议内部几个被递归调用的方法都采用throws，总的方法A采用try-catch的方式处理。 如下，方法float method 中递归地调用了三个方法，递归地调用指如method1返回值拿去调用method2返回的值又再给method3调用。 由于这种递归调用的方式，若在method1、2、3中使用try-catch方式处理，则会出现某个被带哦用的方法出现了异常，确实被处理了，代码也继续执行，但返回的值已经不能供下一个方法正常执行。所以在这种递归地调用方法结构上过早地通过try-catch处理调异常并非是件好事。 手动抛出异常对象-throwtips：throws是异常处理的一种方式，而throw是创建异常的关键字 语法要求语法：在方法内throw 异常类 一般选择抛出Exception(含编译与运行时异常)或运行时异常RuntimeException，或自定义异常类。抛出时通过使用这些异常类的重载构造器(如带参描述) 1234public void method(int i)&#123; if(i &lt; 0) throw new Exception(&quot;i &lt; 0&quot;);&#125; 需求场景模拟 没有通过抛出异常处理 1234567891011121314151617181920212223242526272829/* 如下限制Person的age必须&gt;0，若采用传统的if-else无法达到效果 因为即使断绝了age的赋值，age都会以默认初始化值为0(非法)继续 执行，无法有效断绝非法数据的执行。如下代码效果*/public class ThrowTest &#123; public static void main(String[] args) &#123; Person p = new Person(); p.setAge(-1); System.out.println(&quot;age：&quot; + p.getAge()); System.out.println(&quot;代码继续执行.....&quot;); &#125;&#125;class Person&#123; private String name; private int age; public void setAge(int age) &#123; if(age &gt; 0)&#123; this.age = age; &#125;else&#123; System.out.println(&quot;输入非法数据&quot;); &#125; &#125; public int getAge() &#123; return age; &#125;&#125; 打印结果如下 123输入非法数据age：0代码继续执行..... 异常处理方式1：抛出运行时异常，编译的时候setAge()方法无需对异常处理 123456789101112131415161718192021222324public class ThrowTest &#123; public static void main(String[] args) &#123; Person p = new Person(); p.setAge(-1); System.out.println(&quot;age：&quot; + p.getAge()); System.out.println(&quot;代码继续执行.....&quot;); &#125;&#125;class Person&#123; private String name; private int age; public void setAge(int age) &#123; if(age &lt; 0)&#123; throw new RuntimeException(&quot;运行时异常：非法年龄输入&quot;); &#125; this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125; 打印结果如下 123Exception in thread &quot;main&quot; java.lang.RuntimeException: 运行时异常：非法年龄输入at com.test.java.Person.setAge(ThrowTest.java:19)at com.test.java.ThrowTest.main(ThrowTest.java:7) 异常处理方式2：抛出异常，编译的时候setAge()会检查到异常，需即刻对异常进行处理 1234567891011121314151617181920212223242526public class ThrowTest &#123; public static void main(String[] args) &#123; Person p = new Person(); try &#123; p.setAge(-1); System.out.println(&quot;age：&quot; + p.getAge()); System.out.println(&quot;代码继续执行.....&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Person&#123; private String name; private int age; public void setAge(int age) throws Exception &#123; if(age &lt; 0)&#123; throw new Exception(&quot;运行时异常：非法年龄输入&quot;); &#125; this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125; 打印结果如下 123java.lang.Exception: 运行时异常：非法年龄输入at com.test.java.Person.setAge(ThrowTest.java:24)at com.test.java.ThrowTest.main(ThrowTest.java:8) 自定义异常类 如何自定义异常类？ 继承于现有的异常结构：常用RuntimeException 、Exception 提供全局常量：serialVersionUID，用于序列化传输时唯一标识当前类 提供重载的构造器 123456789public class MyException extends Exception&#123; static final long serialVersionUID = -7034897193246939L; public MyException()&#123; &#125; public MyException(String msg)&#123; super(msg); &#125;&#125; Java基础类库JUnitTest JUnitTest单元测试类： 快捷步骤： 直接在想要测试的方法上添加@Test注解，通过eclipse提示导入相关内容 详细步骤与细节 中当前工程 - 右键择：build path - add libraries - JUnit 4 - 下一步 单元测试类要求：public、供公共的无参的构造器 单元测试方法的要求：public、无返回值，无形参 单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test; 左键双击单元测试方法名，右键：run as - JUnit Test 执行结果没任何异常：绿条 执行结果出现异常：红条 System1System.exit(0);//终止JVM的执行 Arrays 操作数组的工具类：有封装好的快排，二分排等操作(可查看源码学习) method meaning boolean equals(int[] a,int[] b) 判断两个数组是否相等。 String toString(int[] a) 输出数组信息 void fill(int[] a,int val) 将指定值均填充到数组之中 void sort(int[] a) 对数组进行排序 int binarySearch(int[] a,int key) 对排序后的数组进行二分法检索指定的值 …..详细查看API 123456import java.util.Arrays;//如一些二分查找等都有封装好/*boolean equals*/ Scanner1import java.util.Scanner; Math123Math.random();//[0.0,1.0)Math.PI;long Math.round(double d)//四舍五入取整 复用：方法，继承 可扩展性：继承，多态(自带，归类分配控制器，减少编写重载方法) 解耦：封装 封装： 继承：复用，易扩展 多态性：提高代码的通用性，如Object 的equals方法 有关源码的题包装类相关缓存12345678910111213141516171819202122232425262728@Testpublic void test3() &#123; Integer i = new Integer(1); Integer j = new Integer(1); System.out.println(i == j);//false Integer m = 1; Integer n = 1; System.out.println(m == n);//true //注意，如果数值不一样是肯定不一样的 Integer a = 210; Integer b = 211; System.out.println(a == b);//false Integer x = 128; Integer y = 128; System.out.println(x == y);//false&#125;// Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[],// 保存了从-128~127范围的整数。如果我们使用自动装箱的方式，给Integer赋值的范围在// -128~127范围内时，可以直接使用数组中的元素，不用再去new了。目的：提高效率// Integer m = 1; //-128~127范围内相当于同一个数组地址// Integer n = 1;// Integer x = 128;//相当于new了一个Integer对象// Integer y = 128;//相当于new了一个Integer对象 equals重写逻辑包装类在进行equals比较时，首先会比较两个的数据类型、不一致返回false、一致后再比较数值 常用DOS命令 快速进入特定路径下的命令窗体：在拟进入文件路径的地址栏中直接输入cmd 复制与黏贴 win7：任意位置右键“标记”，选中要复制的内容，再点击右键，剪贴板里面了 win10：左键直接选中，然后右键单击一下就到剪贴板里面了 D: 切换盘符直接输入“盘符” md：mkdir make director创建目录 cd：change directory切换目录 cd：相对路径或绝对路径 **cd ..**：回到上级路径 cd \\ ：直接回到根路径 . ：一个点，代表当前路径。（常用与配置环境变量） cls：清屏 dir directory：查看当前路径文件目录： exit：退出DOS命令窗口 rd：只能删除空文件夹： de：删除文件目录内所有内容 echo content(内容)&gt;1.doc：输入流","categories":[],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/tags/JavaSE/"}]},{"title":"视频解析接口","slug":"视频解析接口","date":"2020-12-12T11:41:32.000Z","updated":"2021-03-28T15:05:26.441Z","comments":true,"path":"2020/12/12/视频解析接口/","link":"","permalink":"http://yoursite.com/2020/12/12/%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164亲测系列https://cdn.yangju.vip/k/?url=源：https://www.cnblogs.com/apolloren/p/11247487.html最稳定万能vip视频解析接口 支持HTTPShttps://cdn.yangju.vip/k/?url=https://cdn.yangju.vip/k/?url=https://jx.lache.me/cc/?url=https://api.653520.top/vip/?url=https://jx.ab33.top/vip/?url=https://vip.mpos.ren/v/?url=https://jx.000180.top/jx/?url=https://jx.km58.top/jx/?url=源：https://www.zye.cc/toosl/15775.html无广告通用：https://vip.52jiexi.top/?url= 腾讯直解无广告解析：https://jx.lfeifei.cn/?url= 无广告解析：https://api.steak517.top/?url= 秒播无广告解析：http://api.steak517.top/?url=无广告通用HTTP接口：http://api.yueliangjx.com/?url=无广告通用HTTPS接口：https://api.yueliangjx.com/?url=无广告解析：https://jx.elwtc.com/vip/?url=无广告解析：https://api.78sy.cn/?url= 秒播无广告通用HTTP接口：http://www.2ajx.com/vip.php?url=无广告通用HTTPS接口：https://www.2ajx.com/vip.php?url=通用HTTP接口：http://api.steak517.top/?url=通用HTTPS接口：https://api.steak517.top/?url=https://vip.ikjiexi.top/api/?url= 无广告，速度也还行https://www.kpezp.cn/jlexi.php?url= 速度挺快的*还带记忆播放https://api.8bjx.cn/?url= 秒播吧 记忆https://jx.f41.cc/?url= 速度还可以http://v.nmbaojie.com/mingri/mingri.php?url=速度还行https://www.ckmov.vip/api.php?url= 挺快的http://jx.ejiafarm.com/dy.php?url= 挺快的https://jx.youyitv.com/?url=http://jiexi.xueshi.prohttps://z1.m1907.cn/?jx= 小卡https://jx.618g.com/?url= 速度一般https://www.1717yun.com/jx/ty.php?url= 速度还可以https://cdn.yangju.vip/k/?url= 一般https://vip.jaoyun.com/index.php?url= 还可以https://jx.618g.com/?url= 还可以https://www.myxin.top/jx/api/?url= 腾讯直解 缓存挺快的https://jiexi.071811.cc/jx.php?url= 挺快的https://jx.wslmf.com/?url= 还行就是 不带缓存要拉快进的注意了https://jx.dy-jx.com/?url= 打不开https://vip.mpos.ren/v/?url=黑屏https://jqaaa.com/jx.php?url= 速度挺快的https://jx.598110.com/index.php?url= 速度还可以https://jx.bwcxy.com/?v= 速度还可以https://jx.rdhk.net/?v= 速度一般https://jx.fo97.cn/?url= 好像不能用https://jx.ivito.cn/?url= 一般https://api.927jx.com/vip/?url=一般般https://api.tv920.com/vip/?url=很一般https://api.lhh.la/vip/?url=https://api.sumingys.com/index.php?url= 很一般https://cn.bjbanshan.cn/jx.php?url=挺快的https://jx.mw0.cc/?url=挺快的https://www.33tn.cn/?url= 挺快的http://jx.1ff1.cn/?url= 还行https://jx.000180.top/jx/?url= 一般https://py.ha12.xyz/sos/index.php?url=https://jiexi.380k.com/?url= 挺快的https://jx.wslmf.com/?url= 挺快的https://okjx.cc/?url=http://www.662820.com/xnflv/index.php?url=http://api.lldyy.net/svip/?url=http://www.82190555.com/index/qqvod.php?url=http://jiexi.92fz.cn/player/vip.php?url=http://jiexi.071811.cc/jx2.php?url=http://api.wlzhan.com/sudu/?url=http://beaacc.com/api.php?url=http://qxkkk.bid/jx/jx.php?url=http://www.27v9.cn/index.php?url=http://www.ckplayer.tv/kuku/?url=http://o8ve.cn/1/?url=http://api.xyingyu.com/?url=https://jx.kt111.top/jx/mf/?url=https://api.pangujiexi.com/player.php?url=http://api.lvcha2017.cn/?url=http://kkk.2016ve.cn/kkjx/index.php?url=http://mlxztz.com/vip/?url=http://www.aktv.men/?url=http://jy777.cn/XSD/XSD/?url=http://api.visaok.net/?url=http://api.xyingyu.com/?url=http://api.greatchina56.com/?url=http://jx.618g.com/?url=http://api.baiyug.vip/index.php?url=http://jx.jfysz.cn/jx.php/?url=http://jx.ektao.cn/jx.php/?url=http://jx.reclose.cn/jx.php/?url=http://jx.eayn.org.cn/jx.php/?url=http://api.xyingyu.com/?url=http://jx.iaeec.cn/jx.php/?url=http://jx.83y4n7a.cn/jx.php/?url=http://jx.cmbzzs.cn/jx.php/?url=http://api.greatchina56.com/?url=http://jx.as19811.cn/jx.php/?url=http://jx.sdjnd09.cn/jx.php/?url=http://api.baiyug.vip/index.php?url=http://jx.09876as.cn/jx.php/?url=http://jx.17ktv.com.cn/jx.php/?url=http://jx.ab78a.cn/jx.php/?url=http://jx.09877as.cn/jx.php/?url=http://jx.yipolo111.cn/jx.php/?url=http://jx.908astbb.cn/jx.php/?url=http://jx.dlzyrk001.cn/jx.php/?url=http://jx.dccmy.org.cn/jx.php/?url=http://jx.boctx.cn/jx.php/?url=http://jx.hxbte.cn/jx.php/?url=http://api.visaok.net/?url=http://jx.618g.com/?url=http://yun.baiyug.cn/vip/?url=http://api.baiyug.cn/vip/?url=https://api.flvsp.com/?url=http://api.xfsub.com/index.php?url=http://api.xfsub.com/index.php?url=http://jiexi.071811.cc/jx2.php?url=http://player.jidiaose.com/supapi/iframe.php?v=http://www.82190555.com/index/qqvod.php?url=http://api.pucms.com/?url=http://api.baiyug.cn/vip/index.php?url=https://api.flvsp.com/?url=http://www.82190555.com/index/qqvod.php?url=http://2gty.com/apiurl/yun.php?url=http://v.2gty.com/apiurl/yun.php?url=直接观看：http://tv.inkb.ink/index.html扫码：http://www.guandianzhiku.com/v/s/?url=扫码：https://v.7cyd.com/vip/?url=腾讯视频 慢扫码：http://zxjx.00vb.com/zdhx/index.php?url=扫码：https://www.jqaaa.com/jx.php?url=无广告超清解析：http://jx.awx88.cn/jiexi/?url=弹幕解析：http://gongxiangtv.cn/?url=VIP视频解析北极XS视频解析：http://beijixs.cn/ 视频高清VIP视频解析116kan智能解析：https://vip.116kan.com/ 高清视频365t在線免費解析觀看系統：http://vip.365tol.top/BL智能解析：https://vip.bljiex.com/kingtail智能解析：https://jx.kingtail.xyz/?url=https://jsap.attakids.com/?url=https://api.lnwu.net/?url=91视频解析：https://www.91jxs.com/jiexi/?url=https://api.jhys.top/?url=思古视频服务：https://api.sigujx.com/?url=小野马解析：https://www.xymav.com/?url=诺讯智能解析：https://www.nxflv.com/?url=热搜视频：https://v.resoumen.com/全民解析：http://qmaile.com/ 解析聚合，多线路解析聚神铺vip解析：http://www.jspoo.com/vip.html 解析聚合，多线路选择Yun Parse视频云解析：http://120.27.155.106/ 填视频ID而不是视频网页地址，另支持解析QQ相册等地址爱看解析：http://tv.vipsli.com/TVB云播全网VIP视频解析：http://vip.hktvyb.com/ 聚合解析，多线路Playm3u8解析：https://www.playm3u8.cn/jiexi.php?url= 除了常见VIP视频地址外，还支持解析QQ相册等地址千亿解析：https://www.qianyicp.com/jiexi/index.php?url= 蓝光超清解析接口OK解析：http://www.okjx.cc/ceshi/ 测试后不太清晰618G免费解析：https://jx.618g.com/ 测试后不是很清晰http://avip.fun/tv?utm_source= 测试后直接不清晰","categories":[],"tags":[{"name":"娱乐","slug":"娱乐","permalink":"http://yoursite.com/tags/%E5%A8%B1%E4%B9%90/"}]},{"title":"数据库原理 第二章 关系数据库","slug":"数据库原理 第二章 关系数据库","date":"2020-10-30T10:38:32.000Z","updated":"2020-10-30T10:42:49.309Z","comments":true,"path":"2020/10/30/数据库原理 第二章 关系数据库/","link":"","permalink":"http://yoursite.com/2020/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"关系数据库 基本概念 定义：关系数据库是采用关系模型的数据库系统，而关系模型的数据结构(数据模型三部曲之一)就是关系本身。即现实世界的实体与实体间的联系都用关系来表示，其逻辑结构表现为一张二维表 相关术语： 关系术语 一般表格术语 关系（relation） 表 元组（tuple） 行或记录 属性（attribute） 列 分量 列值/属性值 域（domain） 列值/属性值给定的取值范围(非数据类型上的范围) 基数 一个域允许的不同取值个数 关系模式 关系型，即对表格结构的描述 [关系]关系的类型：三种，基本关系(基本表/基表)、查询表、视图表 [域]笛卡儿积：从数学定义上，笛卡尔积的基数等于两个集合中各分量的组合。从数据表中，即每个表的元组总数的相乘。如表1有n行数据，表2有m行数据，则表1和表2构成的笛卡尔积为n*m 关系操作 关系操作类型：分为两类，查询操作(query)与(插入、删除、修改)操作两大类型组成 查询操作：选择(select)、投影(project)、连接(join)、除(divide)、并(union)、差(except)、交(intersection)、笛卡尔积等。加粗部分为查询的五大基本操作，其他操作均可由其基本操作来实现。 关系数据语言： 定义：关系数据语言主要用于表达对数据库抽象层面的查询操作。 关系数据语言的分类：关系代数语言、关系演算语言、结构化查询语言。 关系代数语言：用对关系的运算来表达查询要求(操作)，重点掌握 关系演算语言：用谓词来表达查询要求(操作) 双重特点语言——结构化查询语言SQL(structured query language)：同时具备关系代数和关系演算双重特点的语言 关系代数语言 关系代数运算符： ​ 备注：R，relationship，关系/数据表、F，function，选择条件，逻辑表达式、A，attribute，属性列、θ，比较运算符 传统集合运算：均为二目运算，交、并、差、笛卡尔积四种 专门关系运算：选择、投影、连接、除运算等 着重解释“连接” 定义： 连接运算过程：R与S均是关系表，从R和S的笛卡尔积(广义笛卡尔积)RxS中选取R关系在A属性组上的值与S关系在B属性组上的值满足比较关系θ的元组，即，只要进行连接运算，首先生成的肯定是笛卡尔乘积 等值/非等值连接：θ为“=”等值连接，若θ为比较运算符则是非等值连接，而自然连接是一种特殊的等值连接。 连接条件F运算符： 类型 格式定义 例子 选择 ∂F(R) ∂Sage &lt; 20(Student) 投影 ∏A(R) ∏Sname，Sdept(Student) 连接 R1⋈R2 (因符号表示问题，常见上述定义) 略 关系的完整性 实体完整性（entity integrity）：主键，表唯一，非空 参照完整性（referential integrity）：外键，列唯一，可空 用户定义的完整性：为某个属性定义取值约束 注意：主键和外键如果存在则必须定义，否则就是数据库设计本身存在问题，实体完整性和参照完整性是关系的两不变性","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库原理 第一章 绪论","slug":"数据库原理 第一章 绪论","date":"2020-10-28T11:57:32.000Z","updated":"2020-11-12T14:27:14.579Z","comments":true,"path":"2020/10/28/数据库原理 第一章 绪论/","link":"","permalink":"http://yoursite.com/2020/10/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%20%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/","excerpt":"","text":"绪论 数据库基本概念 数据（data）：描述事物的符号记录称为数据 数据库（DB，DataBase）：长期存储在计算机内、有组织的、可共享的大量数据的集合 数据库管理系统（DBMS，Data Base Management System）：用于科学高效地存取、维护数据的计算机基础软件，是一个大小复杂的软件系统(如操作系统般)。其最主要的功能如下： 数据定义功能（DDL，Data Definition Language）：如对库、表、字段等数据对象的定义(创建,修改,删除等) 数据操纵功能（DML，Data Manipulation Language）：对数据的增删改查等操作 数据库系统（DBS，DataBase System）：DB + DBMS(相关tool) + Program + DBA组成的存储、管理、处理和维护数据的系统 数据模型 两类数据模型：概念模型(信息模型)、逻辑模型与物理模型 概念模型：以用户角度对数据进行信息建模，不依赖于具体DBMS，是概念级的模型。其他相关概念如下： 实体(entity)：客观存在且相互区别的事物。如，一条具体的信息，类对象的一个实例 实体型(entity type)：用实体名及其属性名的集合来抽象同类实体。如，面向对象中的类 实体集(entity set)：同类型的实体的集合，如全体学生，一些对象的集合、表等 属性(attribute)：实体具有的某一特性。如，数据表中的字段/列 码(key)：唯一标识实体的属性集，(注意是属性集) 联系(relationship)：现实世界中，实体(型/集)与实体(型/集)之间的联系，一般有一对一，一对多，多对多的联系 联系的定义与判断：在A实体集内取1个实体，而这个实体能在B实体集内对应多个实体。则称为一对多，其他类型联系以此类推。 E - R模型：概念模型的最常用的表示方法为实体-联系方法(Entity-Relationship approach)，也称E-R模型，用E-R图描述。具体设计与实现在“概念结构设计篇”讲解 逻辑模型与物理模型：以计算机系统角度对数据的建模，由DBMS。常见逻辑模型如层次、网状、关系、面向对象等模型。 模型之间的关系 数据模型的组成要素：数据模型由数据结构(对象的组成与对象间的联系)、数据操作(增删改查)、数据完整性约束条件(确保数据的完整性)组成。任何数据模型都需考虑的三个因素。 数据库系统结构 基本概念 型（type）：某一类数据的结构与属性的说明。如类的定义 值（value）：值是型的具体赋值。如某一个类的实体对象(实例) 模式（schema）：是指数据库全体数据的逻辑结构和特征的描述，属于“型”的层次，相对稳定 实例（instance）：模式对应的一个具体值称为实例，相对变动 注意，这里“一个具体值”不是只有一个值，而是一个模式的值，即刻整个数据库的数据。 二级映像下的三级结构：由模式对外(应用程序)，对内(数据存储)分别进行了模式映像。从而产生了两个二级映像，即外模式与内模式。 三级结构：外模式，模式，内模式统称数据库三级模式的结构 模式：具体概念不再赘述，强调模式是所有用户的公共数据视图 外模式：又名子模式、用户模式。它是数据库用户(开发者与最终用户)能够看见与使用的局部数据的逻辑结构和特征的描述** 内模式：又称为存储模式，一个数据库只有一个内模式，是数据在数据库内部的组织方式的描述 模式映像的作用：外模式实现了逻辑独立性，内模式实现了物理独立性。从外到内保证模式的相对稳定 数据库系统组成​ 数据库系统由：硬件平台及数据库，软件，人员(数据库管理人员)(DBA，DataBase Administrator)组成。","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库原理 第五章 数据库完整性","slug":"数据库原理 第五章 数据库完整性","date":"2020-10-28T01:11:32.000Z","updated":"2020-10-28T11:51:48.932Z","comments":true,"path":"2020/10/28/数据库原理 第五章 数据库完整性/","link":"","permalink":"http://yoursite.com/2020/10/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/","excerpt":"","text":"数据库完整性 什么是数据库完整性 数据库完整性(integrity)：数据的正确性和相容性 维护数据库完整性功能组成 完整性约束机制：实体完整性、参照完整性、用户定义完整性等 完整性检查方法：一般在增删改查或事务操作前后进行 违约处理：not action(拒绝)，cascad(级联)，nullifies (置空) 实体完整性 定义：create table 中的 primary key定义(列级/表级) 1234create table Student( Sno char(9) /*primary key*/, /*列级定义*/ primary key(Sno) /*表级定义*/); 完整性检查 检查主码值是否唯一，若不唯一拒绝插入与更新 检查主码个属性是否为空，存在一个空，则同样拒绝操作 违约处理：对于主键冲突，违约系统默认一概NOT ACTION(拒绝)处理 参照完整性 定义：create table 中的 foreign key() references定义(表级) 完整性检查与违约处理 隐式处理(默认策略)：NOT ACTION(拒绝) 显示处理(自定义违约处理方式)： 应用场景：只有被参照表(外码表)才可显示定义违约处理策略，即只允许在 foreign key 授权语句后追加，不可写在其他地方，且仅限于update与delete操作 语句格式：[表级定义权限约束 &lt;空格&gt;] ON &lt;违约操作&gt; &lt;违约处理&gt; &lt;违约操作&gt;：且限于 update、delete &lt;违约处理&gt;：拒绝(NO ACTION)，级联(CASCADE)，置空(NULLIFIES) 级联操作：若删除的参照表的数据在其他表被引用，连同删除 12345create table Student( ... primary key(Sno,Cno), /*只允许在foreign key 后追加显示违约处理*/ foreign key(Sno) references Student(Sno) on delete cascade on update cascade); 用户定义的完整性 定义：用户可对具体列(字段)进行约束，一般分为两种 属性上的约束条件：可对单个列级属性进行约束 元组上的约束条件：可对多个列级属性进行约束，完整性约束限制类型同上 完整性约束：限制类型含，not null(非空)，unique(唯一)，check&lt;条件表达式&gt;) 1234567create table SC( Sno char(9) not null, Sname varchar(10) not null, Ssex char(2) check(Ssex IN(&#x27;男&#x27;,&#x27;女&#x27;)), Sgrade samllint check(Sgrade &gt;=0 AND Sgrade &lt;= 100), CHECK(Ssex = &#x27;女&#x27; OR Sname NOT LIKE &#x27;Ms.%&#x27;)/*同时约束多个列*/) 违约处理：系统统一采取**拒绝(NOT ACTION)**处理 完整性约束命名子句概念与子句的创建 前言：上述所有约束都是在create table时设置，若需要修改约束，难道只能重新建表？ 命名子句：在create table设置约束时为每个约束操作命名，后序修改或删除约束可通过操作这个命名 子句格式：constraint &lt;完整性约束条件名&gt;&lt;完整性约束条件&gt; &lt;完整性约束条件&gt;包含：primary key、foreign key，not null、unique、check 1234create table Student( Sno int constraint c1 check(Sno &gt;= 9000 AND Sno &lt;= 9999),/*列级操作*/ constraint StudentKey primary key(Sno) /*表级操作示例*/); 修改完整性限制 使用环境：在 alter table 语句下进行修改(add、drop) 语句格式：`&lt;add | drop&gt; constraint &lt;完整性约束子句名 | 完整性约束子句&gt; 1234567alter table Student drop constraint c1; /*删除Student表中名为c1的完整性约束*/ alter table Student /*在Student表中添加新的完整性约束子句*/ add constraint Sno_domain check(Sno &gt;= 9000 AND Sno &lt;= 9999); /*若想修改约束，则只能先删除约束再添加过新的约束*/ 触发器 定义：触发器(trigger)，由事件驱动的特殊过程(事件-&gt;条件-&gt;动作) 创建触发器：[ 事件(触发时机) -&gt; 条件(触发条件) -&gt; 动作(存储过程)] 12345create trigger &lt;触发器名&gt;&lt;before | after&gt; &lt;触发事件&gt; on &lt;表名&gt; /*定义触发的时机*/referencing &lt;new|old&gt; row as&lt;变量&gt; /*通过referencing引出变量*/for each&lt;row | statement&gt; /*指明动作体执行的频率*/[when &lt;触发条件&gt;]&lt;触发动作体&gt; 只有创建表的用户才能在此表上创建触发器，而且数量有限，具体数量由数据库管理系统本身设计所定 触发器名：必须唯一 表名：只能是基本表，不能是视图 触发事件： 触发时机：可在语句执行前before，或执行后after 操作类型：可以是增删改查，事务等操作，如insert，delete，update… 事件组合：可以单一事件，可组合，insert or delete，或指定列触发 update of &lt;触发列,…&gt; 触发器类型： 语句级触发器(for each statement)：执行完这条语句后且符合触发条件才会调用触发器(有可能这条语句已经操作了若干行数 据)，因此语句级触发器是不允许通过referencing引出变量new或者old row数据的 行级触发器(for each row)：相反，行级触发器，当检查到一行数据符合触发条件就会调用触发器。因为数据行是确定的，所 以可以通过referencing 引出变量new | row的数据 触发条件：触发条件的书写即&lt;条件表达式&gt;的书写 触发动作体：匿名PL/SQL过程块，也可以是存储过程 12/*当对表SC的Grade属性进行修改时，若分数增加了10%，则将此次操作记录到另一个表SC_U(Sno、Cno、Oldgrade、Newgrade)中，其中Oldgrade是修改前的分数，Newgrade是修改后的分数。*/create trigger SC_T 触发器的激活机制： 同一表上的多个触发器按，执行before触发器—&gt; 激活sql语句 —&gt; 执行after触发器流程触发 对于相同的触发器类型的触发器，遵循“谁先创建谁先执行原则”，有些DBMS按触发器名称字母排序。 删除触发器：drop trigger &lt;触发器名&gt; on &lt;表名&gt;","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库原理 第六章  关系数据理论","slug":"数据库原理 第六章 关系数据理论","date":"2020-10-28T01:11:32.000Z","updated":"2020-11-04T07:52:04.851Z","comments":true,"path":"2020/10/28/数据库原理 第六章 关系数据理论/","link":"","permalink":"http://yoursite.com/2020/10/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%20%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/","excerpt":"","text":"关系数据理论范式与范式之间的关系 低级范式可通过分解转换为若干个高一级方式的关系模式的集合 高一级的范式必是必定是低一级范式 包含关系， 1NF 插入异常：Cno初始无，但为码 删除异常：Cno，删除，连累其他数据 修改复杂：存储冗余，修改复杂 2NF 小结：部分函数依赖 依赖定义——&gt;常见依赖特性 == 完全函数依赖，按照依赖的标准定义能体现出，现实世界必定存在依赖关系，而完全性依赖必定存在若干不同且唯一元组(即数据冗余情况最严重(这里应该就不叫冗余了…是必要的))。若让这种情况(完全性依赖)混在其非主属性中(部分函数依赖)，则必定存在一个问题——&gt;存储冗余，而这种存储的冗余而引发的一系列异常如下 存储冗余：不符合完全函数依赖的非主属性必定产生存储冗余 修改复杂化：而当对存储冗余数据本身进行修改自然会呈现出修改的复杂化 对非冗余(符合完全函数依赖/部分函数依赖中非依赖子集)进行删除操作的时候，出现删除异常(删除了同一关系下不符合完全函数依赖的属性) 角度2： 对原本就具备完全函数依赖的关系影响 删除异常：进行删除操作的时候，出现删除异常(删除了同一关系下不符合完全函数依赖的属性) 对不符合完全函数依赖(部分函数依赖)异常 存储冗余：不符合完全函数依赖的非主属性必定产生存储冗余 修改复杂化：而当对存储冗余数据本身进行修改自然会呈现出修改的复杂化 解决方案：投影分解， 3NF 在2NF基础上消除传递函数依赖 BCNF(修正/扩充的第三范式) 全是非平凡的函数依赖 小明，老1，物理 小东，老1，物理 传递函数依赖，同样是会产生存储冗余，(因为2NF不存在完全函数依赖与部分函数依赖的相互影响，因此不存在删除异常)，进而出现存储冗余与与之衍生的修改复杂化 多值依赖 判定方法：对于任意关系中，如果存在两个元组（就是行），记为A,B，如果他们的某一属性X的值相等，那么我们交换它们另外的其中一个属性Y的值后，得到的新的两个元组，这两个元组在原来的表中是可以找到的 整个小结： 劣势依赖：部分函数依赖、传递函数依赖 其实按最基本的依赖关系，去建立数据库就基本符合常规规范 出现部分函数依赖侧面表明该关系中，属性间的关系并非完全依赖，按照 Sdept、 Sloc部分函数依赖 将一个1NF关系分解为多个2NF的关系，并不能完全消除关系模式中的各种异常情况和数据冗余 不能说规范化程度越高的关系模式就越好在设计数据库模式结构时，必须对现实世界的实际情况和用户应用需求作进一步分析，确定一个合适的、能够反映现实世界的模式上面的规范化步骤可以在其中任何一步终止 规范化理论为数据库设计提供了理论的指南和工具也仅仅是指南和工具 并不是规范化程度越高，模式就越好必须结合应用环境和现实世界的具体情况合理地选择数据库模式 反规范化设计：规范化数据将导致数据库中产生更多的表，这些表的结构优化了数据变更性能，但是在有些情况却大大降低了数据查询效率。在这种情况下，通过引进额外的列或额外的表将有助于提高数据查询能力。在表格中有意识的引入一定的数据冗余以改进性能被称为反规范化。反规范化是查询效率与数据冗余的折中。","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"算法积累","slug":"算法积累","date":"2020-10-22T09:12:32.000Z","updated":"2021-03-05T02:42:06.502Z","comments":true,"path":"2020/10/22/算法积累/","link":"","permalink":"http://yoursite.com/2020/10/22/%E7%AE%97%E6%B3%95%E7%A7%AF%E7%B4%AF/","excerpt":"","text":"顺序表排序递增减序 冒泡排序 选择法 逆置 头尾交换 查找最值 暂存变量挨个比较 找子序列 BF算法思维：第二章线性表P67-8 KMP算法 删除删除所有指定数值O(n) 单数组就地过滤重塑：第二章线性表P66~P67(2,11) 题目： 123456789101112131415161718192021/*伪代码： 1.用k记录顺序表中不等于x的元素个数，即需要保存的元素个数， 2.边扫描L边统计k，并将不等于x的元素放在L.data[k]中，最后修改L的长度。 时间复杂度：O(n)，空间复杂度：O(1)函数说明： 功能：删除顺序表所有指定的数值 SeqList&lt;DataType&gt; *L : 顺序表指针变量 int x : 删除数值*/template&lt;typename DataType&gt;void deleteAll(SeqList&lt;DataType&gt; *L, int x) &#123; int i, k = 0; //k用于数组重组的下标变量(新下标) for (i = 0; i &lt; L-&gt;length; i++) &#123; if (L-&gt;data[i] != x) &#123; //非条件值，非过滤参与重组 L-&gt;data[k] = L-&gt;data[i]; k++; &#125; &#125; L-&gt;length = k;//修改顺序表长度&#125; 单链表排序1234567891011121314151617181920212223242526272829303132//三个数num1，num2，num3，通过if-else结构从小到大排序，/*伪代码： 1. 先比较两个数，如num1 &gt; num2 2. 若num1 &gt; num2，则num3的位置只能在 小__num2__num1__大 三个下划线之中。 2.1 若num3比最大(num1)的还大，则在最右(最大)，若比最小的还小(num2) 则在最左边(最小)，否则，else情况就在中间 3. 若num2 &gt; num1，则num3的位置只能在 小__num1__num2__大，后同理上*/public class BranchTest&#123; public static void main(String[]args)&#123; int num1 = -193,num2 = -23,num3 = 221; if(num1 &gt; num2)&#123; if(num3 &gt; num1)&#123; System.out.println(num2 + &quot;, &quot; + num1 + &quot;, &quot; + num3); &#125;else if(num3 &lt; num2)&#123; System.out.println(num3 + &quot;, &quot; + num2 + &quot;, &quot; + num1); &#125;else&#123; System.out.println(num2 + &quot;, &quot; + num3 + &quot;, &quot; + num1); &#125; &#125;else&#123; if(num3 &gt; num2)&#123; System.out.println(num1 + &quot;, &quot; + num2 + &quot;, &quot; + num3); &#125;else if(num3 &lt; num1)&#123; System.out.println(num3 + &quot;, &quot; + num1 + &quot;, &quot; + num2); &#125;else&#123; System.out.println(num1 + &quot;, &quot; + num3 + &quot;, &quot; + num2); &#125; &#125; &#125;&#125; 逆置O(n) 头插法： 凡会在操作过程是失去(链接/追踪)，可以用变量追随暂存 1234567891011121314151617181920212223242526/*伪代码： 1. 设定两个工作指针(用于遍历指针、用于记录遍历指针下一个指针的指针) 2. 通过遍历指针遍历每一个指针，将遍历到指针通过头插法的形式重新生成链表实现逆序 3. 在 2. 操作执行头插法之前需要先记录以下即将取出用于插入结点的下一个结点，否则会失去连接 时间复杂度：O(n)，空间复杂度：O(1);函数说明 LinkList&lt;DataType&gt; *L : 单链表指针*/template&lt;typename DataType&gt;void reverseLinkList(LinkList&lt;DataType&gt; *L) &#123; Node&lt;DataType&gt; *p, *q; p = q = L-&gt;first-&gt;next; L-&gt;first-&gt;next = nullptr; while (p!= nullptr) &#123; q = p; p = p-&gt;next; q-&gt;next = L-&gt;first-&gt;next; L-&gt;first-&gt;next = q; &#125;&#125; 递增减输出并释放 重复使用“暂存变量挨个比较” 查找删除循环链表排序查找对称性判断 头尾同步相近判断，各自到达头节点结束 12345678910111213141516171819202122232425/* 伪代码： 1. 创建两个工作指针，head指向第一个结点，rear指向尾部结点 2. 头尾向中间靠拢判断是否相等 3. 两个指针都移置头结点表示允许结束(兼容奇偶数量对称判断) 函数说明： CDulLinkList&lt;DataType&gt; *L : 循环双链表指针*/template&lt;typename DataType&gt;bool isSymmetric(CDulLinkList&lt;DataType&gt; *L) &#123; DulNode&lt;DataType&gt; *head, *rear; head = L-&gt;first-&gt;next; rear = L-&gt;first-&gt;prior; while (head != L-&gt;first &amp;&amp; rear != L-&gt;first) &#123; if (head-&gt;data != rear-&gt;data) return false; head = head-&gt;next; rear = rear-&gt;prior; &#125; return true;&#125; 删除","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"SQL总结","slug":"SQL总结","date":"2020-10-22T08:21:32.000Z","updated":"2020-10-30T14:02:28.253Z","comments":true,"path":"2020/10/22/SQL总结/","link":"","permalink":"http://yoursite.com/2020/10/22/SQL%E6%80%BB%E7%BB%93/","excerpt":"","text":"数据库操作创建数据库 12create schema &lt;数据库名&gt; authorization &lt;用户名&gt; [内嵌定义];[内嵌定义] ：[&lt;表创建子句&gt;|&lt;视图创建子句&gt;|&lt;授权定义子句&gt;] 删除数据库 1drop schema &lt;数据库名&gt; &lt;cascade|restrict&gt; 数据表操作创建表 1234567create table &lt;表名&gt;(&lt;字段定义&gt;);&lt;字段定义&gt;：( &lt;列名&gt;&lt;数据类型&gt;[列级完整性约束] [, &lt;列名&gt;&lt;数据类型&gt;[列级完整性约束] ] … [, &lt;表级完整性约束&gt;] ) 修改表 12345678alter table&lt;表名&gt; [add[column] &lt;新列名&gt;&lt;数据类型&gt;[列级完整性约束] ] [add &lt;表级完整性约束&gt;] /*ADD **UNIQUE(Name)** */ [drop [column] &lt;列名&gt;[cascade|restrict] ] [drop constraint &lt;完整性约束**名**&gt;[cascade|restrict]] [alter column &lt;已存在列名&gt;&lt;新数据类型&gt;] 删除表 1drop table &lt;表名&gt;[restrict|cascade]; DQL语言12345select [all|distinct]&lt;目标列表达式&gt; [,&lt;目标列表达式&gt;]…from &lt;表/视图名&gt;[,&lt;表/视图名&gt;…][where &lt;条件表达式&gt;][group by &lt;列名1&gt; [having&lt;条件表达式&gt;]][order by &lt;列名2&gt; [asc|desc]]; &lt;目标列表达式&gt;：控制取某字段、字段别名、’常量列’、运算式、调用函数 调用函数：count(*)、sum、avg、max、min。均可选择count( [distinct | all] &lt;列名&gt;) &lt;条件表达式&gt;： =，&gt;，&lt;，&gt;=，&lt;=，!=，&lt;&gt;，!&gt;，!&lt; ; NOT + 上述比较运算符 范围：between and、not between and： &lt;字段名&gt;between &lt;值1&gt;and&lt;值2&gt;; 集合：in，not in ：&lt;字段名&gt; in (&lt;数据集合|子查询&gt;); 字符匹配：like、not like ：&lt;字段名&gt; like ‘&lt;匹配串&gt;’; [ESCAPE ‘&lt;换转义符字符&gt;’] 空值：is null、is not null ：&lt;字段名&gt;is null; 条件：and、or、not：&lt;条件表达式&gt; AND &lt;条件表达式&gt;; DL高级查询DQL高级查询：子查询、连接查询、集合查询 子查询(嵌套查询)12select…from…where &lt;字段&gt;&lt;子查询谓词&gt;(&lt;查询块&gt;)&lt;查询块&gt;：select…from…where &lt;子查询谓词&gt;：in、比较运算符、比较运算符+any/some,all、exists any，&lt;all等…，(any：某个值、all：所有值) exists：不返回任何数据，只产生逻辑真假“true/false” 连接查询 连接查询：等值、非等值、自连接、外连接(左外右外) 连接查询：from 多表 + 表名点取字段 + 别名设计 + 连接谓词 等值连接等值连接查询：连接条件/谓词使用 “=” 符号 12from &lt;表1&gt;[,表2]…where &lt;表1&gt;.&lt;字段&gt; = &lt;表2&gt;.&lt;字段&gt;… 非等值连接查询非等值连接查询：连接条件/谓词不是使用 “=” 符号 自身连接查询自身连接查询：同一个表设置不同的别名 123select&lt;别名1&gt;.&lt;字段1&gt;,&lt;别名2&gt;.&lt;字段2&gt;from&lt;表名1&gt;.&lt;别名1&gt;,&lt;表名2&gt;.&lt;别名2&gt;where &lt;别名1&gt;.&lt;字段2&gt;=&lt;别名2&gt;.&lt;字段1&gt; 外连接查询12from &lt;表1&gt; left outer join &lt;表2&gt; on(&lt;连接条件&gt;) /*左外(保留左表数据)*/from &lt;表1&gt; right outer join &lt;表2&gt; on(&lt;连接条件&gt;) /* 右外(保留右表数据) */ 集合查询12&lt;查询块集合1&gt; &lt;集合查询谓词&gt; &lt;查询块集合2&gt;&lt;集合查询谓词&gt;：交操作intersect，并操作union，差(集)操作except DML语言：​ 插入 1insert into&lt;表名&gt;[(&lt;属性列1[,属性列2]&gt;…)] values(&lt;常量1&gt;[,&lt;常量2&gt;…); 若不写字段，则必须按序写完value参数 插入多条语句values(),(),()… 允许空的字段，value值可用null占位 若填写了属性列表，则value部分必须一一对应(数量上，类型上)。且属性列表不一定按序，可自动识别字段名，但数据要和字段名对应。 子查询插入 1insert into &lt;表名&gt;[(&lt;属性列1[,属性列2]&gt;…)] &lt;子查询&gt; 通过子查询的形式不用写value，但子查询字段同样需要对应属性列信息 ​ 修改 12update &lt;表名&gt; set &lt;列名&gt; = &lt;表达式&gt;[,&lt;列名&gt; = &lt;表达式&gt;][where &lt;条件&gt;] ​ 删除 1delete from &lt;表名&gt; [where &lt;条件&gt;]; 视图123create view &lt;视图名&gt; [(&lt;列名&gt;[,&lt;列名&gt;]…)]as &lt;子查询&gt;[with check option] ​ # 数据库安全性 以下均为自主存储控制方法 授予权限1234grant &lt;权限/操作类型&gt;[,权限]...on &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]... /*一般为： Table &lt;表名&gt;*/to &lt;用户&gt;[,&lt;用户&gt;]... /*注意：授予权限给用户前需存在这个用户(新建或原本存在)*/[with grant option] example： 1234/*把查询Student表的权限授给用户U1*/grant SELECTon TABLE Studentto U1; &lt;权限/操作类型&gt;：即为用户授予哪些操作 可控制操作权限类型 具体语句 数据库 create schema 数据表 create table，alter table 视图 create view 索引 create index 基本表和视图 select，insert，update，delete，references，all privileges(所有权限) 属性列 select，insert，update，references，all privileges &lt;对象类型&gt; &lt;对象名&gt;：一般最大是表级限制。即 Table &lt;表名&gt; &lt;用户&gt;：若不存在指定用户需要先建立用户才能进行对应的授权操作，sql server2008 R2 环境下创建新用户步骤如下： 创建指定数据库的用户需要与这个用户的登录用户绑定：即想建立用户，必须先建立这个用户对应的登录用户 创建新登录用户 打开sql server，连接数据库后。找到根目录下的“安全性”文件夹。 选中“登录名”文件夹并右键点击“新建登录名” 设置登录名，并选择“sql server 身份验证”，设置密码(自己记住)。 最后把“强制密码过期(x)**”的勾选去除**，最后点击右下加确认按钮保存即可 创建用户 进入到需创建用户的数据库文件夹内，找到指定数据库目录下的“安全性”文件夹 此时在选中“安全性”文件夹后右键——&gt;新建——&gt;用户(U) 输入用户名，可自定义(但一般与对应的登录用户名一致) 点击在“登录名”输入栏最右边的“**[…]”按钮，展开后右边点击“浏览”，勾选刚刚建立的新登录用户名**，最后点击左下角确认按钮保存即可。 [with grant option]：若使用该子句，获得权限的用户可以将次权限传递授予给其他用户，默认不允许。且SQL标准不允许循环授权 实操备注： 有别于教材，当前环境添加&lt;对象类型&gt;即table关键字会报错 当前环境grant语句一次性只允许向一个表授权，可同时向多个用户授权 收回权限数据库完整性数据库完整性指：数据的正确性与相容性","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"}]},{"title":"数据结构 第五章 树、森林&与二叉树的转换","slug":"数据结构 第五章 树、森林&与二叉树的转换","date":"2020-10-21T07:16:32.000Z","updated":"2021-01-13T14:48:49.987Z","comments":true,"path":"2020/10/21/数据结构 第五章 树、森林&与二叉树的转换/","link":"","permalink":"http://yoursite.com/2020/10/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97&%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲二叉树、树、森林之间转换树、森林的结构类似复杂多样，不方便设计统一的算法。因此转换为二叉树统一处理 树转换为二叉树树“加兄保子调层次” 加线：所有兄弟节点之间加一条线 去线：对于树中每个结点，只保留 firstchild的连线，其余均删除 层次调整： 文字概述：以原树结构为基准，从根结点开始，第一个孩子为根结点的左孩子，而其余兄弟结点(以原树结构为基准)均为这个左孩子的右孩子(孙子…反之一直右下衍生) 图形化理解：从上到下以原树为基准每个子树除第一个孩子为左孩子外，其余均为这个左孩子的右孩子延续 红色为根节点 蓝色为根节点下第一个孩子 绿色为以原树基准的非首孩子的其他孩子 二叉树转换为树完全倒序操作：加兄保子调层次，调层次保子加兄，再逆序，保子(不保子：加次子/加右孩)，加兄(去兄：去右孩子) “加子去右调层次” 加线：若某个左孩子结点存在，则将这个左孩子的所有右孩子结点都与该左孩子的双亲结点相连 去线：去除所有结点的右孩子结点的连线 层次调整：外貌调整 森林转换为二叉树“森林变树，依次连根” 把森林的每颗树都转换为二叉树 第一颗树不动，其余树依次为上一课树的根节点的右孩子。 二叉树转换为森林“有右即分转森林，无右二叉只变树” 二叉树有可能转换成一棵树也有可能转换成森林 “有右即分”：若二叉树存在右孩子，则将其分离出来，若分离后的二叉树还存在右孩子则继续分离，直至不存在有右孩子的二叉树。 再把每一颗二叉树都转换为树即可。 赫夫曼树(哈夫曼)及其应用赫夫曼树(哈夫曼)树又称为最优二叉树 赫夫曼树的优化思想赫夫曼树的定义赫夫曼树编码 树、森林复杂，转换为二叉树处理 树转换为二叉树 二叉树转换为树 森林(森林-&gt;树)转换为二叉树 二叉树转换为森林 树与森林的遍历：先根、后根。前序，后序 二叉树的应用，赫夫曼树(最优二叉树) 引入：让单一线性的区分结构——&gt;通过权/频率——&gt;用二叉树来体现权的表示，从而实现路径长度上的优化。 而这种路径的优化，在代码执行上缩短总的执行次数。而在存储空间上可以应用在设计长短不等的编码，在通过编码的层面上实现无损的数据压缩(赫夫曼编码) 基本概念：路径长度、树的路径长度、带权路径长度 二叉树转换为赫夫曼树(最优二叉树) 赫夫曼编码(赫夫曼编码转换过程) 材料：字符集，权 画出最优二叉树 左分支代表0，右分支代表1，并实现其前缀编码。","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 第六章 树","slug":"数据结构 第六章 树","date":"2020-10-21T07:11:32.000Z","updated":"2020-10-24T14:08:16.815Z","comments":true,"path":"2020/10/21/数据结构 第六章 树/","link":"","permalink":"http://yoursite.com/2020/10/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%A0%91/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲 树的定义 树的相关概念 树的存储结构 二叉树 二叉树的性质 树的定义 树(Tree)是n(n ≥ 0)个结点的有限集，n = 0则为空树 在任意一颗树中，有且仅有一个称为根(Root)的结点 当结点 n &gt; 1，其余结点可分为m个互不相交的有限集T1、T2、…Tm 其中每个互不相交的有限集本身又是一颗树，并称为根的子树(SubTree) 核心：有且仅有一个称为根**整个树的根结点唯一，子树互不相交 树的相关概念结点类型度(Degree)：结点 拥有的子树的数量，所有结点最大的度称为该数的度 叶结点(Leaf)或终端节点：度 = 0； 非终端结点或分支结点：度 ≠ 0；，此类结点除根结点外，也可称为内部结点 结点间的关系 孩子(Child) 与 双亲(Parent) ：结点的子树的根称为该结点的孩子(Child)，相应地，该节点称为孩子的双亲 兄弟(Sibling)：同一个双亲的孩子之间互称兄弟 祖先：结点的祖先是从根到该结点所经历分支上的所有结点 子孙：以某结点为根，的子树中的任一结点都称为该结点的子孙 其他概念 层次(Level)：从根开始定义，根为第一层 堂兄弟：双亲在同一层结点 深度(Depth)或高度：树种结点最大的层次，称为树的深度 宽度：每一层结点个数的最大值 路径：略 树的类型 森林(forest)：是m颗(m≥0)颗互不相交的树的集合。对树种的每个结点而言，其子树的集合即为森林 有序树 与 无序树： 树的存储结构有别于线性表，树是一对多的结构，无论哪一种顺序存储结构的不能体现出这个关系，所以必须与链式存储结构结合起来表示。 双亲表示法 孩子表示法 孩子兄弟表示法 双亲表示法实现12345678910111213141516/* 树的双亲表示法结点结构定义 */#define MAX_TREE_SIZE 100/* 树结点的数据类型，目前暂定为整型 */typedef int TElemType; /* 结点结构 */typedef struct PTNode&#123; TElemType data; /* 结点数据 */ int parent; /* 双亲位置 */ &#125; PTNode;/* 树结构 */typedef struct&#123; PTNode nodes[MAX_TREE_SIZE]; /* 结点数组 */ int r, n; /* 根的位置和结点数 */ &#125; PTree; 孩子表示法实现12345678910111213141516171819/* 树的孩子表示法结构定义 */#define MAX_TREE_SIZE 100/* 孩子结点 */typedef struct CTNode&#123; int child; struct CTNode *next;&#125; *ChildPtr;/* 表头结构 */typedef struct&#123; TElemType data; ChildPtr firstchild;&#125; CTBox;/* 树结构 */typedef struct&#123; CTBox nodes[MAX_TREE_SIZE]; /* 结点数组 */ int r,n; /* 根的位置和结点数 */ &#125; CTree; 孩子兄弟表示法实现12345/* 树的孩子兄弟表示法结构定义 */typedef struct CSNode&#123; TElemType data; struct CSNode *firstchild,*rightsib;&#125; CSNode, *CSTree; 树的遍历树的遍历：按照某种次序，访问树中所有结点，且每个结点有且只有一次被访问。若规定从左到右遍历，树的遍历一般存在三种 前序(根)遍历 后序(根)遍历 层序(跟)遍历 tips：若树为二叉树，则还有一种中序遍历 注意： 前提规定“从左到右”表示，无论哪种遍历，都是决定从左子树，到右子树 前序遍历​ 从根节点开始遍历，从上到下，按先左子树，后右子树的顺序遍历每一颗子树 后序遍历​ 从根结点出发(不遍历)，从下到上，同样按先左子树，后右子树的顺序遍历每一颗子树。最后再遍历每颗子树的根结点 层序遍历/广度遍历​ 从根结点开始，自上而下，从左到右，逐层遍历 ### 前序遍历 访问树的根结点 从左到右的顺序前序遍历(从上到下)，遍历分别为根结点的每一颗子树 访问根结点，从左到右遍历根结点的孩子，若孩子又存在子树(即根节点)，从1开始循环 后序遍历 从左到右的顺序后序遍历(从下到上)，遍历分别为根结点的每一颗子树 最后访问根结点 从左到右，从下到上，即从最下底层左子树开始，从左到右遍历。每颗子树的根结点总是最后遍历 二叉树二叉树的定义 二叉树(Binary Tree)的每个结点最多只有两颗子树(即可以没有子树，或者有一颗也行，即树的度最大为2) 左子树和右子树是有顺序的，注意区别。因此二叉树存在五种基本状态 空二叉树 只有一个根节点 根结点只有左子树 根结点只有右子树 根结点既有左子树又有右子树 特殊二叉树 斜树 满二叉树 完全二叉树 斜树 左斜树：所有结点都只有左子树 右斜树：所有结点都只有左子树 斜树特点总结：每一层都只有一个结点，结点的个数与二叉树的深度相同。 满二叉树 所有分支结点都存在左子树和右子树 所有叶结点都在同一层 完全二叉树判断方法1： 一颗具有n个结点的二叉树按层序编号(从上到下，从左到右，) 每个结点按照满二叉树的结构逐层顺序编号，如果编号出现空挡，就说明不是完全二叉树，否则就是 判单方法2： 如果二叉树中除去最后一层节点为满二叉树，且最后一层的每个结点依次从左到右分布，则此二叉树被称为完全二叉树。 特点：满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树 二叉树的性质注意：以下二叉树性质，均以1开始从上到下，从左到右编号 二叉树性质1性质1：在二叉树的第 i 层上至多有 2i-1个结点 ( i ≥ 1)，即单层上的至多节点数。 解析：纯数量关系推导 二叉树的性质2性质2：深度为k的二叉树至多有 2k-1 个结点( k ≥ 1) 解析：纯数量关系推导 二叉树的性质3性质3：对于任何一颗二叉树T，如果其终端结点数为n0，度为2的结点数为n2。则n0 = n2 +1 即，所有叶结点数 = 所有根节点数 + 1 二叉树的性质4性质4：具有n个结点得完全二叉树的深度为 |_ log2n _| + 1 (|__ x _|)表示不大于x的最大整数 解析：暂时略《数据结构》从概念到C++的实现，王红梅 P137 二叉树的性质5性质5：具有n个结点完全二叉树存在如下性质 如果 i = 1，则结点 i 是二叉树的根；如果 i &gt; 1，则双亲结点是 i/2」 如果 2i &gt; n，则结点 i 无左孩子，即结点i为叶结点。反之 2i &lt; n 则i结点的左孩子是2i 如果 2i + 1 &gt; n，则结点 i 无右孩子，反之其右孩子是结点 2i + 1 正序的先左到底后右 也是先左到底，但是从左到底处出发，先左后右 二叉树的存储结构顺序存储结构设计由于二叉树定义严格，是一种特殊的树，所以可以仅使用顺序存储结构实现，仅通过数组下标的数量关系就能体现结点之间的逻辑关系 将二叉树从根节点编号为1开始，从上到小，左到右全部编号。直接按序存入数组，若是非完全二叉树，缺少部分填入空指针，但序号依然按照完全二叉树的顺序编号。 对于完全二叉树，数组下标的数量关系足够体现结点的所有逻辑关系(双亲，孩子，兄弟) 对于非完全二叉树/一般二叉树，按完全二叉树顺序编号，空缺部分均填入空指针 性能若二叉树表现出一条深度为k的 左/右斜树，则需开辟 2k-1 个空间存储，造成大量空间的浪费，因此二叉树的顺序存储结构一般只用于完全二叉树 链式存储结构 二叉链表：由于二叉表每个结点最多只有两个孩子，则一个数据域 + 两个 指针域(左右孩子)的存储结构 三叉链表：data + parent + lchild + rchild 12345/* 二叉树的二叉链表结点结构定义 */typedef struct BiTNode&#123; TElemType data; /* 数据域*/ struct BiTNode *lchild,*rchild; /* 左右孩子指针 */&#125;BiTNode,*BiTree; 遍历二叉树前言二叉树的遍历不同于线性表，即使确保“从根结点出发，依次访问二叉树的所有结点”，对于每个结点都可以有不同的选择，从而遍历的次序完全不一样。因此，可得出两个角度： 鉴于二叉树存在多种遍历次序，通常将其限制从左到右的习惯方式遍历。 鉴于可存在多种遍历次序，且处理困难，而计算机只能处理线性序列(循环,判断)**，通常利用与树的递归定义相同的递归方式来遍历。某种意义上将树的结点遍历变成线性序列** 二叉树的遍历方法限制按从左到右遍历的，会存在四种遍历方式，前序遍历、中序遍历、后序遍历、层序遍历。 “限制从左到右”，即调用左子树的递归操作一定在，调用右子树的递归操作之前！ 前、中、后序遍历的意思是，输出语句相对在左右子树递归调用的前、中、后位置 注意：无论前、中、后、层序遍历都是从根节点开始。但，从根节点开始，不等于先输出根节点！ 前序(根)遍历 访问根结点 前序遍历根结点的左子树 前序遍历根结点的右子树 中序(根)遍历 中序遍历根结点的左子树 访问根结点 中序遍历根结点的右子树 后序(根)遍历 后序遍历根结点的左子树 后序遍历根结点的右子树 访问根结点 理解的演变： 大话数据结构代码版，通过递归代码去推演：复杂，慢，易错。唯一好处，更加理解递归-回推 课堂聆听1，上下左右顺序描述更加复杂，无效 课堂聆听2，教材描述。纯文字理解(内含递归) 关键： 除“从根结点开始”这个根结点特指root这一个结点外，其他描述中的“根结点”均指每一颗子树的根结点 xxx遍历法下的描述“xxx遍历根节点的x子树”，其实表示后面的子树用于定位，可以把文字中xxx的描述递归函数的调用，即回到定义的本身，重头开始执行。即把概念描述，和递归理念结合在一起 技巧： 前根遍历： 方式1：根左、根左…根右、根左… 方式2(快)：每一棵树都是先根再输出左右(结点嵌套根) 中序遍历： 技巧是，直接从root结点深度最大的左子数开始。遍历完root结点左子孙后再从右子孙中从深度最大左子树开始。直至遍历中序遍历全部结点 每一棵树都是左到底后，访问根，再去到下一个右结点(结点嵌套，即又每一颗数左道底后，访问根…)… 后序遍历： 根结点肯定是最后访问的，找到深度大，先左输出后右输出。然后依次嵌套重复 方式2(快)：从最底层开始，从下往上推。每一棵树都是根结点最后访问，先左后右(结点嵌套根) 遍历次序记忆关键： 优先采取“树的遍历”中对三种遍历次序的文字主观描述 其次结合三行代码的顺序，结合递归执行思想，去记忆 前序遍历算法12345678910/* 二叉树的前序遍历递归算法 *//* “前”序遍历，输出语句在左子树递归和右子树递归之前，即第一行 */void PreOrderTraverse(BiTree T)&#123; if(T == NULL) return; printf(&quot;%C&quot;,T-&gt;data); //先输出 PreOrderTraverse(T-&gt;lchild);//再左子树递归 PreOrderTraverse(T-&gt;rchild);//最后右边子树递归&#125; 前序遍历算法，遍历次序如下图所示：ABDGHCEIF 中序遍历12345678910/* 二叉树的中序遍历递归算法 *//* “中”序遍历，输出语句在左子树递归和右子树递归之“中”，即第二行 */void InOrderTraverse(BiTree T)&#123; if(T == NULL) return; InOrderTraverse(T-&gt;lchild);//先左子树递归 printf(&quot;%C&quot;,T-&gt;data); //再输出 InOrderTraverse(T-&gt;rchild);//最后右子树递归&#125; 中序遍历，遍历次序如下图所示：GDHBAEICF 后序遍历12345678910/* 二叉树的后序遍历递归算法 *//* “后”序遍历，输出语句在左子树递归和右子树递归之“后”，即最后行 */void PostOrderTraverse(BiTree T)&#123; if(T == NULL) return; PostOrderTraverse(T-&gt;lchild);//先左子树递归 PostOrderTraverse(T-&gt;rchild);//再右子树递归 printf(&quot;%C&quot;,T-&gt;data); //最后才输出&#125; 后序遍历，遍历次序如下图所示：GHDBIEFCA 层序遍历与前三种遍历方式不同，层序遍历更多是由人的主观遍历次序，到对应的代码的实现。而其他三种更倾向于代码的递归逻辑设计到实际的遍历次序。 实现逻辑 初始化：创建队列，根结点入队 若队列不为空，队头出队。让队头的左右孩子入队 以此循环第2步即可 推导二叉树的遍历结果推导逻辑：(具体案例细节可参详P184~P186) 确定根节点：从前序遍历(首位)，或后序遍历(尾) 循环推导 从某一遍历推导出的某一条件出发 使用上一轮得出的条件，与上一轮不同的遍历方式结合再推出一个新条件，以此循环 注意：一般每一轮会都要利用孩子集范围，缩减孩子集范围，作为判断的条件之一 经验总结： 必须含中序遍历的条件则才能唯一确定一颗二叉树 前序遍历，用于确定根后与中序遍历占位后，来确定左孩子(同时也确定子树的根，再中序域划分…) 中序遍历，主要用于，范围划分，且占位！ 后序遍历，只要用于，被划分范围后，确定根结点(范围尾部) 实战演示 二叉树的建立扩展二叉树为了能让每个结点确认是否有左右孩子，在二叉树建立前，将其每个结点的空指针处引出一个虚结点。这种扩展后的二叉树称为扩展二叉树 二叉树的建立二叉树的建立步骤如下 画出拟建立二叉树 画出对应的扩展二叉树 以某种遍历方式写出扩展二叉树的遍历次序 以同类型的遍历方式创建按次序输入实现二叉树的建立 123456789101112131415161718192021/* 按前序输入二叉树中结点的值（一个字符） *//* #表示空树，构造二叉链表表示二叉树T。 */void CreateBiTree(BiTree *T)&#123; TElemType ch = null; /* scanf(&quot;%c&quot;,&amp;ch); */ ch=str[index++]; if(ch==&#x27;#&#x27;) *T=NULL; else &#123; *T=(BiTree)malloc(sizeof(BiTNode)); if(!*T) exit(OVERFLOW); (*T)-&gt;data=ch; /* 生成根结点 */ CreateBiTree(&amp;(*T)-&gt;lchild); /* 构造左子树 */ CreateBiTree(&amp;(*T)-&gt;rchild); /* 构造右子树 */ &#125; &#125; **C++**实现： 12345678910111213141516template&lt;typename DataType&gt;BiNode&lt;DataType&gt;* BiTree&lt;DataType&gt;::Creat()&#123; //声明一个新结点 BiThrNode&lt;DataType&gt; *btn = nullptr; char ch; cin &gt;&gt; ch; if (ch != &#x27;#&#x27;)&#123; btn = new BiThrNode&lt;DataType&gt;; btn-&gt;data = ch; btn-&gt;lchild = Creat(); btn-&gt;rchild = Creat(); &#125; return btn;&#125; 线索二叉树 二叉树的链式存储会存在大量空指针域，n个结点的二叉树就会存在 n+1个空指针域。 可以利用这些空指针域存储以某种次序创建的二叉树结点之间的前驱后继指针信息。 指向前驱和后继的指针称为线索。加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树 二叉树以某种次序遍历使其变为线索二叉树的过程称做线索化**。 线索二叉树的存储结构为区分，rchild/lchild是指向线索还是指向树结构的指针，通过两个Tag枚举变量标志，Thread为线索指针，Link为树指针 123456789typedef enum &#123;Link,Thread&#125; PointerTag; /* Link==0表示指向左右孩子指针, */ /* Thread==1表示指向前驱或后继的线索 */typedef struct BiThrNode /* 二叉线索存储结点结构 */&#123; TElemType data; /* 结点数据 */ struct BiThrNode *lchild, *rchild; /* 左右孩子指针 */ PointerTag LTag; PointerTag RTag; /* 左右标志 */&#125; BiThrNode, *BiThrTree; 中序线索化通过中序遍历实现中序线索化。代码如下，需注意： 全局变量 pre 在外初始化为 root 线索二叉树初始化需把结点置为Link，因为中序线索化只修改Thread； 令某种次序序列中的第一个结点其lchild指向二叉树的根结点 12345678910111213141516171819202122232425262728293031323334//必须以全局变量的方式参与递归操作BiThrNode&lt;char&gt; *pre = nullptr;//中序线索化void InThreading(BiThrNode&lt;char&gt; *p) &#123; //左子树递归至最后结点(非null结点) if (p) &#123; InThreading(p-&gt;lchild); //(!p-&gt;lchild)：表若当前结点左孩子为null，则lchild(前驱)线索化， //即为pre结点 if (!p-&gt;lchild) &#123;//为null p-&gt;LTag = PoinTerTag::Thread; p-&gt;lchild = pre; &#125; //(!pre-&gt;rchild)：表，若当前结点遍历的上一个结点的rchild(后继)为null， //则线索化的后继结点，为当前结点p if (!pre-&gt;rchild) &#123;//为null pre-&gt;RTag = PoinTerTag::Thread; pre-&gt;rchild = p; &#125; pre = p;//存储以某种递归次序线索化(遍历)的上一个结点位置 //因为固定从左到右，所以pre用于LTag的lchild,也用于pre结点本身的有孩子线索化 InThreading(p-&gt;rchild); &#125;&#125;void main()&#123; BiThrTree&lt;char&gt; btt&#123;&#125;; //P189二叉树 ABDH##I##EJ###CF##G## //pre全局遍历的变量环境是 pre = root; pre = btt.root; InThreading(btt.root);&#125; 遍历线索二叉树线索二叉树与双向链表线索二叉树的结构类似双链表结构，因此为了方便线索二叉树的遍历等操作，对线索二叉树添加一个头结点。添加头结点这个操作常常在线索化的时候实现，因此要对上面的中序线索化代码的基础上稍作修改——添加一个头结点，并设定初始状体如下： 头结点的lchild域指向二叉树的根结点，rchild域指向遍历时访问的最后一个结点。 遍历的第一个元素的lchild域指向头结点，最后一个结点的rchild域同样指向头结点 123456789101112131415161718192021222324/* 备注：遍历代码是重点，而对线索化的改进代码。这个是次要，还未分析学习 *//* 中序遍历二叉树T,并将其中序线索化,Thrt指向头结点 */Status InOrderThreading(BiThrTree *Thrt,BiThrTree T)&#123; *Thrt=(BiThrTree)malloc(sizeof(BiThrNode)); if(!*Thrt) exit(OVERFLOW); (*Thrt)-&gt;LTag=Link; /* 建头结点 */ (*Thrt)-&gt;RTag=Thread; (*Thrt)-&gt;rchild=(*Thrt); /* 右指针回指 */ if(!T) /* 若二叉树空,则左指针回指 */ (*Thrt)-&gt;lchild=*Thrt; else &#123; (*Thrt)-&gt;lchild=T; pre=(*Thrt); InThreading(T); /* 中序遍历进行中序线索化 */ pre-&gt;rchild=*Thrt; pre-&gt;RTag=Thread; /* 最后一个结点线索化 */ (*Thrt)-&gt;rchild=pre; &#125; return OK;&#125; 中序遍历线索二叉树(非递归版) BiThrTree T 表示头结点，则按带头结点的线索化，p = T-&gt;lchild; 则表示p等于根结点 1234567891011121314151617181920/* 中序遍历二叉线索树T(头结点)的非递归算法 */Status InOrderTraverse_Thr(BiThrTree T)&#123; BiThrTree p; p=T-&gt;lchild; /* p指向根结点 */ while(p!=T)&#123; /* 空树或遍历结束时,p==T */ while(p-&gt;LTag==Link) p=p-&gt;lchild; if(!visit(p-&gt;data)) /* 访问其左子树为空的结点 */ return ERROR; while(p-&gt;RTag==Thread&amp;&amp;p-&gt;rchild!=T)&#123;//防空树操作 p=p-&gt;rchild; visit(p-&gt;data); /* 访问后继结点 */ &#125; p=p-&gt;rchild; &#125; return OK;&#125; 代码分析 这段代码相当于一个链表的扫描，所以时间复杂度O(n) 小结： 线索二叉树充分利用了二叉树链式存储结构的空指针域空间(节省空间)，仅需创建时的一次遍历就可终生受用的前驱后继信息(节省时间)。 若二叉树需要经常遍历或查找结点时需要某种遍历序列的前驱和后继，则线索二叉树的存储结构是非常不错的选择。","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2020-09-25T13:42:32.000Z","updated":"2020-09-26T01:23:59.406Z","comments":true,"path":"2020/09/25/冒泡排序/","link":"","permalink":"http://yoursite.com/2020/09/25/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","excerpt":"","text":"冒泡排序分析 每一轮交替比较把最值往**后排(下沉)**，能得出参与这次轮次所有数中的最值 首次交替次数：最后一个数无需交替比较。即循环下标结构 for(j = 0;j &lt; len - 1; j ++ ) 接下来继续开始若干次从头开始的交替，逐一把“第2最值”，“第3最值”…排到最后(下沉) 剩余轮次交替次数：每一次交替比较后的最值无需参与下一次交替比较，剩下轮次的交替比较次数呈递减1状态 总比较轮次：每一个数都需走一遍轮次。，最后交替(数组最前的数)只需一个轮次完成，即总论次为：len - 1 总结：理论支持每一轮交替比较把最值往**后排(下沉)**，能得出参与这次轮次所有数当中的最值 核心部分 把最值往后排(下沉) 从大到小，降序，后排下沉最小值，a[ j ] &lt; a[ j + 1 ] 从小到大，升序，后排下沉最大值，a[ j ] &gt; a[ j + 1 ] 数组内部比较交替次数： 首次比较交替次数：len - 1 即for(j = 0;j &lt; len - 1;j++) 剩下轮次比较交替次数：每经一个轮次，交替比较次数减1 整个完整排序的比较轮次：最后交替比较两个数(数组最前的两个数)只需一个轮次完成，len - 1。 代码表示 比较轮次属于外循环：len - 1 内部比较交替次数属于内循环：(首次)len - 1，(剩余)每一轮次，次数减1 从大到小，降序，则后排下沉最小值(a[j] 到 a[j + 1])比较 12345678910//外循环：比较轮次for(i = 0;i &lt; len - 1;i++)&#123; //数组遍历写法 i = 0; i &lt; len; i++ 正常遍历，len-1则少一次 //内循环：交替比较次数，递减1通过i增1来实现 for(j = 0;j &lt; len - 1 - i;j++)&#123; //实现从大到小，降序，后排下沉最小值，a[ j ] &lt; a[ j + 1 ] if(a[j] &lt; a[j + 1])//边界分析：i = 0，判断上溢d = j + 1，因为“&lt;”，所以j = (len-1) - 1，所以d = len - 1(没上溢) //交换位置 &#125;&#125; 时间复杂度分析 参考：https://zhuanlan.zhihu.com/p/66768445","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构 第五章 串","slug":"数据结构 第五章 串","date":"2020-09-25T09:12:32.000Z","updated":"2020-11-23T14:37:40.266Z","comments":true,"path":"2020/09/25/数据结构 第五章 串/","link":"","permalink":"http://yoursite.com/2020/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E4%B8%B2/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲串的定义串(String)：是由零个或多个字符组成的有限序列，又名叫字符串。 记为：s = “a1a2a3…an(n ≥0)” 串中的字符数目n称为串的长度 零个字符串称为空串(null string)即，“ ‘’” ” 序列即相邻字符之间存在前驱后继关系 主串与子串：串中任意个数的连续字符组成的子序列称为该串(主串)的子串 串的比较常用字符标准编码 标准ASCII编码：用7位二进制数表示128个字符 (可表示英语为主的语言) 扩展ASCII编码：用8位二进制数表示256个字符 (可表示英语为主的语言和特殊字符) Unicode编码：用16位二进制表示216个字符，约6.5万多个字符(足以表示全世界成百上千种语言和文字) 比较原则字符串的比较在计算机中取决于挨个字母的前后顺序，靠后的字母比靠前的字母要大。如“silly” &lt; “stupid” 存在字符串 s 与 t，若 s &gt; t，则存在如下两种情况： 情况1：“单纯地多出字母(包含关系)，则多出字母的字符常大”。如：“happy” &gt; “hap”，单纯多出“py” 情况2：“无包含关系，则挨个字母比较顺序，靠后比靠前大”。如：“happy” &gt; “happen”，匹配到第5个字母‘y’ &gt; ‘e’ 小结： 等长：挨个字母前后顺序比较 不等长 完全包含关系，多字母为大，happy &gt; hap 非包含完全包含关系，挨个字母比较，happy &gt; happen 串的抽象数据类型“串”从逻辑结构上和线性表很相似，但基本操作，串更倾向于查找子串位置，替换子串等 123456789101112131415161718192021222324ADT 串(string)Data 串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。Operation StrAssign(T, *chars): 生成一个其值等于字符串常量chars的串T。 StrCopy(T, S): 串S存在，由串S复制得串T。 ClearString(S): 串S存在，将串清空。 StringEmpty(S): 若串S为空，返回true，否则返回false。 StrLength(S): 返回串S的元素个数，即串的长度。 StrCompare(S, T): 若S&gt;T，返回值&gt;0，若S=T，返回0，若S&lt;T，返回值&lt;0。 Concat(T, S1, S2): 用T返回由S1和S2联接而成的新串。 SubString(Sub, S, pos, len): 串S存在，1≤pos≤StrLength(S)， 且0≤len≤StrLength(S)-pos+1，用Sub返 回串S的第pos个字符起长度为len的子串。 Index(S, T, pos): 串S和T存在，T是非空串，1≤pos≤StrLength(S)。 若主串S中存在和串T值相同的子串，则返回它在主串S中 第pos个字符之后第一次出现的位置，否则返回0。 Replace(S, T, V): 串S、T和V存在，T是非空串。用V替换主串S中出现的所有 与T相等的不重叠的子串。 StrInsert(S, pos, T): 串S和T存在，1≤pos≤StrLength(S)+1。 在串S的第pos个字符之前插入串T。 StrDelete(S, pos, len): 串S存在，1≤pos≤StrLength(S)-len+1。 从串S中删除第pos个字符起长度为len的子串。endADT 串的存储结构串的顺序存储结构 串的顺序存储结构一般用定长数组来定义 一般将串的长度值保存数组下标0处，有的也可存储在最后一个下标位置，或在串值后添加结束标记字符如“\\0”(数据结构面向人，一般与日常数数顺序为主) 串的操作常使得，串值存储空间需要动态变化。一般通过自由存储区——堆和相关操作函数(malloc/free)动态分配空间 串的链式存储结构串的链式存储结构因为用结点存储字符序列会浪费大量的空间，除连接串与串操作有一定方便外(只是方便/不是高效)**，总的来说，不如顺序存储灵活，性能也不如顺序存储结构好** BF算法BF算法，也叫朴素的模式匹配算法 串的模式匹配：即子串在主串中的定位操作，如S=”goodgoogle”，找到T=”google”这个子串的位置 匹配思路： 用子串从主串的第一位开始逐一字符匹配 若子串中任意一个字符匹配失败，则整个子串从上一次主串开始匹配的位置的下一个位置开始匹配 以此循环，直至存在子串的每一个字符均被匹配正确的情况 匹配思路图示如下：如S=”goodgoogle”，找到T=”google”这个子串的位置 tips：“|”竖线表示匹配成功，“⚡”表示匹配失败 第一步 第二步 ​ 3. 第三步 第四步 第五步 代码案例思路： 位置变量pos合法过滤 设置主串与子串循环开始索引(下标0表串长度，下标1是第一个字符 匹配循环结构结束条件(||关系，&amp;&amp;表达)：S[0],T[0]表示串长度，子串提前匹配成功，或主串全部被匹配完。则结束循环 若字符匹配成功，则主串与子串索引分别+1，否则主串匹配索引回退，子串索引初始化 若匹配成功(子串被全部匹配)，则计算位置并返回，否则返回错误提示 12345678910111213141516171819202122232425262728293031323334/* 返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。*//* T非空，1≤ pos ≤ StrLength(S)。*/int Index(String S,String T,int pos)&#123; //位置变量pos合法过滤 if (pos &lt; 1 || pos &gt; StrLength(S)) return ERROR; //设置主串与子串循环开始索引 int i = pos; int j = 1;//下标0用于存储字符串长度，下标1即是第一个字符的数组下标 //匹配循环结构结束条件：S[0],T[0]表示串长度，子串提前匹配成功，或主串全部被匹配完。则结束循环 //因，匹配次数 = 字符串长度 = (j - 1)，所以 等于“=”时也需执行 while(j &lt;= T[0] &amp;&amp; i &lt;= S[0])&#123;//&amp;&amp; 在这里表示，有任何一个条件不符合都表示匹配完毕 //若字符匹配成功，则主串与子串索引分别+1 if(S[i] == T[j])&#123; i++; j++; &#125;else&#123; //若匹配失败，则主串匹配索引回退，子串索引初始化 i - j + 2; //i - (j - 1) + 1 &#125; &#125; //若匹配成功(子串被全部匹配)，则计算位置并返回。 //因，匹配次数 = 字符串长度 = (j - 1)，所以若全部匹配，j一定大于字符串长度 if(j &gt; T[0]) return i - T[0];//从起点减去匹配过的次数(增过的量) == 子串长度 //若匹配失败，则返回错误提示 else return ERROR; &#125; 因为当前教材是把字符串长度记录在数组下标0处，所以第一个字符的数组下标就是1。因此未开始匹配字符时，子串匹配索引 j 的初始值就是1，而匹配成功1次后，j++才变成2。即它们之间的关系是，匹配次数 = (j - 1) = 字符长度 主串索引回退代码分析(i - j + 2)：匹配成功一次，才会造成一次主串(子串)索引的自增，所以匹配次数==主串增加量，由上可知，匹配次数 == j -1，所以主串回退到原位因为，i - (j - 1)，而需要进入下一轮匹配则还需要回退原位后 + 1，则： 回退上一次匹配位置下位代码未：i - ( j - 1 ) + 1 == i - j +2 优化理解版《数据结构》从概念到C++的实现，王红梅。P104，通过增加空间复杂度O(1)，引入start变量单独存放子串匹配位置 KMP模式匹配算法KMP匹配算法原理KMP算法核心可总结为两句话：“因为不同所以不同，跳过不同。因为相同所以相同，跳过相同！” “因为不同所以不同，跳过不同”：若存在子串字符互不相同部分，当出现主串字符匹配不了时，则无需BF完全回溯，因为BF回溯后的下一个主子串匹配肯定也是不同的。因此我们应让下次匹配跳到子串首字符(除首字符位置)下一次出现的位置。 “因为相同所以相同，跳过相同”：当子串与主串出现不匹配时，靠近不匹配处的若干字符在字符前缀部分出现过，则不应该仅跳到重复字符(下一次出现位置)的首字符，而是跳过包括这一段相同部分。，即应该跳到(新的匹配位置)于后缀部分相同的前缀部分的下一个位置。 此时，next数组的含义就是记录若当前字符出现不匹配，则需下次开始匹配的位置——重复部分的下一个位置的下标 快速 next数组next数组含义k = 子串下标 = 前缀长度 next数组的计算next 数组代码实现KMP模式匹配算法改进记住，一切能用数学公式或字母来形式化的东西，都是为了辅助我们更好的表述，它是无二义的，请不要害怕它。 我们不一定从数学公式中直接理解","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 第四章 队列","slug":"数据结构 第四章 队列","date":"2020-09-20T13:01:32.000Z","updated":"2020-09-20T12:59:20.061Z","comments":true,"path":"2020/09/20/数据结构 第四章 队列/","link":"","permalink":"http://yoursite.com/2020/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E9%98%9F%E5%88%97/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲 队列的定义 队列的抽线数据结构 队列顺序存储结构及其不足 循环队列的顺序存储结构 小结 队列的链式存储结构 总结 队列的定义队列(queue)：只允许在一端进行插入，另一端进行删除操作的线性表 队列是一种先进先出(First In First Out，FIFO)的线性表。(符合生活中的习惯) 允许插入的一端称为队尾，允许删除的一端称为队头 队列的应用十分广泛：如键盘输入到屏幕显示、操作系统、客服系统等 队列的抽象数据类型12345678910111213ADT 队列(Queue)Data 同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。Operation InitQueue(*Q): 初始化操作，建立一个空队列Q。 DestroyQueue(*Q): 若队列Q存在，则销毁它。 ClearQueue(*Q): 将队列Q清空。 QueueEmpty(Q): 若队列Q为空，返回true，否则返回false。 GetHead(Q, *e): 若队列Q存在且非空，用e返回队列Q的队头元素。 EnQueue(*Q, e): 若队列Q存在，插入新元素e到队列Q中并成为队尾元素。 DeQueue(*Q, *e): 删除队列Q中队头元素，并用e返回其值。 QueueLength(Q): 返回队列Q的元素个数endADT 队列顺序存储结构及其不足队列的顺序存储结构设计传统定义上的设计 队列插入元素：只需在队尾追加一个元素即刻，时间复杂度为O(1) 队列删除元素：把下标为0的队头元素删除后，其余所有元素均需向前移动,时间复杂度为O(n) 现今队列顺序存储结构设计因队头固定为数组起始下标0，导致删除元素效率低，O(n)，且避免只有一个元素时，队头和队尾重合使处理变得麻烦 引入两个指针，front指向队头元素，rear指向队尾元素的下一个位置，此时front = rear表示空队列 队列删除元素时，直接改变队头front的指向从而实现删除元素时间复杂度提升至O(1) 队列的顺序存储结构插入与删除元素过程如下： 队列顺序存储结构的不足若在队列未满时曾经通过可移动头指针删除过元素，会导致当rear指针移至数组末端时(表示无法再插入元素时)，数组靠前部分还有空闲空间的“假溢出”现象。 配合上述“普通队列插入图示”理解假溢出现象如下： 解决方案：采用循环队列。 循环队列的顺序存储结构循环队列的定义循环队列：把队列头尾相接的顺序存储结构(实际把rear指针变成可移动指针)，后面满了，就从头开始。 循环队列特性小结： front指向队头元素下标，rear指向队尾元素的下一个位置 front与rear指针均可独立循环移动 结构定义如下: 123456/* 循环队列的顺序存储结构 */typedef struct&#123; QElemType data[MAXSIZE]; int front; /* 头指针 */ int rear; /* 尾指针，若队列不空，指向队列尾元素的下一个位置 */&#125;SqQueue; 循环队列连续插入数据图示如下： 注意：最终队列满时，rear == front，此时与一开始定义 rear == front 表示队列为空的定义重复了。 解决方案1：设置一个标志变量flag，当front == rear，且flag=0时为队列空，当front == rear，且flag=1时为队列满。 解决方案2： 预留一个空闲空间表示队列满的状态，即队列满时，数组中还有一个空闲单元rear + 1 = front 此时队列可存储数据量为 “ MAXSIZE - 1 ” 注意：循环队列的front和rear指针均可独立循环移动，因此导致存在两种队列满的状态，即rear &gt; front 与 rear &lt; front 的两种情况。如下图所示： 显然 rear &gt; front 的情况是不能完全匹配 rear + 1 == front 这个队列满的判定条件 因此通用的队列满判别条件为： (QueueSize 为队列最大尺寸) “ (rear + 1) % QueueSize == front ” 同理两种rear与front的大小关系决定了计算队列长度通用公式为： “ (rear - front) + QueueSize % QueueSize ” 循环队列的初始化InitQueue123456/* 初始化一个空队列Q */Status InitQueue(SqQueue *Q)&#123; Q-&gt;front=0; Q-&gt;rear=0; return OK;&#125; 循环队列入队EnQueue123456789//循环队列入队操作Status EnQueue(SqQueue *Q, QElemType e) &#123; if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front)//判断队列是否已满 return ERROR; Q-&gt;data[Q-&gt;rear] = e; //队列，只能通过队尾入队，只操作rear Q-&gt;rear = (Q-&gt;rear+1) % MAXSIZE; //然rear指针符合循环队列特点，循环自增归零 return OK;&#125; 循环队列出队DeQueue123456789//循环队列出队操作Status DeQueue(SqQueue *Q, QElemType *e) &#123; if (Q-&gt;rear == Q-&gt;front)//判断队列是否为空，空则无法出队 return ERROR; *e = Q-&gt;data[Q-&gt;front];//队列，只能通过队头入队，只操作front Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE;//让front指针符合循环队列特点，循环自增归零 return OK;&#125; 要点 无论入队还是出队操作，都有一句类似的代码Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE，而这总写法是一种通用的循环自增归零写法。MAXSIZE控制自增的最大值，也是开始循环的值。 (变量 + 1) % MAXSIZE; 图示如下： 入队和出队的rear与front数值变化都是独立的循环自增，互不影响。**两者唯一有交集(关系)**部分已经解决(判读队列空与满的多种情况) 小结队列的顺序存储结构： 队列： 只能通过队尾入队，入队只操作rear，只能通过队头入队，入队只操作front front可移动化，提高删除效率 循环队列： front与rear分别独立循环移动，解决“假溢出”现象 队列满条件： (rear + 1) % QueueSize == front 注意：此时队列可存储数据量为 MAXSIZE - 1 队列长度通用公式： (rear - front) + QueueSize % QueueSize 循环自增归零写法：(变量 + 1) % MAXSIZE; 队列的链式存储结构定义队列的链式存储结构，相当于只能尾进头出的单链表，简称链队列 队头指针(front)指向头结点(不是头指针！) 队尾指针(rear)指向尾指针 front和rear都指向头结点，则表示空队列 结构定义12345678910111213//类似栈的链式存储结果设计//结点结构：QueuePtrtypedef struct QNode &#123; QElemType data; struct Qnode *next;&#125;QNode,*QueuePtr;//链表结构：LinkQueue//LinkQueue相当于一个front与rear结点管理器，存储这两个变量的指向typedef struct &#123; QueuePtr front, rear;/*队头队尾指针*/&#125;LinkQueue; LinkQueue相当于一个front与rear结点管理器，存储这两个变量的指向，front与rear独立工作。在理解上的结构关系(不完全是实际结构)如下： 队列初始化队列链式存储结构初始化关键在于：创建一个头结点，并且front 与 rear 都指向头结点(表示队列为空)，并且把头结点的指针域赋值为NULL InitQueue 123456789/*构建一个空列表Q*/Status InitQueue(LinkQueue *Q)&#123; Q-&gt;front = Q-&gt;rear = (QueuePtr)malloc(sizeof(QNode));//创建一个头结点并同时指向fornt与rear if (!Q-&gt;front)//申请失败则向系统报出异常 exit(1); -&gt;front-&gt;next = NULL;//为头结点指针域赋值NULL return OK;&#125; 初始化到数据入队过程队列的链式存储结构初始化后(空队列)到数据插入的过程理解如下图所示： EnQueue思路： 链式存储结构一般不会满 创建新结点 为新结点的数据域和指针域赋值(插入的总是队尾，所以指针域为NULL) 把新结点(尾结点)s成为原队尾结点的后继结点 修改链表结构LinkQueue的rear指向，返回OK即可 12345678910111213//入队操作Status EnQueue(LinkQueue *Q, QElemType e) &#123; QueuePtr s = (QueuePtr)malloc(sizeof(QNode)); //创建新结点 if (!s) //假如内存申请失败 exit(1); //非正常退出 s-&gt;data = e; //为新结点的数据域和指针域赋值 s-&gt;next = NULL; Q-&gt;rear-&gt;next = s; //把新结点/尾结点s成为给原队尾结点的后继结点 Q-&gt;rear = s; //修改链表结构LinkQueue的rear指向 return OK;&#125; exit() 函数：结束当前进程/当前程序/，在整个程序中，只要调用 exit ，就结束。 exit(1)表示进程异常退出 exit(0)表示进程正常退出 DeQueue关键点： front指针不是直接指向数据结点，而是指向头结点，所以待删除的结点应为Q-&gt;front-&gt;next 删除思路与单链表的删除操作思路一致 若出队的结点刚好是最后一个结点，需要重“置零”一下，否则s-&gt;next == NULL，而且rear会失去指向。 非最后一个结点出队过程示意如下： 最后一个结点出队过程示意如下： 123456789101112131415/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */Status DeQueue(LinkQueue *Q,QElemType *e)&#123; QueuePtr p; if(Q-&gt;front==Q-&gt;rear) return ERROR; p=Q-&gt;front-&gt;next; /* 将欲删除的队头结点暂存给p*/ *e=p-&gt;data; /* 将欲删除的队头结点的值赋值给e */ Q-&gt;front-&gt;next=p-&gt;next;/* 将原队头结点的后继p-&gt;next赋值给头结点后继*/ if(Q-&gt;rear==p) /* 若队头就是队尾，则删除后将rear指向头结点 */ Q-&gt;rear=Q-&gt;front; free(p); return OK;&#125; 总结 从基本单次操作中，循环队列和链队列时间上都是常数时间O(1) 若出队入队频繁，链队列会因每次申请和释放结点存在额外一些时间开销，与循环队列相比有细微差距 在空间上，循环队列会因长度的固定限制，造成空间上的浪费。链队列则不存在 总的来说：可确定长度优先选择循环队列，若无法预估则用链队列。","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 第四章 栈","slug":"数据结构 第四章 栈","date":"2020-09-19T12:01:32.000Z","updated":"2020-11-10T12:10:54.635Z","comments":true,"path":"2020/09/19/数据结构 第四章 栈/","link":"","permalink":"http://yoursite.com/2020/09/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%A0%88/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲 栈的定义 栈的抽线数据类型 栈的顺序存储结构 栈的链式存储结构 小结 栈的应用 栈的定义栈的定义如下： 栈(stack)如同弹夹一样，先进后出，后进先出(Last In First Out，LIFO)的特性。 栈而且是限定仅在表尾(栈顶)进行插入和删除的线性表。 相关术语如下： 栈顶(top)：允许插入和删除的一端 栈底(bottom)：相对于栈顶的另一端 空栈：不含任何数据元素的栈 进栈/压栈/入栈(push)：栈的元素插入操作 出栈/弹栈(pop)：栈的元素删除操作 进栈出栈变化形式 栈的抽象数据类型12345678910111213ADT 栈(stack)Data 同线性表。元素具有相同的类型，相邻元素具有前驱和后继的关系。Operation InitStack(*S)：初始化操作，建立一个空栈S DestroyStack(*S)：若栈存在，则销毁它 ClearStack(*S)：将栈清空 StackEmpty(S)：若栈为空，返回true，否则返回false GetTop(*S,e)：若栈存在且非空，用e返回S的栈顶元素 Push(*S,e)：若栈S存在，插入新元素e到栈S中，并成为栈顶元素 Pop(*S,*e)：删除栈S中的顶栈元素，并用e返回其值 StackLength(S)：返回栈S的元素个数endADT 栈的顺序存储结构顺序栈的结构定义 栈的顺序存储结构也称为 “顺序栈” 通常用数组下标为0的一端作为栈底，因为变化最小 定义一个top变量存储栈顶元素所在的位置，top &lt; StackSize， 栈存在一个元素时(对应数组下标为0)，top = 0 当top = -1 表示为空栈 顺序栈的结构定义如下： 123456#define MAXSIZE 50typedef int SElemType;struct&#123; SElemType data[MAXSIZE]; int top; //记录栈顶下标&#125;SqStack; 进栈&amp;出栈操作Push思路： 若栈已满，退出 修改栈顶top值，+1，并且作为下标存入数据e 12345678910/* 插入元素e为新的栈顶元素 */Status Push(SqStack *S,SElemType e)&#123; if(S-&gt;top == MAXSIZE -1) /* 栈满 */ return ERROR; S-&gt;top++; /* 栈顶指针增加一 */ S-&gt;data[S-&gt;top]=e; /* 将新插入元素赋值给栈顶空间 */ //这两句可写成：S-&gt;data[++S-&gt;top] = *e; return OK;&#125; pop思路： 若栈为空，则无元素出栈 以当前top为数组下标取出值并赋值给e top值自减1 123456789Status Pop(SqStack *S,SElemType *e)&#123; if(S-&gt;top==-1) return ERROR; *e=S-&gt;data[S-&gt;top]; /* 将要删除的栈顶元素赋值给e */ S-&gt;top--; /* 栈顶指针减一 */ //这两句同样可写成：*e = S-&gt;data[S-&gt;top--]; return OK;&#125; 两栈共享空间前言 通常一个程序中要用到多个栈，为了不发生上溢错误，就必须给每个栈分配一个足够大的存储空间。但实际中，很难准确地估计，若每个栈都分配过大的存储空间，势必造成系统空间紧张；若让多个栈共用一个足够大的连续存储空间，则可利用栈的动态特性使他们的存储空间互补。(关键字：’’多个栈’’) 事实上，使用这种数据结构，通常是两个栈的空间需求有相反关系，即一个栈增长时，另一个栈在缩短的情况。这样使用这种结构的意义更大。(如买卖股票，买入必定存在卖出等应用场景) 设计方案 前提是，两个栈的数据类型必须相同 让其中一个栈的栈底为数组下标0（-1），另一个栈底为n-1（n） (n表示数组的长度) 关键思路：两个栈是在数组的两端，向中间靠拢， 两盏共享空间结构1234567/*两盏共享空间结构*/typedef struct &#123; SElemType data[MAXSIZE]; int top1; /*栈1 栈顶指针 */ int top2; /*栈2 栈顶指针 */&#125;SqDoubleStack; 栈内元素存储状态 空栈：top1 = -1，top2 = MAXSIZE 栈满： 往右靠拢：top1 = n - 1，top2 = n -1 往左靠拢：top2 = 0，top1 = 0 向中间靠拢：top1+ 1= top2 通常使用top1 + 1 = top2为栈满的判别条件。 共享空间下的进栈&amp;出栈操作对于两栈共享空间的push与pop方法，除了顺序栈进出栈原有的两个参数外，还需要栈号参数stackNumber，用于判断操作的栈对象。 push思路： 判断栈的是否已经存满 分别执行类同顺序栈的进栈代码(注意：处于尾部栈的下标操作是相反的) 1234567891011/* 插入元素e为新的栈顶元素 */Status Push(SqDoubleStack *S,SElemType e,int stackNumber)&#123; if (S-&gt;top1+1==S-&gt;top2) /* 栈已满，不能再push新元素了 */ return ERROR; if (stackNumber==1) /* 栈1有元素进栈 */ S-&gt;data[++S-&gt;top1]=e; /* 若是栈1则先top1+1后给数组元素赋值。 */ else if (stackNumber==2) /* 栈2有元素进栈 */ S-&gt;data[--S-&gt;top2]=e; /* 若是栈2则先top2-1后给数组元素赋值。 */ return OK;&#125; pop思路： 首先通过stackNumber分别分支处理 判断被选中栈的是否为空 别执行类同顺序栈的出栈代码 12345678910111213/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */Status Pop(SqDoubleStack *S,SElemType *e,int stackNumber)&#123; if (stackNumber==1) &#123; if (S-&gt;top1==-1) return ERROR; /* 说明栈1已经是空栈，溢出 */ *e=S-&gt;data[S-&gt;top1--]; /* 将栈1的栈顶元素出栈 */ &#125;else if (stackNumber==2)&#123; if (S-&gt;top2==MAXSIZE) return ERROR; /* 说明栈2已经是空栈，溢出 */ *e=S-&gt;data[S-&gt;top2++]; /* 将栈2的栈顶元素出栈 */ &#125; return OK;&#125; 时间复杂度分析可知顺序栈的push和pop操作时间复杂度均为O(1) 栈的链式存储结构栈的链式存储结构，简称“链栈” 链栈没有头结点，或者说是把头结点与栈顶指针融为一体 对于链栈来说，基本不存在栈满的情况(除非内存耗尽/死机) 栈顶指针(top) = NULL时，表示空栈 栈的链式存储结构定义如下： 12345678910111213//类似单链表的结构定义：LinkStackPtr(Ptr，Pointer Recod 表指针含义)typedef struct StackNode&#123; SElemType data; struct StackNode *next;&#125;StackNode,*LinkStackPtr;//再创建一个top结点typedef struct LinkStack &#123; LinkStackPtr top;//每一个结点是否被定义为头结点 int count;//链的长度&#125;LinkStack; 链栈的进栈操作思路： 链式结构一般不用考虑插入是否已满 创建新结点 通过“头插法”(让首结点成为新结点的next，然后新结点成为首结点)即新元素只与头结点(栈顶/top)交换 修改count数值 返回OK 12345678910/* 插入元素e为新的栈顶元素 */Status Push(LinkStack *S,SElemType e)&#123; LinkStackPtr s=(LinkStackPtr)malloc(sizeof(StackNode)); s-&gt;data=e; s-&gt;next=S-&gt;top; /* 把当前的栈顶元素赋值给新结点的直接后继*/ S-&gt;top=s; /* 将新的结点s赋值给栈顶指针，见图中② */ S-&gt;count++; return OK;&#125; 链栈的出栈操作思路： 若栈为空，则无元素可出栈 创建暂存结点变量 改变top指向，释放暂存结点 返回OK 12345678910111213141516171819202122/* 若栈S为空栈，则返回TRUE，否则返回FALSE */Status StackEmpty(LinkStack S)&#123; if (S.count==0) return TRUE; else return FALSE;&#125;/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */Status Pop(LinkStack *S,SElemType *e)&#123; LinkStackPtr p; if(StackEmpty(*S)) return ERROR; LinkStackPtr p = S-&gt;top; //将栈顶结点赋值给p *e = p-&gt;data; //返回即将出栈元素值 S-&gt;top = p-&gt;next;//修改top结点指向 free(p); //释放结点 S-&gt;count--; return OK;&#125; 小结 顺序栈和链栈的时间复杂度都是O(1) 顺序栈在元素定位上相比链栈更节省内存开销，但需事先确定一个固定长度 链栈则无长度限制 因此，如果栈的使用过程中元素不可预料，有时很小，有时很大，那么最好使用栈链 反之，如果它的变化在可控范围内，使用顺序栈会更好一些 栈的应用前言栈的引入主要是将问题划分了不同的关注层次，使得思考范围进一步缩小，更加聚焦于我们解决问题的核心。从而简化了程序设计的问题，反之，使用传统“万金油”数组下标操作，则会使我们分散精力去处理一些琐碎的细节问题，反而掩盖了问题的本质。 栈的应用——递归递归的概念递归函数：直接调用自己或通过一系列调用语句间接地调用自己的函数 斐波那契数列的实现斐波那契数列(Fibonacci)：如 “1，1，2，3，5，8，13…” 这种前面相邻两项之和，构成了后一项的序列。 常规迭代方法123456789101112131415/*常规的迭代办法实现前40位Fibonacci数列 */void Fibonacci_Common() &#123; int f[40]; f[0] = 0; f[1] = 1; printf(&quot;%d \\n&quot;, f[0]);//输出首个Fibonacci数字 printf(&quot;%d \\n&quot;, f[1]);//输出第二个Fibonacci数字 int i; for (i = 2; i &lt; 40; i++) &#123; f[i] = f[i - 1] + f[i - 2]; printf(&quot;%d \\n&quot;, f[i]); &#125;&#125; 递归方式实现 从实际存在递归/重复规律的实际问题出发 递归的核心在于：每一次的结果都是需要通过函数调用的方式回退到规律的起点 通过函数return的自然机制递归出每一次的结果 将实际问题的递归规律通过数学函数表示出来(完成递归函数的百分之80) 将数学函数通过代码的形式表达出来 通过递归的方式实现代码如下： 1234567891011121314/*斐波那契的递归函数*/int Fbi(int i) &#123; if( i &lt; 2 ) return i == 0 ? 0 : 1; return Fbi(i - 1) + Fbi(i - 2); /* 这里Fbi就是函数自己，等于在调用自己 */&#125; int main()&#123; int i; for(i = 0;i &lt; 40;i++) printf(&quot;%d &quot;, Fbi(i)); return 0;&#125; 递归和迭代的区别 递归：递归使用选择结构 优点：递归能使程序结构更清晰，更简洁、容易理解，减少读代码时间 缺点：大量的递归调用回建立函数的副本，耗费大量的时间和内存 迭代：迭代使用循环结构 优点：迭代无需反复调用函数和占用额外内存 缺点：代码复杂，程序结构不利于代码的阅读 栈在递归里的应用递归函数的执行特点是： “先回退(前行)，后递归(退回)”即退回和前行两个阶段。而且这两个执行阶段互为逆序 在递归(退回)的过程中，需要不断执行且恢复前行过程中存储起来的某些数据 对于这种先不断前行执行，后又以其逆序的方式恢复这些数据的数据结构，符合栈这样的特点。因此底层的编译器常使用栈实现函数的递归操作。 简单的说，就是在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。 当然，对于现在的高级语言，这样的递归问题是不需要用户来管理这个栈的，一切都由系统代劳了。 栈的应用——四则运算表达式求值后缀表达式(逆波兰)法定义 中缀表达式：形如 “ 9 + (3 - 1) X 3 + 10 ÷ 2 ” 标准的四则运算表达式，所有运算符号都在两数字中间。 对于计算机来说，中缀表达式这种具有括号，乘除加减的复杂四则运算，计算机是不能马上识别出真确的运算顺序，而对于计算机如何实现数学表达式的求职。提出了一种新的表达法——后缀表达法。 后缀表达法(逆波兰)(Reverse Polish Notation，RPN)：是一种不需要括号,所有符号都是在要运算数字的后面出现。 如： “ 9 + (3 - 1) X 3 + 10 ÷ 2 ”的后缀表达式为， “ 9 3 1 - 3 * + 10 2 / + ” 栈的应用——中缀表达式转后缀表达式核心：栈是用来进出运算的符号 数字直接输出 入栈： 未匹配的左括号，优先级高于栈顶符号 低优先级出栈机制结束后再进栈 出栈： 右括号，出栈到与之匹配的左括号为止 低优先级符号出栈直至有比原顶栈符号优先级更低的为止，最后再将其低优先级符号入栈 中缀表达式处理完毕，则输出栈内剩下的所有符号 注意：” ( ) “括号参与出入栈，但不表示在表达式中 具体推导的图示过程，可查看本读物 p108~p110 栈的应用——后缀表达式的计算核心：栈是用来进出运算的数字 后缀表达式在计算机中的具体运算规则如下： 从左到右遍历表达式的每个数字和符号 遇到数字就进栈 遇到符号就把处于栈顶的两个数字出栈，进行运算。把运算结构进栈 直至处理完毕得到最终结果为止 具体推导的图示过程，可查看本读物 p106~p108","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 第三章 循环链表&双向链表","slug":"数据结构 第三章 循环链表&双向链表","date":"2020-09-17T09:12:32.000Z","updated":"2020-10-11T12:25:04.610Z","comments":true,"path":"2020/09/17/数据结构 第三章 循环链表&双向链表/","link":"","permalink":"http://yoursite.com/2020/09/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8&%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲 循环链表 双向链表 小结 循环链表基本概念单循环链表(circular linked)： 将单链表的终端结点指针端口由空指针改为指向头结点，是整个单链表形成一个环。 相对单链表，循环链表可以实现从任意一个结点出发，可访问到链表的全部结点的操作。 为了方便操作，循环链表为空链表时，头结点的指针域也“循环”地指向自己。如下图所示： 实际应用​ 而实际应用中，很多操作是在表的首或尾两端进行。传统单链表使用的头指针在首部操作时间复杂度为O(1)，而尾部操作时间复杂度则为O(n)。 此时，不设置头结点，而是借助”循环”本身的特性，通过设置终端结点的尾指针(rear)**，实现对首尾的高效操作**。 对于终端结点复杂度即为O(1)，对于头结点即rear-&gt;next，头指针即rear-&gt;next-&gt;next，复杂度均为O(1) 循环链表没有增加任何存储量，仅对链接方式稍作改变，因此基本操作的实现与链表相似。如ListLength、GetElem、LocateElem等这些操作只要设计一个方向的指针即可，另一个指针多了也不能提供什么帮助。 合并循环链表通过尾指针链接两个循环链表 123456p = rearA-&gt;next; /* 保存A表的头结点*/ rearA-&gt;next = rearB-&gt;next-&gt;next; /*将本是指向B表的第一个结点（不是头结点） */ /* 赋值给reaA-&gt;next，即*/q = rearB-&gt;next; rearB-&gt;next = p; /* 将原A表的头结点赋值给rearB-&gt;next，即③ */free(q); /* 释放q*/ 双向链表定义及其初始化双向链表(double linked list)**：是在单链表的每个结点中，在设置一个指向其前驱结点**的指针域。定义如下： 123456/*线性表的双向链表存储结构*/typedef struct DulNode&#123; ElemType data; struct DulNode *prior; struct DulNode *next;&#125;DulNode,*DuLinkList; 双链表的插入相对于单链表的插入操作，双链表的插入需要修改4个指针。关键修改代码如下(在结点p的后面插入一个新结点s)： 1234s-&gt;prior = p;s-&gt;next = p-&gt;next;p-&gt;next-&gt;prior = s;p-&gt;next = s; 双链表的删除因为有两个指针域，在指向调整上更加灵活。若p指向待删除结点，则删除的关键代码部分如下(未被验证)： 12p-&gt;prior-&gt;next = p-&gt;next;p-&gt;next-&gt;prior = p-&gt;prior; 小结 双向链表先对于单链表来说，更加复杂，对于对于插入和删除时，需要歌外注意 双向链表有两个指针域，因此空间上占用略多一些 由于双向链表有良好的对称性，使得对某个结点的前后结点操作带来了方便 因此总的来说，双向链表通过复杂的设计用空间效率在某种情况下换取了时间效率","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"mysql基础总结","slug":"mysql基础总结","date":"2020-09-17T03:40:32.000Z","updated":"2020-09-17T06:22:52.375Z","comments":true,"path":"2020/09/17/mysql基础总结/","link":"","permalink":"http://yoursite.com/2020/09/17/mysql%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/","excerpt":"","text":"本单元目标12345678910111213141516171819202122232425262728293031323334353637一、为什么要学习数据库二、数据库的相关概念 DBMS、DB、SQL三、数据库存储数据的特点四、初始MySQL MySQL产品的介绍 MySQL产品的安装 ★ MySQL服务的启动和停止 ★ MySQL服务的登录和退出 ★ MySQL的常见命令和语法规范 五、DQL语言的学习 ★ 基础查询 ★ 条件查询 ★ 排序查询 ★ 常见函数 ★ 分组函数 ★ 分组查询 ★ 连接查询 ★ 子查询 √ 分页查询 ★ union联合查询 √ 六、DML语言的学习 ★ 插入语句 修改语句 删除语句 七、DDL语言的学习 库和表的管理 √ 常见数据类型介绍 √ 常见约束 √ 八、TCL语言的学习 事务和事务处理 九、视图的讲解 √十、变量 十一、存储过程和函数 十二、流程控制结构 数据库的好处121.持久化数据到本地2.可以实现结构化查询，方便管理 数据库相关概念1231、DB：数据库，保存一组有组织的数据的容器2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据3、SQL:结构化查询语言，用于和DBMS通信的语言 数据库存储数据的特点123451、将数据放到表中，表再放到库中2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”5、表中的数据是按行存储的，每一行类似于java中的“对象”。 MySQL产品的介绍和安装MySQL服务的启动和停止1234方式一：计算机——右击管理——服务方式二：通过管理员身份运行net start 服务名（启动服务）net stop 服务名（停止服务） MySQL服务的登录和退出123456789方式一：通过mysql自带的客户端只限于root用户方式二：通过windows自带的客户端登录：mysql 【-h主机名 -P端口号 】-u用户名 -p密码退出：exit或ctrl+C MySQL的常见命令12345678910111213141516171819202122232425261.查看当前所有的数据库show databases;2.打开指定的库use 库名3.查看当前库的所有表show tables;4.查看其它库的所有表show tables from 库名;5.创建表create table 表名( 列名 列类型, 列名 列类型， 。。。);6.查看表结构desc 表名;7.查看服务器的版本方式一：登录到mysql服务端select version();方式二：没有登录到mysql服务端mysql --version或mysql --V MySQL的语法规范12345671.不区分大小写,但建议关键字大写，表名、列名小写2.每条命令最好用分号结尾3.每条命令根据需要，可以进行缩进 或换行4.注释 单行注释：#注释文字 单行注释：-- 注释文字 多行注释：&#x2F;* 注释文字 *&#x2F; SQL的语言分类12345678DQL（Data Query Language）：数据查询语言 select DML(Data Manipulate Language):数据操作语言 insert 、update、deleteDDL（Data Define Languge）：数据定义语言 create、drop、alterTCL（Transaction Control Language）：事务控制语言 commit、rollback SQL的常见命令1234567891011show databases； 查看所有的数据库use 库名； 打开指定 的库show tables ; 显示库中的所有表show tables from 库名;显示指定库中的所有表create table 表名( 字段名 字段类型, 字段名 字段类型); 创建表desc 表名; 查看指定表的结构select * from 表名;显示表中的所有数据 DQL语言的学习进阶1：基础查询12345678语法：SELECT 要查询的东西【FROM 表名】;类似于Java中 :System.out.println(要打印的东西);特点：①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数 进阶2：条件查询1234567891011121314151617181920212223242526条件查询：根据条件过滤原始表的数据，查询到想要的数据语法：select 要查询的字段|表达式|常量值|函数from 表where 条件 ;分类：一、条件表达式 示例：salary&gt;10000 条件运算符： &gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D; !&#x3D; &lt;&gt;二、逻辑表达式示例：salary&gt;10000 &amp;&amp; salary&lt;20000逻辑运算符： and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false or(||)：两个条件只要有一个成立，结果为true，否则为false not(!)：如果条件成立，则not后为false，否则为true三、模糊查询示例：last_name like &#39;a%&#39; 进阶3：排序查询123456789语法：select 要查询的东西from 表where 条件order by 排序的字段|表达式|函数|别名 【asc|desc】 进阶4：常见函数1234567891011121314151617181920212223242526272829303132333435363738一、单行函数1、字符函数 concat拼接 substr截取子串 upper转换成大写 lower转换成小写 trim去前后指定的空格和字符 ltrim去左边空格 rtrim去右边空格 replace替换 lpad左填充 rpad右填充 instr返回子串第一次出现的索引 length 获取字节个数2、数学函数 round 四舍五入 rand 随机数 floor向下取整 ceil向上取整 mod取余 truncate截断3、日期函数 now当前系统日期+时间 curdate当前系统日期 curtime当前系统时间 str_to_date 将字符转换成日期 date_format将日期转换成字符4、流程控制函数 if 处理双分支 case语句 处理多分支 情况1：处理等值判断 情况2：处理条件判断5、其他函数 version版本 database当前库 user当前连接用户 二、分组函数 123456789101112131415sum 求和max 最大值min 最小值avg 平均值count 计数特点：1、以上五个分组函数都忽略null值，除了count(*)2、sum和avg一般用于处理数值型 max、min、count可以处理任何数据类型3、都可以搭配distinct使用，用于统计去重后的结果4、count的参数可以支持： 字段、*、常量值，一般放1 建议使用 count(*) 进阶5：分组查询1234567891011121314151617语法：select 查询的字段，分组函数from 表group by 分组的字段特点：1、可以按单个字段分组2、和分组函数一同查询的字段最好是分组后的字段3、分组筛选 针对的表 位置 关键字分组前筛选： 原始表 group by的前面 where分组后筛选： 分组后的结果集 group by的后面 having4、可以按多个字段分组，字段之间用逗号隔开5、可以支持排序6、having后可以支持别名 进阶6：多表连接查询12笛卡尔乘积：如果连接条件省略或无效则会出现解决办法：添加上连接条件 一、传统模式下的连接 ：等值连接——非等值连接 12341.等值连接的结果 &#x3D; 多个表的交集2.n表连接，至少需要n-1个连接条件3.多个表不分主次，没有顺序要求4.一般为表起别名，提高阅读性和性能 二、sql99语法：通过join关键字实现连接 123456789101112131415161718含义：1999年推出的sql语法支持：等值连接、非等值连接 （内连接）外连接交叉连接语法：select 字段，...from 表1【inner|left outer|right outer|cross】join 表2 on 连接条件【inner|left outer|right outer|cross】join 表3 on 连接条件【where 筛选条件】【group by 分组字段】【having 分组后的筛选条件】【order by 排序的字段或表达式】好处：语句上，连接条件和筛选条件实现了分离，简洁明了！ 三、自连接 案例：查询员工名和直接上级的名称 sql99 123SELECT e.last_name,m.last_nameFROM employees eJOIN employees m ON e.&#96;manager_id&#96;&#x3D;m.&#96;employee_id&#96;; sql92 123SELECT e.last_name,m.last_nameFROM employees e,employees m WHERE e.&#96;manager_id&#96;&#x3D;m.&#96;employee_id&#96;; 进阶7：子查询含义： 12一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询 特点： 123456789101112131415161、子查询都放在小括号内2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧3、子查询优先于主查询执行，主查询使用了子查询的执行结果4、子查询根据查询结果的行数不同分为以下两类：① 单行子查询 结果集只有一行 一般搭配单行操作符使用：&gt; &lt; &#x3D; &lt;&gt; &gt;&#x3D; &lt;&#x3D; 非法使用子查询的情况： a、子查询的结果为一组值 b、子查询的结果为空② 多行子查询 结果集有多行 一般搭配多行操作符使用：any、all、in、not in in： 属于子查询结果中的任意一个就行 any和all往往可以用其他查询代替 进阶8：分页查询应用场景： 1实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句 语法： 1234567select 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 【起始的条目索引，】条目数; 特点： 123456781.起始条目索引从0开始2.limit子句放在查询语句的最后3.公式：select * from 表 limit （page-1）*sizePerPage,sizePerPage假如:每页显示条目数sizePerPage要显示的页数 page 进阶9：联合查询引入： union 联合、合并 语法： 12345select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】.....select 字段|常量|表达式|函数 【from 表】 【where 条件】 特点： 1231、多条查询语句的查询的列数必须是一致的2、多条查询语句的查询的列的类型几乎相同3、union代表去重，union all代表不去重 DML语言插入语法： insert into 表名(字段名，…) values(值1，…); 特点： 123451、字段类型和值类型一致或兼容，而且一一对应2、可以为空的字段，可以不用插入值，或用null填充3、不可以为空的字段，必须插入值4、字段个数和值的个数必须一致5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致 修改修改单表语法： 12update 表名 set 字段&#x3D;新值,字段&#x3D;新值【where 条件】 修改多表语法： 1234update 表1 别名1,表2 别名2set 字段&#x3D;新值，字段&#x3D;新值where 连接条件and 筛选条件 删除方式1：delete语句 单表的删除： ★ delete from 表名 【where 筛选条件】 多表的删除： delete 别名1，别名2 from 表1 别名1，表2 别名2 where 连接条件 and 筛选条件; 方式2：truncate语句 1truncate table 表名 两种方式的区别【面试题】 12345678#1.truncate不能加where条件，而delete可以加where条件#2.truncate的效率高一丢丢#3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始#delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始#4.truncate删除不能回滚，delete删除可以回滚 DDL语句库和表的管理库的管理： 1234一、创建库create database 库名二、删除库drop database 库名 表的管理： #1.创建表 12345678910111213141516171819202122232425262728293031CREATE TABLE IF NOT EXISTS stuinfo( stuId INT, stuName VARCHAR(20), gender CHAR, bornDate DATETIME);DESC studentinfo;#2.修改表 alter语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;#①修改字段名ALTER TABLE studentinfo CHANGE COLUMN sex gender CHAR;#②修改表名ALTER TABLE stuinfo RENAME [TO] studentinfo;#③修改字段类型和列级约束ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;#④添加字段ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;#⑤删除字段ALTER TABLE studentinfo DROP COLUMN email;#3.删除表DROP TABLE [IF EXISTS] studentinfo; 常见类型12345678整型：小数： 浮点型 定点型字符型：日期型：Blob类型： 常见约束123456NOT NULLDEFAULTUNIQUECHECKPRIMARY KEYFOREIGN KEY 数据库事务含义1通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态 特点12345（ACID）原子性：要么都执行，要么都回滚一致性：保证数据的状态操作前和操作后保持一致隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改 相关步骤： 1231、开启事务2、编写事务的一组逻辑操作单元（多条sql语句）3、提交事务或回滚事务 事务的分类：隐式事务，没有明显的开启和结束事务的标志 12比如insert、update、delete语句本身就是一个事务 显式事务，具有明显的开启和结束事务的标志 1234567891、开启事务取消自动提交事务的功能2、编写事务的一组逻辑操作单元（多条sql语句）insertupdatedelete3、提交事务或回滚事务 使用到的关键字12345678set autocommit&#x3D;0;start transaction;commit;rollback;savepoint 断点commit to 断点rollback to 断点 事务的隔离级别:事务并发问题如何发生？ 1当多个事务同时操作同一个数据库的相同数据时 事务的并发问题有哪些？ 123脏读：一个事务读取到了另外一个事务未提交的数据不可重复读：同一个事务中，多次读取到的数据不一致幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据 如何避免事务的并发问题？ 12345通过设置事务的隔离级别1、READ UNCOMMITTED2、READ COMMITTED 可以避免脏读3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读4、SERIALIZABLE可以避免脏读、不可重复读和幻读 设置隔离级别： 1set session|global transaction isolation level 隔离级别名; 查看隔离级别： 1select @@tx_isolation; 视图含义：理解成一张虚拟的表 视图和表的区别： 12345 使用方式 占用物理空间视图 完全相同 不占用，仅仅保存的是sql逻辑表 完全相同 占用 视图的好处： 121、sql语句提高重用性，效率高2、和表实现了分离，提高了安全性 视图的创建1234语法：CREATE VIEW 视图名AS查询语句; 视图的增删改查1234567891011121314151、查看视图的数据 ★SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name&#x3D;&#39;Partners&#39;;2、插入视图的数据INSERT INTO my_v4(last_name,department_id) VALUES(&#39;虚竹&#39;,90);3、修改视图的数据UPDATE my_v4 SET last_name &#x3D;&#39;梦姑&#39; WHERE last_name&#x3D;&#39;虚竹&#39;;4、删除视图的数据DELETE FROM my_v4; 某些视图不能更新123456包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union all常量视图Select中包含子查询joinfrom一个不能更新的视图where子句的子查询引用了from子句中的表 视图逻辑的更新123456789101112#方式一：CREATE OR REPLACE VIEW test_v7ASSELECT last_name FROM employeesWHERE employee_id&gt;100;#方式二:ALTER VIEW test_v7ASSELECT employee_id FROM employees;SELECT * FROM test_v7; 视图的删除1DROP VIEW test_v1,test_v2,test_v3; 视图结构的查看12DESC test_v7;SHOW CREATE VIEW test_v7; 存储过程含义：一组经过预先编译的sql语句的集合 好处： 1231、提高了sql语句的重用性，减少了开发程序员的压力2、提高了效率3、减少了传输次数 分类： 1234561、无返回无参2、仅仅带in类型，无返回有参3、仅仅带out类型，有返回无参4、既带in又带out，有返回有参5、带inout，有返回有参注意：in、out、inout都可以在一个存储过程中带多个 创建存储过程语法： 12345create procedure 存储过程名(in|out|inout 参数名 参数类型,...)begin 存储过程体end 类似于方法： 1234修饰符 返回类型 方法名(参数类型 参数名,...)&#123; 方法体;&#125; 注意 1234567891011121314151617181、需要设置新的结束标记delimiter 新的结束标记示例：delimiter $CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)BEGIN sql语句1; sql语句2;END $2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end3、参数前面的符号的意思in:该参数只能作为输入 （该参数不能做返回值）out：该参数只能作为输出（该参数只能做返回值）inout：既能做输入又能做输出 调用存储过程1call 存储过程名(实参列表) 函数创建函数学过的函数：LENGTH、SUBSTR、CONCAT等 语法： 12345CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型BEGIN 函数体END 调用函数1SELECT 函数名（实参列表） 函数和存储过程的区别123 关键字 调用语法 返回值 应用场景函数 FUNCTION SELECT 函数() 只能是一个 一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个存储过程 PROCEDURE CALL 存储过程() 可以有0个或多个 一般用于更新 流程控制结构系统变量一、全局变量 作用域：针对于所有会话（连接）有效，但不能跨重启 123456789查看所有全局变量SHOW GLOBAL VARIABLES;查看满足条件的部分系统变量SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;查看指定的系统变量的值SELECT @@global.autocommit;为某个系统变量赋值SET @@global.autocommit&#x3D;0;SET GLOBAL autocommit&#x3D;0; 二、会话变量 作用域：针对于当前会话（连接）有效 12345678910查看所有会话变量SHOW SESSION VARIABLES;查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;查看指定的会话变量的值SELECT @@autocommit;SELECT @@session.tx_isolation;为某个会话变量赋值SET @@session.tx_isolation&#x3D;&#39;read-uncommitted&#39;;SET SESSION tx_isolation&#x3D;&#39;read-committed&#39;; 自定义变量一、用户变量 声明并初始化： 123SET @变量名&#x3D;值;SET @变量名:&#x3D;值;SELECT @变量名:&#x3D;值; 赋值： 123456789方式一：一般用于赋简单的值SET 变量名&#x3D;值;SET 变量名:&#x3D;值;SELECT 变量名:&#x3D;值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表; 使用： 1select @变量名; 二、局部变量 声明： 1declare 变量名 类型 【default 值】; 赋值： 123456789方式一：一般用于赋简单的值SET 变量名&#x3D;值;SET 变量名:&#x3D;值;SELECT 变量名:&#x3D;值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表; 使用： 1select 变量名 二者的区别： 1作用域 定义位置 语法 用户变量 当前会话 会话的任何地方 加@符号，不用指定类型 局部变量 定义它的BEGIN END中 BEGIN END的第一句话 一般不用加@,需要指定类型 分支一、if函数 语法：if(条件，值1，值2) 特点：可以用在任何位置 二、case语句 语法： 123456789101112131415情况一：类似于switchcase 表达式when 值1 then 结果1或语句1(如果是语句，需要加分号) when 值2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）情况二：类似于多重ifcase when 条件1 then 结果1或语句1(如果是语句，需要加分号) when 条件2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要） 特点： 可以用在任何位置 三、if elseif语句 语法： 12345if 情况1 then 语句1;elseif 情况2 then 语句2;...else 语句n;end if; 特点： 只能用在begin end中！！！！！！！！！！！！！！！ 三者比较： 应用场合 if函数 简单双分支 case结构 等值判断 的多分支 if结构 区间判断 的多分支 循环语法： 123【标签：】WHILE 循环条件 DO 循环体END WHILE 【标签】; 特点： 12345只能放在BEGIN END里面如果要搭配leave跳转语句，需要使用标签，否则可以不用标签leave类似于java中的break语句，跳出所在循环！！！ 引用：尚硅谷—mysql基础语法总结","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"数据结构 第三章 静态链表","slug":"数据结构 第三章 静态链表","date":"2020-09-09T13:38:32.000Z","updated":"2020-09-16T08:46:29.418Z","comments":true,"path":"2020/09/09/数据结构 第三章 静态链表/","link":"","permalink":"http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲 基本概念 静态链表的初始化 静态链表的插入操作 小结 基本概念 静态链表：用数组描述的链表叫做静态链表。 如Basic、Fortran等早期编程语言，没有指针，就可通过数组实现链表结构(游标实现法)。 静态链表使用两个数据域组成，分别叫data、cur，cur类似单链表中的next。不记录指针，而是记录后继元素的数组下标。 123456/*线性表的静态链表存储结构*/#define MAXSIZE 1000typedef struct&#123; ElemType data; int cur; /*游标(Cursor)，为0时表示无指向*/&#125; 静态链表的第一个和最后一个元素作为特殊处理，不存数据。 未被使用的数组元素称为备用链表。 下标为0的第一个元素cur称为头指针，用于存放备用链表的下标。 数组最后一个元素的cur，存放第一个有数值元素的下标(相当于头结点)。 静态链表初始化123456789/*将一维数组space中各个分量链成一备用链表*/Status InitList(StaticLinkList space)&#123; int i; for(i = 0; i &lt; MAXSIZE - 1; i++)/*为链表所有元素cur赋值，将其中各个分量链成一备用链表*/ space[i] = i + 1; space[MAXSIZE - 1].cur = 0; /*目前链表为空，最后一个元素的cur为0*/ return OK;&#125; 静态链表的插入操作链表的插入/删除操作都需要调用存储空间的申请/释放函数。标准定义的malloc，free函数直接调用就可自动申请或释放空间。对于通过数组实现链表功能的静态链表实现插入/删除操作首先要解决的问题：如何用**静态模拟动态链表对存储空间的分配/管理(申请/释放)**。需要时申请、无用时释放。 Malloc_SSL 因此静态链表需要自己实现单链表的malloc函数功能。 功能描述：若备用空间链表非空，则返回可分配的结点下标(类似向内存申请空间，返回地址值)，否则返回0。 实现思路： 静态链表设计本身然下标为0的元素存放备用链表的下标，所以直接返回下标0的cur即可。 同时，需要把即将返回的备用链表的cur值重新填充到下标为0的cur，为下次分配使用。 12345678910/*若备用空间链表非空，则返回可分配的结点下标，否则返回0*/int Malloc_SSL(StaticLinkList space) &#123; int i = space[0].cur; /* 当前数组第一个元素的cur存的值 */ /* 就是要返回的第一个备用空闲的下标 */ if (space[0]. cur) space[0]. cur = space[i].cur; /* 由于要拿出一个分量来使用了， */ /* 所以我们就得把它的下一个 */ /* 分量用来做备用 */ return i;&#125; ListInsert思路： 基本插入错误过滤 获取空闲分量下标 填充数据域 定位前继结点 头插法 12345678910111213141516171819202122Status ListInsert(StaticLinkList L, int i, ElemType e) &#123; if (i &lt; 1 || i &gt; ListLength(L) + 1) //若链表已满 return ERROR; int j = Malloc_SLL(L); //获得空闲分量的下标 if (j) &#123; L[j].data = e;//将数据赋值给此分量的data int k = MAXSIZE -1,l; //找到插入位置的前继元素，(计数器+while+工作指针后移) //静态链表的头结点在尾部 for (l = 1; l &lt;= i - 1; l++) k = L[k].cur; L[j].cur = L[k].cur;//改变游标指向(头插法) L[k].cur = j; //先把前继节点的后继游标传给新节点的后继游标 return OK; &#125; return ERROR; //若获取分量失败则返回错误 &#125; 注意： 获取头结点下标：int k = MAXSIZE -1 Free_SSL同样，静态链表实现删除操作也要先实现free函数 1234567/*将下标为k的空闲结点回收到备用链表*/void Free_SSL(StaticLinkList space, int k) &#123; space[k].cur = space[0].cur; //让即将要删除的位置成为第一个优先的空位 space[0].cur = k; //即删除节点与备用链表交换两个参数&#125; ListDelete12345678910111213141516Status ListDelete(StaticLinkList L, int i) &#123; if (i &lt; 1 || i &gt; ListLength(L))//删除索引过滤 return ERROR; int k = MAXSIZE - 1; int l; for (l = 1; l &lt;= i -1; l++) //定位前继节点 k = L[k].cur; int d = L[k].cur;//创建临时变量存储欲删除cur L[k].cur = L[d].cur; Free_SSL(L,d); return OK;&#125; 小结静态链表其实为了给没有指针的高级语言设计的一种实现单链表能力的方法。特性与单链表类似，尽管以后这种方法不一定用上，但这样的思考方式是非常巧妙的。","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 第三章 单链表","slug":"数据结构 第三章 单链表","date":"2020-09-05T14:38:32.000Z","updated":"2020-09-29T08:06:30.394Z","comments":true,"path":"2020/09/05/数据结构 第三章 单链表/","link":"","permalink":"http://yoursite.com/2020/09/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%8D%95%E9%93%BE%E8%A1%A8/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲 线性表链式存储结构定义 单链表的创建 单链表的读取 单链表的插入和删除 总结 线性表链式存储结构定义基本概念为保持线性结构“前驱后继，一对一”逻辑结构前提下，同时避免顺序存储结构中对相邻关系的依赖性。链式结构，除了要存数据元素信息外，还要存储它的后继元素的存储地址。 数据域：存储数据元素信息的域 指针域：存储直接后继位置的域，其中存储的信息称做指针或链 结点(Node)：数据域和指针域组成数据元素ai的存储映像 链表：由n个结点链成的一个链表 单链表：链表中的每个结点只包含一个指针域 单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起，如图所示： 线性表链式存储结构代码描述 相关规定，线性链表的最后一个结点为“空”(用NULL或“^”符号表示) 头结点：在单链表的第一个结点前附设的一个结点，指针域指向第一个结点，若指针域为“空”，表示线性表为空 头结点主要作用是为便于对链表进行统一操作，头结点的数据域可不存储信息，或者存储线性表长度等附加信息。 单链表的定义123456//线性表的单链表存储结构typedef struct Node &#123; ElemType data; struct Node *next;&#125;Node;typedef struct Node *LinkList;//定义LinkList，指针变量的typedef typedef struct Node &#123;...&#125;Node;中的Node同名对象(实例)Node的作用：常用于为sizeof()函数传参。 typedef struct Node *LinkList; 语法理解：如typedef int Status; ‘Status‘等价于int，在这里可以看作类似变量的声明，即 声明一个int类型变量Status int Status，而int *Status表示定义一个int型的指针变量。同样类比在typedef中，“*”表示typedef的对象是Node 结构体的指针变量，即LinkList 等价于 struct Node *linkList; (不过写法上确实有点新颖，有点融合着写) 单链表的读取工作指针：对于链表的元素定位操作，常常需要通过计数器从头到尾遍历计数而确定某一元素位置的指针，而“从头”不能直接用头结点直接指针后移遍历的，因为这样会失去了头结点原本的意义与功能。 因此常声明一个变量p存储头结点指针域来完成之后的指针偏移遍历操作，一般将这个从头开始复杂遍历的指针称为工作指针 “工作指针后移”则是工作指针通常的工作状态。 GetElem思路： 声明一个工作指针 p，指向链表的第一个结点(查询不查头结点)。 设置计时器变量 j，并初始化为1，通过重新数数的方式找到序号位置。 当j&lt;i时，遍历链表，让p的指针向后移动，称为“工作指针后移”，计时器j累加1. 若到链表末尾p为空，则说明第i个结点不存在。 否则查找成功，返回结点p的数据。 123456789101112131415161718/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) *//* 操作结果：用e返回L中第i个数据元素的值 */Status GetElem(LinkList L,int i,ElemType *e)&#123; //--------------查询部分--------------- int j; LinkList p; /* 声明工作指针p */ p = L-&gt;next; /* 让p指向链表L的第一个结点 */ j = 1; /* j为计数器 */ while (p &amp;&amp; j&lt;i)&#123; /* p不为空或者计数器j还没有等于i时，循环继续 */ p = p-&gt;next; /* 让p指向下一个结点 */ ++j; &#125; if ( !p || j&gt;i ) //注意这里是 大于 &gt; 符号 return ERROR; /* 第i个元素不存在 */ //--------------查询部分--------------- *e = p-&gt;data; /* 取第i个元素的数据 */ return OK;&#125; 链式存储没有表长，更加没有序号。事先不知循环次数，只能设置计数器，使用while循环解决; 最坏情况复杂度是O(n); 单链表的创建单链表的初始化单链表的初始化，即空表的建立 InitList123456789/* 初始化顺序线性表 */Status InitList(LinkList *L) &#123; *L=(LinkList)malloc(sizeof(Node)); /* 产生头结点(向内存申请一个结点的空间),并使L指向此头结点 */ if(!(*L)) /* 存储分配失败 */ return ERROR; (*L)-&gt;next=NULL; /* 指针域为空 */ return OK;&#125; malloc函数：void *malloc(long NumBytes)向内存申请NumBytes个字节的空间，并返回了指向这块内存的指针。若分配失败，则返回一个空指针(NULL）,如系统空间不足等失败情况。使用malloc函数需注意如下几点： 申请了内存空间后，必须检查是否分配成功。 当不需要再使用申请的内存时，记得释放；并把这块内存的指针指向NULL，防止程序后面不小心使用了它。 malloc与free这两个函数应该是配对使用。如果申请后不释放就是内存泄露；如果无故释放那就是什么也没有做。释放只能一次，如果释放两次及两次以上会出现错误（释放空指针例外，释放空指针其实也等于啥也没做，所以释放空指针释放多少次都没有问题）。 虽然malloc()函数的类型是(void *)，任何类型的指针都可以转换成(void *),但是最好还是在前面进行强制类型转换，因为这样可以躲过一些编译器的检查。 参考链接：malloc()和free()的基本概念以及基本用法 LinkList *L形参的理解： Status InitList(LinkList *L)注意，此时传入形参L已是二级指针(指针的指针)。 一级指针与二级指针的区别与使用： 形参传递永远是值传递(临时变量)，想要通过调用函数去改变传入实参的内容，则需要至少传入欲修改参数类型基础上的一级指针，并且通过“*” 调用实体内容进行修改。而并不能仅修改传入新参的内容，因为新参内容本身怎么修改都不会影响传入的实参。(值传递原则) 当传值时，只可以引用值而不可以改变值， 当你传指针时，只可以改变指针所指的内容，不可以改变指针本身 但传指针的指针时，即可以改变指针所指的内容，又可以改变指针本身 LinkList *L二级指针的用处：回归目的本身，很明确。即想要LinkList L;这个指针变量L最终指向通过malloc函数申请空间后返回的地址值(即地址的赋值)。理应L=malloc(sizeof(Node));即可，从一条语句操作上是完全正确的，类型也是一致的。但问题在于如今想要通过调用函数且把L作为实参传入修改其地址值。这样的前提下，若只传入想要修改内容类型的本身(这里就是指针变量/一级指针)，安装值传递原则是达不到效果的，代码如下所示： 12345678910111213Status InitList(LinkList L) &#123; //形参修改成一级指针 L = (LinkList)malloc(sizeof(Node)); if (!(L)) return ERROR; L-&gt;next = NULL; &#125;void main() &#123; LinkList L = NULL; InitList(L); if (L == NULL) printf(&quot;L=NULL&quot;);//最终L还是NULL被打印出来，没有被改变 getchar();&#125; “想要通过调用函数去改变传入实参的内容，则需要至少传入欲修改参数类型基础上的一级指针”，即先要修改指针值本身，则至少需要传入该参数类型上的一级指针，即指针的指针，这就是Status InitList(LinkList L) &#123;...&#125; 二级指针形参的意义。 参考链接： (C++)函数参数传递中的一级指针和二级指针 引用传递和值传递以及链表中的LinkList L、LinkList *L、LinkList &amp;L 单链表的整表创建单链表的整表创建又分为“头插法”，“尾插法”两种。 CreateListHead“头插法”即新结点的指针域通过修改i - 1结点的后继节点指向完成结点的插入。 123456789101112131415/* 随机产生n个元素的值，建立带表头结点的单链线性表L（头插法） */void CreateListHead(LinkList *L, int n) &#123; LinkList s;//初始化一个即将插入新结点 int i; srand(time(0)); /* 初始化(修改)随机数种子 */ *L = (LinkList)malloc(sizeof(Node)); (*L)-&gt;next = NULL; /* 先建立一个带头结点的单链表 */ for (i=0; i&lt;n; i++) &#123; s = (LinkList)malloc(sizeof(Node)); /* 生成新结点 */ s-&gt;data = rand()%100+1; /* 随机生成100以内的数字填充数据域 */ s-&gt;next = (*L)-&gt;next; (*L)-&gt;next = p; /* 插入到表头 */ &#125;&#125; srand函数与rand函数使用(stdio.h) void srand(unsigned int seed)：设置随机数种子 srand函数用来设置rand函数产生随机数时的随机数种子，参数seed必须是整数，通常可以用time(0)的返回值作为seed。如果每次seed都设置相同的值，rand()产生 一系列 随机数值每次都一样。当计算机正常开机后，随机种子的值是定了的，除非你破坏了系统，或者通过srand函数修改。 int rand(void)：生成随机数 在0到RAND_MAX之间的整数值生成一个随机数，rand的内部是用线性同余法做的，不是真的随机数，只不过因为其周期特别长，所以在一定范围内可以看成是随机的。(RAND_MAX的范围最少在32767之间（int），即双字节（16位）。若unsigned int双字节是65535) 参考链接：C语言的srand与rand函数浅谈 time函数的使用 函数原型：time_t time(time_t *seconds) time函数用于返回格林尼治时间(1970年1月1日00:00:00到当前时刻的时长)，单位是秒。存在与&lt;time.h&gt;库，一般使用方式t1=time(NULL) 或 t1=time(0)来获取当前格林尼治时间。 CreateListTail“尾插法”，符合日常排队思维，后到的排在后。为了方便操作，需要引入尾指针概念 尾指针： 功能：用于指向当前链表的终端结点 初始化：与头结点一致，均指向头指针。(类似队列初始化) 基于尾指针功能的插入逻辑： 12r-&gt;next = s;//英文尾指针就是指向链表的终端结点，而实现向后插入，则直接插入在尾结点后即可r = s; //而从尾指针后面插入的新元素必将是新的尾结点，所以把它定义为新的尾指针即可 CreateListTail尾插法实现代码如下： 123456789101112131415/* 随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */void CreateListTail(LinkList *L, int n) &#123; LinkList s,r; int i; srand(time(0)); /* 初始化随机数种子 */ *L = (LinkList)malloc(sizeof(Node)); /* L为整个线性表 */ r=*L; /* 尾指针初始化 */ for (i=0; i&lt;n; i++) &#123; s = (Node *)malloc(sizeof(Node)); /* 生成新结点 */ s-&gt;data = rand()%100+1; /* 随机生成100以内的数字 */ r-&gt;next=s; /* 将表尾终端结点的指针指向新结点 */ r = s; /* 将当前的新结点定义为表尾终端结点 */ &#125; r-&gt;next = NULL; /* 表示当前链表结束 */&#125; 除了首次循环r是头结点，其余r成为了永远的尾结点。 r = p;功能是，注意这里没有真正修改了地址值，而是局部变量顺应循环设计的循环变换，变换内容是将最新插入的结点成为下次循环的尾结点。 删除内容说明： 通过学习“《数据结构》——从概念到C++实现(第3版)” 认识实现结点从后面插入的逻辑实现原理是基于到对尾插法是利用尾指针功能的本身。—— 2020年9月26日 GetElem与链式插入操作小结工作指针： 常表定位指针，定位方式通常为工作指针后移 p = p-&gt;next; GetElem 头插法 尾插法 删除 初始为头指针，同步定位 i 初始为头结点，定位 i 的前继结点 同左 同左 LinkList p = L-&gt;next LinkList p = *L 同左 同左 tip：i 表示顺序表的位置 头插法实质：头插法：利用头指针“插入逻辑”进行插入的方法 插入逻辑：“逆序操作”，防止与当前操作结点的后继结点失去联系的操作 123s-&gt;next = p-&gt;next; //p表示工作指针，在插入操作，p是定位到i-1位置，即插入位置的前继结点。 //s表示即将插入的新结点p-&gt;next = s; 尾插法实质：尾插法：基于尾指针“功能”的插入逻辑进行插入的方法 功能：用于指向当前链表的终端结点 初始化：与头结点一致，均指向头指针。(类似队列初始化) 12r-&gt;next = s;//英文尾指针就是指向链表的终端结点，而实现向后插入，则直接插入在尾结点后即可r = s; //而从尾指针后面插入的新元素必将是新的尾结点，所以把它定义为新的尾指针即可 单链表的整表删除思路： 声明一结点p和q； 将第一个结点赋值给p； 循环： 将下一个结点赋值给q； 释放p； 将q赋值给p 123456789101112/* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */Status ClearList(LinkList *L)&#123; LinkList p,q; p=(*L)-&gt;next; /* p指向第一个结点 */ while(p)&#123; /* 没到表尾 */ q=p-&gt;next; free(p); p=q; &#125; (*L)-&gt;next=NULL; /* 头结点指针域为空 */ return OK;&#125; free函数，它的作用就是让系统回收一个Node结点，释放内存。 单链表的插入和删除ListInsert思路： 按照插入原理，首先需定位到i -1结点位置，即插入位置的前继结点，调整GetElem函数查询部分代码即可； 创建空节点s，并把数据元素e填充到数据域； 插入原理(头插法)：s-&gt;next = p-&gt;next; P-&gt;next=s;； 返回成功； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， *//* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */Status ListInsert(LinkList *L,int i,ElemType e)&#123; int j; LinkList p,s; p = *L; j = 1; while (p &amp;&amp; j &lt; i)&#123; /* 寻找第i-1个结点 */ p = p-&gt;next; ++j; &#125; if (!p || j &gt; i) return ERROR; /* 第i个元素不存在 */ s = (LinkList)malloc(sizeof(Node)); /* 生成新结点(C语言标准函数) */ s-&gt;data = e; s-&gt;next = p-&gt;next; /* 将p的后继结点赋值给s的后继 */ p-&gt;next = s; /* 将s赋值给p的后继 */ return OK;&#125;**要点**：- ListInsert函数巧妙将p赋值为**头结点地址**`p = *L;`来实现定位**i - 1**结点位置功能(插入位置的前继结点)。有别于GetElem函数`p = (*L)-&gt;next;`。- 插入原理：新结点的指针域通过**修改i - 1结点的后继节点指向**完成结点的插入。- 插入原理的两条语句**不能颠倒执行顺序**。## ListDelete**思路**：1. 按照删除原理，同样需定位到**i -1 **结点位置，并且**不能删除头结点**；1. 定位成功后，创建一个用于临时存放的节点指针q，将欲删除的节点p-&gt;next赋值给q；1. 将q节点中的数据赋值给e，作为返回；1. 释放q节点；1. 返回成功；```C/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) *//* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */Status ListDelete(LinkList *L,int i,ElemType *e) &#123; int j; LinkList p,q; p = *L; j = 1; while (p-&gt;next &amp;&amp; j &lt; i)&#123; /* 遍历寻找第i个元素 */ p = p-&gt;next; ++j; &#125; if (!(p-&gt;next) || j &gt; i) return ERROR; /* 第i个元素不存在 */ q = p-&gt;next; p-&gt;next = q-&gt;next; /* 将q的后继赋值给p的后继 */ *e = q-&gt;data; /* 将q结点中的数据给e */ free(q); /* 让系统回收此结点，释放内存 */ return OK;&#125; 要点： 有别于GetElem与ListInsert函数while或if条件p，ListDelete函数的条件改为p-&gt;next。 GetElem条件判断p是否为NULL，是因为p的初始值就定义成 p = (*)L-&gt;next，不存在对头结点操作的可能性; ListInsert条件判断p是否为NULL，是因为插入数据是允许空表插入; ListDelete条件判断p是否为NULL，是因为删除不允许空表删除。 与整表删除要点一致，均需要通过一个变量q去记录将要删除的结点地址，不然会丢失地址，造成内存泄漏。 插入和删除复杂度分析 当不知第i个结点指针位置(首次插入/删除)，时间复杂度为O(n)； 若需要在i个位置插入若干个结点，则除了第一次外其余结点插入或删除的时间复杂度为O(1)； 结论：插入或删除数据越频繁的操作，单链表的效率优势就越明显。 总结单链表各方法实现思路 GetEelm：计数器 + while循环匹配 + 工作指针后移 p-&gt;next = p;； ListInsert / CreateListHead：均采用了插入的方法，`s-&gt;next=p-&gt;next; p-&gt;next=s;； ListInsert/ ListDelete：均需要定位到欲操作位置的前继结点，通过初始赋值头结点地址p=(*L)； ListDelete： “绕指针删除”q=p-&gt;next; p-&gt;next=q-&gt;next;； ListDelete / ClearList：均需将欲删除结点用另一个变量暂存后再删除，不然会丢失地址，造成内存泄漏； CreateListTail / ClearList：同样在循环内通过局部变量直接交换节点地址实现，节点操作按序进行(从前到后)，如尾插法r-&gt;next=p; r =p;或整表删除q=p-&gt;next; free(p); p=q; 不同操作中指针类型的要求原理：形参传递永远是值传递(临时变量)，想要通过调用函数去改变传入实参的内容必须： 至少传入欲修改参数类型基础上的一级指针 *通过“” 调用实体内容进行修改。 结论： 当传值时，只可以引用值而不可以改变值， 当你传指针时，只可以改变指针所指的内容，不可以改变指针本身 但传指针的指针时，即可以改变指针所指的内容，又可以改变指针本身 初始化链表需要用二级指针； 销毁链表(头结点也销毁)需要用到二级指针； 插入、删除、遍历、清空结点用一级指针即可； 单链表结构与顺序存储结构优缺点 存储结构 存储分配方式 时间性能 空间性能 顺序存储 连续存储单元 查找：O(1)，插删：O(n) 需预定分配存储空间，而大小不好掌握 链式存储 任意存储单元 查找：O(n)，插删：O(n) 或 O(1) 无需事先预定，内存有空间即可，不限数量 若线性表需要频繁查找且很少进行插入和删除操作，宜采用顺序存储结构； 如用户注册的个人信息，除了注册时插入数据外，绝大多数都是读取而且 若线性表需要频繁增加和删除，宜采用链式存储结构； 如游戏中玩家的武器装备仓库列表等 若线性表元素个数变化较大，或者根本不知道有多大时，最好用单链表结构不用考虑空间分配问题；","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 第三章 线性表及其顺序存储结构","slug":"数据结构 第三章 线性表及其顺序存储结构","date":"2020-09-03T04:40:32.000Z","updated":"2020-09-25T14:55:10.604Z","comments":true,"path":"2020/09/03/数据结构 第三章 线性表及其顺序存储结构/","link":"","permalink":"http://yoursite.com/2020/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%8F%8A%E5%85%B6%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲 线性表的定义 线性表的抽象数据类型 线性表的顺序存储结构 地址计算方法 顺序存储结构的存入与取出 顺序存储结构的插入与删除 线性表顺序存储结构的优缺点 线性表的定义线性表（List）：零个(空表)或多个数据元素的有限序列。即线性表的长度n≧0。关键点如下： 序列：表示元素之间是有严格的顺序。元素之间的关系是一对一的关系。 若线性表记为(a1，…ai-1，ai，ai+1，…，an)，称ai-1是ai的直接前驱元素，ai+1则是ai的直接后继元素 第一个元素无前驱，最后一个元素无后继，其他元素有且只有一个前驱和后继 有限 元素类型相同 线性表的抽象数据类型线性表的抽象数据类型定义如下： 1234567891011121314ADT 线性表（List）Data &#123;a1,a2,…,an&#125;Operation InitList(*L): 初始化操作，建立一个空的线性表L。 ListEmpty(L): 判断线性表是否为空表，若线性表为空，返回true，否则返回false。 ClearList(*L): 将线性表清空。 GetElem(L,i,*e): 将线性表L中的第i个位置元素值返回给e。 LocateElem(L,e): 在线性表L中查找与给定值e相等的元素，如果查找成功， 返回该元素在表中序号表示成功；否则，返回0表示失败。 ListInsert(*L,i,e): 在线性表L中第i个位置插入新元素e。 ListDelete(*L,i,*e): 删除线性表L中第i个位置元素，并用e返回其值。 ListLength(L): 返回线性表L的元素个数。endADT ps：上述为最基本操作，其他更复杂的操作完全可以通过这些基本操作组合实现。 线性表的顺序存储结构线性表的顺序存储定义线性表的顺序存储结构：指的是用一段地址连续的存储单元依次存储线性表的数据元素。 最常见的就是用一维数组来实现顺序存储结构 线性表的顺序存储结构代码如下： 123456#define MAXSIZE 20 //存储空间处时分配量typedef int ElemType //数据类型根据实际情况而定，这里假设为inttypedef strcuct&#123; ElemType data [MAXSIZE]; int length; //线性表当前长度&#125;SqList; 据上述可知，描述顺序存储结构需要三个属性： 存储空间的起始位置：其实就是数组data(首地址) 线性表的最大存储容量：数组长度MaxSize 线性表的当前长度：length 顺序线性表的初始化12345/* 初始化顺序线性表 */Status InitList(SqList *L) &#123; L-&gt;length=0; return OK;&#125; 地址计算方法数组长度与线性表长度的区别 数组长度：是指存放线性表存储空间的长度，一般是固定值。int data[3]={1,2,3}长度为3。 线性表长度：线性表中存在数据元素个数，是经常变化的。 数组下标从“0”开始，线性表是从“1”数起的。 地址计算方法数据元素的序号和存放它的数组下标之间对应关系如下图所示： 对于第i个数据元素ai的存储地址可由a1推算出： LOC(ai) = LOC(a1)+(i-1)*c LOC表示获得存储位置的函数，c表示数据元素的类型的存储单元 对于第 i 个数据元素ai的存取位置关系： ai = data[i - 1] 顺序存储结构的存入与取出GetElem思路： 线性表必须存在数据; i 的数值在数组下标范围内; 返回数组的第 i-1 下标的值即可; 123456789101112131415#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;//基本说明：Status是函数的类型，其值是函数结果状态代码，如OK等//初始条件(输入条件)：线性表L已存在，位置参数i范围应处于： 1 ≤ i ≤ ListLength(L)//操作结果：用e返回L中的第i个元素Status GetElem(SqList L,int i,ElemType *e) &#123; if (L.length == 0 || i &lt; 1 || i &gt; L.length) return ERROR; *e = L.data[i - 1]; return OK;&#125; 任意位置的存取时间复杂度都为O(1)**，即存取性能为O(1)，称为“随机存取结构**”。 “存取”，不等于“插删” 顺序线性表的存取仅需要知道存入的位置逻辑即可，因此查询位置的复杂度决定了存取的复杂度 顺序存储结构的插入与删除存在线性表定义如下： 1234567#define MAXSIZE 20typedef int ElemType;typedef struct &#123; ElemType data[MAXSIZE]; int length;&#125;SqList; ListInsert思路： 如果线性表的长度等于数组长度，则抛出异常或者动态增加容量; 如果插入位置不合理，抛出异常; 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置; 将要插入元素填入位置 i 中; 1234567891011121314151617181920212223/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， *//* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */Status ListInsert(SqList *L,int i,ElemType e)&#123; int k; if (L-&gt;length==MAXSIZE) /* 顺序线性表已经满 */ return ERROR; if (i&lt;1 || i&gt;L-&gt;length+1)/* 当i比第一位置小或者比最后一位置后一位置还要大时 */ return ERROR; if (i&lt;=L-&gt;length)&#123; /* 若插入数据位置不在表尾 */ for(k=L-&gt;length-1;k&gt;=i-1;k--) /* 将要插入位置之后的数据元素向后移动一位 */ L-&gt;data[k+1]=L-&gt;data[k]; &#125; /*索引改良 for (k = L-&gt;length; k &gt;= i; k--) &#123; L-&gt;data[k] = L-&gt;data[k - 1]; &#125; */ L-&gt;data[i-1]=e; /* 将新元素插入 */ L-&gt;length++; return OK;&#125; ListDelete思路： 线性表必须存在数据; 如果删除位置不合理，抛出异常; 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置; 表的长度减少1; 12345678910111213141516171819/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) *//* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */Status ListDelete(SqList *L,int i,ElemType *e) &#123; if (L-&gt;length==0) /* 线性表为空 */ return ERROR; if (i&lt;1 || i&gt;L-&gt;length) /* 删除位置不正确 */ return ERROR; *e=L-&gt;data[i-1]; int k; if (i&lt;L-&gt;length)&#123; /* 如果删除不是最后位置 */ for(k=i;k&lt;L-&gt;length;k++)/* 将删除位置后继元素前移 */ L-&gt;data[k-1]=L-&gt;data[k]; &#125; L-&gt;length--; return OK;&#125; 线性表顺序存储结构的优缺点时间复杂度分析存入与取出查询任意位置可由公式直接查出，从而决定存取的时间复杂度**均为O(1)**。 插入与删除 最优情况复杂度：插入与删除位置为最后一个元素，复杂度为O(1) 最坏情况复杂度：插入与删除位置为第一个位置，复杂度为O(n) 平均情况复杂度：位置靠前，移动元素多。位置靠后，移动元素少。平均为(n-1)/2，复杂度即为O(n) 优缺点总结优点： 无须为表示表中元素之间的逻辑关系而增加额外的存储空间(即可由公式直接关联) 可以快速地存取表中任意位置的元素 缺点： 插入和删除操作需要移动大量的元素 当线性表长度变化较大时，难以确定存储空间的容量。即难以确定MAXSIZE属性的大小 造成存储空间的“碎片” 小结 顺序存储结构的线性表，适合于元素个数不太需要变化，更多用于存取数据的应用。 插入和删除效率低的原因在于，相邻两元素之间的存储位置也依赖于邻居关系本身。","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 第二章 算法基础","slug":"数据结构 第二章 算法基础","date":"2020-09-01T03:40:32.000Z","updated":"2020-10-22T12:21:10.624Z","comments":true,"path":"2020/09/01/数据结构 第二章 算法基础/","link":"","permalink":"http://yoursite.com/2020/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 大纲 算法的定义 算法的特性 算法设计的要求 算法效率的度量方法 函数的渐进增长 算法时间复杂度 算法空间复杂度 最坏情况与平均情况 算法的定义算法：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 算法的特性算法具有的五个基本特性：输入、输出、有穷性、确定性、可行性。 输入与输出 算法具有零个或多个输入。 算法至少有一个或多个输出。 有穷性 算法在执行有限步骤之后，自动结束而不会出现无限循环。 每一个步骤在可接受的时间内完成。即实际意义。 确定性确定性：算法的每一步骤都具有确定的含义，不会出现二义性，类似函数。 可行性 算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。 可行性意味着算法可转换为程序上机运行。 算法设计的要求算法设计的要求包含：正确性、可读性、健壮性、时间效率高和存储量低。 正确性正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。大体分为以下四个层次： 没有语法错误 对于合法的输入数据能够产生满足要求的输出结果 对于非法的输入数据能够得出满足规格说明的结果 对于精心选择的，甚至刁难的测试数据都有满足要求的输出结构。 一般情况下，我们把层次3作为一个算法是否正确的标准 可读性可读性：算法设计的另一个目的是为了便于阅读、理解和交流。 健壮性健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名奇妙的结果。 时间效率高和存储量低设计算法应该尽量满足时间效率高和存储量(占用内存与外部硬盘存储空间)低的需求。 算法效率的度量方法ps：这里指的效率大都是指算法的执行时间。 事后统计方法事后统计方法：这种方法主要是通过事先设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。 但这种方法显然存在很大的缺陷： 必须依据算法事先编制对应的测试程序，费时费力，工作量可能翻倍。 计时器的计时效果比较依赖计算机硬件和软件等环境因素。 算法的测试数据设计困难。 事前分析估算方法事前分析估算方法：在计算机程序编程前，依据统计方法对算法提前进行估算。 事前分析一个程序在计算机运行所消耗的时间取决于下列因素： 算法采用的策略、方法。 编译产生的代码质量。 问题的输入规模。 机器执行指令的速度。 结论： 一个程序的运行时间，依赖于算法的好坏和问题的**输入规模(输入变量的值)**。 测定运行时间最可靠的方法就是依据输入规模计算语句的执行次数。 执行次数，也成为基本操作数量，记作 f(n)，n表示输入规模。 函数的渐进增长ps：判断两个算法效率的高低，会存在因不同量级的输入规模而得出相反的结果。 因此给出定义，输入规模n在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，我们称函数是渐进增长快的。 函数渐进增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐进快于g(n)。 结论：判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而**更应该关注主项(最高阶项)**的阶数。 算法时间复杂度时间复杂度的定义算法时间复杂度，记作T(n)=O(f(n))，通过大写O( )**来体现时间复杂度的记法，也称之为大O记法**。 在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)= O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。 推导大O阶方法 写出每一条语句的执行次数。 把所有语句的执行次数相加并且进行基本的数学化简。 用常数1取代运行时间中的所有加法常数。 只保留最高阶项。 若最高阶项存在且不是1，则去除与这个项相乘的常数。 123456789int i,j; //执行1次for(i = 0; i &lt; n; i++)&#123; //执行n次 for(j = i; j &lt; n; j++)&#123; /*时间复杂度O(1)的程序步骤序列*/ //执行n-2次...n-1,n,执行1次 //执行n-2次...n-1,n,执行1次 &#125; &#125;printf(&quot;end&quot;); //执行1次 总执行次数为：1+n+(n-1)+(n-2)+…+1 + 1= n(n+1)/2 +2 = n2/2+n/2 + 2 去除常数： n2/2+n/2 保留最高阶项： n2/2 最高阶项存在且不等于1，去除相乘常数：n2，即最终时间复杂度为 O(n2) 可看作等差数列求和：na1 + n(n-1)/2 * d 首项a1=1，公差d=1，项数n=n 常见时间复杂度 阶 非正式术语 常见结构 例 O(1) 常数阶 顺序结构、无循环分支结构 12 O(n) 线性阶 无内嵌循环结构 2n+3 O(n2) 平方阶 二层内嵌循环结构 3n2+2n+1 O(log n) 对数阶 非1线性增长的循环索引 log2n+20 O(n log n) nlog n阶 2n+3nlog2n O(n3) 立方阶 三层内嵌循环 n3+2 2n 指数阶 2n 常用时间复杂度所耗费得时间从小到大依次是： O(1) &lt; O(log⁡n) &lt; O(n) &lt; O(nlog⁡n) &lt; O(n2) &lt; O(n3) &lt; O(an) &lt; O(n!) &lt; O(nn) 对数阶补充说明 123456int count =1;while(count &lt; n)&#123; count = count * 2; /*时间复杂度O(1)的程序步骤序列*/&#125; 每次count乘2之后，就距离n更接近一分，而需要乘多少次？接需要执行多少次，才能跳出循环？ 把需要乘的次数设为x，则2x=n，得到执行次数x=log2n 算法的空间复杂度空间复杂度：算法的空间复杂度即算法所需的存储空间，记作：S(n)=O(f(n)，此时n为问题的规模，f(n)为语句关于n所占存储空间函数。 当不用限定词地使用“复杂度”，则通常指时间复杂度。 时间复杂度和空间复杂度一般情况下可以相互转换。 最坏情况与平均情况最坏情况：即一个算法存在的最低执行效率情况。 在应用中，最坏情况是一种重要的需求，通常，除非特别指定，提及的运行时间都是指最坏情况的运行时间 平均运行时间是所有情况中最有意义的，它属于期望的运行时间。","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 第一章 绪论","slug":"数据结构 第一章 绪论","date":"2020-08-29T14:03:32.000Z","updated":"2020-09-26T08:45:58.868Z","comments":true,"path":"2020/08/29/数据结构 第一章 绪论/","link":"","permalink":"http://yoursite.com/2020/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/","excerpt":"","text":"读物：《大话数据结构》 印次：2020年5月第25次印刷(2020.5重印) 知识大纲 数据结构的起源 基本概念和术语 逻辑结构与物理结构 抽象数据类型 数据结构的起源早期认知人们都把计算机理解为数值计算工具。解决问题方式如下： 分析问题 抽像其数据模型 设计数据模型对应算法 编写程序 实际环境现实中，更多是解决非数值型问题，因此需要更加有效的科学手段。**(比如表、树图等数据结构)。 基本概念和术语数据数据的基本概念数据：是描述客观事物的符号，是计算机中可操作的对象，是能被计算机识别，并能够输入给计算机处理的符号集合。 比如编程所用到的数据类型，还包括字符、声音、图像、视频等这里所描述的数据，其实就是符号 数据的基本特性 可输入到计算机中 能被计算机程序处理 数据元素数据元素：组成数据的，有一定意义的基本单位，在及算你中通常作为整体处理。也被称为记录。 数据项数据项：一个数据元素可以由若干个数据项组成。 比如人这样的数据元素，可以有眼、耳、口、鼻，姓名、年龄、性别这些数据项 数据项是数据的最小单位 在研究数据结构问题时，数据元素才是建立数据模型的着眼点 数据对象数据对象：是性质相同的数据元素的集合，是数据的子集。 小结 数据：就是符号，数值型和非数值型集合 数据元素：组成数据有意义的基本单位，即java中的“类” 数据项：组成数据元素的基本单位，即类里面的“属性” 数据对象：是数据的子集。即类里面的“对象/实例” 数据结构数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。结构即关系！ 一个“好”的程序，必须分析待处理对象的特性及其**各处理对象之间存在的关系**这就是研究数据结构的意义所在。 “分析待处理对象的特性”，即以前接触高级语言的“面向对象编程” 博主如今缺乏的，即是学习“各处理对象之间存在的关系” 数据结构实际涵盖三个主要内容：逻辑结构(表,队,树,图…)、存储结构(顺序存储,链式存储)、基本操作(ADT)组成 逻辑结构与物理结构逻辑结构逻辑结构：是指数据对象中数据元素之间的相互关系，也是今后讨论的重点。主要类型包含如下 集合结果 线性结构 树形结构 图像结构 集合结构集合结构：集合结构中的数据元素除了同一个集合外，它们之间没有其他关系。 它们相互平等，唯一且共同的属性就是“同属一个集合”，类似数学的集合，形如“鱼塘” 线性结构线性结构：线性结构中的数据元素之间是一对一的关系，类似“火车，项链”。 树形结构树形结构：树形结构中的数据元素之间存在一种一对多的的层次关系。形如“大树”分支。 图形结构图像结构：图形结构的数据元素是多对多的关系，类似“人际关系”，交错复杂。 小结用示意图表示数据的逻辑结构时，要注意两点 将每一个数据元素看做一个结点，用圆圈表示 元素之间的逻辑关系用结点之间的连线表示，如果这个关系是有方向的，必须标明箭头 物理结构/存储结构物理结构：是指数据的逻辑结构在计算机中的存储形式。 即数据元素如何存储到计算机的存储器中，这里的存储器主要针对内存而言 数据的存储结构应正确反映数据元素之间的逻辑关系，这才是重点 存储结构形式有两种：顺序存储和链式存储 顺序存储结构顺序存储结构：是把数据元素存放在地址连续的存储单元里。此时，其数据间的逻辑关系和物理关系是一致的。 形如理想状态下的排队，又如编程中的数组存储/开辟空间机制 链式存储结构链式存储结构：是把数据元素存放在任意的存储单元里，而这组存储单元可以是连续的，也可以是不连续的。 形如去银行、医院等地方，设置了“叫号排序”的机制。实际，把变量的地址存储在一个指针变量中，通过指针变量找到对应的数据 小结 逻辑结构是面向问题的，而物理结构就是面向计算机的 顺序存储：连续开辟-按序对应 链式存储：任意开辟-叫号对应 抽象数据类型数据类型数据类型：是指一组性质相同的值的集合,及定义在此集合上的一些操作的总称。 在计算机中，内存也不是无限大的，计算机的研究者们就考虑，要对数据类型进行分类，分出多种数据类型来适合各种不同的计算条件差异，同时节省内存 C语言中数据类型可以分为两类 原子类型：不可以再分解的基本类型，例如整型、浮点型、字符型等。 结构类型：由若干种数据类型组合而成，是可再分解。如整型数组由若干整型数据组成的 抽象数据类型抽象抽象：抽象是指抽取出事物具有的普遍性的本质。即抽出问题的特征而忽略非本质的细节。 抽象数据类型抽象数据类型(Abstract Data Type，ADT)：是指一个数学模型及定义在该模型上的一组操作。 抽象数据类型不仅仅指那些已经定义并实现的数据类型(int、char等)，还可以是计算机编程者在设计软件程序时自己定义的数据类型，即如同高级语言的即“类”一样。而“及定义在该模型上的一组操作”即如同定义类，及其基本“方法” 比如，无论在PC、平版电脑、只能手机上都拥有“整数”这个类型，那么可以说“整型”其实就是一个抽象的数据类型，而且“抽象”的意义在于数据类型的数学抽象特征。 抽象数据类型体现了程序设计中，问题分解、抽线、信息隐藏的特性。 抽象数据类型的标准格式ADT 抽象数据类型名 Data 数据元素之间逻辑关系的定义 Operation 操作1 初始条件 操作结构描述 操作2 ... endADT 总结 现实问题中更需要解决的是非数值运算问题。 数据 数据即符号 数据元素即“类” 数据对象即可“实例” 数据项即“属性” 结构即关系 数据结构定义：是相互之间存在一种或多种特定关系的数据元素的集合 逻辑结构与物理结构，即面向问题，与面向存储。 四大逻辑结构(“四形”) 集合结构 线性结构 树形结构 图形结构 两大物理结构 顺序存储(数组) 链式存储(指针) 抽象数据类型 数据类型 原子类型(不可分割/int，char) 结构类型(组合而成) 抽象数据类型 已定义数据类型抽象，即int，char 自定义数据类型抽象，即struct，类 抽象数据类型规范:ADT、Data、Operation、endADT 作者建议研读方法 复习c语言的基础知识。 第一遍阅读，建议从头至尾进行通读。 阅读时，摘抄/笔记是非常好的习惯。“最淡的墨水也胜于最强的记忆” 阅读每一章时，特别是阅读****算法的推导过程，一定要在电脑中运行代码和进行调试，设置断点和逐行执行，参照书的讲解，观察变量的变化情况来理解算法的编写原理。 阅读完每一章时，一定要在理解基础上记忆一些关键东西，最佳效果就是不看书也可以一点不错的默写相关的算法。 阅读完每一章时，一定要适当练习。 在之后的学习或工作中，尽量把学到的数据结构和算法运用到现实开发中。 《大话数据树结构》初读后有感教材和自学读物，所面向的读者是完全不同的教材特性 好的教材应试是提纲挈领、重点突出。 一定要留出思考空间，否则就没必要再听老师上课了。教材很多内容的讲解都是由老师在课堂上完成的。 教材中必定有练习、课后习题、思考题等，而这些大多可以通过老师来解答。 比如我们中学时的语文、数学课本，很薄的一本书通常要用一个学期、甚至一年的时间来学，这就是因为它们是教材而不是自学读物。如果小说,可能一两天就读完了。 读物——隔空交流的介质作者角度 作者认为，读者拿到的虽然只是一本没有表情、不会说话的书，但其实也是在隔空与另一个朋友交流。 人与人的交流不可能只是就事论事，一定会有情感的沟通，这种情感如果能产生共鸣、达成互信，就会让沟通的事情本身更容易理解和接受。 博主理解 读物本是以内容第一为原则。但其作者的表诉方式，引用，感受等情感会附带许多作者本人的价值观。即情感交流，也是阅读的影响之一。 对于技术类读物，除技术内外，最明显的就是学习读者的编书方式，从编书结构从而建立更全面，深刻，有效的知识的架构。 如本书最明显的其中一个特征就是会对每一个小知识群进行小结提炼。这也会影响到我摘抄笔记的录入结构。","categories":[],"tags":[{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"图床解决方案","slug":"图床解决方案","date":"2020-08-29T00:11:02.000Z","updated":"2021-03-21T15:08:22.603Z","comments":true,"path":"2020/08/29/图床解决方案/","link":"","permalink":"http://yoursite.com/2020/08/29/%E5%9B%BE%E5%BA%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"参考链接 本人解决方案：https://www.jianshu.com/p/b69950a49ae2 markdown各种解决方案：https://www.jianshu.com/p/ea1eb11db63f picgo连接gitee： https://www.jianshu.com/p/b69950a49ae2 https://blog.csdn.net/disILLL/article/details/104944710 https://www.cnblogs.com/qtzd/p/12554902.html 软件关系简要说明 Typora 作为markdown编辑器本身具备的优势 最新版支持 picgo自动上传功能呢 picgo(图床工具) 主要功能：与各大图床存储平台对接，实现快捷本地上传，返回各种需求的连接服务(markdown、html、svg链接等) gitee：作为一个免费图床存储平台，无防盗链设置","categories":[],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"Hexo在Gitee平台部署过程","slug":"Hexo在Gitee平台部署过程","date":"2020-08-28T23:09:02.000Z","updated":"2021-03-21T15:07:58.792Z","comments":true,"path":"2020/08/29/Hexo在Gitee平台部署过程/","link":"","permalink":"http://yoursite.com/2020/08/29/Hexo%E5%9C%A8Gitee%E5%B9%B3%E5%8F%B0%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B/","excerpt":"","text":"前提 已经安装hexo，并且能够通过hexo d命令推送到GitHub实现远程推送。 实现方案具体可参考《基于Hexo框架的博客搭建及其GitHub部署》 已经注册Gitee账号并且绑定手机。 Gitee新建仓库 新建仓库时名称最好是保持跟你注册时的个人空间地址是一样的。因为这样你就不会生成二级域名了。如果不跟注册时的个人空间地址一样的话，到时候自己的网站就会有二级域名的存在了。 输入仓库名称与路径后会在“归属”一栏下生成一个仓库链接，记录下来为之后的_config.yml文件配置做准备 _config.yml文件配置修改配置文件中repo 属性为：{仓库地址} .git 仓库地址在创建仓库的时候会显示，或者在刚创建完的时候浏览器的url就是仓库地址 仓库地址一般组成： https://gitee.com/{个人空间名}/{仓库名称} 123456# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deploymentdeploy: type: &#39;git&#39; repo: &#123;仓库地址&#125;.git branch: master repo: https://gitee.com/yihangdeng/yihangdeng.git 修改配置保存后，可以像推送到GitHub上那样，通过hexo d命令上传到gitee。刷新gitee仓库查看是否有内容 开启仓库page服务 进入页面后直接点击启动即可。 启动完成后会生成网站地址，这个网站地址就是访问你博客的地址。 gitee page 只有付费版才能自动更新，免费版只能手动点击 “设置” 中的更新按钮，来更新部署。 参考链接 gitee：https://www.cnblogs.com/chaojilaoshi/p/13266271.html gitee：https://www.jianshu.com/p/5014133ba61a page更新：https://www.jianshu.com/p/6460df84a099","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"Gitee","slug":"Gitee","permalink":"http://yoursite.com/tags/Gitee/"}]},{"title":"基于Hexo框架的博客搭建及其GitHub部署","slug":"基于Hexo框架的博客搭建及其GitHub部署","date":"2020-08-28T01:09:02.000Z","updated":"2020-09-02T09:50:08.071Z","comments":true,"path":"2020/08/28/基于Hexo框架的博客搭建及其GitHub部署/","link":"","permalink":"http://yoursite.com/2020/08/28/%E5%9F%BA%E4%BA%8EHexo%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%85%B6GitHub%E9%83%A8%E7%BD%B2/","excerpt":"","text":"Hexo简介 Hexo 是一个快速、简洁且高效的静态博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo受众面较广，对应的问题、扩展等内容在网上均有成熟解决方案，推荐安装使用。 安装安装前提安装Hexo之前需要先安装Node.js与Git。 ps：本文所有安装过程基于Windows环境下操作 Git安装 官网下载地址：https://git-scm.com/downloads 默认自动弹出适配版本，若没有则在“Git for Windows Setup”选择对应电脑位数下载 安装过程一直next直到完成即刻。 设置Git用户名 ps:Windows终端(cmd)内操作,不设置用户名和密码在安装hexo的过程中会报错 设置用户名git config --global user.name &quot;username&quot; 设置邮箱git config --global user.email useremail@qq.com 修改后可以检查一下，查看用户名和密码 git config user.name git config user.email 查看其他配置信息 git config --list Node.js安装 官方下载地址：https://nodejs.org/en/ 一般选择左边的 XX.XX.X LTS (长期支持版) 安装过程简单，直接操作即可。 安装完成后存在两个组件，一个是Node.js本身，另一个是npm(包管理器) hexo下载与安装 以管理员身份进入Windows终端。 检查node.js的安装结果node –vnpm –v 通过npm或cnpm安装hexo npm是外国的镜像源速度很慢，用淘宝的cnpm比较快 npm install -g cnpm --registry=http://registry.npm.taobao.org 通过cnpm下载安装hexocnmp install -g hexo cli 安装完成后通过命令可查看版本表示安装成功hexo –v hexo博客初始化 以下操作均在”总文件”路径下完成，且实例说明以名为”myblog”的文件夹表示hexo总文件夹。 若接下来的操作出现什么错误，直接把这个总文件夹删除重新来过即可 在想要安装博客的路径下创建一个总文件夹，如“myblog” 通过终端进入到这个总文件夹路径下 初始化博客 hexo init 常用组成文件功能介绍 ├_config.yml├&lt;source&gt;&emsp;&emsp;├&lt;_posts&gt;├&lt;themes&gt; _config.yml：配置文件，用于配置博客的重要属性 &lt;source&gt;：用于存放各种类型的md文件 &lt;_posts&gt; ：hexo new命令生成的md文件存位置 &lt;themes&gt;：存放不同的主题 启动博客，通过浏览器尝试访问 hexo s 终端会提示本地端口访问，一般为：localhost:4000 基本操作 ps：所有hexo命令操作都需要在安装hexo的总文件夹路径下操作 创建一篇文章， 新建的文章即md文件存放在/source/_posts hexo new &quot;My New Post&quot; 停止运行hexoctrl + c 清理之前生成的内容 hexo clean 校验并生成新的内容 hexo g GitHub部署仓库设置 登录github，创建仓库：repository name设置为：username.github.io 您github账号中的username,如博主账号username为yihangdeng则repository name 设置为：yihangdeng.github.io 其他保持默认即可，点击“Create repository”完成仓库创建 生成的链接结构为： https://github.com/username/username.github.io.git如：https://github.com/yihangdeng/yihangdeng.github.io.git Git远程部署插件安装cnpm install --save hexo-deployer-git 配置_config.yml设置总文件夹下的配置文件_config.yml，在配置信息的最底部修改并添加内容如下 123456# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deploymentdeploy: type: ‘git’ repo: (仓库创建后生成的链接) branch: master 123456# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deploymentdeploy: type: git repo: https:&#x2F;&#x2F;github.com&#x2F;yihangdeng&#x2F;yihangdeng.github.io.git branch: master 内容推送 通过命令远程部署到GitHub仓库hexo d 在远程部署的过程中有时要求输入GitHub的用户名和密码，如：Username for &quot;https://github.com\\&quot; 输入用户名Password for &quot;https://username@github.com\\&quot; 输入密码(密码默认不显示，直接输入后回车即可)若出错请检查是否有配置git的用户名和邮箱 刷新GitHub仓库可查看生成内容已部署到GitHub中 通过浏览器访问你的博客 url：username.github.io 如：yiahngdeng.github.io 若访问不了，请先尝试访问博主的博客(yiahngdeng.github.io)进而确认是部署出错还是访问GitHub的网络出现问题，具体参加博文《GitHub访问及其下载问题解决方案》。 常见错误 建议每次修改内容后都执行“hexo g”命令校验生成一下，报错的内容会显示在终端上。 标明错误行数：一般是配置文件中的“键值对”敲错，记住是英文冒号加空格，“: ” Git错误提示之：fatal: Not a git repository (or any of the parent directories): .git 提示说没有.git这样一个目录，在命令行 输入 git init 然后回车就好了 参考链接 codesheep：https://www.bilibili.com/video/BV1Yb411a7ty","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"}]}],"categories":[],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/tags/JavaSE/"},{"name":"娱乐","slug":"娱乐","permalink":"http://yoursite.com/tags/%E5%A8%B1%E4%B9%90/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"xml","slug":"xml","permalink":"http://yoursite.com/tags/xml/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"应用框架","slug":"应用框架","permalink":"http://yoursite.com/tags/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/"},{"name":"ORM框架","slug":"ORM框架","permalink":"http://yoursite.com/tags/ORM%E6%A1%86%E6%9E%B6/"},{"name":"技术积累","slug":"技术积累","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"项目构建","slug":"项目构建","permalink":"http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"},{"name":"个人文档","slug":"个人文档","permalink":"http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%96%87%E6%A1%A3/"},{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Gitee","slug":"Gitee","permalink":"http://yoursite.com/tags/Gitee/"}]}