<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo在Gitee平台部署过程</title>
    <url>/2020/08/29/Hexo%E5%9C%A8Gitee%E5%B9%B3%E5%8F%B0%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><ol>
<li><p>已经安装hexo，并且能够通过<code>hexo d</code>命令推送到GitHub实现远程推送。</p>
<blockquote>
<p>实现方案具体可参考<a class="link"   href="https://yihangdeng.gitee.io/2020/08/28/%E5%9F%BA%E4%BA%8EHexo%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%85%B6GitHub%E9%83%A8%E7%BD%B2/" >《基于Hexo框架的博客搭建及其GitHub部署》<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
</li>
<li><p>已经注册Gitee账号并且绑定手机。</p>
</li>
</ol>
<h1 id="Gitee新建仓库"><a href="#Gitee新建仓库" class="headerlink" title="Gitee新建仓库"></a>Gitee新建仓库</h1><ul>
<li>新建仓库时名称最好是保持跟你注册时的<strong>个人空间地址</strong>是一样的。因为这样你就不会生成二级域名了。如果不跟注册时的<em>个人空间地址</em>一样的话，到时候自己的网站就会有二级域名的存在了。</li>
<li>输入仓库名称与路径后会在“<strong>归属</strong>”一栏下生成一个<strong>仓库链接</strong>，记录下来为之后的_config.yml文件配置做准备</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/hexo%E5%8F%91%E5%B8%83gitee%E5%88%9B%E5%BB%BA2.jpg"
                     
                ></p>
<h1 id="config-yml文件配置"><a href="#config-yml文件配置" class="headerlink" title="_config.yml文件配置"></a>_config.yml文件配置</h1><p>修改配置文件中<strong>repo</strong> 属性为：{<strong>仓库地址</strong>} <strong>.git</strong></p>
<blockquote>
<ul>
<li>仓库地址在创建仓库的时候会显示，或者在刚创建完的时候浏览器的url就是仓库地址</li>
<li><strong>仓库地址</strong>一般组成：<strong> <a class="link"   href="https://gitee.com/%7B%E4%B8%AA%E4%BA%BA%E7%A9%BA%E9%97%B4%E5%90%8D%7D/%7B%E4%BB%93%E5%BA%93%E5%90%8D%E7%A7%B0%7D" >https://gitee.com/{个人空间名}/{仓库名称}<i class="fas fa-external-link-alt"></i></a></strong></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: &#39;git&#39;</span><br><span class="line">  repo:  &#123;仓库地址&#125;.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<blockquote>
<p>repo:  <a class="link"   href="https://gitee.com/yihangdeng/yihangdeng.git" >https://gitee.com/yihangdeng/yihangdeng.git<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>修改配置保存后，可以像推送到GitHub上那样，通过<code>hexo d</code>命令上传到gitee。刷新gitee仓库查看是否有内容</p>
<h1 id="开启仓库page服务"><a href="#开启仓库page服务" class="headerlink" title="开启仓库page服务"></a>开启仓库page服务</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/hexo%E5%8F%91%E5%B8%83gitee-Page%E6%9C%8D%E5%8A%A1.jpg"
                     
                ></p>
<p>进入页面后直接点击<strong>启动</strong>即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/hexo%E5%8F%91%E5%B8%83giteePage%E5%90%AF%E5%8A%A8.jpg"
                     
                ></p>
<p>启动完成后会生成<strong>网站地址</strong>，这个网站地址就是访问你博客的地址。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/hexo%E5%8F%91%E5%B8%83gitee-Page%E5%9C%B0%E5%9D%80.jpg"
                     
                ></p>
<ul>
<li>gitee page 只有付费版才能自动更新，免费版只能手动点击 “设置” 中的更新按钮，来更新部署。</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li>gitee：<a class="link"   href="https://www.cnblogs.com/chaojilaoshi/p/13266271.html" >https://www.cnblogs.com/chaojilaoshi/p/13266271.html<i class="fas fa-external-link-alt"></i></a></li>
<li>gitee：<a class="link"   href="https://www.jianshu.com/p/5014133ba61a" >https://www.jianshu.com/p/5014133ba61a<i class="fas fa-external-link-alt"></i></a></li>
<li>page更新：<a class="link"   href="https://www.jianshu.com/p/6460df84a099" >https://www.jianshu.com/p/6460df84a099<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>环境搭建</tag>
        <tag>Gitee</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/2021/03/21/Mybatis/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="基本历史"><a href="#基本历史" class="headerlink" title="基本历史"></a>基本历史</h1><p>原是Apache的一个开源项目iBatis, 2010年6月这 个项目由Apache Software Foundation 迁移到了 Google Code，随着开发团队转投Google Code 旗下， iBatis3.x正式更名为MyBatis ，代码于 2013年11月迁移到<a class="link"   href="https://github.com/mybatis/mybatis-3" >Github<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="Mybatis的优势"><a href="#Mybatis的优势" class="headerlink" title="Mybatis的优势"></a>Mybatis的优势</h1><p>java领域中，对比最常见的三种数据库编程。</p>
<h2 id="JDBC及相关工具"><a href="#JDBC及相关工具" class="headerlink" title="JDBC及相关工具"></a>JDBC及相关工具</h2><p>相关工具：JDBC—&gt;Dbutils(QueryRunner)—&gt;JdbcTemplate(Spring)</p>
<ul>
<li><p>SQL夹在Java代码块里，<strong>耦合度高导致硬编码</strong>，维护不易且实际开发需求中sql是有变化，频繁修改的情况多见。</p>
<blockquote>
<p>若改动一下数据库或改变一下sql语句，则整个项目需要重新打包构建部署</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210322161214.png"
                     
                ></p>
</li>
</ul>
<h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><p>Hibernate：<strong>全自动</strong>ORM（Object Relation Mapping）框架</p>
<ul>
<li><strong>全黑箱操作</strong>，想优化sql，必须再学习Hibernate的HQL定制sql语句，开发者希望sql语句交给开发人员编写，不失去其灵活性。</li>
<li><strong>只能全自动全映射</strong>，数据表有100个列，则即使只查询某一个字段都需要把全部列映射过来。导致数据库性能下降</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210322161239.png"
                     
                ></p>
<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><ul>
<li>MyBatis支持通过XML方式<strong>定制化 SQL</strong>、存储过程以及高级映射的优秀的持久层框架</li>
<li>因此Mybatis是<strong>半自动</strong>，<strong>轻量级</strong>的框架。</li>
<li>MyBatis 避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。</li>
<li>MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO(Plain Old Java  Objects，普通的Java对象)映射成数据库中的记录</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210322161329.png"
                     
                ></p>
<h1 id="Mybatis下载"><a href="#Mybatis下载" class="headerlink" title="Mybatis下载"></a>Mybatis下载</h1><ul>
<li><p>GitHub网址</p>
<ol>
<li>进入GitHub页面</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210321111234.png"
                     
                ></p>
<ol start="2">
<li>选的特定版本下载</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210321111420.png"
                     
                ></p>
</li>
<li><p>基本资料介绍</p>
<ul>
<li>解压mybatis-3.4.1，使用mybatis只需要导入mybatis-3.4.1.jar即可，lib目录下的jar包是mybatis需要添加其他功能才需要选择性导入的包</li>
</ul>
</li>
</ul>
<h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><h2 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h2><ol>
<li><p><a class="link"   href="https://mybatis.org/mybatis-3/zh/getting-started.html" >打开<i class="fas fa-external-link-alt"></i></a>，mybatis在线官方文档。操作基本按照官方文档进行</p>
</li>
<li><p>准备jar包</p>
<ul>
<li>mybatis-3.4.1.jar：mybatis核心jar包</li>
<li>mysql-connector-java-5.1.37-bin.jar：数据库连接jar包</li>
</ul>
</li>
<li><p>创建测试数据库：本例数据库名为 mybatis，创建测试数据表tbl_employee</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210321163228.png"
                     
                ></p>
</li>
<li><p>新建一个java项目，并建立对应的JavaBean</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210321163346.png"
                     
                ></p>
</li>
<li><p><strong>依据mybatis官方文档从XML中构建SqlSessionFactory</strong></p>
</li>
<li><p>本例是<strong>直接在类路径下</strong>创建XML文档：在项目内新建一个名为mybatis-config.xml (全局配置)文件，从官方文档中复制如下内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 需修改部分--------------------------------------------------------------tips --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 还缺少文件----------------------------------------------------------------tips --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改XML中的数据源信息：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 驱动 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>/&gt;</span><span class="comment">&lt;!-- 数据库地址 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span><span class="comment">&lt;!-- 用户名 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span><span class="comment">&lt;!-- 密码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从mybatis-config.xml 中构建SqlSessionFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加如下代码从 SqlSessionFactory 中获取 SqlSession</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure>
</li>
<li><p>拟执行查询操作，能查询已映射的 SQL语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形参1：sql隐射XML文件的唯一标识符</span></span><br><span class="line"><span class="comment">//形参2：执行sql语句的传入参数</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	Blog blog = (Blog) session.selectOne(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建已隐射的XML文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="comment">&lt;!-- sql映射文件 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 名称空间：暂时来说名字可以随便起，一般映射哪个实体对象就起名为 xxxMapper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.test.mybatis.bean.EmployeeMapper&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- id：唯一标识，一般起名为[操作类型 + 操作对象]selectXxx --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- resultTupe：返回类型，若返回是一个对象，则填入这个类的全类名 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- #&#123;id&#125;：从传递过来的参数中取出id指，类似java占位符 ? --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmp&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.test.mybatis.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">		select * from tbl_employee where id = #&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改第8步代码，开始执行查询操作，能查询已映射的 SQL语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形参1：sql映射XML文件的唯一标识符，可直接填入XML的id(若存在重名)</span></span><br><span class="line"><span class="comment">//	但建议使用XML中 namespace.id 的方式唯一标识</span></span><br><span class="line"><span class="comment">//形参2：执行sql语句的传入参数，如下查询id=1的员工信息</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    String id = <span class="string">&quot;com.test.mybatis.bean.EmployeeMapper.selectEmp&quot;</span>;</span><br><span class="line">    Employee employee = (Employee) session.selectOne(id, <span class="number">1</span>);</span><br><span class="line">    System.out.println(employee);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在全局配置文件mybatis-config.xml中修改为自定义的sql隐射文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 将写好的sql隐射文件注册到全局配置文件中，文件在全类名路径下，因此直接写即可 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;EmployeeMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最终效果</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210321163030.png"
                     
                ></p>
</li>
<li><p><strong>小结</strong></p>
<ol>
<li><p>根据xml全局配置文件创建一个SqlSessionFactrory</p>
</li>
<li><p>创建sql映射文件，配置了每一个sql，以及sql的 封装规则等</p>
</li>
<li><p>将sql映射文件注册在全局配置文件中</p>
</li>
<li><p>代码部分</p>
<ol>
<li><p>根据全局配置文件得到SqlSessionFactory</p>
</li>
<li><p>使用sqlSession工厂，获得sqlSession对象来执行增删改查</p>
<p>一个sqlSession就是代表和数据库的一次会话，用完关闭</p>
</li>
<li><p>使用sql的唯一标志来告诉Mybatis执行哪个sql，sqk均保存在sql映射文件中</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="接口式编程"><a href="#接口式编程" class="headerlink" title="接口式编程"></a>接口式编程</h2><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>对于上述的第8或12步骤的方式执行sql操作，mybatis还提供了一种更为智能，受众面更广的实现方式。即<strong>接口与配置文件</strong>进行动态<strong>绑定</strong>。以后使用mybatis均使用这种方式操作</p>
<ol>
<li><p>如日常开发<strong>创建dao的接口</strong>，EmployeeMapper.java</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210322154338.png"
                     
                ></p>
</li>
<li><p><strong>规范化</strong>sql映射文件中的<strong>namespace</strong>与<strong>id</strong>的值，形成如下<strong>对应关系</strong></p>
<ul>
<li><strong>namespace</strong> 值 == 对应dao操作的<strong>接口的全类名</strong></li>
<li><strong>id 值</strong> == 对应dao操作接口中特定的<strong>方法名</strong>(方法返回类型与传入参数也要对应sql语句本身)</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210322154725.png"
                     
                ></p>
</li>
<li><p>不再直接使用mybatis的session对象直接进行数据库操作，而是通过调用<code>session.getMapper();</code>方法，传入<strong>接口的类型</strong>，使其自动创建一个<strong>代理对象</strong>，通过这个代理对象<strong>实现类</strong>去执行增删改查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//String id = &quot;com.test.mybatis.bean.EmployeeMapper.selectEmp&quot;;</span></span><br><span class="line">    <span class="comment">//Employee employee = (Employee) session.selectOne(id, 1);</span></span><br><span class="line">    EmployeeMapper mapper = session.getMapper(EmployeeMapper.class);</span><br><span class="line">    Employee employee = mapper.getEmpById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(employee);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>代码不仅<strong>更清晰</strong></li>
<li>不用担心<strong>传入类型安全</strong>(8/12步骤方式传入类型为Object)，</li>
<li>不用担心可能<strong>出错的字符串</strong>字面值以及返回类型需要<strong>强制类型转换</strong></li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li><p><strong>接口式编程</strong></p>
<ul>
<li>原生：      Dao         ===&gt;   DaoImpl</li>
<li>mybatis：Mapper  ===&gt;  xxMapper.xml</li>
</ul>
</li>
<li><p><strong>SqlSession</strong>代表和数据库的<strong>一次会话</strong>；<strong>用完必须关闭</strong>；</p>
</li>
<li><p><strong>SqlSession</strong>和connection一样她都是<strong>非线程安全</strong>。每次使用都应该去获取新的对象。</p>
</li>
<li><p>mapper接口没有实现类，但是mybatis会为这个接口生成一个代理对象(将接口和xml进行绑定)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EmployeeMapper empMapper =	sqlSession.getMapper(EmployeeMapper.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>两个重要的配置文件</strong></p>
<ul>
<li><p><strong>mybatis的全局配置文件</strong>：包含数据库<strong>连接池信息</strong>，事务管理器信息等…<strong>系统运行环境信息</strong></p>
</li>
<li><p><strong>sql映射文件</strong>：保存了<strong>每一个sql语句</strong>的映射信息(将sql抽取出来)</p>
</li>
</ul>
</li>
</ol>
<h1 id="config-xml相关标签"><a href="#config-xml相关标签" class="headerlink" title="config_xml相关标签"></a>config_xml相关标签</h1><h2 id="标签书写提示检查"><a href="#标签书写提示检查" class="headerlink" title="标签书写提示检查"></a>标签书写提示检查</h2><p>若配置文件书写中无法弹出mybatis标签的提示，可以进行如下操作，一般IDE都有</p>
<ol>
<li><p>准备mybatis-3-config.dtd文件</p>
<ol>
<li>联网状态下可以点击xml文件中链接下载：<a class="link"   href="http://mybatis.org/dtd/mybatis-3-config.dtd" >http://mybatis.org/dtd/mybatis-3-config.dtd<i class="fas fa-external-link-alt"></i></a></li>
<li>或者在mybatis-3,4,1.jar包中ibatis.builder.xml中解压出来</li>
</ol>
</li>
<li><p>进入eclipse 进行如下设置</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210322161143.png"
                     
                ></p>
<ol start="3">
<li>最后在IDE中关闭所有xml文件，再打开测试即可</li>
</ol>
</li>
</ol>
<hr>
<p>以下介绍均为最基本，最常用的使用方式。详细使用与功能介绍可参详<a class="link"   href="https://mybatis.org/mybatis-3/zh/getting-started.html" >官方文档<i class="fas fa-external-link-alt"></i></a></p>
<hr>
<h2 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h2><p>mybatis可以使用properties来引入外部 .properties配置文件的内容，主要使用在数据源信息上。</p>
<ul>
<li><strong>resource</strong>：引入<strong>类路径</strong>下的资源</li>
<li><strong>url</strong>：引入<strong>网络路径</strong>或者<strong>磁盘路径</strong>下的资源</li>
</ul>
<hr>
<ol>
<li><p>如在类路径下创建一个dbconfig.properties文件，用于存放数据源信息，内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdbc.driver&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis</span><br><span class="line">jdbc.username&#x3D;root</span><br><span class="line">jdbc.password&#x3D;root</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>properties</code>标签引入相关信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">	&lt;!-- 若不在类路径下，则按包名定位到，如com&#x2F;test&#x2F;dbconfig.properties... --&gt;</span><br><span class="line">	&lt;properties resource&#x3D;&quot;dbconfig.properties&quot;&gt;&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;environments default&#x3D;&quot;development&quot;&gt;</span><br><span class="line">		&lt;environment id&#x3D;&quot;development&quot;&gt;</span><br><span class="line">			&lt;transactionManager type&#x3D;&quot;JDBC&quot; &#x2F;&gt;</span><br><span class="line">			&lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">				&lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot; &#x2F;&gt;</span><br><span class="line">				&lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot; &#x2F;&gt;</span><br><span class="line">				&lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot; &#x2F;&gt;</span><br><span class="line">				&lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot; &#x2F;&gt;</span><br><span class="line">			&lt;&#x2F;dataSource&gt;</span><br><span class="line">		&lt;&#x2F;environment&gt;</span><br><span class="line">	&lt;&#x2F;environments&gt;</span><br><span class="line"></span><br><span class="line">	&lt;mappers&gt;</span><br><span class="line">		&lt;mapper resource&#x3D;&quot;EmployeeMapper.xml&quot; &#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;mappers&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210322171530.png"
                     
                ></p>
</li>
</ol>
<h2 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h2><p>这是 MyBatis中极为重要的调整设置，它们会改变MyBatis 的运行时行为。一般使用默认即可，不需要配置，需要再查看文档进行相应的配置。</p>
<ul>
<li><strong>name</strong>为要设置对应的<strong>配置信息</strong>，</li>
<li><strong>value</strong>就是配置的<strong>值</strong></li>
</ul>
<hr>
<p>例如：选取官方文档其中一个设置<strong>mapUnderscoreToCamelCase</strong>  </p>
<table>
<thead>
<tr>
<th>设置名</th>
<th>描述</th>
<th>有效值</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>mapUnderscoreToCamelCase</td>
<td>是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn</td>
<td>true|false</td>
<td>False</td>
</tr>
</tbody></table>
<p>默认是False，若开启后，数据库列名为 <strong>last_Name</strong> 可直接映射java属性名<strong>lastName</strong>，而无需使用别名修改为lastName进行映射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">	&lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;settings&gt;</span><br></pre></td></tr></table></figure>

<h2 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h2><h3 id="自定义类别名"><a href="#自定义类别名" class="headerlink" title="自定义类别名"></a>自定义类别名</h3><p>为某个java类全类名起别名</p>
<ul>
<li><strong>type</strong>：指定要起别名的类的全类名，<strong>默认别名</strong>就是类<strong>名</strong>(不分大小写)</li>
<li><strong>alias</strong>：指定<strong>新的别名</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">		&lt;!-- 方式1.1：指定被起别名类全类名，使用默认别名(类名) --&gt;&lt;!-- </span><br><span class="line">		&lt;typeAlias type&#x3D;&quot;com.test.mybatis.bean.Employee&quot;&#x2F;&gt;--&gt;</span><br><span class="line">		 </span><br><span class="line">		&lt;!-- 方式1.2：在方式1的基础上，使用alias标签指定自定义别名 --&gt;&lt;!-- </span><br><span class="line">		&lt;typeAlias type&#x3D;&quot;com.test.mybatis.bean.Employee&quot; alias&#x3D;&quot;emp&quot;&#x2F;&gt; --&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;!-- 方式2.1：为指定包下所有类起别名，此时只能使用默认别名 --&gt;&lt;!-- </span><br><span class="line">		&lt;package name&#x3D;&quot;com.test.mybatis.bean&quot;&#x2F;&gt;--&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;!-- 方式2.2：若指定某包名与其子包下存在两个同名的类，则可以使用@Alias(&quot;Name&quot;)注解直接为指定java类起别名 --&gt;</span><br><span class="line">		&lt;!-- 注意：需要指明使用别名注解的包是什么，即要保留方式2.1的package标签，否则会报错 --&gt;</span><br><span class="line">		&lt;package name&#x3D;&quot;com.test.mybatis.bean&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;typeAliases&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;ABC&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>示例方式1.2效果如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210322222457.png"
                     
                ></p>
</li>
</ul>
<h3 id="默认设置别名"><a href="#默认设置别名" class="headerlink" title="默认设置别名"></a>默认设置别名</h3><p>Mybatis官方已默认为java常用的一些基本数据类型，包装类型，集合操作等起了别名。自定义别名时注意不要于其发生冲突</p>
<ul>
<li>基本数据类型：别名加下划线’’_’’</li>
<li>java类：小写</li>
</ul>
<table>
<thead>
<tr>
<th>别名</th>
<th>映射的类型</th>
</tr>
</thead>
<tbody><tr>
<td>_byte</td>
<td>byte</td>
</tr>
<tr>
<td>_long</td>
<td>long</td>
</tr>
<tr>
<td>_short</td>
<td>short</td>
</tr>
<tr>
<td>_int</td>
<td>int</td>
</tr>
<tr>
<td>_integer</td>
<td>int</td>
</tr>
<tr>
<td>_double</td>
<td>double</td>
</tr>
<tr>
<td>_float</td>
<td>float</td>
</tr>
<tr>
<td>_boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>String</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>integer</td>
<td>Integer</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>date</td>
<td>Date</td>
</tr>
<tr>
<td>decimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>bigdecimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>object</td>
<td>Object</td>
</tr>
<tr>
<td>map</td>
<td>Map</td>
</tr>
<tr>
<td>hashmap</td>
<td>HashMap</td>
</tr>
<tr>
<td>list</td>
<td>List</td>
</tr>
<tr>
<td>arraylist</td>
<td>ArrayList</td>
</tr>
<tr>
<td>collection</td>
<td>Collection</td>
</tr>
<tr>
<td>iterator</td>
<td>Iterator</td>
</tr>
</tbody></table>
<h2 id="typeHandlers"><a href="#typeHandlers" class="headerlink" title="typeHandlers"></a>typeHandlers</h2>]]></content>
      <tags>
        <tag>应用框架</tag>
        <tag>ORM框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL总结</title>
    <url>/2020/10/22/SQL%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><p><strong>创建数据库</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">schema</span> &lt;数据库名&gt; authorization &lt;用户名&gt; [内嵌定义];</span><br><span class="line">[内嵌定义] ：[&lt;表创建子句&gt;|&lt;视图创建子句&gt;|&lt;授权定义子句&gt;]</span><br></pre></td></tr></table></figure>



<p><strong>删除数据库</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">schema</span> &lt;数据库名&gt; &lt;<span class="keyword">cascade</span>|restrict&gt;</span><br></pre></td></tr></table></figure>



<h1 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h1><p>创建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> &lt;表名&gt;(&lt;字段定义&gt;);</span><br><span class="line">&lt;字段定义&gt;：(</span><br><span class="line">	&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束]</span><br><span class="line">	[, &lt;列名&gt;&lt;数据类型&gt;[列级完整性约束] ]</span><br><span class="line">	…</span><br><span class="line">	[, &lt;表级完整性约束&gt;]</span><br><span class="line">   )</span><br></pre></td></tr></table></figure>



<p>修改表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span>&lt;表名&gt;</span><br><span class="line">	[<span class="keyword">add</span>[<span class="keyword">column</span>] &lt;新列名&gt;&lt;数据类型&gt;[列级完整性约束] ]  </span><br><span class="line">	[<span class="keyword">add</span> &lt;表级完整性约束&gt;] <span class="comment">/*ADD **UNIQUE(Name)** */</span></span><br><span class="line">	</span><br><span class="line">	[<span class="keyword">drop</span> [<span class="keyword">column</span>] &lt;列名&gt;[<span class="keyword">cascade</span>|restrict] ]              </span><br><span class="line">	[<span class="keyword">drop</span> <span class="keyword">constraint</span> &lt;完整性约束**名**&gt;[<span class="keyword">cascade</span>|restrict]]       </span><br><span class="line"></span><br><span class="line">	[<span class="keyword">alter</span> <span class="keyword">column</span> &lt;已存在列名&gt;&lt;新数据类型&gt;]       </span><br></pre></td></tr></table></figure>

<p>删除表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> &lt;表名&gt;[restrict|<span class="keyword">cascade</span>];</span><br></pre></td></tr></table></figure>



<h1 id="DQL语言"><a href="#DQL语言" class="headerlink" title="DQL语言"></a>DQL语言</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> [<span class="keyword">all</span>|<span class="keyword">distinct</span>]&lt;目标列表达式&gt; [,&lt;目标列表达式&gt;]…</span><br><span class="line"><span class="keyword">from</span> &lt;表/视图名&gt;[,&lt;表/视图名&gt;…]</span><br><span class="line">[<span class="keyword">where</span> &lt;条件表达式&gt;]</span><br><span class="line">[<span class="keyword">group</span> <span class="keyword">by</span> &lt;列名<span class="number">1</span>&gt; [<span class="keyword">having</span>&lt;条件表达式&gt;]]</span><br><span class="line">[<span class="keyword">order</span> <span class="keyword">by</span> &lt;列名<span class="number">2</span>&gt; [<span class="keyword">asc</span>|<span class="keyword">desc</span>]];</span><br></pre></td></tr></table></figure>

<ul>
<li>&lt;目标列表达式&gt;：控制取某字段、字段别名、’常量列’、运算式、调用函数</li>
<li>调用函数：count(*)、sum、avg、max、min。均可选择count( [distinct | all] &lt;列名&gt;)</li>
<li>&lt;条件表达式&gt;：<ol>
<li>=，&gt;，&lt;，&gt;=，&lt;=，!=，&lt;&gt;，!&gt;，!&lt; ; NOT + 上述比较运算符</li>
<li><strong>范围：</strong>between and、not between and： <code>&lt;字段名&gt;between &lt;值1&gt;and&lt;值2&gt;</code>;</li>
<li><strong>集合：</strong>in，not in ：<code>&lt;字段名&gt; in (&lt;数据集合|子查询&gt;);</code></li>
<li><strong>字符匹配：</strong>like、not like ：<code>&lt;字段名&gt; like ‘&lt;匹配串&gt;’; [ESCAPE ‘&lt;换转义符字符&gt;’]</code></li>
<li><strong>空值：</strong>is null、is not null ：<code>&lt;字段名&gt;is null;</code></li>
<li><strong>条件：</strong>and、or、not：<code>&lt;条件表达式&gt; AND &lt;条件表达式&gt;;</code></li>
</ol>
</li>
</ul>
<h1 id="DL高级查询"><a href="#DL高级查询" class="headerlink" title="DL高级查询"></a>DL高级查询</h1><p>DQL高级查询：子查询、连接查询、集合查询</p>
<h2 id="子查询-嵌套查询"><a href="#子查询-嵌套查询" class="headerlink" title="子查询(嵌套查询)"></a>子查询(嵌套查询)</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>…<span class="keyword">from</span>…<span class="keyword">where</span> &lt;字段&gt;&lt;子查询谓词&gt;(&lt;查询块&gt;)</span><br><span class="line">&lt;查询块&gt;：<span class="keyword">select</span>…<span class="keyword">from</span>…<span class="keyword">where</span></span><br></pre></td></tr></table></figure>

<ul>
<li>&lt;子查询谓词&gt;：in、比较运算符、比较运算符+any/some,all、exists</li>
<li>any，&lt;all等…，(any：某个值、all：所有值)</li>
<li>exists：不返回任何数据，只产生逻辑真假“true/false”</li>
</ul>
<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><ul>
<li>连接查询：等值、非等值、自连接、外连接(左外右外)</li>
<li>连接查询：<strong>from 多表 + 表名点取字段 + 别名设计 + 连接谓词</strong></li>
</ul>
<h3 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h3><p>等值连接查询：连接条件/谓词使用 “=” 符号</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">from &lt;表1&gt;[,表2]…</span><br><span class="line">where &lt;表1&gt;.&lt;字段&gt; = &lt;表2&gt;.&lt;字段&gt;…</span><br></pre></td></tr></table></figure>

<h3 id="非等值连接查询"><a href="#非等值连接查询" class="headerlink" title="非等值连接查询"></a>非等值连接查询</h3><p>非等值连接查询：连接条件/谓词不是使用 “=” 符号</p>
<h3 id="自身连接查询"><a href="#自身连接查询" class="headerlink" title="自身连接查询"></a>自身连接查询</h3><p>自身连接查询：同一个表设置不同的别名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>&lt;别名<span class="number">1</span>&gt;.&lt;字段<span class="number">1</span>&gt;,&lt;别名<span class="number">2</span>&gt;.&lt;字段<span class="number">2</span>&gt;</span><br><span class="line"><span class="keyword">from</span>&lt;表名<span class="number">1</span>&gt;.&lt;别名<span class="number">1</span>&gt;,&lt;表名<span class="number">2</span>&gt;.&lt;别名<span class="number">2</span>&gt;</span><br><span class="line"><span class="keyword">where</span> &lt;别名<span class="number">1</span>&gt;.&lt;字段<span class="number">2</span>&gt;=&lt;别名<span class="number">2</span>&gt;.&lt;字段<span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">from &lt;表1&gt; left outer join &lt;表2&gt; on(&lt;连接条件&gt;) /*左外(保留左表数据)*/</span><br><span class="line">from &lt;表1&gt; right outer join &lt;表2&gt; on(&lt;连接条件&gt;) /* 右外(保留右表数据) */</span><br></pre></td></tr></table></figure>

<h2 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;查询块集合1&gt; &lt;集合查询谓词&gt; &lt;查询块集合2&gt;</span><br><span class="line">&lt;集合查询谓词&gt;：交操作intersect，并操作union，差(集)操作except</span><br></pre></td></tr></table></figure>



<h1 id="DML语言："><a href="#DML语言：" class="headerlink" title="DML语言："></a>DML语言：</h1><p>​    插入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span>&lt;表名&gt;[(&lt;属性列<span class="number">1</span>[,属性列<span class="number">2</span>]&gt;…)] <span class="keyword">values</span>(&lt;常量<span class="number">1</span>&gt;[,&lt;常量<span class="number">2</span>&gt;…);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>若不写字段，则必须按序写完value参数</p>
</li>
<li><p>插入多条语句values(),(),()…</p>
</li>
<li><p>允许空的字段，value值可用null占位 </p>
</li>
<li><p>若填写了属性列表，则value部分必须一一对应(数量上，类型上)。且属性列表<strong>不一定按序</strong>，可自动识别字段名，但数据要和字段名对应。</p>
<p>子查询插入</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> &lt;表名&gt;[(&lt;属性列<span class="number">1</span>[,属性列<span class="number">2</span>]&gt;…)] &lt;子查询&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过子查询的形式不用写value，但子查询字段同样需要对应属性列信息</li>
</ul>
<p>​    修改</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> &lt;表名&gt; <span class="keyword">set</span> &lt;列名&gt; = &lt;表达式&gt;[,&lt;列名&gt; = &lt;表达式&gt;]</span><br><span class="line">[<span class="keyword">where</span> &lt;条件&gt;]</span><br></pre></td></tr></table></figure>

<p>​    删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> &lt;表名&gt; [<span class="keyword">where</span> &lt;条件&gt;]; </span><br></pre></td></tr></table></figure>

<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> &lt;视图名&gt; [(&lt;列名&gt;[,&lt;列名&gt;]…)]</span><br><span class="line"><span class="keyword">as</span> &lt;子查询&gt;</span><br><span class="line">[<span class="keyword">with</span> <span class="keyword">check</span> <span class="keyword">option</span>]</span><br></pre></td></tr></table></figure>



<p>​    </p>
<pre><code># 数据库安全性</code></pre>
<p>以下均为自主存储控制方法</p>
<h2 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> &lt;权限/操作类型&gt;[,权限]...</span><br><span class="line"><span class="keyword">on</span> &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]... <span class="comment">/*一般为： Table &lt;表名&gt;*/</span></span><br><span class="line"><span class="keyword">to</span> &lt;用户&gt;[,&lt;用户&gt;]...	<span class="comment">/*注意：授予权限给用户前需存在这个用户(新建或原本存在)*/</span></span><br><span class="line">[<span class="keyword">with</span> <span class="keyword">grant</span> <span class="keyword">option</span>]</span><br></pre></td></tr></table></figure>

<p>example：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*把查询Student表的权限授给用户U1*/</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">to</span> U1;</span><br></pre></td></tr></table></figure>

<p>&lt;权限/操作类型&gt;：即为用户授予<strong>哪些操作</strong></p>
<table>
<thead>
<tr>
<th>可控制操作权限类型</th>
<th>具体语句</th>
</tr>
</thead>
<tbody><tr>
<td>数据库</td>
<td>create schema</td>
</tr>
<tr>
<td>数据表</td>
<td>create table，alter table</td>
</tr>
<tr>
<td>视图</td>
<td>create view</td>
</tr>
<tr>
<td>索引</td>
<td>create index</td>
</tr>
<tr>
<td>基本表和视图</td>
<td>select，insert，update，delete，references，all privileges(所有权限)</td>
</tr>
<tr>
<td>属性列</td>
<td>select，insert，update，references，all privileges</td>
</tr>
</tbody></table>
<p><strong>&lt;对象类型&gt; &lt;对象名&gt;</strong>：一般最大是表级限制。即  <code>Table &lt;表名&gt;</code></p>
<p><strong>&lt;用户&gt;</strong>：若不存在指定用户需要先建立用户才能进行对应的授权操作，sql server2008 R2 环境下创建新用户步骤如下：</p>
<p>创建指定数据库的用户需要与这个用户的登录用户绑定：即<strong>想建立用户，必须先建立这个用户对应的登录用户</strong></p>
<ol>
<li><p>创建<strong>新登录用户</strong></p>
<ol>
<li>打开sql server，连接数据库后。找到根目录下的“<strong>安全性</strong>”文件夹。</li>
<li>选中“<strong>登录名</strong>”文件夹并<strong>右键</strong>点击“<strong>新建登录名</strong>”</li>
<li>设置登录名，并选择“<strong>sql server 身份验证</strong>”，<strong>设置密码</strong>(自己记住)。</li>
<li>最后把“<strong>强制密码过期(x)**”的勾选</strong>去除**，最后点击右下加确认按钮保存即可</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%96%B0%E5%BB%BA%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E5%90%8D.jpg"
                     
                ></p>
</li>
<li><p>创建<strong>用户</strong></p>
<ol>
<li>进入到需创建用户的<strong>数据库</strong>文件夹内，找到<strong>指定数据库目录下的</strong>“<strong>安全性</strong>”文件夹</li>
<li>此时在选中“<strong>安全性</strong>”文件夹后<strong>右键——&gt;新建——&gt;用户(U)</strong></li>
<li>输入<strong>用户名</strong>，可自定义(但一般与对应的登录用户名一致)</li>
<li>点击在“<strong>登录名</strong>”输入栏最右边的“**[…]<strong>”按钮，展开后右边点击“</strong>浏览<strong>”，勾选刚刚建立的</strong>新登录用户名**，最后点击左下角确认按钮保存即可。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%96%B0%E5%BB%BA%E7%94%A8%E6%88%B7.jpg"
                     
                ></p>
</li>
</ol>
<p><strong>[with grant option]</strong>：若使用该子句，获得权限的用户可以将次权限传递授予给其他用户，默认不允许。且SQL标准不允许循环授权</p>
<p>实操备注：</p>
<ul>
<li>有别于教材，当前环境添加&lt;对象类型&gt;即table关键字会报错</li>
<li>当前环境grant语句一次性只允许向一个表授权，可同时向多个用户授权</li>
</ul>
<h2 id="收回权限"><a href="#收回权限" class="headerlink" title="收回权限"></a>收回权限</h2><h1 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h1><p>数据库完整性指：数据的<strong>正确性</strong>与<strong>相容性</strong></p>
]]></content>
      <tags>
        <tag>SQL</tag>
        <tag>技术积累</tag>
      </tags>
  </entry>
  <entry>
    <title>video interface set</title>
    <url>/2020/12/12/video%20interface%20set/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">亲测系列</span><br><span class="line">https:<span class="comment">//cdn.yangju.vip/k/?url=</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">源：https:<span class="comment">//www.cnblogs.com/apolloren/p/11247487.html</span></span><br><span class="line">最稳定万能vip视频解析接口 支持HTTPS</span><br><span class="line">https:<span class="comment">//cdn.yangju.vip/k/?url=</span></span><br><span class="line">https:<span class="comment">//cdn.yangju.vip/k/?url=</span></span><br><span class="line">https:<span class="comment">//jx.lache.me/cc/?url=</span></span><br><span class="line">https:<span class="comment">//api.653520.top/vip/?url=</span></span><br><span class="line">https:<span class="comment">//jx.ab33.top/vip/?url=</span></span><br><span class="line">https:<span class="comment">//vip.mpos.ren/v/?url=</span></span><br><span class="line">https:<span class="comment">//jx.000180.top/jx/?url=</span></span><br><span class="line">https:<span class="comment">//jx.km58.top/jx/?url=</span></span><br><span class="line"></span><br><span class="line">源：https:<span class="comment">//www.zye.cc/toosl/15775.html</span></span><br><span class="line">无广告通用：https:<span class="comment">//vip.52jiexi.top/?url=  腾讯直解</span></span><br><span class="line">无广告解析：https:<span class="comment">//jx.lfeifei.cn/?url= </span></span><br><span class="line">无广告解析：https:<span class="comment">//api.steak517.top/?url= 秒播</span></span><br><span class="line">无广告解析：http:<span class="comment">//api.steak517.top/?url=</span></span><br><span class="line">无广告通用HTTP接口：http:<span class="comment">//api.yueliangjx.com/?url=</span></span><br><span class="line">无广告通用HTTPS接口：https:<span class="comment">//api.yueliangjx.com/?url=</span></span><br><span class="line">无广告解析：https:<span class="comment">//jx.elwtc.com/vip/?url=</span></span><br><span class="line">无广告解析：https:<span class="comment">//api.78sy.cn/?url= 秒播</span></span><br><span class="line">无广告通用HTTP接口：http:<span class="comment">//www.2ajx.com/vip.php?url=</span></span><br><span class="line">无广告通用HTTPS接口：https:<span class="comment">//www.2ajx.com/vip.php?url=</span></span><br><span class="line">通用HTTP接口：http:<span class="comment">//api.steak517.top/?url=</span></span><br><span class="line">通用HTTPS接口：https:<span class="comment">//api.steak517.top/?url=</span></span><br><span class="line">https:<span class="comment">//vip.ikjiexi.top/api/?url=   无广告，速度也还行</span></span><br><span class="line">https:<span class="comment">//www.kpezp.cn/jlexi.php?url=  速度挺快的*还带记忆播放</span></span><br><span class="line">https:<span class="comment">//api.8bjx.cn/?url=   秒播吧 记忆</span></span><br><span class="line">https:<span class="comment">//jx.f41.cc/?url= 速度还可以</span></span><br><span class="line">http:<span class="comment">//v.nmbaojie.com/mingri/mingri.php?url=速度还行</span></span><br><span class="line">https:<span class="comment">//www.ckmov.vip/api.php?url= 挺快的</span></span><br><span class="line">http:<span class="comment">//jx.ejiafarm.com/dy.php?url= 挺快的</span></span><br><span class="line">https:<span class="comment">//jx.youyitv.com/?url=</span></span><br><span class="line">http:<span class="comment">//jiexi.xueshi.pro</span></span><br><span class="line">https:<span class="comment">//z1.m1907.cn/?jx=  小卡</span></span><br><span class="line">https:<span class="comment">//jx.618g.com/?url=  速度一般</span></span><br><span class="line">https:<span class="comment">//www.1717yun.com/jx/ty.php?url= 速度还可以</span></span><br><span class="line">https:<span class="comment">//cdn.yangju.vip/k/?url=   一般</span></span><br><span class="line">https:<span class="comment">//vip.jaoyun.com/index.php?url= 还可以</span></span><br><span class="line">https:<span class="comment">//jx.618g.com/?url=   还可以</span></span><br><span class="line">https:<span class="comment">//www.myxin.top/jx/api/?url=  腾讯直解 缓存挺快的</span></span><br><span class="line">https:<span class="comment">//jiexi.071811.cc/jx.php?url=  挺快的</span></span><br><span class="line">https:<span class="comment">//jx.wslmf.com/?url=   还行就是  不带缓存要拉快进的注意了</span></span><br><span class="line">https:<span class="comment">//jx.dy-jx.com/?url= 打不开</span></span><br><span class="line">https:<span class="comment">//vip.mpos.ren/v/?url=黑屏</span></span><br><span class="line">https:<span class="comment">//jqaaa.com/jx.php?url= 速度挺快的</span></span><br><span class="line">https:<span class="comment">//jx.598110.com/index.php?url= 速度还可以</span></span><br><span class="line">https:<span class="comment">//jx.bwcxy.com/?v=  速度还可以</span></span><br><span class="line">https:<span class="comment">//jx.rdhk.net/?v=    速度一般</span></span><br><span class="line">https:<span class="comment">//jx.fo97.cn/?url= 好像不能用</span></span><br><span class="line">https:<span class="comment">//jx.ivito.cn/?url= 一般</span></span><br><span class="line">https:<span class="comment">//api.927jx.com/vip/?url=一般般</span></span><br><span class="line">https:<span class="comment">//api.tv920.com/vip/?url=很一般</span></span><br><span class="line">https:<span class="comment">//api.lhh.la/vip/?url=</span></span><br><span class="line">https:<span class="comment">//api.sumingys.com/index.php?url=  很一般</span></span><br><span class="line">https:<span class="comment">//cn.bjbanshan.cn/jx.php?url=挺快的</span></span><br><span class="line">https:<span class="comment">//jx.mw0.cc/?url=挺快的</span></span><br><span class="line">https:<span class="comment">//www.33tn.cn/?url= 挺快的</span></span><br><span class="line">http:<span class="comment">//jx.1ff1.cn/?url=  还行</span></span><br><span class="line">https:<span class="comment">//jx.000180.top/jx/?url=  一般</span></span><br><span class="line">https:<span class="comment">//py.ha12.xyz/sos/index.php?url=</span></span><br><span class="line">https:<span class="comment">//jiexi.380k.com/?url= 挺快的</span></span><br><span class="line">https:<span class="comment">//jx.wslmf.com/?url=   挺快的</span></span><br><span class="line">https:<span class="comment">//okjx.cc/?url=</span></span><br><span class="line">http:<span class="comment">//www.662820.com/xnflv/index.php?url=</span></span><br><span class="line">http:<span class="comment">//api.lldyy.net/svip/?url=</span></span><br><span class="line">http:<span class="comment">//www.82190555.com/index/qqvod.php?url=</span></span><br><span class="line">http:<span class="comment">//jiexi.92fz.cn/player/vip.php?url=</span></span><br><span class="line">http:<span class="comment">//jiexi.071811.cc/jx2.php?url=</span></span><br><span class="line">http:<span class="comment">//api.wlzhan.com/sudu/?url=</span></span><br><span class="line">http:<span class="comment">//beaacc.com/api.php?url=</span></span><br><span class="line">http:<span class="comment">//qxkkk.bid/jx/jx.php?url=</span></span><br><span class="line">http:<span class="comment">//www.27v9.cn/index.php?url=</span></span><br><span class="line">http:<span class="comment">//www.ckplayer.tv/kuku/?url=</span></span><br><span class="line">http:<span class="comment">//o8ve.cn/1/?url=</span></span><br><span class="line">http:<span class="comment">//api.xyingyu.com/?url=</span></span><br><span class="line">https:<span class="comment">//jx.kt111.top/jx/mf/?url=</span></span><br><span class="line">https:<span class="comment">//api.pangujiexi.com/player.php?url=</span></span><br><span class="line">http:<span class="comment">//api.lvcha2017.cn/?url=</span></span><br><span class="line">http:<span class="comment">//kkk.2016ve.cn/kkjx/index.php?url=</span></span><br><span class="line">http:<span class="comment">//mlxztz.com/vip/?url=</span></span><br><span class="line">http:<span class="comment">//www.aktv.men/?url=</span></span><br><span class="line">http:<span class="comment">//jy777.cn/XSD/XSD/?url=</span></span><br><span class="line">http:<span class="comment">//api.visaok.net/?url=</span></span><br><span class="line">http:<span class="comment">//api.xyingyu.com/?url=</span></span><br><span class="line">http:<span class="comment">//api.greatchina56.com/?url=</span></span><br><span class="line">http:<span class="comment">//jx.618g.com/?url=</span></span><br><span class="line">http:<span class="comment">//api.baiyug.vip/index.php?url=</span></span><br><span class="line">http:<span class="comment">//jx.jfysz.cn/jx.php/?url=</span></span><br><span class="line">http:<span class="comment">//jx.ektao.cn/jx.php/?url=</span></span><br><span class="line">http:<span class="comment">//jx.reclose.cn/jx.php/?url=</span></span><br><span class="line">http:<span class="comment">//jx.eayn.org.cn/jx.php/?url=</span></span><br><span class="line">http:<span class="comment">//api.xyingyu.com/?url=</span></span><br><span class="line">http:<span class="comment">//jx.iaeec.cn/jx.php/?url=</span></span><br><span class="line">http:<span class="comment">//jx.83y4n7a.cn/jx.php/?url=</span></span><br><span class="line">http:<span class="comment">//jx.cmbzzs.cn/jx.php/?url=</span></span><br><span class="line">http:<span class="comment">//api.greatchina56.com/?url=</span></span><br><span class="line">http:<span class="comment">//jx.as19811.cn/jx.php/?url=</span></span><br><span class="line">http:<span class="comment">//jx.sdjnd09.cn/jx.php/?url=</span></span><br><span class="line">http:<span class="comment">//api.baiyug.vip/index.php?url=</span></span><br><span class="line">http:<span class="comment">//jx.09876as.cn/jx.php/?url=</span></span><br><span class="line">http:<span class="comment">//jx.17ktv.com.cn/jx.php/?url=</span></span><br><span class="line">http:<span class="comment">//jx.ab78a.cn/jx.php/?url=</span></span><br><span class="line">http:<span class="comment">//jx.09877as.cn/jx.php/?url=</span></span><br><span class="line">http:<span class="comment">//jx.yipolo111.cn/jx.php/?url=</span></span><br><span class="line">http:<span class="comment">//jx.908astbb.cn/jx.php/?url=</span></span><br><span class="line">http:<span class="comment">//jx.dlzyrk001.cn/jx.php/?url=</span></span><br><span class="line">http:<span class="comment">//jx.dccmy.org.cn/jx.php/?url=</span></span><br><span class="line">http:<span class="comment">//jx.boctx.cn/jx.php/?url=</span></span><br><span class="line">http:<span class="comment">//jx.hxbte.cn/jx.php/?url=</span></span><br><span class="line">http:<span class="comment">//api.visaok.net/?url=</span></span><br><span class="line">http:<span class="comment">//jx.618g.com/?url=</span></span><br><span class="line">http:<span class="comment">//yun.baiyug.cn/vip/?url=</span></span><br><span class="line">http:<span class="comment">//api.baiyug.cn/vip/?url=</span></span><br><span class="line">https:<span class="comment">//api.flvsp.com/?url=</span></span><br><span class="line">http:<span class="comment">//api.xfsub.com/index.php?url=</span></span><br><span class="line">http:<span class="comment">//api.xfsub.com/index.php?url=</span></span><br><span class="line">http:<span class="comment">//jiexi.071811.cc/jx2.php?url=</span></span><br><span class="line">http:<span class="comment">//player.jidiaose.com/supapi/iframe.php?v=</span></span><br><span class="line">http:<span class="comment">//www.82190555.com/index/qqvod.php?url=</span></span><br><span class="line">http:<span class="comment">//api.pucms.com/?url=</span></span><br><span class="line">http:<span class="comment">//api.baiyug.cn/vip/index.php?url=</span></span><br><span class="line">https:<span class="comment">//api.flvsp.com/?url=</span></span><br><span class="line">http:<span class="comment">//www.82190555.com/index/qqvod.php?url=</span></span><br><span class="line">http:<span class="comment">//2gty.com/apiurl/yun.php?url=</span></span><br><span class="line">http:<span class="comment">//v.2gty.com/apiurl/yun.php?url=</span></span><br><span class="line">直接观看：http:<span class="comment">//tv.inkb.ink/index.html</span></span><br><span class="line">扫码：http:<span class="comment">//www.guandianzhiku.com/v/s/?url=</span></span><br><span class="line">扫码：https:<span class="comment">//v.7cyd.com/vip/?url=腾讯视频 慢</span></span><br><span class="line">扫码：http:<span class="comment">//zxjx.00vb.com/zdhx/index.php?url=</span></span><br><span class="line">扫码：https:<span class="comment">//www.jqaaa.com/jx.php?url=</span></span><br><span class="line">无广告超清解析：http:<span class="comment">//jx.awx88.cn/jiexi/?url=</span></span><br><span class="line">弹幕解析：http:<span class="comment">//gongxiangtv.cn/?url=</span></span><br><span class="line">VIP视频解析北极XS视频解析：http:<span class="comment">//beijixs.cn/ 视频高清</span></span><br><span class="line">VIP视频解析<span class="number">116</span>kan智能解析：https:<span class="comment">//vip.116kan.com/ 高清视频</span></span><br><span class="line"><span class="number">365</span>t在線免費解析觀看系統：http:<span class="comment">//vip.365tol.top/</span></span><br><span class="line">BL智能解析：https:<span class="comment">//vip.bljiex.com/</span></span><br><span class="line">kingtail智能解析：https:<span class="comment">//jx.kingtail.xyz/?url=</span></span><br><span class="line">https:<span class="comment">//jsap.attakids.com/?url=</span></span><br><span class="line">https:<span class="comment">//api.lnwu.net/?url=</span></span><br><span class="line"><span class="number">91</span>视频解析：https:<span class="comment">//www.91jxs.com/jiexi/?url=</span></span><br><span class="line">https:<span class="comment">//api.jhys.top/?url=</span></span><br><span class="line">思古视频服务：https:<span class="comment">//api.sigujx.com/?url=</span></span><br><span class="line">小野马解析：https:<span class="comment">//www.xymav.com/?url=</span></span><br><span class="line">诺讯智能解析：https:<span class="comment">//www.nxflv.com/?url=</span></span><br><span class="line">热搜视频：https:<span class="comment">//v.resoumen.com/</span></span><br><span class="line">全民解析：http:<span class="comment">//qmaile.com/ 解析聚合，多线路解析</span></span><br><span class="line">聚神铺vip解析：http:<span class="comment">//www.jspoo.com/vip.html 解析聚合，多线路选择</span></span><br><span class="line">Yun Parse视频云解析：http:<span class="comment">//120.27.155.106/ 填视频ID而不是视频网页地址，另支持解析QQ相册等地址</span></span><br><span class="line">爱看解析：http:<span class="comment">//tv.vipsli.com/</span></span><br><span class="line">TVB云播全网VIP视频解析：http:<span class="comment">//vip.hktvyb.com/ 聚合解析，多线路</span></span><br><span class="line">Playm3u8解析：https:<span class="comment">//www.playm3u8.cn/jiexi.php?url= 除了常见VIP视频地址外，还支持解析QQ相册等地址</span></span><br><span class="line">千亿解析：https:<span class="comment">//www.qianyicp.com/jiexi/index.php?url= 蓝光超清解析接口</span></span><br><span class="line">OK解析：http:<span class="comment">//www.okjx.cc/ceshi/ 测试后不太清晰</span></span><br><span class="line"><span class="number">618</span>G免费解析：https:<span class="comment">//jx.618g.com/ 测试后不是很清晰</span></span><br><span class="line">http:<span class="comment">//avip.fun/tv?utm_source= 测试后直接不清晰</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>娱乐</tag>
      </tags>
  </entry>
  <entry>
    <title>javaWeb</title>
    <url>/2021/03/24/javaWeb/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Dom4j解析技术"><a href="#Dom4j解析技术" class="headerlink" title="Dom4j解析技术"></a>Dom4j解析技术</h1><p>dom4j 是优秀的第三方解析XML类库。需要使用 dom4j 就需要到 dom4j 官网下载 dom4j 的 jar 包。具体操作可以查看官方文档，或者下载离线jar包后查看离线帮助文档，如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210324165652.png"
                     
                ></p>
<h2 id="Dom4j编程步骤"><a href="#Dom4j编程步骤" class="headerlink" title="Dom4j编程步骤"></a>Dom4j编程步骤</h2><ol>
<li>添加jar包，如 dom4j-1.6.1.jar</li>
<li>通过创建<strong>SAXReader</strong>对象调用read方法<strong>加载xml文件</strong>获取<strong>Document</strong>对象</li>
<li>通过Document对象获取对应的xml对象的<strong>根元素</strong></li>
<li>通过根元素调用element(标签名)或elements(标签名)方法获取对应的xml标签对象或集合</li>
<li>获得标签对象后通过调用对应方法获取属性，或子标签。具体演示如下</li>
</ol>
<hr>
<ul>
<li><p>创建实例XML文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">sn</span>=<span class="string">&quot;SN12341232&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>effective of java<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>9.9<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>刘德华<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">sn</span>=<span class="string">&quot;SN12341231&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>深入了解虚拟机<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>99.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>陈慧娴<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写标签对应的java类，并封装成java类，输出所有属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String book;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double price;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="comment">//....建立构造，重写toString等基操</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> DocumentException </span>&#123;</span><br><span class="line">    <span class="comment">//1、通过创建SAXReader对象调用read方法加载xml文件获取Document对象</span></span><br><span class="line">    SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">    Document read = reader.read(<span class="string">&quot;src/books.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//2、通过Document对象获取对应的xml对象的根元素</span></span><br><span class="line">    Element rootElement = read.getRootElement();</span><br><span class="line">    <span class="comment">//3、通过根元素获取对应的xml标签对象,主要使用element()与elements()方法</span></span><br><span class="line">    List&lt;Element&gt; books = rootElement.elements(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(Element book : books)&#123;</span><br><span class="line">        <span class="comment">//1、获取当前标签属性</span></span><br><span class="line">        String sn = book.attributeValue(<span class="string">&quot;sn&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、获取book标签下name、price、author标签的值</span></span><br><span class="line">        <span class="comment">//方式1：通过再获取子标签的element对象,再调用getText()</span></span><br><span class="line">        String name = book.element(<span class="string">&quot;name&quot;</span>).getText();</span><br><span class="line">        <span class="comment">//方式2：直接通过</span></span><br><span class="line">        String author = book.elementText(<span class="string">&quot;author&quot;</span>);</span><br><span class="line">        Double price = Double.parseDouble(book.elementText(<span class="string">&quot;price&quot;</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Book(sn,name,price,author));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出如下</span></span><br><span class="line"><span class="comment">Book&#123;book=&#x27;SN12341232&#x27;, name=&#x27;effective of java&#x27;, price=9.9, author=&#x27;刘德华&#x27;&#125;</span></span><br><span class="line"><span class="comment">Book&#123;book=&#x27;SN12341231&#x27;, name=&#x27;深入了解虚拟机&#x27;, price=99.99, author=&#x27;陈慧娴&#x27;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="JavaWeb技术概述"><a href="#JavaWeb技术概述" class="headerlink" title="JavaWeb技术概述"></a>JavaWeb技术概述</h1><h2 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h2><ul>
<li><strong>WWW</strong>是World Wide Web简称，目的为了实现全世界能利用<strong>因特网进行文档交换</strong>，是一个大规模、分布式、联机式的信息储藏所。</li>
<li>Web是基于客户/服务器的一种B/S体系结构，其基本工作原理为，客户使用浏览器向Web服务器发出请求，服务器响应客户请求，向客户送回所请求的网页，客户在浏览器窗口上显示网页的内容。</li>
<li>组成Web体系的<strong>三大结构</strong><ul>
<li><strong>Web服务器</strong></li>
<li><strong>Web客户端</strong></li>
<li><strong>通信协议</strong></li>
</ul>
</li>
</ul>
<h3 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>Web服务器是向浏览器提供服务器的程序</li>
<li>Web服务器<strong>应用层使用HTTP协议</strong>，<strong>信息内容采用HTML</strong>，<strong>信息定位使用URL</strong></li>
<li>最常用的Web服务器是<strong>Apache</strong>服务器，开源、免费、Linux/Windows。另一种较为流行的Web服务器为Microsoft公司专门为Windows平台开发的<strong>IIS</strong>服务器</li>
<li><strong>Tomcat</strong>也是一种常用的<strong>Web服务器</strong>，它具有<strong>Web服务器</strong>功能同时<strong>也是Web容器</strong>，可允许Servlet和JSP</li>
</ul>
<h4 id="Tomcat-amp-Sevlet-JSP-JDK版本对应关系"><a href="#Tomcat-amp-Sevlet-JSP-JDK版本对应关系" class="headerlink" title="Tomcat&amp;Sevlet/JSP/JDK版本对应关系"></a>Tomcat&amp;Sevlet/JSP/JDK版本对应关系</h4><ul>
<li>当前企业常用Tomcati的版本 7、8</li>
<li><strong>Servlet2.5</strong>版本是现在世面使用最多的版本**(xml 配置**)</li>
<li><strong>Servlet3.0</strong> 之后就是<strong>注解</strong>版本的 Servlet 使用。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210324223805.png"
                     
                ></p>
<hr>
<h4 id="其他Web服务器"><a href="#其他Web服务器" class="headerlink" title="其他Web服务器"></a>其他Web服务器</h4><ul>
<li><strong>Jboss</strong>：是一个遵从 JavaEE 规范的、开放源代码的、纯 Java 的 EJB 服务器，它支持所有的 JavaEE 规范（免费）学习门槛高，不适合入门</li>
<li><strong>GlassFish</strong>： 由 Oracle 公司开发的一款 JavaWeb 服务器，是一款强健的商业(<strong>收费</strong>)服务器，达到产品级质量（应用很少）</li>
<li><strong>Resin</strong>：是 CAUCHO 公司的产品，是一个非常流行的服务器，对 servlet 和 JSP 提供了良好的支持， 性能也比较优良，resin 自身采用 JAVA 语言开发（<strong>收费</strong>，应用比较多）。 </li>
<li><strong>WebLogic</strong>：是 Oracle 公司的产品，是目前应用<strong>最广泛的 Web</strong> 服务器，支持 JavaEE 规范， 而且不断的完善以适应新的开发要求，适合大型项目（<strong>收费</strong>，用的不多，适合大公司）</li>
</ul>
<h3 id="Web客户端"><a href="#Web客户端" class="headerlink" title="Web客户端"></a>Web客户端</h3><p>​    浏览器主要功能想服务器发送请求与对响应信息进行解析、并正确显示出来</p>
<h3 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><ul>
<li>HTTP协议成为<strong>超文本传输协议</strong>，规定了Web客户与服务器之间<strong>如何通信</strong></li>
<li>是一个基于<strong>请求-响应</strong>的协议</li>
<li>主要<strong>通信流程</strong><ol>
<li>在浏览器输入网址，按下Enter键</li>
<li>浏览器建立一个<strong>HTTP</strong>请求信息，使用<strong>DNS</strong>获得网址的<strong>IP</strong>地址</li>
<li>通过IP地址与服务器建立一条<strong>TCP</strong>连接</li>
<li>通过这条TCP连接将<strong>HTTP信息</strong>发送给服务器，并从服务器接收回一条信息</li>
</ol>
</li>
</ul>
<h4 id="URL-amp-URI"><a href="#URL-amp-URI" class="headerlink" title="URL&amp;URI"></a>URL&amp;URI</h4><p><strong>URL</strong>称为统一资源定位符，用于在Internet中定位某个主机的资源，主要四部分组成</p>
<ol>
<li><strong>协议名称</strong>：如HTTP、FTP、TELNET、MAIL等</li>
<li><strong>主机域名或IP地址</strong>：<a class="link"   href="http://www.baidu.com、localhos、127.0.0.1等/" >www.baidu.com、localhos、127.0.0.1等<i class="fas fa-external-link-alt"></i></a></li>
<li>[<strong>端口号</strong>]：Web应用的80端口等，可忽略不写</li>
<li><strong>资源名称</strong>：资源在服务器上的相对路径和名称，如/index.html</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.baidu.com&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;www.baidu.com&#x2F;helloweb&#x2F;hello.jsp</span><br></pre></td></tr></table></figure>

<p>URI，URN待补充</p>
<h2 id="服务器资源"><a href="#服务器资源" class="headerlink" title="服务器资源"></a>服务器资源</h2><h3 id="资源类型"><a href="#资源类型" class="headerlink" title="资源类型"></a>资源类型</h3><p>Web服务器处理客户端请求有两种方式</p>
<ol>
<li><strong>静态</strong>请求：客户端所需请求的资源<strong>不需要进行任何处理</strong>，直接作为HTTP响应返回。对应的资源称之为<strong>静态资源</strong></li>
<li><strong>动态</strong>请求：客户端所需请求的资源需要在服务器<strong>委托</strong>给一些服务器端技术<strong>进行处理</strong>，如CGI、JSP、ASP等，然后将处理结果作为HTTP响应返回，对应地也成为<strong>动态资源</strong></li>
</ol>
<h3 id="动态文档技术"><a href="#动态文档技术" class="headerlink" title="动态文档技术"></a>动态文档技术</h3><p>动态文档是指文档的内容可根据需要动态生成，同时又分以下两种技术：</p>
<ul>
<li><p><strong>服务器端</strong>动态文档技术：</p>
<ul>
<li><strong>模块化</strong>技术：<strong>CGI</strong>、<strong>Servlet</strong>—java解决方案</li>
<li>Web文档<strong>嵌入式脚本</strong>：<strong>ASP</strong>、<strong>PHP</strong>、<strong>JSP</strong></li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210325111711.png"
                      style="zoom:80%;" /
                ></li>
<li><p><strong>客户端</strong>动态文档技术</p>
<ul>
<li><strong>JavaScript</strong></li>
</ul>
</li>
</ul>
<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>下载Tomcat，<a class="link"   href="https://tomcat.apache.org/" >官方链接<i class="fas fa-external-link-alt"></i></a></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210325100045.png"
                      style="zoom:80%;" /
                >
</li>
<li><p>将下载的安装包<strong>直接解压到</strong>指定目录即可</p>
</li>
<li><p>找到Tomcat目录下的<strong>bin目录</strong>，双击<strong>startup.bat</strong>文件即可启动</p>
</li>
<li><p>在浏览器输入输入地址 <a class="link"   href="http://localhost:8080/" >http://localhost:8080<i class="fas fa-external-link-alt"></i></a> ，若出现tomcat首页则表示安装成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210327204432.png"
                     
                ></p>
</li>
</ol>
<h2 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h2><ul>
<li><strong>bin</strong>：用与存放Tomcat 服务器的<strong>可执行程序</strong></li>
<li><strong>conf</strong>：用与存放Tocmat 服务器的配置文件</li>
<li><strong>lib</strong>：用与存放Tomcat 服务器的<strong>jar 包</strong>，对应javaEE的实现规范的实现类</li>
<li><strong>logs</strong> ：用与存放Tomcat 服务器运行时输出的<strong>日志信息</strong></li>
<li><strong>temp</strong>：用与存放Tomcdat 运行时产生的<strong>临时数据</strong></li>
<li><strong>webapps</strong>：用与存放<strong>部署的Web</strong>工程，根目录下，<strong>一个文件夹一个Web工程</strong></li>
<li><strong>work</strong>：是Tomcat<strong>工作时的目录</strong>，用来存放 Tomcat 运行时 <strong>jsp 翻译为 Servlet 的源码</strong>，和 Session 钝化的目录</li>
</ul>
<h2 id="启动与关闭"><a href="#启动与关闭" class="headerlink" title="启动与关闭"></a>启动与关闭</h2><h3 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h3><ol>
<li>Tomcat目录下的<strong>bin目录</strong>，双击<strong>startup.bat</strong>文件即可启动，或以<strong>命令行方式</strong>在路径下执行命令<code>startup</code></li>
<li>用<strong>命令行方式</strong>在路径下执行命令<code>catalina run</code></li>
</ol>
<hr>
<ul>
<li><p>startup命令的源码解析：为了可以在任意目录下启动 Tomcat 服务器，可以选择把bin目录添加到 path下，此时在任意目录下通过startup命令启动Tomcat服务器会提示如下错误，即<strong>要求设置 CATALINA_HOME 这个环境变量</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The CATALINA_HOME environment variable is not defined correctly</span><br><span class="line">This environment variable is needed to run this program</span><br></pre></td></tr></table></figure>

<ul>
<li><p>阅读startup.bat批处理文件源码可知，<strong>CATALINA_HOME环境变量</strong>指向为Tomcat安装的根目录(bin目录的上一级目录)</p>
</li>
<li><p>startup.bat 文件，实际调用的是<strong>catalina.bat</strong>文件</p>
</li>
<li><p>通过命令行窗口直接输入catalina, 提示如下，表示<code>catalina</code>命令的可选参数</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">commands:</span></span><br><span class="line"><span class="function"><span class="title">debug</span>             <span class="title">Start</span> <span class="title">Catalina</span> <span class="title">in</span> <span class="title">a</span> <span class="title">debugger</span></span></span><br><span class="line"><span class="function"><span class="title">debug</span> -<span class="title">security</span>   <span class="title">Debug</span> <span class="title">Catalina</span> <span class="title">with</span> <span class="title">a</span> <span class="title">security</span> <span class="title">manager</span></span></span><br><span class="line"><span class="function"><span class="title">jpda</span> <span class="title">start</span>        <span class="title">Start</span> <span class="title">Catalina</span> <span class="title">under</span> <span class="title">JPDA</span> <span class="title">debugger</span></span></span><br><span class="line"><span class="function"><span class="title">run</span>               <span class="title">Start</span> <span class="title">Catalina</span> <span class="title">in</span> <span class="title">the</span> <span class="title">current</span> <span class="title">window</span></span></span><br><span class="line"><span class="function"><span class="title">run</span> -<span class="title">security</span>     <span class="title">Start</span> <span class="title">in</span> <span class="title">the</span> <span class="title">current</span> <span class="title">window</span> <span class="title">with</span> <span class="title">security</span> <span class="title">manager</span></span></span><br><span class="line"><span class="function"><span class="title">start</span>             <span class="title">Start</span> <span class="title">Catalina</span> <span class="title">in</span> <span class="title">a</span> <span class="title">separate</span> <span class="title">window</span></span></span><br><span class="line"><span class="function"><span class="title">start</span> -<span class="title">security</span>   <span class="title">Start</span> <span class="title">in</span> <span class="title">a</span> <span class="title">separate</span> <span class="title">window</span> <span class="title">with</span> <span class="title">security</span> <span class="title">manager</span></span></span><br><span class="line"><span class="function"><span class="title">stop</span>              <span class="title">Stop</span> <span class="title">Catalina</span></span></span><br><span class="line"><span class="function"><span class="title">version</span>           <span class="title">What</span> <span class="title">version</span> <span class="title">of</span> <span class="title">tomcat</span> <span class="title">are</span> <span class="title">you</span> <span class="title">running</span>?</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>常用的catalina命令选项如下</p>
<ul>
<li><strong>run</strong>：在 catalina 同一个命令行窗口下启动服务器. </li>
<li><strong>start</strong>：开启一个新窗口启动服务器</li>
<li><strong>stop</strong>：关闭服务器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关闭方式"><a href="#关闭方式" class="headerlink" title="关闭方式"></a>关闭方式</h3><ul>
<li><strong>方式一</strong>：点击tomcat 服务器窗口右上角X关闭</li>
<li><strong>方式二</strong>：把Tomcat 服务器窗口置为当前窗口，然后按快捷键 Ctrl+C </li>
<li><strong>方式三</strong>：找到Tomcat的<strong>bin</strong>目录下的 <code>shutdown.bat</code> 双击，或cmd进入该目录执行<code>shutdown</code>，就可以停止 Tomcat 服务器</li>
</ul>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>首先，建议通过CMD命令行的方式进入到bin目录下，通过命令行的方式执行<code>catalina run</code>命令，则会有错误提示信息显示</p>
<ol>
<li>双击startup.bat出现黑窗口一闪而过，JAVA_HOME环境变量没有配置正确</li>
</ol>
<h2 id="修改默认端口号"><a href="#修改默认端口号" class="headerlink" title="修改默认端口号"></a>修改默认端口号</h2><ol>
<li><p>找到Tomcat目录下的<strong>conf目录</strong>，找到 <strong>server.xml</strong></p>
</li>
<li><p>修改如下标签下的<code>port</code>属性端口号信息即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;7777&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改后需<strong>重启</strong>Tomcat服务器才能生效</p>
</li>
</ol>
<h2 id="部署Web工程"><a href="#部署Web工程" class="headerlink" title="部署Web工程"></a>部署Web工程</h2><p>Tomcat目录下的<strong>webapps目录</strong>：存放<strong>部署的Web</strong>工程，<strong>一个文件夹一个Web工程</strong>。如默认tomcat含以下<strong>5个web应用</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210327204809.png"
                     
                ></p>
<ul>
<li><p><strong>方式一</strong>：把 web 工程的目录<strong>拷贝</strong>到 Tomcat的<strong>webapps目录中</strong></p>
<ol>
<li><p>在<strong>webapps</strong>目录下新建web应用的文件夹，如helloWeb</p>
</li>
<li><p>将web应用内容拷贝的该文件夹内</p>
</li>
<li><p><a class="link"   href="http://localhost:8888/" >http://localhost:8888<i class="fas fa-external-link-alt"></i></a> 对应webapps的根目录，url与webapps目录的路径关系如下</p>
</li>
<li><p>稍等十几秒后，一般tomcat会自动重新部署。若没有效果，则可以尝试重启tomcat服务器</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210327205553.png"
                      style="zoom:80%;" /
                >
</li>
</ol>
</li>
<li><p><strong>方式二</strong>：配置文件<strong>映射</strong>部署，即项目任意路径部署</p>
<ol>
<li><p>找到Tomcat下的 <strong>conf</strong>目录<code>\Catalina\localhost\ </code>根目录下,创建如下<strong>xml配置文件</strong>，一般一个工程一个xml文件。(旧版本的tomcat可能不存在上述目录，没有就自己建立这个目录结构即可)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">&quot;/abc&quot;</span> <span class="attr">docBase</span>=<span class="string">&quot;E:\book&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>.xml文件的<strong>文件名</strong>：tomcat9测试，xml文件名才是决定访问(url)根路径</li>
<li><del><strong>path</strong>：表示工程的访问(url)路径，如<code>/abc</code></del></li>
<li><strong>docBase</strong>：表示你的<strong>工程目录</strong>在磁盘下的路径</li>
</ul>
</li>
<li><p>一般修改添加或删除，tomcat中的web应用内容，稍等十多秒会<strong>自动重新部署</strong>。若没有效果，则可以重启tomcat服务器使其部署</p>
</li>
</ol>
</li>
</ul>
<h2 id="默认工程及首页"><a href="#默认工程及首页" class="headerlink" title="默认工程及首页"></a>默认工程及首页</h2><ul>
<li>当地址栏输入访问地址<strong>没有工程名</strong>地址：<code>http://ip:port/</code>  ，默认访问的是 ROOT 工程。 </li>
<li>当地址栏输入访问地址<strong>只有工程名</strong>地址： <code>http://ip:port/工程名/</code>，默认访问工程内的 <strong>index.html</strong> 页面</li>
</ul>
<h1 id="IDEA整合Tomcat"><a href="#IDEA整合Tomcat" class="headerlink" title="IDEA整合Tomcat"></a>IDEA整合Tomcat</h1><h2 id="整合Tomcat服务器"><a href="#整合Tomcat服务器" class="headerlink" title="整合Tomcat服务器"></a>整合Tomcat服务器</h2><ol>
<li><p><strong>进入IDEA如下设置</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210327215834.png"
                     
                ></p>
</li>
<li><p>配置你的 Tomcat 安装目录，可以添加多个不同版本的tomcat</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210327220051.png"
                     
                ></p>
</li>
</ol>
<h2 id="创建动态Web工程"><a href="#创建动态Web工程" class="headerlink" title="创建动态Web工程"></a>创建动态Web工程</h2><ol>
<li><p>2020版本后的IDEA，建立非Maven管理的web项目需<strong>先建立一个普通</strong>的java Model。右键Add Framework Support</p>
<p>(若选择使用maven则可以在建立model时选择java enterprise)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210327221135.png"
                     
                ></p>
</li>
<li><p>勾选Web Application ，勾选Create web.xml</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210327221507.png"
                     
                ></p>
<ol start="3">
<li><p>创建成功如下图，(一般手动di在WEB-INF目录下建立一个lib目录)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210327221705.png"
                     
                ></p>
</li>
</ol>
<h2 id="Web工程目录"><a href="#Web工程目录" class="headerlink" title="Web工程目录"></a>Web工程目录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|--开发项目文件</span><br><span class="line">|----src			&#x2F;&#x2F;存放源代码</span><br><span class="line">|----WEB资源总目录	 &#x2F;&#x2F;约定：但不规定目录名(eclipse WebContent,IDEA web)</span><br><span class="line">|-------WEB-INF		&#x2F;&#x2F;约定：存放供服务器访问的资源(浏览器无法直接访问)</span><br><span class="line">		web.xml		&#x2F;&#x2F;约定：整个动态web工程的配置部署描述文件，配置如(servlet、filter...)组件</span><br><span class="line">		lib			</span><br><span class="line">|----css			</span><br><span class="line">|----img					</span><br><span class="line">	 ...</span><br><span class="line">|----index.html</span><br></pre></td></tr></table></figure>



<h2 id="启用Web工程"><a href="#启用Web工程" class="headerlink" title="启用Web工程"></a>启用Web工程</h2><ol>
<li><p>每当创建一个web工程时，IDEA会对应Web工程创建一个Tomcat实例</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210327225539.png"
                     
                ></p>
</li>
<li><p>一般为了区分tomcat实例，都将当前项目的tomcat实例名称<strong>改为与web项目名</strong>一致</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210327225932.png"
                     
                ></p>
</li>
<li><p>确认你的 Tomcat 实例中有你要部署运行的 web 工程模块</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210327230350.png"
                     
                ></p>
</li>
<li><p>还可以修改你的 Tomcat 实例启动后默认的访问地址与浏览器</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210327230443.png"
                     
                ></p>
</li>
<li><p>IDEA中、启动、debug启动、停止、与重启按钮说明</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210327231117.png"
                     
                ></p>
</li>
</ol>
<ul>
<li><p>IDEA中默认启动web项目的效果</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210327231802.png"
                     
                ></p>
</li>
<li><p>重启选项说明</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210327231555.png"
                     
                ></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>个人电子文档</title>
    <url>/2021/03/14/%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>tips：不可在线浏览，需复制链接下载回本地，修改后缀后访问pdf文件</p>
<ul>
<li>C语言：<a class="link"   href="https://gitee.com/yihangdeng/net-resources/raw/master/PersonnelDocument/C%E8%AF%AD%E8%A8%80%E6%80%BB%E7%BB%93-yhd.png" >复制链接<i class="fas fa-external-link-alt"></i></a></li>
<li>计算机网络：<a class="link"   href="https://gitee.com/yihangdeng/net-resources/raw/master/PersonnelDocument/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93-yhd.png" >复制链接<i class="fas fa-external-link-alt"></i></a></li>
<li>数据库原理：<a class="link"   href="https://gitee.com/yihangdeng/net-resources/raw/master/PersonnelDocument/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86-yhd(Cornell).png" >复制链接<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <tags>
        <tag>技术积累</tag>
        <tag>个人文档</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2020/09/25/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="冒泡排序分析"><a href="#冒泡排序分析" class="headerlink" title="冒泡排序分析"></a>冒泡排序分析</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%8A%A8%E6%80%81%E7%A4%BA%E6%84%8F%E5%9B%BE.gif"
                      alt="冒泡排序"
                ></p>
<ol>
<li>每一轮交替比较把最值往**后排(下沉)**，能得出参与这次轮次所有数中的最值<ul>
<li>首次交替次数：最后一个数无需交替比较。即循环下标结构 for(j = 0;<strong>j &lt; len - 1</strong>; j ++ )</li>
</ul>
</li>
<li>接下来继续开始若干次从头开始的交替，逐一把“第2最值”，“第3最值”…排到最后(下沉)<ul>
<li>剩余轮次交替次数：每一次交替比较后的最值无需参与下一次交替比较，剩下轮次的交替比较次数呈<strong>递减1状态</strong></li>
<li>总比较轮次：每一个数都需走一遍轮次。，最后交替(数组最前的数)只需一个轮次完成，即总论次为：<strong>len - 1</strong></li>
</ul>
</li>
</ol>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><h2 id="理论支持"><a href="#理论支持" class="headerlink" title="理论支持"></a>理论支持</h2><p>每一轮交替比较把最值往**后排(下沉)**，能得出参与这次轮次所有数当中的最值</p>
<h2 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h2><ol>
<li><p>把最值往<strong>后排(下沉)</strong></p>
<ul>
<li>从大到小，降序，后排下沉最小值，a[ j ] &lt; a[ j + 1 ]</li>
<li>从小到大，升序，后排下沉最大值，a[ j ] &gt; a[ j + 1 ]</li>
</ul>
</li>
<li><p>数组内部比较交替次数：</p>
<ul>
<li>首次比较交替次数：<strong>len - 1</strong>    即<code>for(j = 0;j &lt; len - 1;j++)</code></li>
<li>剩下轮次比较交替次数：<strong>每经一个轮次，交替比较次数减1</strong></li>
</ul>
</li>
<li><p>整个完整排序的比较轮次：最后交替比较两个数(数组最前的两个数)只需一个轮次完成，<strong>len - 1</strong>。  </p>
</li>
</ol>
<h2 id="代码表示"><a href="#代码表示" class="headerlink" title="代码表示"></a>代码表示</h2><ol>
<li>比较轮次属于<strong>外循环</strong>：<strong>len - 1</strong></li>
<li>内部比较交替次数属于<strong>内循环</strong>：(首次)<strong>len - 1</strong>，(剩余)<strong>每一轮次，次数减1</strong></li>
<li>从大到小，降序，则后排下沉最小值(a[j] 到 a[j + 1])比较</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外循环：比较轮次</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len - <span class="number">1</span>;i++)&#123;		<span class="comment">//数组遍历写法 i = 0; i &lt; len; i++ 正常遍历，len-1则少一次</span></span><br><span class="line">    <span class="comment">//内循环：交替比较次数，递减1通过i增1来实现</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; len - <span class="number">1</span> - i;j++)&#123;</span><br><span class="line">        <span class="comment">//实现从大到小，降序，后排下沉最小值，a[ j ] &lt; a[ j + 1 ]</span></span><br><span class="line">        <span class="keyword">if</span>(a[j] &lt; a[j + <span class="number">1</span>])<span class="comment">//边界分析：i = 0，判断上溢d = j + 1，因为“&lt;”，所以j = (len-1) - 1，所以d = len - 1(没上溢)</span></span><br><span class="line">            <span class="comment">//交换位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h1><blockquote>
<p>参考：<a class="link"   href="https://zhuanlan.zhihu.com/p/66768445" >https://zhuanlan.zhihu.com/p/66768445<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图床解决方案</title>
    <url>/2020/08/29/%E5%9B%BE%E5%BA%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><p>本人解决方案：<a class="link"   href="https://www.jianshu.com/p/b69950a49ae2" >https://www.jianshu.com/p/b69950a49ae2<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p>markdown各种解决方案：<a class="link"   href="https://www.jianshu.com/p/ea1eb11db63f" >https://www.jianshu.com/p/ea1eb11db63f<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p>picgo连接gitee：</p>
<ul>
<li><a class="link"   href="https://www.jianshu.com/p/b69950a49ae2" >https://www.jianshu.com/p/b69950a49ae2<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/disILLL/article/details/104944710" >https://blog.csdn.net/disILLL/article/details/104944710<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.cnblogs.com/qtzd/p/12554902.html" >https://www.cnblogs.com/qtzd/p/12554902.html<i class="fas fa-external-link-alt"></i></a> </li>
</ul>
</li>
</ul>
<h1 id="软件关系简要说明"><a href="#软件关系简要说明" class="headerlink" title="软件关系简要说明"></a>软件关系简要说明</h1><ul>
<li><p>Typora</p>
<ol>
<li>作为markdown编辑器本身具备的优势</li>
<li>最新版支持 picgo自动上传功能呢</li>
</ol>
</li>
<li><p>picgo(图床工具)</p>
<ul>
<li>主要功能：与各大图床存储平台对接，实现快捷本地上传，返回各种需求的连接服务(markdown、html、svg链接等)</li>
</ul>
</li>
<li><p>gitee：作为一个免费图床存储平台，无防盗链设置</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo框架的博客搭建及其GitHub部署</title>
    <url>/2020/08/28/%E5%9F%BA%E4%BA%8EHexo%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%85%B6GitHub%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h1><ul>
<li>Hexo 是一个快速、简洁且高效的<strong>静态博客框架</strong>。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成<strong>静态网页</strong>。  </li>
<li>Hexo受众面较广，对应的问题、扩展等内容在网上均有成熟解决方案，推荐安装使用。</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>安装Hexo之前需要先安装Node.js与Git。</p>
<blockquote>
<p>ps：本文所有安装过程基于Windows环境下操作</p>
</blockquote>
<h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h3><ol>
<li><p>官网下载地址：<a class="link"   href="https://git-scm.com/downloads" >https://git-scm.com/downloads<i class="fas fa-external-link-alt"></i></a></p>
<blockquote>
<p>默认自动弹出适配版本，若没有则在“Git for Windows Setup”选择对应电脑位数下载</p>
</blockquote>
</li>
<li><p>安装过程一直<kbd><strong>next</strong></kbd>直到完成即刻。</p>
</li>
<li><p>设置Git用户名</p>
<blockquote>
<p>ps:Windows终端(cmd)内操作,不设置用户名和密码在安装hexo的过程中会报错</p>
</blockquote>
<ul>
<li>设置用户名<br><code>git config --global user.name &quot;username&quot;</code></li>
<li>设置邮箱<br><code>git config --global user.email useremail@qq.com</code><blockquote>
<ul>
<li>修改后可以检查一下，查看用户名和密码<br> <code>git config user.name</code><br> <code>git config user.email</code>  </li>
<li>查看其他配置信息<br> <code>git config --list</code></li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="Node-js安装"><a href="#Node-js安装" class="headerlink" title="Node.js安装"></a>Node.js安装</h3><ol>
<li><p>官方下载地址：<a class="link"   href="https://nodejs.org/en/" >https://nodejs.org/en/<i class="fas fa-external-link-alt"></i></a></p>
<blockquote>
<p>一般选择左边的 XX.XX.X LTS (长期支持版)</p>
</blockquote>
</li>
<li><p>安装过程简单，直接操作即可。</p>
</li>
<li><p>安装完成后存在两个组件，一个是Node.js本身，另一个是npm(包管理器)</p>
</li>
</ol>
<h2 id="hexo下载与安装"><a href="#hexo下载与安装" class="headerlink" title="hexo下载与安装"></a>hexo下载与安装</h2><ol>
<li><p>以<strong>管理员身份</strong>进入Windows终端。</p>
</li>
<li><p>检查node.js的安装结果<br><code>node –v</code><br><code>npm –v</code></p>
</li>
<li><p>通过npm或cnpm安装hexo</p>
<blockquote>
<p>npm是外国的镜像源速度很慢，用淘宝的cnpm比较快</p>
</blockquote>
<p><code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code></p>
</li>
<li><p>通过cnpm下载安装hexo<br><code>cnmp install -g hexo cli</code></p>
</li>
<li><p>安装完成后通过命令可查看版本表示安装成功<br><code>hexo –v</code></p>
</li>
</ol>
<h2 id="hexo博客初始化"><a href="#hexo博客初始化" class="headerlink" title="hexo博客初始化"></a>hexo博客初始化</h2><ul>
<li>以下操作均在”总文件”路径下完成，且实例说明以名为”myblog”的文件夹表示hexo总文件夹。</li>
<li>若接下来的操作出现什么错误，直接把这个总文件夹删除重新来过即可</li>
</ul>
<hr>
<ol>
<li>在想要安装博客的路径下创建一个总文件夹，如“myblog”</li>
<li>通过终端进入到这个总文件夹路径下</li>
<li>初始化博客<br> <code>hexo init</code></li>
<li>常用组成文件功能介绍<blockquote>
<p>├_config.yml<br>├&lt;source&gt;<br>&emsp;&emsp;├&lt;_posts&gt;<br>├&lt;themes&gt;</p>
</blockquote>
</li>
</ol>
<ul>
<li>_config.yml：配置文件，用于配置博客的重要属性</li>
<li>&lt;source&gt;：用于存放各种类型的md文件</li>
<li>&lt;_posts&gt; ：hexo new命令生成的md文件存位置</li>
<li>&lt;themes&gt;：存放不同的主题</li>
</ul>
<ol start="5">
<li><p>启动博客，通过浏览器尝试访问<br> <code>hexo s</code></p>
<blockquote>
<p>终端会提示本地端口访问，一般为：localhost:4000</p>
</blockquote>
</li>
</ol>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><blockquote>
<p>ps：所有hexo命令操作都需要在安装hexo的<strong>总文件夹</strong>路径下操作</p>
</blockquote>
<ol>
<li>创建一篇文章， 新建的文章即md文件存放在/source/_posts<br>   <code>hexo new &quot;My New Post&quot;</code></li>
<li>停止运行hexo<br><code>ctrl + c</code></li>
<li>清理之前生成的内容<br>   <code>hexo clean</code></li>
<li>校验并生成新的内容<br>   <code>hexo g</code></li>
</ol>
<h2 id="GitHub部署"><a href="#GitHub部署" class="headerlink" title="GitHub部署"></a>GitHub部署</h2><h3 id="仓库设置"><a href="#仓库设置" class="headerlink" title="仓库设置"></a>仓库设置</h3><ol>
<li><p>登录github，创建仓库：repository name设置为：<strong>username</strong>.github.io</p>
<blockquote>
<p>您github账号中的username,如博主账号username为yihangdeng<br>则repository name 设置为：yihangdeng.github.io</p>
</blockquote>
</li>
<li><p>其他保持默认即可，点击“Create repository”完成仓库创建</p>
<blockquote>
<p>生成的链接结构为： https://<span></span>github.com/<strong>username</strong>/<strong>username</strong>.github.io.git<br>如：https://<span></span>github.com/yihangdeng/yihangdeng.github.io.git</p>
</blockquote>
</li>
</ol>
<h3 id="Git远程部署插件安装"><a href="#Git远程部署插件安装" class="headerlink" title="Git远程部署插件安装"></a>Git远程部署插件安装</h3><p><code>cnpm install --save hexo-deployer-git</code></p>
<h3 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="配置_config.yml"></a>配置_config.yml</h3><p>设置<strong>总文件夹</strong>下的配置文件_config.yml，在配置信息的最底部修改并添加内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line"> 	type: ‘git’</span><br><span class="line"> 	repo: (仓库创建后生成的链接)</span><br><span class="line">  	branch: master</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line"> 	type: git</span><br><span class="line"> 	repo: https:&#x2F;&#x2F;github.com&#x2F;yihangdeng&#x2F;yihangdeng.github.io.git</span><br><span class="line"> 	branch: master</span><br></pre></td></tr></table></figure>

<h3 id="内容推送"><a href="#内容推送" class="headerlink" title="内容推送"></a>内容推送</h3><ol>
<li><p>通过命令远程部署到GitHub仓库<br><code>hexo d</code></p>
<blockquote>
<p>在远程部署的过程中有时要求输入GitHub的用户名和密码，如：<br>Username for &quot;<a class="link"   href="https://github.com/&quot;" >https://github.com\&quot;<i class="fas fa-external-link-alt"></i></a>  输入用户名<br>Password for &quot;<a class="link"   href="https://username@github.com/&quot;" >https://username@github.com\&quot;<i class="fas fa-external-link-alt"></i></a> 输入密码<br>(密码默认不显示，直接输入后回车即可)<br>若出错请检查是否有配置git的用户名和邮箱</p>
</blockquote>
</li>
<li><p>刷新GitHub仓库可查看生成内容已部署到GitHub中</p>
</li>
<li><p>通过浏览器访问你的博客  </p>
<ul>
<li>url：username.github.io  </li>
<li>如：yiahngdeng.github.io<blockquote>
<p>若访问不了，请先尝试访问博主的博客(yiahngdeng.github.io)进而确认是部署出错还是访问GitHub的网络出现问题，具体参加博文《GitHub访问及其下载问题解决方案》。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><ol>
<li>建议每次修改内容后都执行“hexo g”命令校验生成一下，报错的内容会显示在终端上。</li>
<li>标明错误行数：一般是配置文件中的“键值对”敲错，记住是<strong>英文冒号加空格</strong>，“: ”</li>
<li>Git错误提示之：fatal: Not a git repository (or any of the parent directories): .git 提示说没有.git这样一个目录，在命令行 输入 git init  然后回车就好了</li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li>codesheep：<a class="link"   href="https://www.bilibili.com/video/BV1Yb411a7ty" >https://www.bilibili.com/video/BV1Yb411a7ty<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>环境搭建</tag>
        <tag>技术积累</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库原理 第二章 关系数据库</title>
    <url>/2020/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93.png"
                     
                ></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><strong>定义</strong>：关系数据库是采用<strong>关系模型</strong>的数据库系统，而关系模型的<strong>数据结构</strong>(数据模型三部曲之一)就是<strong>关系</strong>本身。即<strong>现实世界的实体与实体间的联系</strong>都用<strong>关系</strong>来表示，其<strong>逻辑结构</strong>表现为<strong>一张二维表</strong></li>
<li><strong>相关术语</strong>：</li>
</ol>
<table>
<thead>
<tr>
<th>关系术语</th>
<th>一般表格术语</th>
</tr>
</thead>
<tbody><tr>
<td>关系（relation）</td>
<td>表</td>
</tr>
<tr>
<td>元组（tuple）</td>
<td>行或记录</td>
</tr>
<tr>
<td>属性（attribute）</td>
<td>列</td>
</tr>
<tr>
<td>分量</td>
<td>列值/属性值</td>
</tr>
<tr>
<td>域（domain）</td>
<td>列值/属性值<strong>给定的取值范围</strong>(非数据类型上的范围)</td>
</tr>
<tr>
<td>基数</td>
<td>一个域允许的<strong>不同取值个数</strong></td>
</tr>
<tr>
<td>关系模式</td>
<td>关系型，即对表格结构的描述</td>
</tr>
</tbody></table>
<ul>
<li>[关系]<strong>关系的类型</strong>：<strong>三种</strong>，基本关系(<strong>基本表</strong>/基表)、<strong>查询表</strong>、<strong>视图表</strong></li>
<li>[域]<strong>笛卡儿积</strong>：从数学定义上，笛卡尔积的基数等于两个集合中各分量的组合。<strong>从数据表中</strong>，即<strong>每个表的元组总数的相乘</strong>。如表1有n行数据，表2有m行数据，则表1和表2构成的笛卡尔积为n*m</li>
</ul>
<h2 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h2><ol>
<li><p><strong>关系操作类型</strong>：分为<strong>两类</strong>，<strong>查询操作</strong>(query)与<strong>(插入、删除、修改)</strong>操作两大类型组成</p>
<ul>
<li><strong>查询操作</strong>：<strong>选择</strong>(select)、<strong>投影</strong>(project)、连接(join)、除(divide)、<strong>并</strong>(union)、<strong>差</strong>(except)、交(intersection)、<strong>笛卡尔积</strong>等。加粗部分为查询的<strong>五大基本操作</strong>，其他操作均可由其基本操作来实现。</li>
</ul>
</li>
<li><p><strong>关系数据语言</strong>：</p>
<ol>
<li><strong>定义</strong>：关系数据语言主要用于<strong>表达对数据库抽象层面的查询操作</strong>。</li>
<li><strong>关系数据语言的分类</strong>：<strong>关系代数语言</strong>、<strong>关系演算语言</strong>、<strong>结构化查询语言</strong>。<ul>
<li>关系代数语言：用<strong>对关系的运算</strong>来表达查询要求(操作)，<strong>重点掌握</strong></li>
<li>关系演算语言：用<strong>谓词</strong>来表达查询要求(操作)</li>
<li>双重特点语言——结构化查询语言SQL(structured query language)：同时具备关系代数和关系演算双重特点的语言</li>
</ul>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB.jpg"
                      alt="关系数据语言"
                ></p>
</li>
<li><p><strong>关系代数语言</strong></p>
<p>关系代数运算符：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%B7.jpg"
                     
                ></p>
<p>​    备注：R，relationship，关系/数据表、F，function，选择条件，逻辑表达式、A，attribute，属性列、θ，比较运算符</p>
<ol>
<li><p><strong>传统集合运算</strong>：均为二目运算，<strong>交、并、差、笛卡尔积</strong>四种</p>
</li>
<li><p><strong>专门关系运算</strong>：<strong>选择、投影、连接、除运算等</strong></p>
</li>
<li><p>着重解释“<strong>连接</strong>”</p>
<ol>
<li><p><strong>定义</strong>：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E8%BF%9E%E6%8E%A5%E5%90%AB%E4%B9%89.jpg"
                     
                ></p>
</li>
<li><p><strong>连接运算过程</strong>：R与S均是关系表，从R和S的笛卡尔积(广义笛卡尔积)RxS中选取R关系在A属性组上的值与S关系在B属性组上的值满足比较关系θ的元组，<strong>即，只要进行连接运算，首先生成的肯定是笛卡尔乘积</strong></p>
</li>
<li><p><strong>等值/非等值连接</strong>：θ为“=”等值连接，若θ为比较运算符则是非等值连接，而<strong>自然连接是一种特殊的等值连接</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E8%BF%9E%E6%8E%A5%E8%BF%90%E7%AE%97%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F.jpg"
                     
                ></p>
</li>
<li><p>连接条件F运算符：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6.jpg"
                     
                ></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>类型</th>
<th>格式定义</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>选择</td>
<td>∂<sub>F</sub>(R)</td>
<td>∂<sub>Sage &lt; 20</sub>(Student)</td>
</tr>
<tr>
<td>投影</td>
<td>∏<sub>A</sub>(R)</td>
<td>∏<sub>Sname，Sdept</sub>(Student)</td>
</tr>
<tr>
<td>连接</td>
<td>R<sub>1</sub>⋈R<sub>2</sub> (因符号表示问题，常见上述定义)</td>
<td>略</td>
</tr>
</tbody></table>
<h2 id="关系的完整性"><a href="#关系的完整性" class="headerlink" title="关系的完整性"></a>关系的完整性</h2><ol>
<li><strong>实体完整性</strong>（entity integrity）：主键，表唯一，非空</li>
<li><strong>参照完整性</strong>（referential integrity）：外键，列唯一，可空</li>
<li><strong>用户定义的完整性</strong>：为某个属性定义取值约束</li>
</ol>
<p>注意：<strong>主键和外键如果存在则必须定义，否则就是数据库设计本身存在问题</strong>，实体完整性和参照完整性是<strong>关系的两不变性</strong></p>
]]></content>
      <tags>
        <tag>SQL</tag>
        <tag>技术积累</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库原理 第一章 绪论</title>
    <url>/2020/10/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%20%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA.png"
                     
                ></p>
<h2 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h2><ol>
<li><strong>数据</strong>（data）：描述事物的<strong>符号记录</strong>称为<strong>数据</strong></li>
<li><strong>数据库</strong>（<strong>DB</strong>，DataBase）：长期存储在计算机内、有组织的、可共享的<strong>大量数据的集合</strong></li>
<li><strong>数据库管理系统</strong>（<strong>DBMS</strong>，Data Base Management System）：用于科学高效地<strong>存取、维护数据</strong>的<strong>计算机基础软件</strong>，是一个大小复杂的<strong>软件系统</strong>(如操作系统般)。其<strong>最主要的功能</strong>如下：<ul>
<li><strong>数据定义功能</strong>（<strong>DDL</strong>，Data Definition Language）：如对<strong>库、表、字段等</strong>数据对象的定义(创建,修改,删除等)</li>
<li><strong>数据操纵功能</strong>（<strong>DML</strong>，Data Manipulation Language）：对<strong>数据</strong>的<strong>增删改查</strong>等操作</li>
</ul>
</li>
<li><strong>数据库系统</strong>（<strong>DBS</strong>，DataBase System）：DB + DBMS(相关tool) + Program + DBA组成的存储、管理、处理和维护数据的系统</li>
</ol>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><ol>
<li><p><strong>两类数据模型</strong>：<strong>概念模型</strong>(信息模型)、<strong>逻辑模型与物理模型</strong></p>
<ul>
<li><p><strong>概念模型</strong>：以<strong>用户角度</strong>对数据进行信息建模，不依赖于具体DBMS，是<strong>概念级的模型</strong>。其他相关概念如下：</p>
<ul>
<li><p>实体(entity)：<strong>客观存在且相互区别</strong>的事物。<strong>如，一条具体的信息，类对象的一个实例</strong></p>
</li>
<li><p>实体型(entity type)：用实体名及其属性名的集合来<strong>抽象</strong>同类实体。<strong>如，面向对象中的类</strong></p>
</li>
<li><p>实体集(entity set)：同类型的<strong>实体</strong>的<strong>集合</strong>，<strong>如全体学生，一些对象的集合、表等</strong></p>
</li>
<li><p>属性(attribute)：实体具有的<strong>某一特性</strong>。<strong>如，数据表中的字段/列</strong></p>
</li>
<li><p>码(key)：<strong>唯一标识实体</strong>的<strong>属性集</strong>，(注意是属性<strong>集</strong>)</p>
</li>
<li><p>联系(relationship)：现实世界中，实体(型/集)与实体(型/集)之间的联系，一般有<strong>一对一，一对多，多对多</strong>的联系</p>
<p>   <strong>联系的定义与判断</strong>：在A实体集内<strong>取1个实体</strong>，而这个实体能在B实体集内对应多个实体。则称为一对多，其他类型联系以此类推。  </p>
</li>
<li><p>E - R模型：概念模型的最常用的表示方法为<strong>实体-联系方法</strong>(Entity-Relationship approach)，也称E-R模型，用E-R图描述。具体设计与实现在“概念结构设计篇”讲解  </p>
</li>
</ul>
</li>
<li><p><strong>逻辑模型与物理模型</strong>：以<strong>计算机系统角度</strong>对数据的建模，由DBMS。常见逻辑模型如<strong>层次、网状、关系、面向对象等模型</strong>。</p>
</li>
</ul>
</li>
<li><p><strong>模型之间的关系</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.jpg"
                     
                ></p>
</li>
<li><p><strong>数据模型的组成要素</strong>：数据模型由<strong>数据结构</strong>(对象的组成与对象间的联系)、<strong>数据操作</strong>(增删改查)、<strong>数据完整性约束条件</strong>(确保数据的完整性)组成。<strong>任何数据模型都需考虑的三个因素</strong>。</p>
</li>
</ol>
<h2 id="数据库系统结构"><a href="#数据库系统结构" class="headerlink" title="数据库系统结构"></a>数据库系统结构</h2><ol>
<li><p><strong>基本概念</strong></p>
<ol>
<li><p><strong>型</strong>（type）：某一类数据的结构与属性的说明。如类的定义</p>
</li>
<li><p><strong>值</strong>（value）：值是型的具体赋值。如某一个类的实体对象(实例)</p>
<hr>
</li>
<li><p><strong>模式</strong>（schema）：是指<strong>数据库</strong>全体数据的逻辑<strong>结构</strong>和特征的描述，属于“<strong>型</strong>”的层次，<strong>相对稳定</strong></p>
</li>
<li><p><strong>实例</strong>（instance）：模式对应的一个<strong>具体值</strong>称为<strong>实例</strong>，<strong>相对变动</strong></p>
<p>注意，这里“一个具体值”不是只有一个值，而是一个模式的值，即刻整个数据库的数据。</p>
</li>
</ol>
</li>
<li><p><strong>二级映像下的三级结构</strong>：由<strong>模式对外</strong>(应用程序)，<strong>对内</strong>(数据存储)分别进行了<strong>模式映像</strong>。从而产生了两个<strong>二级映像</strong>，即<strong>外模式</strong>与<strong>内模式</strong>。</p>
<ol>
<li><strong>三级结构</strong>：<strong>外模式，模式，内模式</strong>统称数据库三级模式的结构<ul>
<li><strong>模式</strong>：具体概念不再赘述，<strong>强调模式是所有用户的公共数据视图</strong></li>
<li><strong>外模式</strong>：又名子模式、用户模式。它是<strong>数据库用户</strong>(开发者与最终用户)能够<strong>看见与使用</strong>的<strong>局部数据</strong>的逻辑结构和特征的描述**</li>
<li><strong>内模式</strong>：又称为存储模式，<strong>一个数据库只有一个内模式</strong>，<strong>是数据在数据库内部的组织方式的描述</strong></li>
</ul>
</li>
<li><strong>模式映像的作用</strong>：<strong>外模式</strong>实现了<strong>逻辑独立性</strong>，<strong>内模式</strong>实现了<strong>物理独立性</strong>。从外到内<strong>保证模式的相对稳定</strong></li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84(yhd).jpg"
                      alt="三级模式"
                ></p>
</li>
</ol>
<h2 id="数据库系统组成"><a href="#数据库系统组成" class="headerlink" title="数据库系统组成"></a>数据库系统组成</h2><p>​    数据库系统由：<strong>硬件平台及数据库</strong>，<strong>软件</strong>，<strong>人员</strong>(数据库管理人员)(<strong>DBA</strong>，DataBase Administrator)组成。</p>
]]></content>
      <tags>
        <tag>SQL</tag>
        <tag>技术积累</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库原理 第五章 数据库完整性</title>
    <url>/2020/10/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
    <content><![CDATA[<h1 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7.png"
                     
                ></p>
<h2 id="什么是数据库完整性"><a href="#什么是数据库完整性" class="headerlink" title="什么是数据库完整性"></a>什么是数据库完整性</h2><ol>
<li><p>数据库完整性(integrity)：<strong>数据</strong>的<strong>正确性</strong>和<strong>相容性</strong></p>
</li>
<li><p>维护数据库完整性功能组成</p>
<ol>
<li><strong>完整性约束机制</strong>：实体完整性、参照完整性、用户定义完整性等</li>
<li><strong>完整性检查方法</strong>：一般在增删改查或事务操作前后进行</li>
<li><strong>违约处理</strong>：<strong>not action</strong>(拒绝)，<strong>cascad</strong>(级联)，<strong>nullifies</strong> (置空)</li>
</ol>
</li>
</ol>
<h2 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h2><ol>
<li><p><strong>定义</strong>：<strong>create</strong> table 中的 <strong>primary key</strong>定义(列级/表级)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Student(</span><br><span class="line">	Sno <span class="built_in">char</span>(<span class="number">9</span>) <span class="comment">/*primary key*/</span>,  <span class="comment">/*列级定义*/</span></span><br><span class="line">    primary <span class="keyword">key</span>(Sno) <span class="comment">/*表级定义*/</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>完整性检查</strong></p>
<ol>
<li>检查<strong>主码值是否唯一</strong>，若不唯一<strong>拒绝</strong>插入与更新</li>
<li>检查<strong>主码个属性是否为空</strong>，存在一个空，则同样拒绝操作</li>
</ol>
</li>
<li><p><strong>违约处理</strong>：对于主键冲突，违约<strong>系统默认</strong>一概<strong>NOT ACTION(拒绝)</strong>处理</p>
</li>
</ol>
<h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2><ol>
<li><p><strong>定义</strong>：<strong>create</strong> table 中的 <strong>foreign key() references</strong>定义(<strong>表级</strong>)</p>
</li>
<li><p><strong>完整性检查与违约处理</strong></p>
<ol>
<li><p><strong>隐式处理</strong>(默认策略)：<strong>NOT ACTION(拒绝)</strong></p>
</li>
<li><p><strong>显示处理</strong>(自定义违约处理方式)：</p>
<ol>
<li><p><strong>应用场景</strong>：只有被参照表(外码表)才可显示定义违约处理策略，<strong>即只允许在 foreign key 授权语句后追加，不可写在其他地方</strong>，且仅限于update与delete操作</p>
</li>
<li><p>语句格式：[表级定义权限约束 &lt;空格&gt;]  ON <strong> &lt;违约操作&gt; &lt;违约处理&gt; </strong></p>
<ul>
<li><p><strong>&lt;违约操作&gt;</strong>：且限于 update、delete</p>
</li>
<li><p><strong>&lt;违约处理&gt;</strong>：拒绝(<strong>NO ACTION</strong>)，级联(<strong>CASCADE</strong>)，置空(<strong>NULLIFIES</strong>)</p>
<p>级联操作：若删除的参照表的数据在其他表被引用，连同删除</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Student(</span><br><span class="line">	...</span><br><span class="line">    primary <span class="keyword">key</span>(Sno,Cno),		<span class="comment">/*只允许在foreign key 后追加显示违约处理*/</span></span><br><span class="line">    <span class="keyword">foreign</span> <span class="keyword">key</span>(Sno) <span class="keyword">references</span> Student(Sno) <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">cascade</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">cascade</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h2 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h2><ol>
<li><p><strong>定义</strong>：用户可对具体列(字段)进行约束，一般分为两种</p>
<ul>
<li><strong>属性上的约束条件：可对</strong>单个列级属性<strong>进行</strong>约束</li>
<li><strong>元组上的约束条件</strong>：可对<strong>多个列级属性</strong>进行<strong>约束</strong>，完整性约束限制类型同上</li>
</ul>
</li>
<li><p><strong>完整性约束</strong>：限制类型含，<strong>not null</strong>(非空)，<strong>unique</strong>(唯一)，<strong>check</strong>&lt;条件表达式&gt;)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> SC(</span><br><span class="line">	Sno <span class="built_in">char</span>(<span class="number">9</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    Sname <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    Ssex <span class="built_in">char</span>(<span class="number">2</span>) <span class="keyword">check</span>(Ssex <span class="keyword">IN</span>(<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;女&#x27;</span>)),</span><br><span class="line">    Sgrade samllint <span class="keyword">check</span>(Sgrade &gt;=<span class="number">0</span> <span class="keyword">AND</span> Sgrade &lt;= <span class="number">100</span>),</span><br><span class="line">    <span class="keyword">CHECK</span>(Ssex = <span class="string">&#x27;女&#x27;</span> <span class="keyword">OR</span> Sname <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;Ms.%&#x27;</span>)<span class="comment">/*同时约束多个列*/</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>违约处理</strong>：系统统一采取**拒绝(NOT ACTION)**处理</p>
</li>
</ol>
<h2 id="完整性约束命名子句"><a href="#完整性约束命名子句" class="headerlink" title="完整性约束命名子句"></a>完整性约束命名子句</h2><h3 id="概念与子句的创建"><a href="#概念与子句的创建" class="headerlink" title="概念与子句的创建"></a>概念与子句的创建</h3><ol>
<li><p><strong>前言</strong>：上述所有约束都是在create table时设置，若需要修改约束，难道只能重新建表？</p>
</li>
<li><p><strong>命名子句</strong>：在create table设置约束时<strong>为每个约束操作命名</strong>，后序修改或删除约束可通过操作这个命名</p>
</li>
<li><p><strong>子句格式</strong>：<code>constraint &lt;完整性约束条件名&gt;&lt;完整性约束条件&gt; </code></p>
<ul>
<li>&lt;完整性约束条件&gt;包含：<strong>primary key、foreign key，not null、unique、check</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Student(</span><br><span class="line">	Sno <span class="built_in">int</span> <span class="keyword">constraint</span> c1 <span class="keyword">check</span>(Sno &gt;= <span class="number">9000</span> <span class="keyword">AND</span> Sno &lt;= <span class="number">9999</span>),<span class="comment">/*列级操作*/</span></span><br><span class="line">    <span class="keyword">constraint</span> StudentKey primary <span class="keyword">key</span>(Sno) <span class="comment">/*表级操作示例*/</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="修改完整性限制"><a href="#修改完整性限制" class="headerlink" title="修改完整性限制"></a>修改完整性限制</h3><ol>
<li><strong>使用环境</strong>：在 <code>alter table</code> 语句下进行修改(add、drop)</li>
<li><strong>语句格式</strong>：`&lt;add | drop&gt; constraint &lt;完整性约束子句名 | 完整性约束子句&gt;</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Student</span><br><span class="line">	<span class="keyword">drop</span> <span class="keyword">constraint</span> c1; <span class="comment">/*删除Student表中名为c1的完整性约束*/</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Student  <span class="comment">/*在Student表中添加新的完整性约束子句*/</span></span><br><span class="line">	<span class="keyword">add</span> <span class="keyword">constraint</span> Sno_domain <span class="keyword">check</span>(Sno &gt;= <span class="number">9000</span> <span class="keyword">AND</span> Sno &lt;= <span class="number">9999</span>);</span><br><span class="line">	</span><br><span class="line"><span class="comment">/*若想修改约束，则只能先删除约束再添加过新的约束*/</span></span><br></pre></td></tr></table></figure>

<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><ol>
<li><p><strong>定义</strong>：触发器(trigger)，<strong>由事件驱动的特殊过程</strong>(事件-&gt;条件-&gt;动作)</p>
</li>
<li><p><strong>创建触发器</strong>：[ 事件(触发时机) -&gt; 条件(触发条件) -&gt; 动作(存储过程)]</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> &lt;触发器名&gt;</span><br><span class="line">&lt;<span class="keyword">before</span> | <span class="keyword">after</span>&gt; &lt;触发事件&gt; <span class="keyword">on</span> &lt;表名&gt; <span class="comment">/*定义触发的时机*/</span></span><br><span class="line"><span class="keyword">referencing</span> &lt;<span class="keyword">new</span>|<span class="keyword">old</span>&gt; <span class="keyword">row</span> <span class="keyword">as</span>&lt;变量&gt; <span class="comment">/*通过referencing引出变量*/</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span>&lt;<span class="keyword">row</span> | <span class="keyword">statement</span>&gt; <span class="comment">/*指明动作体执行的频率*/</span></span><br><span class="line">[<span class="keyword">when</span> &lt;触发条件&gt;]&lt;触发动作体&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>只有创建表的用户才能在此表上创建触发器，而且数量有限，具体数量由数据库管理系统本身设计所定</li>
<li>触发器名：必须唯一</li>
<li>表名：只能是基本表，不能是视图</li>
<li><strong>触发事件</strong>：<ul>
<li>触发时机：可在语句执行前before，或执行后after</li>
<li>操作类型：可以是<strong>增删改查，事务等</strong>操作，如insert，delete，update…</li>
<li>事件组合：可以单一事件，可组合，insert or delete，或指定列触发 update of &lt;触发列,…&gt;</li>
</ul>
</li>
<li><strong>触发器类型</strong>：<ul>
<li>语句级触发器(for each statement)：<strong>执行完这条语句</strong>后且符合触发条件才会调用触发器(有可能这条语句已经操作了若干行数  据)，因此<strong>语句级</strong>触发器是<strong>不允许通过referencing</strong>引出变量new或者old row数据的</li>
<li>行级触发器(for each row)：相反，行级触发器，当检查到一行数据符合触发条件就会调用触发器。因为数据行是确定的，所  以可以通过referencing 引出变量new | row的数据  </li>
</ul>
</li>
<li><strong>触发条件</strong>：触发条件的书写即<strong>&lt;条件表达式&gt;的书写</strong></li>
<li><strong>触发动作体</strong>：匿名PL/SQL过程块，也可以是存储过程</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*当对表SC的Grade属性进行修改时，若分数增加了10%，则将此次操作记录到另一个表SC_U(Sno、Cno、Oldgrade、Newgrade)中，其中Oldgrade是修改前的分数，Newgrade是修改后的分数。*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> SC_T</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol>
<li><p><strong>触发器的激活机制</strong>：</p>
<ol>
<li>同一表上的多个触发器按，执行before触发器—&gt; 激活sql语句 —&gt; 执行after触发器流程触发</li>
<li>对于相同的触发器类型的触发器，遵循“<strong>谁先创建谁先执行原则</strong>”，有些DBMS按触发器名称字母排序。</li>
</ol>
</li>
<li><p><strong>删除触发器</strong>：<code>drop trigger &lt;触发器名&gt; on &lt;表名&gt;</code></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>SQL</tag>
        <tag>技术积累</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库原理 第六章  关系数据理论</title>
    <url>/2020/10/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%20%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="关系数据理论"><a href="#关系数据理论" class="headerlink" title="关系数据理论"></a>关系数据理论</h1><p>范式与范式之间的关系</p>
<p>低级范式可通过分解转换为若干个高一级方式的关系模式的集合</p>
<p>高一级的范式必是必定是低一级范式</p>
<p>包含关系，</p>
<p>1NF</p>
<ul>
<li>插入异常：Cno初始无，但为码</li>
<li>删除异常：Cno，删除，连累其他数据</li>
<li>修改复杂：存储冗余，修改复杂</li>
</ul>
<p>2NF</p>
<p>小结：部分函数依赖</p>
<p>依赖定义——&gt;常见依赖特性 == 完全函数依赖，按照依赖的标准定义能体现出，现实世界必定存在依赖关系，而完全性依赖必定存在若干不同且唯一元组(即数据冗余情况最严重(这里应该就不叫冗余了…是必要的))。若让这种情况(完全性依赖)混在其非主属性中(部分函数依赖)，则必定存在一个问题——&gt;存储冗余，而这种存储的冗余而引发的一系列异常如下</p>
<ul>
<li>存储冗余：不符合完全函数依赖的非主属性必定产生存储冗余</li>
<li>修改复杂化：而当对存储冗余数据本身进行修改自然会呈现出修改的复杂化</li>
<li>对非冗余(符合完全函数依赖/部分函数依赖中非依赖子集)进行删除操作的时候，出现删除异常(删除了同一关系下不符合完全函数依赖的属性)</li>
</ul>
<p>角度2：</p>
<ul>
<li>对原本就具备完全函数依赖的关系影响<ul>
<li>删除异常：进行删除操作的时候，出现删除异常(删除了同一关系下不符合完全函数依赖的属性)</li>
</ul>
</li>
<li>对不符合完全函数依赖(部分函数依赖)异常<ul>
<li>存储冗余：不符合完全函数依赖的非主属性必定产生存储冗余</li>
<li>修改复杂化：而当对存储冗余数据本身进行修改自然会呈现出修改的复杂化</li>
</ul>
</li>
</ul>
<p>解决方案：投影分解，</p>
<p>3NF</p>
<p>在2NF基础上消除传递函数依赖</p>
<p>BCNF(修正/扩充的第三范式)</p>
<p>全是非平凡的函数依赖</p>
<p>小明，老1，物理</p>
<p>小东，老1，物理</p>
<p>传递函数依赖，同样是会产生存储冗余，(因为2NF不存在完全函数依赖与部分函数依赖的相互影响，因此不存在删除异常)，进而出现存储冗余与与之衍生的修改复杂化</p>
<p>多值依赖</p>
<p><strong>判定方法：对于任意关系中，如果存在两个元组（就是行），记为A,B，如果他们的某一属性X的值相等，那么我们交换它们另外的其中一个属性Y的值后，得到的新的两个元组，这两个元组在原来的表中是可以找到的</strong></p>
<p>整个小结：</p>
<p>劣势依赖：部分函数依赖、传递函数依赖</p>
<p>其实按最基本的依赖关系，去建立数据库就基本符合常规规范</p>
<p>出现部分函数依赖侧面表明该关系中，属性间的关系并非完全依赖，按照</p>
<p>Sdept、 Sloc部分函数依赖</p>
<p>将一个1NF关系分解为多个2NF的关系，并不能完全消除关系模式中的各种异常情况和数据冗余</p>
<p>不能说规范化程度越高的关系模式就越好<br>在设计数据库模式结构时，必须对现实世界的实际情况和用户应用需求作进一步分析，确定一个合适的、能够反映现实世界的模式<br>上面的规范化步骤可以在其中任何一步终止 </p>
<p>规范化理论为数据库设计提供了理论的指南和工具<br>也仅仅是指南和工具 </p>
<p>并不是规范化程度越高，模式就越好<br>必须结合应用环境和现实世界的具体情况合理地选择数据库模式 </p>
<p>反规范化设计：<br>规范化数据将导致数据库中产生更多的表，这些表的结构优化了数据变更性能，但是在有些情况却大大降低了数据查询效率。在这种情况下，通过引进额外的列或额外的表将有助于提高数据查询能力。<br>在表格中有意识的引入一定的数据冗余以改进性能被称为反规范化。<br>反规范化是查询效率与数据冗余的折中。</p>
]]></content>
      <tags>
        <tag>SQL</tag>
        <tag>技术积累</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 第三章 循环链表&amp;双向链表</title>
    <url>/2020/09/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8&amp;%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<ul>
<li><strong>读物</strong>：<a class="link"   href="https://book.douban.com/subject/6424904/" >《大话数据结构》<i class="fas fa-external-link-alt"></i></a></li>
<li><strong>印次</strong>：2020年5月第25次印刷(2020.5重印)</li>
</ul>
<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ol>
<li><strong>循环链表</strong></li>
<li><strong>双向链表</strong></li>
<li><strong>小结</strong></li>
</ol>
<h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>单循环链表(circular linked)：</strong> 将单链表的<strong>终端结点指针端口</strong>由空指针改为<strong>指向头结点</strong>，是整个单链表形成一个<strong>环</strong>。  </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png"
                      alt="循环链表"
                ></p>
<ul>
<li>相对单链表，<strong>循环链表</strong>可以实现<strong>从任意一个结点出发，可访问到链表的全部结点</strong>的操作。</li>
<li>为了方便操作，循环链表<strong>为空链表</strong>时，<strong>头结点的指针域也“循环”地指向自己</strong>。如下图所示：</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8-%E5%A4%B4%E7%BB%93%E7%82%B9.png"
                      alt="头结点"
                ></p>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>​    而实际应用中，很多操作是在表的<strong>首或尾</strong>两端进行。传统单链表使用的头指针在<strong>首部</strong>操作时间复杂度为O(1)，<strong>而尾部操作时间复杂度则为O(n)</strong>。 此时，不设置头结点，而是<strong>借助”循环”本身的特性</strong>，通过设置<strong>终端结点的尾指针(rear)**，实现对</strong>首尾的高效操作**。  </p>
<ul>
<li>对于终端结点复杂度即为O(1)，对于头结点即<code>rear-&gt;next</code>，头指针即<code>rear-&gt;next-&gt;next</code>，复杂度均为O(1)</li>
<li>循环链表没有增加任何存储量，仅对链接方式稍作改变，因此<strong>基本操作的实现与链表相似</strong>。如<strong>ListLength、GetElem、LocateElem等</strong>这些操作<strong>只要设计一个方向</strong>的指针即可，另一个指针多了也不能提供什么帮助。</li>
</ul>
<h2 id="合并循环链表"><a href="#合并循环链表" class="headerlink" title="合并循环链表"></a>合并循环链表</h2><p>通过尾指针链接两个循环链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = rearA-&gt;next;	<span class="comment">/* 保存A表的头结点*/</span>                    </span><br><span class="line">rearA-&gt;next = rearB-&gt;next-&gt;next;    <span class="comment">/*将本是指向B表的第一个结点（不是头结点） */</span></span><br><span class="line">								<span class="comment">/* 赋值给reaA-&gt;next，即*/</span></span><br><span class="line">q = rearB-&gt;next; </span><br><span class="line">rearB-&gt;next = p;  <span class="comment">/* 将原A表的头结点赋值给rearB-&gt;next，即③ */</span></span><br><span class="line"><span class="built_in">free</span>(q);   <span class="comment">/* 释放q*/</span></span><br></pre></td></tr></table></figure>



<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><h2 id="定义及其初始化"><a href="#定义及其初始化" class="headerlink" title="定义及其初始化"></a>定义及其初始化</h2><p><strong>双向链表(double linked list)**：是在单链表的每个结点中，在设置一个指向其</strong>前驱结点**的指针域。定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*线性表的双向链表存储结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;DulNode,*DuLinkList;</span><br></pre></td></tr></table></figure>

<h2 id="双链表的插入"><a href="#双链表的插入" class="headerlink" title="双链表的插入"></a>双链表的插入</h2><p>相对于单链表的插入操作，双链表的插入需要<strong>修改4个指针</strong>。关键修改代码如下(在结点p的后面插入一个新结点s)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s-&gt;prior = p;</span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = s;</span><br><span class="line">p-&gt;next = s;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5.jpg"
                      alt="双向链表的插入"
                ></p>
<h2 id="双链表的删除"><a href="#双链表的删除" class="headerlink" title="双链表的删除"></a>双链表的删除</h2><p>因为有两个指针域，在指向调整上更加灵活。<strong>若p指向待删除结点</strong>，则删除的关键代码部分如下(<strong>未被验证</strong>)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = p-&gt;prior;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4.png"
                      alt="双向链表的删除"
                ></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>双向链表先对于单链表来说，<strong>更加复杂</strong>，对于<strong>对于插入和删除</strong>时，需要歌外注意</li>
<li>双向链表有<strong>两个指针域</strong>，因此<strong>空间上占用略多一些</strong></li>
<li>由于双向链表有<strong>良好的对称性</strong>，使得对某个结点的<strong>前后结点操作</strong>带来了方便</li>
<li>因此总的来说，双向链表通过复杂的设计<strong>用空间效率在某种情况下换取了时间效率</strong></li>
</ul>
]]></content>
      <tags>
        <tag>技术积累</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 第一章 绪论</title>
    <url>/2020/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<ul>
<li><strong>读物</strong>：<a class="link"   href="https://book.douban.com/subject/6424904/" >《大话数据结构》<i class="fas fa-external-link-alt"></i></a></li>
<li><strong>印次</strong>：2020年5月第25次印刷(2020.5重印)</li>
</ul>
<h1 id="知识大纲"><a href="#知识大纲" class="headerlink" title="知识大纲"></a>知识大纲</h1><ol>
<li>数据结构的起源</li>
<li>基本概念和术语</li>
<li>逻辑结构与物理结构</li>
<li>抽象数据类型</li>
</ol>
<h1 id="数据结构的起源"><a href="#数据结构的起源" class="headerlink" title="数据结构的起源"></a>数据结构的起源</h1><h2 id="早期认知"><a href="#早期认知" class="headerlink" title="早期认知"></a>早期认知</h2><p>人们都把计算机理解为<strong>数值计算工具</strong>。解决问题方式如下：</p>
<ol>
<li>分析问题</li>
<li>抽像其数据模型</li>
<li>设计数据模型对应算法</li>
<li>编写程序</li>
</ol>
<h2 id="实际环境"><a href="#实际环境" class="headerlink" title="实际环境"></a>实际环境</h2><p>现实中，更多是<strong>解决非数值型问题，因此需要</strong>更加有效的科学手段。**(<strong>比如表、树图等数据结构</strong>)。</p>
<h1 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><h3 id="数据的基本概念"><a href="#数据的基本概念" class="headerlink" title="数据的基本概念"></a>数据的基本概念</h3><p>数据：是描述客观事物的<strong>符号</strong>，是计算机中<strong>可操作</strong>的对象，是<strong>能被计算机识别</strong>，并<strong>能够输入</strong>给计算机<strong>处理</strong>的<strong>符号集合</strong>。</p>
<blockquote>
<p>比如编程所用到的数据类型，还包括字符、声音、图像、视频等<br>这里所描述的数据，其实就是符号</p>
</blockquote>
<h3 id="数据的基本特性"><a href="#数据的基本特性" class="headerlink" title="数据的基本特性"></a>数据的基本特性</h3><ul>
<li><strong>可输入</strong>到计算机中</li>
<li>能被<strong>计算机程序处理</strong></li>
</ul>
<h2 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h2><p>数据元素：<strong>组成数据</strong>的，有一定<strong>意义</strong>的基本单位，在及算你中通常作为整体处理。也被称为<strong>记录</strong>。</p>
<h2 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h2><p>数据项：一个数据元素可以由若干个数据项组成。</p>
<blockquote>
<p>比如人这样的数据元素，可以有眼、耳、口、鼻，姓名、年龄、性别这些数据项</p>
</blockquote>
<ul>
<li><strong>数据项</strong>是<strong>数据</strong>的<strong>最小单位</strong></li>
<li>在研究数据结构问题时，<strong>数据元素</strong>才是建立数据模型的着眼点</li>
</ul>
<h2 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h2><p>数据对象：是<strong>性质相同</strong>的数据元素的集合，是数据的<strong>子集</strong>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>数据：就是<strong>符号</strong>，数值型和非数值型集合</li>
<li>数据元素：组成数据有意义的基本单位，即java中的“<strong>类</strong>”</li>
<li>数据项：组成数据元素的基本单位，即类里面的“<strong>属性</strong>”</li>
<li>数据对象：是<strong>数据</strong>的子集。即类里面的“<strong>对象/实例</strong>”</li>
</ul>
<hr>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构：是相互之间存在一种或多种特定<strong>关系</strong>的<strong>数据元素</strong>的集合。结构即关系！</p>
<p>一个“好”的程序，必须分析待处理<strong>对象的特性</strong>及其**<em>各处理对象之间存在的关系**</em>这就是研究数据结构的意义所在。</p>
<blockquote>
<ul>
<li>“分析待处理对象的特性”，即以前接触高级语言的“面向对象编程”  </li>
<li>博主如今缺乏的，即是学习“各处理对象之间存在的关系”</li>
</ul>
</blockquote>
<p><strong>数据结构实际涵盖三个主要内容</strong>：<strong>逻辑结构</strong>(表,队,树,图…)、<strong>存储结构</strong>(顺序存储,链式存储)、<strong>基本操作</strong>(ADT)组成</p>
<h1 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h1><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>逻辑结构：是指数据对象中数据元素之间的相互关系，也是今后讨论的重点。主要类型包含如下</p>
<ul>
<li>集合结果</li>
<li>线性结构</li>
<li>树形结构</li>
<li>图像结构</li>
</ul>
<h3 id="集合结构"><a href="#集合结构" class="headerlink" title="集合结构"></a>集合结构</h3><p>集合结构：集合结构中的数据元素除了<strong>同一个集合</strong>外，它们之间没有其他关系。</p>
<blockquote>
<p>它们相互平等，唯一且共同的属性就是“<strong>同属一个集合</strong>”，类似数学的集合，形如“鱼塘”</p>
</blockquote>
<h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><p>线性结构：线性结构中的数据元素之间是<strong>一对一</strong>的关系，类似“<strong>火车，项链</strong>”。</p>
<h3 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h3><p>树形结构：树形结构中的数据元素之间存在一种<strong>一对多</strong>的的层次关系。形如“<strong>大树</strong>”分支。</p>
<h3 id="图形结构"><a href="#图形结构" class="headerlink" title="图形结构"></a>图形结构</h3><p>图像结构：图形结构的数据元素是<strong>多对多</strong>的关系，类似“<strong>人际关系</strong>”，交错复杂。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>用示意图表示数据的逻辑结构时，要注意两点</p>
<ul>
<li>将每一个<strong>数据元素</strong>看做一个<strong>结点</strong>，用<strong>圆圈</strong>表示</li>
<li>元素之间的逻辑关系用结点之间的连线表示，如果这个关系是<strong>有方向</strong>的，必须标明箭头</li>
</ul>
<hr>
<h2 id="物理结构-存储结构"><a href="#物理结构-存储结构" class="headerlink" title="物理结构/存储结构"></a>物理结构/存储结构</h2><p>物理结构：是指数据的逻辑结构在计算机中的<strong>存储形式</strong>。</p>
<blockquote>
<ul>
<li>即数据元素如何存储到计算机的存储器中，这里的存储器主要针对<strong>内存</strong>而言 </li>
<li>数据的存储结构应正确反映数据元素之间的逻辑关系，这才是重点  </li>
</ul>
</blockquote>
<hr>
<p><strong>存储结构形式有两种：顺序存储和链式存储</strong></p>
<h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p>顺序存储结构：是把数据元素存放在<strong>地址连续</strong>的存储单元里。此时，其数据间的<strong>逻辑关系和物理关系是一致</strong>的。</p>
<blockquote>
<p>形如理想状态下的<strong>排队</strong>，又如编程中的<strong>数组</strong>存储/开辟空间机制</p>
</blockquote>
<h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><p>链式存储结构：是把数据元素存放在<strong>任意的存储单元</strong>里，而这组存储单元可以是连续的，也可以是不连续的。</p>
<blockquote>
<p>形如去银行、医院等地方，设置了“<strong>叫号排序</strong>”的机制。<br>实际，把变量的地址存储在一个指针变量中，通过指针变量找到对应的数据</p>
</blockquote>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><ul>
<li>逻辑结构是<strong>面向问题</strong>的，而物理结构就是<strong>面向计算机</strong>的</li>
<li>顺序存储：<strong>连续</strong>开辟-<strong>按序</strong>对应</li>
<li>链式存储：<strong>任意</strong>开辟-<strong>叫号</strong>对应</li>
</ul>
<h1 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>数据类型</strong>：是指一组<strong>性质相同</strong>的值的集合,及定义在此集合上的<strong>一些操作</strong>的总称。</p>
<blockquote>
<p>在计算机中，内存也不是无限大的，计算机的研究者们就考虑，要对数据类型进行分类，分出多种数据类型来适合各种不同的计算条件差异，同时节省内存</p>
</blockquote>
<p>C语言中数据类型可以分为两类</p>
<ul>
<li><strong>原子类型</strong>：<strong>不可以再分解</strong>的基本类型，例如整型、浮点型、字符型等。</li>
<li><strong>结构类型</strong>：由<strong>若干种数据类型组合</strong>而成，是可再分解。如整型数组由若干整型数据组成的</li>
</ul>
<h2 id="抽象数据类型-1"><a href="#抽象数据类型-1" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>抽象：抽象是指抽取出事物具有的普遍性的本质。即抽出<strong>问题的特征</strong>而忽略非本质的细节。</p>
<h3 id="抽象数据类型-2"><a href="#抽象数据类型-2" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>抽象数据类型(Abstract Data Type，ADT)：是指一个<strong>数学模型</strong>及定义在该模型上的<strong>一组操作</strong>。</p>
<blockquote>
<ol>
<li>抽象数据类型不仅仅指那些已经定义并实现的数据类型(int、char等)，还可以是计算机编程者在设计软件程序时<strong>自己定义的数据类型</strong>，即如同高级语言的即“<strong>类</strong>”一样。而“及定义在该模型上的一组操作”即如同定义类，及其基本“<strong>方法</strong>”</li>
<li>比如，无论在PC、平版电脑、只能手机上都拥有“整数”这个类型，那么可以说“整型”其实就是一个抽象的数据类型，而且“<strong>抽象</strong>”<strong>的意义</strong>在于数据类型的<strong>数学抽象特征</strong>。</li>
</ol>
</blockquote>
<p><strong>抽象数据类型</strong>体现了程序设计中，<strong>问题分解、抽线、信息隐藏</strong>的特性。</p>
<h3 id="抽象数据类型的标准格式"><a href="#抽象数据类型的标准格式" class="headerlink" title="抽象数据类型的标准格式"></a>抽象数据类型的标准格式</h3><pre><code>ADT 抽象数据类型名
Data
    数据元素之间逻辑关系的定义
Operation
    操作1
        初始条件
        操作结构描述
    操作2
        ...

endADT</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p>现实问题中更需要解决的是<strong>非数值运算</strong>问题。</p>
</li>
<li><p>数据  </p>
<ul>
<li>数据即<strong>符号</strong></li>
<li>数据元素即“<strong>类</strong>”</li>
<li>数据对象即可“<strong>实例</strong>”</li>
<li>数据项即“<strong>属性</strong>”</li>
</ul>
</li>
<li><p><strong>结构即关系</strong></p>
<blockquote>
<p>数据结构定义：<strong>是相互之间存在一种或多种特定关系的数据元素的集合</strong></p>
</blockquote>
</li>
<li><p>逻辑结构与物理结构，即<strong>面向问题，与面向存储</strong>。</p>
<ol>
<li>四大逻辑结构(“<strong>四形</strong>”)<ul>
<li>集合结构</li>
<li>线性结构</li>
<li>树形结构</li>
<li>图形结构</li>
</ul>
</li>
<li>两大物理结构<ul>
<li>顺序存储(数组)</li>
<li>链式存储(指针)</li>
</ul>
</li>
</ol>
</li>
<li><p>抽象数据类型</p>
<ol>
<li>数据类型<ul>
<li>原子类型(不可分割/int，char)</li>
<li>结构类型(组合而成)</li>
</ul>
</li>
<li>抽象数据类型<ul>
<li><strong>已定义</strong>数据类型抽象，即int，char</li>
<li>自定义数据类型抽象，即struct，类</li>
</ul>
</li>
<li>抽象数据类型规范:ADT、Data、Operation、endADT</li>
</ol>
</li>
</ol>
<h1 id="作者建议研读方法"><a href="#作者建议研读方法" class="headerlink" title="作者建议研读方法"></a>作者建议研读方法</h1><ul>
<li>复习c语言的基础知识。</li>
<li>第一遍阅读，建议从头至尾进行通读。</li>
<li>阅读时，摘抄/笔记是非常好的习惯。“最淡的墨水也胜于最强的记忆”</li>
<li><strong>阅读每一章时，特别是阅读****<em>算法的推导过程</em></strong>，<strong>一定要在电脑中运行代码和进行调试，设置断点和逐行执行，参照书的讲解，观察变量的变化情况来理解算法的编写原理</strong>。</li>
<li>阅读完每一章时，一定要在<strong>理解基础上</strong>记忆一些<strong>关键东西</strong>，最佳效果就是不看书也可以一点不错的默写相关的算法。</li>
<li>阅读完每一章时，一定要适当练习。</li>
<li>在之后的学习或工作中，尽量把学到的数据结构和算法<strong>运用</strong>到现实开发中。</li>
</ul>
<h1 id="《大话数据树结构》初读后有感"><a href="#《大话数据树结构》初读后有感" class="headerlink" title="《大话数据树结构》初读后有感"></a>《大话数据树结构》初读后有感</h1><h2 id="教材和自学读物，所面向的读者是完全不同的"><a href="#教材和自学读物，所面向的读者是完全不同的" class="headerlink" title="教材和自学读物，所面向的读者是完全不同的"></a>教材和自学读物，所面向的读者是完全不同的</h2><h3 id="教材特性"><a href="#教材特性" class="headerlink" title="教材特性"></a>教材特性</h3><ol>
<li>好的教材应试是<strong>提纲挈领、重点突出</strong>。</li>
<li>一定要<strong>留出思考空间</strong>，否则就没必要再听老师上课了。教材很多内容的讲解都是由<strong>老师</strong>在课堂上完成的。</li>
<li>教材中必定有<strong>练习、课后习题、思考题等</strong>，而这些大多可以通过老师来解答。<blockquote>
<p>比如我们中学时的语文、数学课本，很薄的一本书通常要用一个学期、甚至一年的时间来学，这就是因为它们是教材而不是自学读物。如果小说,可能一两天就读完了。</p>
</blockquote>
</li>
</ol>
<h2 id="读物——隔空交流的介质"><a href="#读物——隔空交流的介质" class="headerlink" title="读物——隔空交流的介质"></a>读物——隔空交流的介质</h2><h3 id="作者角度"><a href="#作者角度" class="headerlink" title="作者角度"></a>作者角度</h3><ol>
<li>作者认为，读者拿到的虽然只是一本没有表情、不会说话的书，但其实也是在隔空与另一个朋友交流。</li>
<li>人与人的交流不可能只是就事论事，一定会有情感的沟通，这种情感如果能产生共鸣、达成互信，就会让沟通的事情本身更容易理解和接受。</li>
</ol>
<h3 id="博主理解"><a href="#博主理解" class="headerlink" title="博主理解"></a>博主理解</h3><ol>
<li>读物本是以内容第一为原则。但其作者的表诉方式，引用，感受等情感会附带许多作者本人的价值观。即情感交流，也是阅读的影响之一。</li>
<li>对于技术类读物，除技术内外，最明显的就是学习读者的编书方式，从编书结构从而建立更全面，深刻，有效的知识的架构。<blockquote>
<p>如本书最明显的其中一个特征就是会对每一个小知识群进行小结提炼。这也会影响到我摘抄笔记的录入结构。</p>
</blockquote>
</li>
</ol>
]]></content>
      <tags>
        <tag>技术积累</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 第三章 静态链表</title>
    <url>/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<ul>
<li><strong>读物</strong>：<a class="link"   href="https://book.douban.com/subject/6424904/" >《大话数据结构》<i class="fas fa-external-link-alt"></i></a></li>
<li><strong>印次</strong>：2020年5月第25次印刷(2020.5重印)</li>
</ul>
<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ol>
<li><strong>基本概念</strong></li>
<li><strong>静态链表的初始化</strong></li>
<li><strong>静态链表的插入操作</strong></li>
<li><strong>小结</strong></li>
</ol>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li><p>静态链表：用<strong>数组</strong>描述的链表叫做静态链表。</p>
<blockquote>
<p> 如Basic、Fortran等早期编程语言，没有指针，就可通过数组实现链表结构(游标实现法)。</p>
</blockquote>
</li>
<li><p>静态链表使用<strong>两个数据域组成</strong>，分别叫<strong>data、cur</strong>，cur类似单链表中的<strong>next</strong>。不记录指针，而是<strong>记录后继元素的数组下标</strong>。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*线性表的静态链表存储结构*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> cur;	<span class="comment">/*游标(Cursor)，为0时表示无指向*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态链表的<strong>第一个</strong>和<strong>最后一个</strong>元素作为特殊处理，不存数据。</li>
<li><strong>未被使用</strong>的数组元素称为<strong>备用链表</strong>。<ol>
<li><strong>下标为0</strong>的第一个元素cur称为<strong>头指针</strong>，用于<strong>存放备用链表的下标</strong>。</li>
<li>数组最后一个元素的cur，存放第一个有数值元素的下标(<strong>相当于头结点</strong>)。</li>
</ol>
</li>
</ul>
<h1 id="静态链表初始化"><a href="#静态链表初始化" class="headerlink" title="静态链表初始化"></a>静态链表初始化</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*将一维数组space中各个分量链成一备用链表*/</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(StaticLinkList space)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAXSIZE - <span class="number">1</span>; i++)<span class="comment">/*为链表所有元素cur赋值，将其中各个分量链成一备用链表*/</span></span><br><span class="line">        space[i] = i + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    space[MAXSIZE - <span class="number">1</span>].cur = <span class="number">0</span>;	<span class="comment">/*目前链表为空，最后一个元素的cur为0*/</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png"
                      alt="静态链表基本结构示意图"
                ></p>
<h1 id="静态链表的插入操作"><a href="#静态链表的插入操作" class="headerlink" title="静态链表的插入操作"></a>静态链表的插入操作</h1><p>链表的<strong>插入/删除</strong>操作都需要调用存储空间的<strong>申请/释放</strong>函数。标准定义的malloc，free函数直接调用就可自动申请或释放空间。对于<strong>通过数组</strong>实现链表功能的<strong>静态链表</strong>实现插入/删除操作<strong>首先要解决的问题</strong>：如何用**静态模拟动态链表对存储空间的分配/管理(申请/释放)**。需要时申请、无用时释放。</p>
<h2 id="Malloc-SSL"><a href="#Malloc-SSL" class="headerlink" title="Malloc_SSL"></a>Malloc_SSL</h2><ul>
<li><p>因此静态链表需要<strong>自己实现</strong>单链表的malloc函数功能。</p>
</li>
<li><p><strong>功能描述</strong>：若备用空间链表非空，则返回可分配的结点下标(类似向内存申请空间，返回地址值)，否则返回0。</p>
</li>
<li><p><strong>实现思路</strong>：</p>
<ol>
<li><p>静态链表设计本身然下标为0的元素<strong>存放备用链表的下标</strong>，所以直接返回下标0的cur即可。</p>
</li>
<li><p>同时，需要把<strong>即将返回</strong>的备用链表的<strong>cur</strong>值重新填充到下标为0的cur，<strong>为下次分配使用</strong>。</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*若备用空间链表非空，则返回可分配的结点下标，否则返回0*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc_SSL</span><span class="params">(StaticLinkList space)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">int</span> i = space[<span class="number">0</span>].cur;           		<span class="comment">/* 当前数组第一个元素的cur存的值 */</span></span><br><span class="line">	                                		<span class="comment">/* 就是要返回的第一个备用空闲的下标 */</span></span><br><span class="line">	<span class="keyword">if</span> (space[<span class="number">0</span>]. cur)         </span><br><span class="line">	    space[<span class="number">0</span>]. cur = space[i].cur;       <span class="comment">/* 由于要拿出一个分量来使用了， */</span></span><br><span class="line">	                                        <span class="comment">/* 所以我们就得把它的下一个 */</span></span><br><span class="line">	                                        <span class="comment">/* 分量用来做备用 */</span></span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ListInsert"><a href="#ListInsert" class="headerlink" title="ListInsert"></a>ListInsert</h2><p>思路：</p>
<ol>
<li>基本插入错误过滤</li>
<li>获取空闲分量下标</li>
<li>填充数据域</li>
<li>定位前继结点</li>
<li>头插法</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; ListLength(L) + <span class="number">1</span>)	<span class="comment">//若链表已满</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">int</span> j = Malloc_SLL(L);	<span class="comment">//获得空闲分量的下标</span></span><br><span class="line">	<span class="keyword">if</span> (j) &#123;</span><br><span class="line">		L[j].data = e;<span class="comment">//将数据赋值给此分量的data</span></span><br><span class="line">							</span><br><span class="line">		<span class="keyword">int</span> k = MAXSIZE <span class="number">-1</span>,l; <span class="comment">//找到插入位置的前继元素，(计数器+while+工作指针后移)</span></span><br><span class="line">            				 <span class="comment">//静态链表的头结点在尾部			</span></span><br><span class="line">		<span class="keyword">for</span> (l = <span class="number">1</span>; l &lt;= i - <span class="number">1</span>; l++)</span><br><span class="line">			k = L[k].cur;</span><br><span class="line">        </span><br><span class="line">		L[j].cur = L[k].cur;<span class="comment">//改变游标指向(头插法)</span></span><br><span class="line">		L[k].cur = j;       <span class="comment">//先把前继节点的后继游标传给新节点的后继游标                                               </span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ERROR;	<span class="comment">//若获取分量失败则返回错误</span></span><br><span class="line">	   	  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>获取头结点下标：<code>int k = MAXSIZE -1</code></li>
</ul>
<h2 id="Free-SSL"><a href="#Free-SSL" class="headerlink" title="Free_SSL"></a>Free_SSL</h2><p>同样，静态链表实现删除操作也要先实现free函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*将下标为k的空闲结点回收到备用链表*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free_SSL</span><span class="params">(StaticLinkList space, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	space[k].cur = space[<span class="number">0</span>].cur;	<span class="comment">//让即将要删除的位置成为第一个优先的空位</span></span><br><span class="line">	space[<span class="number">0</span>].cur = k;	<span class="comment">//即删除节点与备用链表交换两个参数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ListDelete"><a href="#ListDelete" class="headerlink" title="ListDelete"></a>ListDelete</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; ListLength(L))<span class="comment">//删除索引过滤</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> k = MAXSIZE - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> l;</span><br><span class="line">	<span class="keyword">for</span> (l = <span class="number">1</span>; l &lt;= i <span class="number">-1</span>; l++)	<span class="comment">//定位前继节点</span></span><br><span class="line">		k = L[k].cur;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> d = L[k].cur;<span class="comment">//创建临时变量存储欲删除cur</span></span><br><span class="line">	L[k].cur = L[d].cur;</span><br><span class="line">	Free_SSL(L,d);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>静态链表其实为了给没有指针的高级语言设计的一种实现单链表能力的方法。特性与单链表类似，尽管以后这种方法不一定用上，但这样的思考方式是非常巧妙的。</p>
]]></content>
      <tags>
        <tag>技术积累</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 第二章 算法基础</title>
    <url>/2020/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<ul>
<li><strong>读物</strong>：<a class="link"   href="https://book.douban.com/subject/6424904/" >《大话数据结构》<i class="fas fa-external-link-alt"></i></a></li>
<li><strong>印次</strong>：2020年5月第25次印刷(2020.5重印)</li>
</ul>
<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ol>
<li><strong>算法的定义</strong></li>
<li><strong>算法的特性</strong></li>
<li><strong>算法设计的要求</strong></li>
<li><strong>算法效率的度量方法</strong></li>
<li><strong>函数的渐进增长</strong></li>
<li><strong>算法时间复杂度</strong></li>
<li><strong>算法空间复杂度</strong></li>
<li><strong>最坏情况与平均情况</strong></li>
</ol>
<h1 id="算法的定义"><a href="#算法的定义" class="headerlink" title="算法的定义"></a>算法的定义</h1><p>算法：算法是解决特定问题<strong>求解步骤的描述</strong>，在计算机中表现为<strong>指令的有限序列</strong>，并且每条指令表示一个或多个操作。</p>
<h1 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h1><p>算法具有的五个基本特性：<strong>输入、输出、有穷性、确定性、可行性</strong>。</p>
<h2 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h2><ul>
<li>算法具有<strong>零个或多个</strong>输入。</li>
<li>算法至少<strong>有一个或多个</strong>输出。</li>
</ul>
<h2 id="有穷性"><a href="#有穷性" class="headerlink" title="有穷性"></a>有穷性</h2><ol>
<li>算法在执行有限步骤之后，自动结束而<strong>不会出现无限循环</strong>。</li>
<li>每一个步骤在<strong>可接受的时间</strong>内完成。即实际意义。</li>
</ol>
<h2 id="确定性"><a href="#确定性" class="headerlink" title="确定性"></a>确定性</h2><p>确定性：算法的每一步骤都具有<strong>确定的含义，不会出现二义性</strong>，类似函数。</p>
<h2 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h2><ul>
<li>算法的每一步都必须是<strong>可行的</strong>，也就是说，每一步都能够通过执行有限次数完成。</li>
<li>可行性意味着算法<strong>可转换为程序上机运行</strong>。</li>
</ul>
<h1 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h1><p>算法设计的要求包含：<strong>正确性、可读性、健壮性、时间效率高和存储量低</strong>。</p>
<h2 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h2><p>正确性：算法的正确性是指算法至少应该具有<strong>输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案</strong>。大体分为以下<strong>四个层次</strong>：</p>
<ul>
<li><p><strong>没有语法错误</strong></p>
</li>
<li><p>对于<strong>合法</strong>的输入数据能够产生<strong>满足要求的输出结果</strong></p>
</li>
<li><p>对于<strong>非法</strong>的输入数据能够得出<strong>满足规格说明的结果</strong></p>
</li>
<li><p>对于精心选择的，甚至刁难的测试数据都有满足要求的输出结构。</p>
<blockquote>
<p>一般情况下，我们把层次3作为一个算法是否正确的标准</p>
</blockquote>
</li>
</ul>
<h2 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h2><p>可读性：算法设计的另一个目的是为了<strong>便于阅读、理解和交流</strong>。</p>
<h2 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h2><p>健壮性：当<strong>输入数据不合法</strong>时，算法也能做出相关处理，而<strong>不是</strong>产生<strong>异常或莫名奇妙</strong>的结果。</p>
<h2 id="时间效率高和存储量低"><a href="#时间效率高和存储量低" class="headerlink" title="时间效率高和存储量低"></a>时间效率高和存储量低</h2><p>设计算法应该尽量满足时间效率高和存储量(占用内存与外部硬盘存储空间)低的需求。</p>
<h1 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h1><p><strong>ps</strong>：这里指的效率大都是指算法的<strong>执行时间</strong>。</p>
<h2 id="事后统计方法"><a href="#事后统计方法" class="headerlink" title="事后统计方法"></a>事后统计方法</h2><p>事后统计方法：这种方法主要是通过事先<strong>设计好的测试程序和数据</strong>，利用计算机<strong>计时器</strong>对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。  </p>
<p>但这种方法显然存在很大的缺陷：</p>
<ul>
<li>必须依据算法事先编制对应的测试程序，费时费力，工作量可能翻倍。</li>
<li>计时器的计时效果比较依赖计算机硬件和软件等环境因素。</li>
<li>算法的测试数据设计困难。</li>
</ul>
<h2 id="事前分析估算方法"><a href="#事前分析估算方法" class="headerlink" title="事前分析估算方法"></a>事前分析估算方法</h2><p>事前分析估算方法：在计算机程序<strong>编程前</strong>，依据统计方法对算法提前进行估算。</p>
<p>事前分析一个程序在计算机运行所消耗的时间取决于下列因素：</p>
<ol>
<li>算法采用的策略、方法。</li>
<li>编译产生的代码质量。</li>
<li>问题的输入规模。</li>
<li>机器执行指令的速度。</li>
</ol>
<p><strong>结论</strong>：</p>
<ul>
<li><p>一个程序的运行时间，<strong>依赖于</strong>算法的<strong>好坏</strong>和问题的**输入规模(输入变量的值)**。</p>
</li>
<li><p>测定运行时间最可靠的方法就是依据输入规模计算语句的<strong>执行次数</strong>。</p>
<blockquote>
<p>执行次数，也成为基本操作数量，记作 f(n)，n表示输入规模。</p>
</blockquote>
</li>
</ul>
<h1 id="函数的渐进增长"><a href="#函数的渐进增长" class="headerlink" title="函数的渐进增长"></a>函数的渐进增长</h1><p><strong>ps</strong>：判断两个算法效率的高低，会存在因不同量级的输入规模而得出相反的结果。</p>
<blockquote>
<p>因此给出定义，输入规模n在没有限制的情况下，只要<strong>超过一个数值N</strong>，这个函数就<strong>总是</strong>大于另一个函数，我们称函数是渐进增长快的。</p>
</blockquote>
<p>函数渐进增长：<strong>给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐进快于g(n)。</strong></p>
<hr>
<p><strong>结论</strong>：判断一个算法的效率时，函数中的<strong>常数</strong>和其他<strong>次要项</strong>常常可以<strong>忽略</strong>，而**更应该关注主项(最高阶项)**的阶数。</p>
<h1 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h1><h2 id="时间复杂度的定义"><a href="#时间复杂度的定义" class="headerlink" title="时间复杂度的定义"></a>时间复杂度的定义</h2><p><strong>算法时间复杂度</strong>，记作T(n)=O(f(n))，通过大写<strong>O( )**来体现时间复杂度的记法，也称之为</strong>大O记法**。</p>
<blockquote>
<p><strong>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)= O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。</strong>   </p>
</blockquote>
<h2 id="推导大O阶方法"><a href="#推导大O阶方法" class="headerlink" title="推导大O阶方法"></a>推导大O阶方法</h2><ol>
<li><p>写出每一条语句的执行次数。</p>
</li>
<li><p>把所有语句的执行次数相加并且进行基本的数学化简。</p>
<hr>
</li>
<li><p>用<strong>常数1</strong>取代运行时间中的所有<strong>加法常数</strong>。</p>
</li>
<li><p>只保留<strong>最高阶项</strong>。</p>
</li>
<li><p>若最高阶项存在且不是1，则去除与<strong>这个项相乘的常数</strong>。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;				<span class="comment">//执行1次</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;			<span class="comment">//执行n次</span></span><br><span class="line">	<span class="keyword">for</span>(j = i; j &lt; n; j++)&#123;</span><br><span class="line">		<span class="comment">/*时间复杂度O(1)的程序步骤序列*/</span></span><br><span class="line">       		<span class="comment">//执行n-2次...n-1,n,执行1次</span></span><br><span class="line">        	<span class="comment">//执行n-2次...n-1,n,执行1次</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;end&quot;</span>);				<span class="comment">//执行1次</span></span><br></pre></td></tr></table></figure>

<ul>
<li>总执行次数为：1+n+(n-1)+(n-2)+…+1 + 1= n(n+1)/2 +2 = n<sup>2</sup>/2+n/2 + 2</li>
<li>去除常数： n<sup>2</sup>/2+n/2</li>
<li>保留最高阶项： n<sup>2</sup>/2</li>
<li>最高阶项存在且不等于1，去除相乘常数：n<sup>2</sup>，即最终时间复杂度为 O(n<sup>2</sup>)</li>
</ul>
<blockquote>
<ul>
<li>可看作等差数列求和：na<sub>1</sub> + n(n-1)/2 * d</li>
<li>首项a<sub>1</sub>=1，公差d=1，项数n=n</li>
</ul>
</blockquote>
<h2 id="常见时间复杂度"><a href="#常见时间复杂度" class="headerlink" title="常见时间复杂度"></a>常见时间复杂度</h2><table>
<thead>
<tr>
<th align="center">阶</th>
<th align="center">非正式术语</th>
<th align="center">常见结构</th>
<th align="center">例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(1)</td>
<td align="center">常数阶</td>
<td align="center">顺序结构、无循环分支结构</td>
<td align="center">12</td>
</tr>
<tr>
<td align="center">O(n)</td>
<td align="center">线性阶</td>
<td align="center">无内嵌循环结构</td>
<td align="center">2n+3</td>
</tr>
<tr>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">平方阶</td>
<td align="center">二层内嵌循环结构</td>
<td align="center">3n<sup>2</sup>+2n+1</td>
</tr>
<tr>
<td align="center">O(log n)</td>
<td align="center">对数阶</td>
<td align="center">非1线性增长的循环索引</td>
<td align="center">log<sub>2</sub>n+20</td>
</tr>
<tr>
<td align="center">O(n log n)</td>
<td align="center">nlog n阶</td>
<td align="center"></td>
<td align="center">2n+3nlog<sub>2</sub>n</td>
</tr>
<tr>
<td align="center">O(n<sup>3</sup>)</td>
<td align="center">立方阶</td>
<td align="center">三层内嵌循环</td>
<td align="center">n<sup>3</sup>+2</td>
</tr>
<tr>
<td align="center">2<sup>n</sup></td>
<td align="center">指数阶</td>
<td align="center"></td>
<td align="center">2<sup>n</sup></td>
</tr>
</tbody></table>
<p>常用时间复杂度所耗费得时间从小到大依次是：</p>
<p><strong>O(1) &lt; O(log⁡n) &lt; O(n) &lt; O(nlog⁡n) &lt; O(n<sup>2</sup>) &lt; O(n<sup>3</sup>) &lt; O(a<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>) </strong></p>
<p><strong>对数阶补充说明</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(count &lt; n)&#123;</span><br><span class="line">	count = count * <span class="number">2</span>;</span><br><span class="line">	<span class="comment">/*时间复杂度O(1)的程序步骤序列*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>每次count乘2之后，就距离n更接近一分，而需要乘多少次？接需要执行多少次，才能跳出循环？</li>
<li>把需要乘的次数设为x，则2<sup>x</sup>=n，得到执行次数x=log<sub>2</sub>n</li>
</ul>
<h1 id="算法的空间复杂度"><a href="#算法的空间复杂度" class="headerlink" title="算法的空间复杂度"></a>算法的空间复杂度</h1><p>空间复杂度：算法的空间复杂度即<strong>算法所需的存储空间</strong>，记作：<strong>S(n)=O(f(n)，</strong>此时n为问题的规模，f(n)为语句关于n所占<strong>存储空间函数</strong>。</p>
<blockquote>
<ul>
<li>当不用限定词地使用“复杂度”，则通常指时间复杂度。</li>
<li>时间复杂度和空间复杂度一般情况下可以相互转换。</li>
</ul>
</blockquote>
<h1 id="最坏情况与平均情况"><a href="#最坏情况与平均情况" class="headerlink" title="最坏情况与平均情况"></a>最坏情况与平均情况</h1><p>最坏情况：即一个算法存在的<strong>最低执行效率</strong>情况。</p>
<ul>
<li>在应用中，最坏情况是一种重要的需求，通常，除非特别指定，提及的<strong>运行时间</strong>都是指<strong>最坏情况</strong>的运行时间</li>
<li>平均运行时间是所有情况中最有意义的，它属于<strong>期望</strong>的运行时间。</li>
</ul>
]]></content>
      <tags>
        <tag>技术积累</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 第五章 串</title>
    <url>/2020/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E4%B8%B2/</url>
    <content><![CDATA[<ul>
<li><strong>读物</strong>：<a class="link"   href="https://book.douban.com/subject/6424904/" >《大话数据结构》<i class="fas fa-external-link-alt"></i></a></li>
<li><strong>印次</strong>：2020年5月第25次印刷(2020.5重印)</li>
</ul>
<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><h1 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h1><p><strong>串(String)：</strong>是由<strong>零个或多个字符</strong>组成的<strong>有限</strong>序列，又名叫<strong>字符串</strong>。</p>
<ul>
<li>记为：<strong>s = “a<sub>1</sub>a<sub>2</sub>a<sub>3</sub>…a<sub>n</sub>(n ≥0)”</strong></li>
<li>串中的<strong>字符数目n</strong>称为<strong>串的长度</strong></li>
<li><strong>零</strong>个字符串称为<strong>空串</strong>(null string)即，“<strong> ‘’” </strong>”</li>
<li><strong>序列</strong>即相邻字符之间存在<strong>前驱后继</strong>关系</li>
<li><strong>主串与子串</strong>：串中<strong>任意个数</strong>的<strong>连续</strong>字符组成的<strong>子序列</strong>称为该串(<strong>主串</strong>)的子串</li>
</ul>
<h1 id="串的比较"><a href="#串的比较" class="headerlink" title="串的比较"></a>串的比较</h1><h2 id="常用字符标准编码"><a href="#常用字符标准编码" class="headerlink" title="常用字符标准编码"></a>常用字符标准编码</h2><ul>
<li><strong>标准ASCII编码</strong>：用<strong>7位</strong>二进制数表示<strong>128个字符</strong> (可表示英语为主的语言)</li>
<li><strong>扩展ASCII编码</strong>：用<strong>8位</strong>二进制数表示<strong>256个字符</strong> (可表示英语为主的语言和<strong>特殊字符</strong>)</li>
<li><strong>Unicode编码</strong>：用<strong>16位</strong>二进制表示<strong>2<sup>16</sup>个字符，约6.5万多个字符</strong>(足以表示<strong>全世界成百上千种语言和文字</strong>)</li>
</ul>
<h2 id="比较原则"><a href="#比较原则" class="headerlink" title="比较原则"></a>比较原则</h2><p>字符串的比较在计算机中取决于<strong>挨个字母</strong>的<strong>前后顺序</strong>，<strong>靠后</strong>的字母比<strong>靠前</strong>的字母要大。如“silly” &lt; “stupid”</p>
<p>存在字符串 s 与 t，若 s &gt; t，则存在如下两种情况：</p>
<ol>
<li>情况1：“<strong>单纯地多出字母</strong>(包含关系)，则多出字母的字符常大”。如：“happy” &gt; “hap”，单纯多出“py”</li>
<li>情况2：“无包含关系，则<strong>挨个字母比较顺序</strong>，靠后比靠前大”。如：“happy” &gt; “happen”，匹配到第5个字母‘y’ &gt; ‘e’</li>
</ol>
<p>小结：</p>
<ul>
<li>等长：挨个字母前后顺序比较</li>
<li>不等长<ul>
<li>完全包含关系，多字母为大，happy &gt; hap</li>
<li>非包含完全包含关系，挨个字母比较，happy &gt; happen</li>
</ul>
</li>
</ul>
<h1 id="串的抽象数据类型"><a href="#串的抽象数据类型" class="headerlink" title="串的抽象数据类型"></a>串的抽象数据类型</h1><p>“串”从<strong>逻辑结构</strong>上和线性表很相似，但<strong>基本操作</strong>，串<strong>更倾向于查找子串位置，替换子串等</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADT 串(<span class="built_in">string</span>)</span><br><span class="line">Data</span><br><span class="line">    串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">    StrAssign(T, *chars):        生成一个其值等于字符串常量chars的串T。</span><br><span class="line">    StrCopy(T, S):               串S存在，由串S复制得串T。</span><br><span class="line">    ClearString(S):              串S存在，将串清空。</span><br><span class="line">    StringEmpty(S):              若串S为空，返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br><span class="line">    StrLength(S):                返回串S的元素个数，即串的长度。</span><br><span class="line">    StrCompare(S, T):            若S&gt;T，返回值&gt;<span class="number">0</span>，若S=T，返回<span class="number">0</span>，若S&lt;T，返回值&lt;<span class="number">0</span>。</span><br><span class="line">    Concat(T, S1, S2):           用T返回由S1和S2联接而成的新串。</span><br><span class="line">    SubString(Sub, S, pos, len): 串S存在，<span class="number">1</span>≤pos≤StrLength(S)，</span><br><span class="line">                                 且<span class="number">0</span>≤len≤StrLength(S)-pos+<span class="number">1</span>，用Sub返</span><br><span class="line">                                 回串S的第pos个字符起长度为len的子串。</span><br><span class="line">    Index(S, T, pos):            串S和T存在，T是非空串，<span class="number">1</span>≤pos≤StrLength(S)。</span><br><span class="line">                                 若主串S中存在和串T值相同的子串，则返回它在主串S中</span><br><span class="line">                                 第pos个字符之后第一次出现的位置，否则返回<span class="number">0</span>。</span><br><span class="line">    Replace(S, T, V):            串S、T和V存在，T是非空串。用V替换主串S中出现的所有</span><br><span class="line">                                 与T相等的不重叠的子串。</span><br><span class="line">    StrInsert(S, pos, T):        串S和T存在，<span class="number">1</span>≤pos≤StrLength(S)+<span class="number">1</span>。</span><br><span class="line">                                 在串S的第pos个字符之前插入串T。</span><br><span class="line">    StrDelete(S, pos, len):      串S存在，<span class="number">1</span>≤pos≤StrLength(S)-len+<span class="number">1</span>。</span><br><span class="line">                                 从串S中删除第pos个字符起长度为len的子串。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>





<h1 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h1><h2 id="串的顺序存储结构"><a href="#串的顺序存储结构" class="headerlink" title="串的顺序存储结构"></a>串的顺序存储结构</h2><ul>
<li>串的顺序存储结构一般用<strong>定长数组</strong>来定义</li>
<li>一般将<strong>串的长度值</strong>保存数组下标<strong>0</strong>处，有的也可存储在<strong>最后一个下标位置</strong>，或在串值后添加<strong>结束标记字符</strong>如“\0”(数据结构面向人，一般与日常数数顺序为主)</li>
<li>串的操作常使得，串值存储空间需要<strong>动态变化</strong>。一般通过<strong>自由存储区</strong>——<strong>堆</strong>和相关<strong>操作函数</strong>(malloc/free)<strong>动态分配空间</strong></li>
</ul>
<h2 id="串的链式存储结构"><a href="#串的链式存储结构" class="headerlink" title="串的链式存储结构"></a>串的链式存储结构</h2><p>串的链式存储结构因为用<strong>结点存储字符序列会浪费大量的空间</strong>，<strong>除连接串与串操作有一定方便外(只是方便/不是高效)**，总的来说，</strong>不如顺序存储灵活，性能也不如顺序存储结构好**</p>
<h1 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h1><p>BF算法，也叫朴素的模式匹配算法</p>
<p><strong>串的模式匹配</strong>：即<strong>子串在主串中的定位操作</strong>，如S=”goodgoogle”，找到T=”google”这个子串的位置</p>
<h2 id="匹配思路："><a href="#匹配思路：" class="headerlink" title="匹配思路："></a>匹配思路：</h2><ol>
<li>用子串从主串的第一位开始<strong>逐一字符匹配</strong></li>
<li>若子串中任意一个字符匹配失败，则整个子串从上一次主串<strong>开始匹配的位置</strong>的下一个位置开始匹配</li>
<li>以此循环，直至存在子串的每一个字符均被匹配正确的情况</li>
</ol>
<p><strong>匹配思路图示如下</strong>：如S=”goodgoogle”，找到T=”google”这个子串的位置</p>
<p><strong>tips</strong>：“|”竖线表示匹配成功，“⚡”表示匹配失败</p>
<ol>
<li><strong>第一步</strong></li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D01.jpg"
                      alt="模式匹配"
                ></p>
<ol start="2">
<li><strong>第二步</strong></li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D02.jpg"
                      alt="模式匹配"
                ></p>
<p>​    3. <strong>第三步</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D03.jpg"
                     
                ></p>
<ol start="4">
<li><strong>第四步</strong></li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D04.jpg"
                     
                ></p>
<ol start="5">
<li><strong>第五步</strong></li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D05.jpg"
                     
                ></p>
<h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><p>思路：</p>
<ol>
<li>位置变量pos合法过滤</li>
<li>设置主串与子串循环开始索引(下标0表串长度，下标1是第一个字符</li>
<li>匹配循环结构结束条件(||关系，&amp;&amp;表达)：S[0],T[0]表示串长度，子串提前匹配成功，或主串全部被匹配完。则结束循环</li>
<li>若字符匹配成功，则主串与子串索引分别+1，否则主串匹配索引回退，子串索引初始化</li>
<li>若匹配成功(子串被全部匹配)，则计算位置并返回，否则返回错误提示</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。*/</span></span><br><span class="line"><span class="comment">/*  T非空，1≤ pos ≤ StrLength(S)。*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(String S,String T,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="comment">//位置变量pos合法过滤</span></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">1</span> || pos &gt; StrLength(S))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置主串与子串循环开始索引</span></span><br><span class="line">    <span class="keyword">int</span> i = pos;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;<span class="comment">//下标0用于存储字符串长度，下标1即是第一个字符的数组下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//匹配循环结构结束条件：S[0],T[0]表示串长度，子串提前匹配成功，或主串全部被匹配完。则结束循环</span></span><br><span class="line">    <span class="comment">//因，匹配次数 = 字符串长度 = (j - 1)，所以 等于“=”时也需执行</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= T[<span class="number">0</span>] &amp;&amp; i &lt;= S[<span class="number">0</span>])&#123;<span class="comment">//&amp;&amp; 在这里表示，有任何一个条件不符合都表示匹配完毕</span></span><br><span class="line">         <span class="comment">//若字符匹配成功，则主串与子串索引分别+1</span></span><br><span class="line">        <span class="keyword">if</span>(S[i] == T[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//若匹配失败，则主串匹配索引回退，子串索引初始化</span></span><br><span class="line">            i - j + <span class="number">2</span>;	<span class="comment">//i - (j - 1) + 1 </span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若匹配成功(子串被全部匹配)，则计算位置并返回。</span></span><br><span class="line">    <span class="comment">//因，匹配次数 = 字符串长度 = (j - 1)，所以若全部匹配，j一定大于字符串长度</span></span><br><span class="line">    <span class="keyword">if</span>(j &gt; T[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> i - T[<span class="number">0</span>];<span class="comment">//从起点减去匹配过的次数(增过的量) == 子串长度</span></span><br><span class="line">    	</span><br><span class="line">     <span class="comment">//若匹配失败，则返回错误提示</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;								</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>因为当前教材是把字符串<strong>长度</strong>记录在数组<strong>下标0处</strong>，所以第一个字符的数组下标就是<strong>1</strong>。因此未开始匹配字符时，子串匹配索引 j 的初始值就是1，而<strong>匹配成功1次后</strong>，j++才变成<strong>2</strong>。即它们之间的关系是，<strong>匹配次数 = (j - 1) = 字符长度</strong></p>
</li>
<li><p><strong>主串索引回退代码分析</strong>(<code>i - j + 2</code>)：匹配成功一次，才会造成一次主串(子串)索引的自增，所以<strong>匹配次数==主串增加量</strong>，由上可知，匹配次数 == j -1，所以主串<strong>回退到原位</strong>因为，<strong>i - (j - 1)</strong>，而需要进入下一轮匹配则还需要回退原位后 + 1，则：  </p>
<p>回退上一次匹配位置下位代码未：<strong>i - ( j - 1 ) + 1 == i - j +2</strong></p>
</li>
</ul>
<h2 id="优化理解版"><a href="#优化理解版" class="headerlink" title="优化理解版"></a>优化理解版</h2><p>《数据结构》从概念到C++的实现，王红梅。P104，通过增加空间复杂度O(1)，引入start变量单独存放子串匹配位置</p>
<h1 id="KMP模式匹配算法"><a href="#KMP模式匹配算法" class="headerlink" title="KMP模式匹配算法"></a>KMP模式匹配算法</h1><h2 id="KMP匹配算法原理"><a href="#KMP匹配算法原理" class="headerlink" title="KMP匹配算法原理"></a>KMP匹配算法原理</h2><p>KMP算法核心可总结为两句话：“<strong>因为不同所以不同，跳过不同。因为相同所以相同，跳过相同</strong>！”</p>
<ol>
<li><p>“<strong>因为不同所以不同，跳过不同</strong>”：若存在子串字符互不相同部分，当出现主串字符匹配不了时，则无需BF完全回溯，因为BF回溯后的下一个主子串匹配肯定也是不同的。因此我们应让下次匹配<strong>跳到子串首字符(除首字符位置)下一次出现的位置。</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/kmp%E4%BC%98%E5%8C%961.jpg"
                      alt="kmp"
                ></p>
</li>
</ol>
<ol>
<li><p>“<strong>因为相同所以相同，跳过相同</strong>”：当子串与主串出现不匹配时，靠近不匹配处的若干字符在字符前缀部分出现过，则不应该仅跳到重复字符(下一次出现位置)的首字符，而是跳过包括这一段相同部分。，即应该跳到(新的匹配位置)于后缀部分相同的前缀部分的下一个位置。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/kmp%E4%BC%98%E5%8C%962.jpg"
                      alt="KMP"
                ></p>
<p>此时，next数组的含义就是记录若当前字符出现不匹配，则需下次开始匹配的位置——重复部分的下一个位置的下标</p>
<p>快速</p>
</li>
</ol>
<h2 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h2><h3 id="next数组含义"><a href="#next数组含义" class="headerlink" title="next数组含义"></a>next数组含义</h3><p>k = 子串下标 = 前缀长度</p>
<h3 id="next数组的计算"><a href="#next数组的计算" class="headerlink" title="next数组的计算"></a>next数组的计算</h3><h3 id="next-数组代码实现"><a href="#next-数组代码实现" class="headerlink" title="next 数组代码实现"></a>next 数组代码实现</h3><h1 id="KMP模式匹配算法改进"><a href="#KMP模式匹配算法改进" class="headerlink" title="KMP模式匹配算法改进"></a>KMP模式匹配算法改进</h1><p>记住，一切能用数学公式或字母来形式化的东西，都是为了辅助我们更好的表述，它是无二义的，请不要害怕它。</p>
<p>我们不一定从数学公式中直接理解</p>
]]></content>
      <tags>
        <tag>技术积累</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 第五章 树、森林&amp;与二叉树的转换</title>
    <url>/2020/10/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97&amp;%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<ul>
<li><strong>读物</strong>：<a class="link"   href="https://book.douban.com/subject/6424904/" >《大话数据结构》<i class="fas fa-external-link-alt"></i></a></li>
<li><strong>印次</strong>：2020年5月第25次印刷(2020.5重印)</li>
</ul>
<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><h1 id="二叉树、树、森林之间转换"><a href="#二叉树、树、森林之间转换" class="headerlink" title="二叉树、树、森林之间转换"></a>二叉树、树、森林之间转换</h1><p>树、森林的结构类似复杂多样，不方便设计统一的算法。因此转换为二叉树统一处理</p>
<h2 id="树转换为二叉树树"><a href="#树转换为二叉树树" class="headerlink" title="树转换为二叉树树"></a>树转换为二叉树树</h2><p>“<strong>加兄保子调层次</strong>”</p>
<ol>
<li><strong>加线</strong>：<strong>所有兄弟节点</strong>之间加一条线</li>
<li><strong>去线</strong>：对于树中<strong>每个结点</strong>，<strong>只保留 firstchild</strong>的连线，其余均删除</li>
<li><strong>层次调整</strong>： <ol>
<li>文字概述：以<strong>原树结构</strong>为基准，从根结点开始，<strong>第一个孩子</strong>为根结点的<strong>左孩子</strong>，而其余兄弟结点(以原树结构为基准)均为<strong>这个左孩子的右孩子(孙子…反之一直右下衍生)</strong></li>
<li>图形化理解：从上到下以<strong>原树为基准</strong>每个子树<strong>除第一个孩子</strong>为<strong>左孩子外</strong>，其余均为<strong>这个左孩子的右孩子延续</strong><ul>
<li>红色为根节点</li>
<li>蓝色为根节点下第一个孩子</li>
<li>绿色为<strong>以原树基准</strong>的非首孩子的其他孩子</li>
</ul>
</li>
</ol>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%A0%91%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.gif"
                      alt="树转二叉树"
                ></p>
<h2 id="二叉树转换为树"><a href="#二叉树转换为树" class="headerlink" title="二叉树转换为树"></a>二叉树转换为树</h2><p>完全倒序操作：加兄保子调层次，调层次保子加兄，再逆序，保子(不保子：加次子/加右孩)，加兄(去兄：去右孩子)</p>
<p>“<strong>加子去右调层次</strong>”</p>
<ol>
<li><strong>加线</strong>：若某个左孩子结点存在，则将这个左孩子的所有右孩子结点都与该左孩子的双亲结点相连</li>
<li><strong>去线</strong>：去除所有结点的<strong>右孩子</strong>结点的连线</li>
<li>层次调整：外貌调整</li>
</ol>
<h2 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h2><p>“<strong>森林变树，依次连根</strong>”</p>
<ol>
<li>把森林的<strong>每颗树</strong>都转换为<strong>二叉树</strong></li>
<li>第一颗树不动，其余树依次为上一课树的<strong>根节点的右孩子</strong>。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91.jpg"
                      alt="森林转换为树"
                ></p>
<h2 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h2><p>“<strong>有右即分转森林，无右二叉只变树</strong>”</p>
<p>二叉树有可能转换成一棵树也有可能转换成森林</p>
<ol>
<li>“<strong>有右即分</strong>”：若二叉树<strong>存在右孩子</strong>，则将其分离出来，若<strong>分离后的二叉树</strong>还存在右孩子则继续分离，直至不存在有右孩子的二叉树。</li>
<li>再把每一颗二叉树都转换为树即可。</li>
</ol>
<h1 id="赫夫曼树-哈夫曼-及其应用"><a href="#赫夫曼树-哈夫曼-及其应用" class="headerlink" title="赫夫曼树(哈夫曼)及其应用"></a>赫夫曼树(哈夫曼)及其应用</h1><p>赫夫曼树(哈夫曼)树又称为<strong>最优二叉树</strong></p>
<h2 id="赫夫曼树的优化思想"><a href="#赫夫曼树的优化思想" class="headerlink" title="赫夫曼树的优化思想"></a>赫夫曼树的优化思想</h2><h2 id="赫夫曼树的定义"><a href="#赫夫曼树的定义" class="headerlink" title="赫夫曼树的定义"></a>赫夫曼树的定义</h2><h2 id="赫夫曼树编码"><a href="#赫夫曼树编码" class="headerlink" title="赫夫曼树编码"></a>赫夫曼树编码</h2><ol>
<li><p>树、森林复杂，转换为二叉树处理</p>
<ol>
<li>树转换为二叉树</li>
<li>二叉树转换为树</li>
<li>森林(森林-&gt;树)转换为二叉树</li>
<li>二叉树转换为森林</li>
</ol>
</li>
<li><p>树与森林的遍历：先根、后根。前序，后序</p>
</li>
<li><p>二叉树的应用，赫夫曼树(最优二叉树)</p>
<p>引入：让单一线性的区分结构——&gt;通过权/频率——&gt;用二叉树来体现权的表示，从而实现路径长度上的优化。</p>
<p>而这种路径的优化，在代码执行上缩短总的执行次数。而在存储空间上可以应用在设计长短不等的编码，在通过编码的层面上实现无损的数据压缩(赫夫曼编码)</p>
<ol>
<li>基本概念：路径长度、树的路径长度、带权路径长度</li>
<li>二叉树转换为赫夫曼树(最优二叉树)</li>
<li>赫夫曼编码(赫夫曼编码转换过程)<ol>
<li>材料：字符集，权</li>
<li>画出最优二叉树</li>
<li>左分支代表0，右分支代表1，并实现其前缀编码。</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>技术积累</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 第四章 队列</title>
    <url>/2020/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<ul>
<li><strong>读物</strong>：<a class="link"   href="https://book.douban.com/subject/6424904/" >《大话数据结构》<i class="fas fa-external-link-alt"></i></a></li>
<li><strong>印次</strong>：2020年5月第25次印刷(2020.5重印)</li>
</ul>
<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ol>
<li><strong>队列的定义</strong></li>
<li><strong>队列的抽线数据结构</strong></li>
<li><strong>队列顺序存储结构及其不足</strong></li>
<li><strong>循环队列的顺序存储结构</strong></li>
<li><strong>小结</strong></li>
<li><strong>队列的链式存储结构</strong></li>
<li><strong>总结</strong></li>
</ol>
<h1 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h1><p><strong>队列(queue)：</strong>只允许在<strong>一端</strong>进行<strong>插入</strong>，<strong>另一端</strong>进行<strong>删除</strong>操作的<strong>线性表</strong></p>
<ul>
<li>队列是一种<strong>先进先出(First In First Out，FIFO)</strong>的线性表。(符合生活中的习惯)</li>
<li>允许<strong>插入</strong>的一端称为<strong>队尾</strong>，允许<strong>删除</strong>的一端称为<strong>队头</strong></li>
</ul>
<p>队列的应用十分广泛：如键盘输入到屏幕显示、操作系统、客服系统等</p>
<h1 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADT 队列(Queue)</span><br><span class="line">Data</span><br><span class="line">    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">    InitQueue(*Q):    初始化操作，建立一个空队列Q。</span><br><span class="line">    DestroyQueue(*Q): 若队列Q存在，则销毁它。</span><br><span class="line">    ClearQueue(*Q):   将队列Q清空。</span><br><span class="line">    QueueEmpty(Q):    若队列Q为空，返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br><span class="line">    GetHead(Q, *e):   若队列Q存在且非空，用e返回队列Q的队头元素。</span><br><span class="line">    EnQueue(*Q, e):   若队列Q存在，插入新元素e到队列Q中并成为队尾元素。</span><br><span class="line">    DeQueue(*Q, *e):  删除队列Q中队头元素，并用e返回其值。</span><br><span class="line">    QueueLength(Q):   返回队列Q的元素个数</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>

<h1 id="队列顺序存储结构及其不足"><a href="#队列顺序存储结构及其不足" class="headerlink" title="队列顺序存储结构及其不足"></a>队列顺序存储结构及其不足</h1><h2 id="队列的顺序存储结构设计"><a href="#队列的顺序存储结构设计" class="headerlink" title="队列的顺序存储结构设计"></a>队列的顺序存储结构设计</h2><h3 id="传统定义上的设计"><a href="#传统定义上的设计" class="headerlink" title="传统定义上的设计"></a>传统定义上的设计</h3><ul>
<li>队列<strong>插入</strong>元素<strong>：只需在队尾追加</strong>一个元素即刻，<strong>时间复杂度为O(1)</strong></li>
<li>队列<strong>删除</strong>元素：把下标为0的队头元素删除后，<strong>其余所有元素均需向前移动</strong>,<strong>时间复杂度为O(n)</strong></li>
</ul>
<h3 id="现今队列顺序存储结构设计"><a href="#现今队列顺序存储结构设计" class="headerlink" title="现今队列顺序存储结构设计"></a>现今队列顺序存储结构设计</h3><p>因<strong>队头固定为数组起始下标0，导致删除元素效率低</strong>，O(n)，且避免<strong>只有一个元素时</strong>，队头和队尾<strong>重合</strong>使处理变得麻烦</p>
<ul>
<li>引入<strong>两个指针</strong>，<strong>front</strong>指向<strong>队头元素</strong>，<strong>rear</strong>指向<strong>队尾元素的下一个位置</strong>，此时front = rear表示<strong>空队列</strong></li>
<li>队列<strong>删除元素</strong>时，<strong>直接改变队头front的指向</strong>从而实现删除元素时间复杂度提升至<strong>O(1)</strong></li>
</ul>
<p>队列的顺序存储结构插入与删除元素过程如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%99%AE%E9%80%9A%E9%98%9F%E5%88%97%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"
                      alt="队列顺序存储结构"
                ></p>
<h2 id="队列顺序存储结构的不足"><a href="#队列顺序存储结构的不足" class="headerlink" title="队列顺序存储结构的不足"></a>队列顺序存储结构的不足</h2><p>若在队列未满时曾经通过可移动头指针删除过元素，会导致当rear指针移至数组末端时(表示无法再插入元素时)，数组靠前部分还有空闲空间的<strong>“假溢出”</strong>现象。</p>
<p>配合上述“普通队列插入图示”理解假溢出现象如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E5%81%87%E6%BA%A2%E5%87%BA%E7%8E%B0%E8%B1%A1.png"
                      alt="假溢出"
                ></p>
<p><strong>解决方案</strong>：采用<strong>循环队列</strong>。</p>
<h1 id="循环队列的顺序存储结构"><a href="#循环队列的顺序存储结构" class="headerlink" title="循环队列的顺序存储结构"></a>循环队列的顺序存储结构</h1><h2 id="循环队列的定义"><a href="#循环队列的定义" class="headerlink" title="循环队列的定义"></a>循环队列的定义</h2><p><strong>循环队列</strong>：把队列<strong>头尾相接</strong>的顺序存储结构(实际把<strong>rear</strong>指针变成<strong>可移动指针</strong>)，<strong>后面满了，就从头开始</strong>。</p>
<p>循环队列特性小结：</p>
<ul>
<li><strong>front</strong>指向<strong>队头元素下标</strong>，<strong>rear</strong>指向<strong>队尾元素的下一个位置</strong></li>
<li><strong>front与rear</strong>指针均可<strong>独立循环移动</strong></li>
</ul>
<p>结构定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 循环队列的顺序存储结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	QElemType data[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> front;    	<span class="comment">/* 头指针 */</span></span><br><span class="line">	<span class="keyword">int</span> rear;		<span class="comment">/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>



<p>循环队列连续插入数据图示如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97rear%E6%8C%87%E9%92%88.png"
                      alt="循环队列rear指针"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97rear%E6%8C%87%E9%92%882.png"
                      alt="循环队列"
                ></p>
<p><strong>注意</strong>：最终<strong>队列满</strong>时，<strong>rear == front</strong>，此时与一开始定义<strong> rear == front </strong> 表示<strong>队列为空</strong>的定义重复了。</p>
<p><del><strong>解决方案1</strong>：设置一个标志变量flag，当front == rear，且flag=0时为队列空，当front == rear，且flag=1时为队列满。</del></p>
<p><strong>解决方案2</strong>：</p>
<ul>
<li>预留一个空闲空间表示队列满的状态，即<strong>队列满时，数组中还有一个空闲单元</strong><code>rear + 1 = front</code>  </li>
<li>此时队列<strong>可存储数据量</strong>为 <strong>“ MAXSIZE - 1 ”</strong></li>
</ul>
<p>注意：循环队列的front和rear指针<strong>均可独立循环移动</strong>，因此导致存在<strong>两种队列满的状态</strong>，即<strong>rear &gt; front 与 rear &lt; front 的两种情况</strong>。如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E6%BB%A1%E7%9A%84%E8%AE%BE%E8%AE%A1.png"
                      alt="循环队列满状态"
                ></p>
<ul>
<li><p><strong>显然 rear &gt; front 的情况是不能完全匹配 rear + 1 == front 这个队列满的判定条件</strong></p>
</li>
<li><p>因此<strong>通用的队列满判别条件为</strong>： (QueueSize 为队列最大尺寸)</p>
<p><strong>“ (rear + 1) % QueueSize == front  ”</strong></p>
</li>
<li><p>同理两种rear与front的大小关系决定了<strong>计算队列长度通用公式为</strong>：  </p>
<p><strong>“ (rear - front) + QueueSize % QueueSize ”</strong></p>
</li>
</ul>
<h2 id="循环队列的初始化"><a href="#循环队列的初始化" class="headerlink" title="循环队列的初始化"></a>循环队列的初始化</h2><h3 id="InitQueue"><a href="#InitQueue" class="headerlink" title="InitQueue"></a>InitQueue</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化一个空队列Q */</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue *Q)</span></span>&#123;</span><br><span class="line">	Q-&gt;front=<span class="number">0</span>;</span><br><span class="line">	Q-&gt;rear=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="循环队列入队"><a href="#循环队列入队" class="headerlink" title="循环队列入队"></a>循环队列入队</h2><h3 id="EnQueue"><a href="#EnQueue" class="headerlink" title="EnQueue"></a>EnQueue</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环队列入队操作</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue *Q, QElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MAXSIZE == Q-&gt;front)<span class="comment">//判断队列是否已满</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">	Q-&gt;data[Q-&gt;rear] = e; <span class="comment">//队列，只能通过队尾入队，只操作rear</span></span><br><span class="line">	Q-&gt;rear = (Q-&gt;rear+<span class="number">1</span>) % MAXSIZE; <span class="comment">//然rear指针符合循环队列特点，循环自增归零</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="循环队列出队"><a href="#循环队列出队" class="headerlink" title="循环队列出队"></a>循环队列出队</h3><h3 id="DeQueue"><a href="#DeQueue" class="headerlink" title="DeQueue"></a>DeQueue</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环队列出队操作</span></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue *Q, QElemType *e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Q-&gt;rear == Q-&gt;front)<span class="comment">//判断队列是否为空，空则无法出队</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	*e = Q-&gt;data[Q-&gt;front];<span class="comment">//队列，只能通过队头入队，只操作front</span></span><br><span class="line">	Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MAXSIZE;<span class="comment">//让front指针符合循环队列特点，循环自增归零</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ol>
<li><p>无论入队还是出队操作，都有一句类似的代码<code>Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE</code>，而这总写法是一种通用的<strong>循环自增归零写法</strong>。MAXSIZE控制自增的最大值，也是开始循环的值。</p>
<p><strong>(变量 + 1) % MAXSIZE;</strong> 图示如下：</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E5%BE%AA%E7%8E%AF%E8%87%AA%E5%A2%9E%E5%BD%92%E9%9B%B6%E5%86%99%E6%B3%95.png"
                      alt="循环自增归零"
                ></p>
<ol start="2">
<li>入队和出队的rear与front数值变化都是<strong>独立</strong>的<strong>循环自增</strong>，<strong>互不影响</strong>。**两者唯一有交集(关系)**部分已经解决(判读队列空与满的多种情况)</li>
</ol>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><h2 id="队列的顺序存储结构："><a href="#队列的顺序存储结构：" class="headerlink" title="队列的顺序存储结构："></a>队列的顺序存储结构：</h2><ol>
<li><p><strong>队列</strong>：</p>
<ul>
<li><p>只能通过<strong>队尾入队</strong>，入队<strong>只操作rear</strong>，只能通过<strong>队头入队</strong>，入队<strong>只操作front</strong></p>
</li>
<li><p>front可移动化，提高删除效率</p>
</li>
</ul>
</li>
<li><p><strong>循环队列</strong>：</p>
<ul>
<li>front与rear分别独立<strong>循环移动</strong>，解决“<strong>假溢出</strong>”现象</li>
<li>队列满条件：<ul>
<li><strong> (rear + 1) % QueueSize == front </strong></li>
<li>注意：此时队列<strong>可存储数据量</strong>为 <strong>MAXSIZE - 1</strong></li>
</ul>
</li>
<li>队列长度通用公式：<strong> (rear - front) + QueueSize % QueueSize </strong></li>
<li>循环自增归零写法：<strong>(变量 + 1) % MAXSIZE;</strong></li>
</ul>
</li>
</ol>
<h1 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>队列的链式存储结构，相当于<strong>只能尾进头出的单链表</strong>，简称<strong>链队列</strong></p>
<ul>
<li><strong>队头</strong>指针(<strong>front</strong>)指向<strong>头结点(不是头指针！)</strong></li>
<li><strong>队尾</strong>指针(<strong>rear</strong>)指向<strong>尾指针</strong></li>
<li>front和rear都指向<strong>头结点</strong>，则表示<strong>空队列</strong></li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/队列链式存储结构空队列.png"
                      alt="空队列" style="zoom: 67%;" /
                >

<h2 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类似栈的链式存储结果设计</span></span><br><span class="line"><span class="comment">//结点结构：QueuePtr</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line">	QElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Qnode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表结构：LinkQueue</span></span><br><span class="line"><span class="comment">//LinkQueue相当于一个front与rear结点管理器，存储这两个变量的指向</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	QueuePtr front, rear;<span class="comment">/*队头队尾指针*/</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>

<p>LinkQueue相当于一个front与rear结点管理器，存储这两个变量的指向，front与rear独立工作。<strong>在理解上的结构关系</strong>(不完全是实际结构)如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E9%98%9F%E5%88%97%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84(%E7%90%86%E8%A7%A3%E4%B8%8A).png"
                      alt="队列链式存储"
                ></p>
<h2 id="队列初始化"><a href="#队列初始化" class="headerlink" title="队列初始化"></a>队列初始化</h2><p>队列链式存储结构初始化关键在于：<strong>创建一个头结点</strong>，并且front 与 rear <strong>都指向</strong>头结点(表示队列为空)，并且把<strong>头结点的指针域</strong>赋值为<strong>NULL</strong></p>
<p><strong>InitQueue</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*构建一个空列表Q*/</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue *Q)</span></span>&#123;</span><br><span class="line">   Q-&gt;front = Q-&gt;rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));<span class="comment">//创建一个头结点并同时指向fornt与rear</span></span><br><span class="line">   <span class="keyword">if</span> (!Q-&gt;front)<span class="comment">//申请失败则向系统报出异常</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">   -&gt;front-&gt;next = <span class="literal">NULL</span>;<span class="comment">//为头结点指针域赋值NULL</span></span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="初始化到数据入队过程"><a href="#初始化到数据入队过程" class="headerlink" title="初始化到数据入队过程"></a>初始化到数据入队过程</h2><p>队列的链式存储结构初始化后(空队列)到数据插入的过程理解如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E9%98%9F%E5%88%97%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A51.png"
                      alt="队列插入操作"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E9%98%9F%E5%88%97%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A52.png"
                     
                ></p>
<h2 id="EnQueue-1"><a href="#EnQueue-1" class="headerlink" title="EnQueue"></a>EnQueue</h2><p><strong>思路</strong>：</p>
<ol>
<li>链式存储结构一般不会满</li>
<li>创建新结点</li>
<li>为新结点的数据域和指针域赋值(<strong>插入的总是队尾，所以指针域为NULL</strong>)</li>
<li><strong>把新结点(尾结点)s成为原队尾结点的后继结点</strong></li>
<li>修改链表结构LinkQueue的rear指向，返回OK即可</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//入队操作</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue *Q, QElemType e)</span> </span>&#123;</span><br><span class="line">	QueuePtr s = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));	<span class="comment">//创建新结点</span></span><br><span class="line">	<span class="keyword">if</span> (!s)		<span class="comment">//假如内存申请失败</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);	<span class="comment">//非正常退出</span></span><br><span class="line"></span><br><span class="line">	s-&gt;data = e;	<span class="comment">//为新结点的数据域和指针域赋值</span></span><br><span class="line">	s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	Q-&gt;rear-&gt;next = s;	<span class="comment">//把新结点/尾结点s成为给原队尾结点的后继结点</span></span><br><span class="line">	Q-&gt;rear = s;	<span class="comment">//修改链表结构LinkQueue的rear指向</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>exit()</strong> 函数：结束当前进程/当前程序/，在整个程序中，只要调用 exit ，就结束。</p>
<ul>
<li><strong>exit(1)</strong>表示进程<strong>异常退出</strong></li>
<li><strong>exit(0)</strong>表示进程<strong>正常退出</strong></li>
</ul>
<h2 id="DeQueue-1"><a href="#DeQueue-1" class="headerlink" title="DeQueue"></a>DeQueue</h2><p><strong>关键点</strong>：</p>
<ol>
<li>front指针不是直接指向数据结点，而是<strong>指向头结点</strong>，所以<strong>待删除的结点</strong>应为<code>Q-&gt;front-&gt;next</code></li>
<li>删除思路与<strong>单链表的删除操作思路一致</strong></li>
<li>若<strong>出队的结点</strong>刚好是<strong>最后一个结点</strong>，需要重<strong>“置零”</strong>一下，否则s-&gt;next == NULL，而且rear会失去指向。</li>
</ol>
<p><strong>非最后一个结点出队过程示意如下</strong>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/DeQueue%E9%9D%9E%E6%9C%80%E5%90%8E%E7%BB%93%E7%82%B9.png"
                      alt="队列出队"
                ></p>
<p><strong>最后一个结点出队过程示意如下</strong>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/DeQueue%E6%9C%80%E5%90%8E%E7%BB%93%E7%82%B9.png"
                      alt="队列出队"
                ></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */</span></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue *Q,QElemType *e)</span></span>&#123;</span><br><span class="line">	QueuePtr p;</span><br><span class="line">	<span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	p=Q-&gt;front-&gt;next;		<span class="comment">/* 将欲删除的队头结点暂存给p*/</span></span><br><span class="line">	*e=p-&gt;data;				<span class="comment">/* 将欲删除的队头结点的值赋值给e */</span></span><br><span class="line">	Q-&gt;front-&gt;next=p-&gt;next;<span class="comment">/* 将原队头结点的后继p-&gt;next赋值给头结点后继*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(Q-&gt;rear==p)		<span class="comment">/* 若队头就是队尾，则删除后将rear指向头结点 */</span></span><br><span class="line">		Q-&gt;rear=Q-&gt;front;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>从基本<strong>单次操作</strong>中，循环队列和链队列时间上<strong>都是常数时间</strong>O(1)</li>
<li>若<strong>出队入队频繁</strong>，链队列会因每次申请和释放结点存在<strong>额外一些时间开销</strong>，与循环队列相比有<strong>细微差距</strong></li>
<li>在<strong>空间上</strong>，<strong>循环队列</strong>会因长度的固定限制，造成<strong>空间上的浪费</strong>。链队列则不存在</li>
</ul>
<p><strong>总的来说</strong>：<strong>可确定长度</strong>优先选择<strong>循环队列</strong>，若无法预估则用<strong>链队列</strong>。</p>
]]></content>
      <tags>
        <tag>技术积累</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 第四章 栈</title>
    <url>/2020/09/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%A0%88/</url>
    <content><![CDATA[<ul>
<li><strong>读物</strong>：<a class="link"   href="https://book.douban.com/subject/6424904/" >《大话数据结构》<i class="fas fa-external-link-alt"></i></a></li>
<li><strong>印次</strong>：2020年5月第25次印刷(2020.5重印)</li>
</ul>
<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ol>
<li><strong>栈的定义</strong></li>
<li><strong>栈的抽线数据类型</strong></li>
<li><strong>栈的顺序存储结构</strong></li>
<li><strong>栈的链式存储结构</strong></li>
<li><strong>小结</strong></li>
<li><strong>栈的应用</strong></li>
</ol>
<h1 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h1><p><strong>栈的定义如下：</strong></p>
<ol>
<li>栈(stack)如同<strong>弹夹</strong>一样，<strong>先进后出，后进先出</strong>(Last In First Out，<strong>LIFO</strong>)的特性。</li>
<li>栈而且是限定<strong>仅在表尾(栈顶)</strong>进行插入和删除的<strong>线性表</strong>。</li>
</ol>
<p>相关术语如下：</p>
<ul>
<li><strong>栈顶(top)</strong>：允许插入和删除的一端</li>
<li><strong>栈底(bottom)</strong>：相对于栈顶的另一端</li>
<li><strong>空栈</strong>：不含任何数据元素的栈</li>
<li><strong>进栈/压栈/入栈(push)</strong>：栈的元素插入操作</li>
<li><strong>出栈/弹栈(pop)</strong>：栈的元素删除操作</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89.png"
                      alt="栈的定义"
                ></p>
<p><del>进栈出栈变化形式</del></p>
<h1 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADT 栈(<span class="built_in">stack</span>)</span><br><span class="line">Data</span><br><span class="line">    同线性表。元素具有相同的类型，相邻元素具有前驱和后继的关系。</span><br><span class="line">Operation</span><br><span class="line">    InitStack(*S)：初始化操作，建立一个空栈S</span><br><span class="line">    DestroyStack(*S)：若栈存在，则销毁它</span><br><span class="line">    ClearStack(*S)：将栈清空</span><br><span class="line">    StackEmpty(S)：若栈为空，返回<span class="literal">true</span>，否则返回<span class="literal">false</span></span><br><span class="line">    GetTop(*S,e)：若栈存在且非空，用e返回S的栈顶元素</span><br><span class="line">    Push(*S,e)：若栈S存在，插入新元素e到栈S中，并成为栈顶元素</span><br><span class="line">    Pop(*S,*e)：删除栈S中的顶栈元素，并用e返回其值</span><br><span class="line">    StackLength(S)：返回栈S的元素个数</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>



<h1 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h1><h2 id="顺序栈的结构定义"><a href="#顺序栈的结构定义" class="headerlink" title="顺序栈的结构定义"></a>顺序栈的结构定义</h2><ul>
<li>栈的顺序存储结构也称为 “<strong>顺序栈</strong>”</li>
<li>通常用数组<strong>下标为0</strong>的一端作为<strong>栈底</strong>，因为变化最小</li>
<li>定义一个<strong>top</strong>变量存储<strong>栈顶元素所在的位置</strong>，top &lt; StackSize，<ul>
<li>栈存在一个元素时(<strong>对应数组下标为0</strong>)，<strong>top = 0</strong></li>
<li>当<strong>top = -1</strong> 表示为<strong>空栈</strong></li>
</ul>
</li>
</ul>
<p>顺序栈的结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SElemType;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    SElemType data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> top;	<span class="comment">//记录栈顶下标</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>

<h2 id="进栈-amp-出栈操作"><a href="#进栈-amp-出栈操作" class="headerlink" title="进栈&amp;出栈操作"></a>进栈&amp;出栈操作</h2><h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><p><strong>思路</strong>：</p>
<ul>
<li>若栈已满，退出</li>
<li>修改栈顶top值，+1，并且作为下标存入数据e</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack *S,SElemType e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S-&gt;top == MAXSIZE <span class="number">-1</span>) <span class="comment">/* 栈满 */</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">        </span><br><span class="line">    	S-&gt;top++;				<span class="comment">/* 栈顶指针增加一 */</span></span><br><span class="line">        S-&gt;data[S-&gt;top]=e;  <span class="comment">/* 将新插入元素赋值给栈顶空间 */</span></span><br><span class="line">    	<span class="comment">//这两句可写成：S-&gt;data[++S-&gt;top] = *e;</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p><strong>思路</strong>：</p>
<ul>
<li>若栈为空，则无元素出栈</li>
<li>以当前top为数组下标取出值并赋值给e</li>
<li>top值自减1</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack *S,SElemType *e)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">        *e=S-&gt;data[S-&gt;top];	<span class="comment">/* 将要删除的栈顶元素赋值给e */</span></span><br><span class="line">        S-&gt;top--;				<span class="comment">/* 栈顶指针减一 */</span></span><br><span class="line">    	<span class="comment">//这两句同样可写成：*e = S-&gt;data[S-&gt;top--];</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li>通常一个程序中要<strong>用到多个栈</strong>，为了不发生上溢错误，就必须给每个栈分配一个<strong>足够大的存储空间</strong>。但实际中，<strong>很难准确地估计</strong>，若每个栈都分配过大的存储空间，势必造成系统<strong>空间紧张</strong>；若让<strong>多个栈共用</strong>一个足够大的连续存储空间，则可利用栈的动态特性使他们的存储空间互补。(<strong>关键字：’’多个栈’’</strong>)</li>
<li>事实上，使用这种数据结构，通常是<strong>两个栈</strong>的空间需求有<strong>相反关系</strong>，即<strong>一个栈增长时，另一个栈在缩短</strong>的情况。这样使用这种结构的<strong>意义更大</strong>。(如买卖股票，买入必定存在卖出等应用场景)</li>
</ul>
<h3 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h3><ul>
<li>前提是，两个<strong>栈的数据类型</strong>必须<strong>相同</strong></li>
<li>让其中一个栈的<strong>栈底</strong>为<strong>数组下标0（-1）</strong>，另一个<strong>栈底</strong>为<strong>n-1（n）</strong> (n表示数组的长度)</li>
<li>关键思路：<strong>两个栈是在数组的两端，向中间靠拢</strong>，</li>
</ul>
<h3 id="两盏共享空间结构"><a href="#两盏共享空间结构" class="headerlink" title="两盏共享空间结构"></a>两盏共享空间结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*两盏共享空间结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	SElemType data[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> top1;	<span class="comment">/*栈1 栈顶指针 */</span></span><br><span class="line">	<span class="keyword">int</span> top2;	<span class="comment">/*栈2 栈顶指针 */</span></span><br><span class="line">&#125;SqDoubleStack;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="栈内元素存储状态"><a href="#栈内元素存储状态" class="headerlink" title="栈内元素存储状态"></a>栈内元素存储状态</h3><ol>
<li><strong>空栈</strong>：top<strong>1</strong> = <strong>-1</strong>，top<strong>2</strong> = <strong>MAXSIZE</strong></li>
<li><strong>栈满</strong>：<ol>
<li><strong>往右靠拢</strong>：top<strong>1</strong> = <strong>n - 1</strong>，top<strong>2</strong> = <strong>n -1</strong></li>
<li><strong>往左靠拢</strong>：top<strong>2</strong> = <strong>0</strong>，top<strong>1</strong> = <strong>0</strong></li>
<li><strong>向中间靠拢</strong>：top<strong>1</strong>+ <strong>1</strong>= top<strong>2</strong></li>
</ol>
</li>
</ol>
<p>通常使用<strong><code>top1 + 1 = top2</code></strong>为<strong>栈满的判别条件</strong>。</p>
<h3 id="共享空间下的进栈-amp-出栈操作"><a href="#共享空间下的进栈-amp-出栈操作" class="headerlink" title="共享空间下的进栈&amp;出栈操作"></a>共享空间下的进栈&amp;出栈操作</h3><p>对于两栈共享空间的push与pop方法，除了顺序栈进出栈原有的两个参数外，<strong>还需要栈号参数stackNumber</strong>，用于判断操作的栈对象。</p>
<h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p><strong>思路</strong>：</p>
<ul>
<li>判断栈的是否已经存满</li>
<li>分别执行类同顺序栈的进栈代码(<strong>注意：处于尾部栈的下标操作是相反的</strong>)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqDoubleStack *S,SElemType e,<span class="keyword">int</span> stackNumber)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top1+<span class="number">1</span>==S-&gt;top2)	<span class="comment">/* 栈已满，不能再push新元素了 */</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;	</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (stackNumber==<span class="number">1</span>)			<span class="comment">/* 栈1有元素进栈 */</span></span><br><span class="line">        S-&gt;data[++S-&gt;top1]=e; <span class="comment">/* 若是栈1则先top1+1后给数组元素赋值。 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (stackNumber==<span class="number">2</span>)	<span class="comment">/* 栈2有元素进栈 */</span></span><br><span class="line">        S-&gt;data[--S-&gt;top2]=e; <span class="comment">/* 若是栈2则先top2-1后给数组元素赋值。 */</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pop-1"><a href="#pop-1" class="headerlink" title="pop"></a>pop</h4><p><strong>思路</strong>：</p>
<ul>
<li>首先通过stackNumber分别分支处理</li>
<li>判断被选中栈的是否为空</li>
<li>别执行类同顺序栈的出栈代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqDoubleStack *S,SElemType *e,<span class="keyword">int</span> stackNumber)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (stackNumber==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S-&gt;top1==<span class="number">-1</span>) </span><br><span class="line">            <span class="keyword">return</span> ERROR; <span class="comment">/* 说明栈1已经是空栈，溢出 */</span></span><br><span class="line">        *e=S-&gt;data[S-&gt;top1--]; <span class="comment">/* 将栈1的栈顶元素出栈 */</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (stackNumber==<span class="number">2</span>)&#123; </span><br><span class="line">        <span class="keyword">if</span> (S-&gt;top2==MAXSIZE) </span><br><span class="line">            <span class="keyword">return</span> ERROR; <span class="comment">/* 说明栈2已经是空栈，溢出 */</span></span><br><span class="line">        *e=S-&gt;data[S-&gt;top2++]; <span class="comment">/* 将栈2的栈顶元素出栈 */</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>可知顺序栈的<strong>push和pop</strong>操作时间复杂度均为<strong>O(1)</strong></p>
<h1 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h1><p>栈的链式存储结构，简称“<strong>链栈</strong>”</p>
<ul>
<li>链栈没有头结点，或者说是把<strong>头结点与栈顶指针</strong>融为一体</li>
<li>对于链栈来说，基本<strong>不存在栈满</strong>的情况(除非内存耗尽/死机)</li>
<li>栈顶指针(<strong>top</strong>) = <strong>NULL</strong>时，表示<strong>空栈</strong></li>
</ul>
<p>栈的链式存储结构定义如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89.jpg"
                      alt="栈的链式存储结构"
                ></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类似单链表的结构定义：LinkStackPtr(Ptr，Pointer Recod 表指针含义)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>&#123;</span></span><br><span class="line"></span><br><span class="line">	SElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;StackNode,*LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再创建一个top结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span> &#123;</span></span><br><span class="line">	LinkStackPtr top;<span class="comment">//每一个结点是否被定义为头结点</span></span><br><span class="line">	<span class="keyword">int</span> count;<span class="comment">//链的长度</span></span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure>

<h2 id="链栈的进栈操作"><a href="#链栈的进栈操作" class="headerlink" title="链栈的进栈操作"></a>链栈的进栈操作</h2><p><strong>思路</strong>：</p>
<ul>
<li>链式结构一般不用考虑插入是否已满</li>
<li>创建新结点</li>
<li>通过“<strong>头插法</strong>”(让首结点成为新结点的next，然后新结点成为首结点)即新元素只与头结点(栈顶/top)交换</li>
<li>修改count数值</li>
<li>返回OK</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack *S,SElemType e)</span></span>&#123;</span><br><span class="line">    LinkStackPtr s=(LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode)); </span><br><span class="line">    s-&gt;data=e; </span><br><span class="line">    s-&gt;next=S-&gt;top;	<span class="comment">/* 把当前的栈顶元素赋值给新结点的直接后继*/</span></span><br><span class="line">    S-&gt;top=s;         <span class="comment">/* 将新的结点s赋值给栈顶指针，见图中② */</span></span><br><span class="line">    S-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="链栈的出栈操作"><a href="#链栈的出栈操作" class="headerlink" title="链栈的出栈操作"></a>链栈的出栈操作</h2><p><strong>思路</strong>：</p>
<ul>
<li>若栈为空，则无元素可出栈</li>
<li>创建暂存结点变量</li>
<li>改变top指向，释放暂存结点</li>
<li>返回OK</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 若栈S为空栈，则返回TRUE，否则返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(LinkStack S)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (S.count==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack *S,SElemType *e)</span></span>&#123; </span><br><span class="line">    LinkStackPtr p;</span><br><span class="line">    <span class="keyword">if</span>(StackEmpty(*S))</span><br><span class="line">    	<span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">	LinkStackPtr p = S-&gt;top;	<span class="comment">//将栈顶结点赋值给p</span></span><br><span class="line">	*e = p-&gt;data;	<span class="comment">//返回即将出栈元素值</span></span><br><span class="line">	S-&gt;top = p-&gt;next;<span class="comment">//修改top结点指向</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(p);	<span class="comment">//释放结点</span></span><br><span class="line">	S-&gt;count--;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>顺序栈和链栈的时间复杂度<strong>都是O(1)</strong></li>
<li>顺序栈在元素定位上相比链栈更<strong>节省内存开销</strong>，<strong>但需事先确定一个固定长度</strong></li>
<li>链栈则<strong>无长度限制</strong></li>
</ul>
<hr>
<ul>
<li>因此，如果栈的使用过程中<strong>元素不可预料，有时很小，有时很大</strong>，那么最好使用<strong>栈链</strong></li>
<li>反之，如果它的<strong>变化在可控范围内</strong>，使用<strong>顺序栈</strong>会更好一些</li>
</ul>
<h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>栈的引入主要是<strong>将问题划分了不同的关注层次，使得思考范围进一步缩小，更加聚焦于我们解决问题的核心。从而简化了程序设计的问题</strong>，反之，使用传统“万金油”数组下标操作，则会使我们分散精力去处理一些琐碎的细节问题，反而掩盖了问题的本质。</p>
<h2 id="栈的应用——递归"><a href="#栈的应用——递归" class="headerlink" title="栈的应用——递归"></a>栈的应用——递归</h2><h3 id="递归的概念"><a href="#递归的概念" class="headerlink" title="递归的概念"></a>递归的概念</h3><p>递归函数：<strong>直接调用自己或通过一系列调用语句间接地调用自己的函数</strong></p>
<h3 id="斐波那契数列的实现"><a href="#斐波那契数列的实现" class="headerlink" title="斐波那契数列的实现"></a>斐波那契数列的实现</h3><p>斐波那契数列(<strong>Fibonacci</strong>)：如 “<strong>1，1，2，3，5，8，13…</strong>” 这种<strong>前面相邻两项之和，构成了后一项</strong>的序列。</p>
<h4 id="常规迭代方法"><a href="#常规迭代方法" class="headerlink" title="常规迭代方法"></a>常规迭代方法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*常规的迭代办法实现前40位Fibonacci数列 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fibonacci_Common</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> f[<span class="number">40</span>];</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, f[<span class="number">0</span>]);<span class="comment">//输出首个Fibonacci数字</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, f[<span class="number">1</span>]);<span class="comment">//输出第二个Fibonacci数字</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">		f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, f[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归方式实现"><a href="#递归方式实现" class="headerlink" title="递归方式实现"></a>递归方式实现</h4><ol>
<li>从实际存在<strong>递归/重复</strong>规律的实际问题出发<ul>
<li>递归的核心在于：每一次的结果都是需要通过<strong>函数调用</strong>的方式<strong>回退到规律的起点</strong></li>
<li>通过<strong>函数return</strong>的自然机制<strong>递归</strong>出每一次的结果</li>
</ul>
</li>
<li>将实际问题的递归规律<strong>通过数学函数表示</strong>出来(完成递归函数的百分之80)</li>
<li>将数学函数<strong>通过代码</strong>的形式表达出来</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E9%80%92%E5%BD%92%E7%9A%84%E5%88%86%E6%9E%90.png"
                      alt="递归"
                ></p>
<p>通过递归的方式实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*斐波那契的递归函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fbi</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( i &lt; <span class="number">2</span> )</span><br><span class="line">		<span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">return</span> Fbi(i - <span class="number">1</span>) + Fbi(i - <span class="number">2</span>);  <span class="comment">/* 这里Fbi就是函数自己，等于在调用自己 */</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">40</span>;i++)  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, Fbi(i));  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>递归和迭代的区别</strong></p>
<ol>
<li>递归：递归使用<strong>选择结构</strong><ul>
<li><strong>优点</strong>：递归能使<strong>程序结构更清晰，更简洁、容易理解，减少读代码时间</strong></li>
<li><strong>缺点</strong>：大量的递归调用回建立函数的副本，<strong>耗费大量的时间和内存</strong></li>
</ul>
</li>
<li>迭代：迭代使用<strong>循环结构</strong><ul>
<li><strong>优点</strong>：迭代<strong>无需反复调用函数和占用额外内存</strong></li>
<li><strong>缺点</strong>：代码复杂，程序结构不利于代码的阅读</li>
</ul>
</li>
</ol>
<h3 id="栈在递归里的应用"><a href="#栈在递归里的应用" class="headerlink" title="栈在递归里的应用"></a>栈在递归里的应用</h3><p>递归函数的执行特点是：</p>
<ul>
<li>“<strong>先回退(前行)，后递归(退回)</strong>”即退回和前行两个阶段。而且这两个执行阶段互为<strong>逆序</strong></li>
<li>在<strong>递归(退回)</strong>的过程中，需要不断执行且<strong>恢复前行过程中存储起来的某些数据</strong></li>
</ul>
<p>对于这种<strong>先不断前行执行，后又以其逆序的方式恢复这些数据</strong>的数据结构，<strong>符合栈这样的特点</strong>。因此底层的<strong>编译器</strong>常使用<strong>栈实现函数的递归操作</strong>。</p>
<blockquote>
<p>简单的说，就是在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。</p>
<p>当然，对于现在的高级语言，这样的递归问题是不需要用户来管理这个栈的，一切都由系统代劳了。</p>
</blockquote>
<h2 id="栈的应用——四则运算表达式求值"><a href="#栈的应用——四则运算表达式求值" class="headerlink" title="栈的应用——四则运算表达式求值"></a>栈的应用——四则运算表达式求值</h2><h3 id="后缀表达式-逆波兰-法定义"><a href="#后缀表达式-逆波兰-法定义" class="headerlink" title="后缀表达式(逆波兰)法定义"></a>后缀表达式(逆波兰)法定义</h3><ul>
<li><p><strong>中缀表达式</strong>：形如 <strong>“ 9 + (3 - 1) X 3 + 10 ÷ 2 ”</strong> 标准的四则运算表达式，<strong>所有运算符号</strong>都在两数字<strong>中间</strong>。</p>
<blockquote>
<p>对于计算机来说，中缀表达式这种具有括号，乘除加减的复杂四则运算，计算机是不能马上识别出真确的运算顺序，而对于计算机如何实现数学表达式的求职。提出了一种新的表达法——<strong>后缀表达法</strong>。  </p>
</blockquote>
</li>
<li><p><strong>后缀表达法(逆波兰)(Reverse Polish Notation，RPN)</strong>：是一种<strong>不需要括号</strong>,<strong>所有符号</strong>都是在要运算数字的<strong>后面</strong>出现。    </p>
<p>如： <strong>“ 9 + (3 - 1) X 3 + 10 ÷ 2 ”</strong>的后缀表达式为， <strong>“ 9 3 1 - 3 *  + 10 2 / + ”</strong></p>
</li>
</ul>
<h3 id="栈的应用——中缀表达式转后缀表达式"><a href="#栈的应用——中缀表达式转后缀表达式" class="headerlink" title="栈的应用——中缀表达式转后缀表达式"></a>栈的应用——中缀表达式转后缀表达式</h3><p><strong>核心</strong>：栈是用来进出运算的<strong>符号</strong></p>
<ul>
<li><strong>数字直接输出</strong></li>
<li><strong>入栈</strong>：<ul>
<li><strong>未匹配的左括号</strong>，<strong>优先级高</strong>于栈顶符号</li>
<li>低优先级出栈机制结束后再进栈</li>
</ul>
</li>
<li><strong>出栈</strong>：<ul>
<li><strong>右括号</strong>，出栈到与之匹配的左括号为止</li>
<li><strong>低优先级</strong>符号出栈直至有比原顶栈符号优先级更低的为止，最后再将其低优先级符号入栈</li>
<li>中缀表达式<strong>处理完毕</strong>，则输出栈内剩下的所有符号</li>
</ul>
</li>
<li><strong>注意：” ( ) “括号参与出入栈，但不表示在表达式中</strong></li>
</ul>
<blockquote>
<p>具体推导的图示过程，可查看本读物 p108~p110</p>
</blockquote>
<h3 id="栈的应用——后缀表达式的计算"><a href="#栈的应用——后缀表达式的计算" class="headerlink" title="栈的应用——后缀表达式的计算"></a>栈的应用——后缀表达式的计算</h3><p><strong>核心</strong>：栈是用来进出运算的<strong>数字</strong></p>
<p>后缀表达式在计算机中的具体运算规则如下：</p>
<ol>
<li>从<strong>左到右</strong>遍历表达式的每个<strong>数字和符号</strong></li>
<li>遇到<strong>数字就进栈</strong></li>
<li>遇到<strong>符号</strong>就把处于<strong>栈顶的两个数字出栈</strong>，进行运算。把<strong>运算结构进栈</strong></li>
<li>直至处理完毕得到最终结果为止</li>
</ol>
<blockquote>
<p>具体推导的图示过程，可查看本读物 p106~p108</p>
</blockquote>
]]></content>
      <tags>
        <tag>技术积累</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法积累</title>
    <url>/2020/10/22/%E7%AE%97%E6%B3%95%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="递增减序"><a href="#递增减序" class="headerlink" title="递增减序"></a>递增减序</h3><ol>
<li>冒泡排序</li>
<li>选择法</li>
</ol>
<h3 id="逆置"><a href="#逆置" class="headerlink" title="逆置"></a>逆置</h3><ol>
<li>头尾交换</li>
</ol>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h3><ol>
<li>暂存变量挨个比较</li>
</ol>
<h3 id="找子序列"><a href="#找子序列" class="headerlink" title="找子序列"></a>找子序列</h3><ol>
<li>BF算法思维：第二章线性表P67-8</li>
<li>KMP算法</li>
</ol>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="删除所有指定数值O-n"><a href="#删除所有指定数值O-n" class="headerlink" title="删除所有指定数值O(n)"></a>删除所有指定数值O(n)</h3><ol>
<li><p>单数组就地过滤重塑：第二章线性表P66~P67(2,11)</p>
<p>题目：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">伪代码：</span></span><br><span class="line"><span class="comment">	1.用k记录顺序表中不等于x的元素个数，即需要保存的元素个数，</span></span><br><span class="line"><span class="comment">	2.边扫描L边统计k，并将不等于x的元素放在L.data[k]中，最后修改L的长度。</span></span><br><span class="line"><span class="comment">	时间复杂度：O(n)，空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">函数说明：</span></span><br><span class="line"><span class="comment">	功能：删除顺序表所有指定的数值</span></span><br><span class="line"><span class="comment">	SeqList&lt;DataType&gt; *L : 顺序表指针变量</span></span><br><span class="line"><span class="comment">	int x : 删除数值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">deleteAll</span><span class="params">(SeqList&lt;DataType&gt; *L, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, k = <span class="number">0</span>; <span class="comment">//k用于数组重组的下标变量(新下标)</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L-&gt;length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (L-&gt;data[i] != x) &#123; <span class="comment">//非条件值，非过滤参与重组</span></span><br><span class="line">			L-&gt;data[k] = L-&gt;data[i];</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;length = k;<span class="comment">//修改顺序表长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><h2 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三个数num1，num2，num3，通过if-else结构从小到大排序，</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">伪代码：</span></span><br><span class="line"><span class="comment">	1. 先比较两个数，如num1 &gt; num2</span></span><br><span class="line"><span class="comment">	2. 若num1 &gt; num2，则num3的位置只能在 小__num2__num1__大</span></span><br><span class="line"><span class="comment">		三个下划线之中。</span></span><br><span class="line"><span class="comment">		2.1 若num3比最大(num1)的还大，则在最右(最大)，若比最小的还小(num2)</span></span><br><span class="line"><span class="comment">			则在最左边(最小)，否则，else情况就在中间</span></span><br><span class="line"><span class="comment">	3. 若num2 &gt; num1，则num3的位置只能在 小__num1__num2__大，后同理上</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BranchTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num1 = -<span class="number">193</span>,num2 = -<span class="number">23</span>,num3 = <span class="number">221</span>;</span><br><span class="line">		<span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">			<span class="keyword">if</span>(num3 &gt; num1)&#123;</span><br><span class="line">				System.out.println(num2 + <span class="string">&quot;, &quot;</span> + num1 + <span class="string">&quot;, &quot;</span> + num3);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num3 &lt; num2)&#123;</span><br><span class="line">				System.out.println(num3 + <span class="string">&quot;, &quot;</span> + num2 + <span class="string">&quot;, &quot;</span> + num1);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				System.out.println(num2 + <span class="string">&quot;, &quot;</span> + num3 + <span class="string">&quot;, &quot;</span> + num1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(num3 &gt; num2)&#123;</span><br><span class="line">				System.out.println(num1 + <span class="string">&quot;, &quot;</span> + num2 + <span class="string">&quot;, &quot;</span> + num3);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num3 &lt; num1)&#123;</span><br><span class="line">				System.out.println(num3 + <span class="string">&quot;, &quot;</span> + num1 + <span class="string">&quot;, &quot;</span> + num2);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				System.out.println(num1 + <span class="string">&quot;, &quot;</span> + num3 + <span class="string">&quot;, &quot;</span> + num2);</span><br><span class="line">			&#125;		</span><br><span class="line">		&#125;				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="逆置O-n"><a href="#逆置O-n" class="headerlink" title="逆置O(n)"></a>逆置O(n)</h3><ol>
<li><p>头插法：</p>
<p>凡会在操作过程是失去(链接/追踪)，可以用变量追随暂存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">伪代码：</span></span><br><span class="line"><span class="comment">	1. 设定两个工作指针(用于遍历指针、用于记录遍历指针下一个指针的指针)</span></span><br><span class="line"><span class="comment">	2. 通过遍历指针遍历每一个指针，将遍历到指针通过头插法的形式重新生成链表实现逆序</span></span><br><span class="line"><span class="comment">	3. 在 2. 操作执行头插法之前需要先记录以下即将取出用于插入结点的下一个结点，否则会失去连接</span></span><br><span class="line"><span class="comment">	时间复杂度：O(n)，空间复杂度：O(1);</span></span><br><span class="line"><span class="comment">函数说明</span></span><br><span class="line"><span class="comment">	LinkList&lt;DataType&gt; *L : 单链表指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseLinkList</span><span class="params">(LinkList&lt;DataType&gt; *L)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	Node&lt;DataType&gt; *p, *q;</span><br><span class="line">	p = q = L-&gt;first-&gt;next;</span><br><span class="line"></span><br><span class="line">	L-&gt;first-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">while</span> (p!= <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		q = p;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">		q-&gt;next = L-&gt;first-&gt;next;</span><br><span class="line">		L-&gt;first-&gt;next = q;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="递增减输出并释放"><a href="#递增减输出并释放" class="headerlink" title="递增减输出并释放"></a>递增减输出并释放</h3><ol>
<li>重复使用“暂存变量挨个比较”</li>
</ol>
<h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><h2 id="排序-2"><a href="#排序-2" class="headerlink" title="排序"></a>排序</h2><h2 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h2><h3 id="对称性判断"><a href="#对称性判断" class="headerlink" title="对称性判断"></a>对称性判断</h3><ol>
<li><p>头尾同步相近判断，各自到达头节点结束</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">伪代码：</span></span><br><span class="line"><span class="comment">	1. 创建两个工作指针，head指向第一个结点，rear指向尾部结点</span></span><br><span class="line"><span class="comment">	2. 头尾向中间靠拢判断是否相等</span></span><br><span class="line"><span class="comment">	3. 两个指针都移置头结点表示允许结束(兼容奇偶数量对称判断)</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">函数说明：</span></span><br><span class="line"><span class="comment">	CDulLinkList&lt;DataType&gt; *L : 循环双链表指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(CDulLinkList&lt;DataType&gt; *L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	DulNode&lt;DataType&gt; *head, *rear;</span><br><span class="line">	head = L-&gt;first-&gt;next;</span><br><span class="line">	rear = L-&gt;first-&gt;prior;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (head != L-&gt;first &amp;&amp; rear != L-&gt;first) &#123;</span><br><span class="line">		<span class="keyword">if</span> (head-&gt;data != rear-&gt;data)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">		rear = rear-&gt;prior;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h2>]]></content>
      <tags>
        <tag>技术积累</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/2021/03/20/Maven/</url>
    <content><![CDATA[<p><strong>导言</strong>：生产环境下开发不再是一个项目一个工程，而是每一个模块创建一个工程，而多个模块整合在一起就需要 使用到像 Maven 这样的构建工具。</p>
<p>[TOC]</p>
<h1 id="现今项目开发问题"><a href="#现今项目开发问题" class="headerlink" title="现今项目开发问题"></a>现今项目开发问题</h1><ol>
<li><p><strong>project - package 结构的不足</strong></p>
<p>若一个项目就是一个工程，当项目非常庞大时，不适合用这种二级机构管理。如一个项目多个功能模块，一个功能模块就一个MVC</p>
<blockquote>
<p>推祟三层结构：engineering - project - package 则能更好的适应大工程的分工开发(如IDEA)</p>
<p>工程拆分后又如何进行互相调用和访问呢？这就需要用到 Maven 的依赖管理机制</p>
</blockquote>
</li>
<li><p><strong>项目中jar包的问题</strong></p>
<ol>
<li>jar包必须手动“复制”、“粘贴”到WEB-INF/lib目录下</li>
</ol>
</li>
<li><p>同样的jar包文件重复出现在不同的项目工程中</p>
<ol start="2">
<li>jar包来源不明确，不规范</li>
<li>jar 包之间的依赖关系繁多，且难以得知</li>
</ol>
</li>
</ol>
<h1 id="Maven是什么"><a href="#Maven是什么" class="headerlink" title="Maven是什么"></a>Maven是什么</h1><h2 id="Maven基本概念"><a href="#Maven基本概念" class="headerlink" title="Maven基本概念"></a>Maven基本概念</h2><p>​    Maven <code>[ˈmeɪvn]</code> 是一款服务于<strong>java平</strong>台的<strong>自动化构建工具</strong>。</p>
<blockquote>
<p>java平台自动化构建工具发展历史：Make—&gt;Ant—&gt;<strong>Maven</strong>(使用面广)—&gt;Gradle</p>
</blockquote>
<h2 id="何为项目构建"><a href="#何为项目构建" class="headerlink" title="何为项目构建"></a>何为项目构建</h2><p><strong>基本概念</strong>：以java源文件,框架配置文件,JSP,HTML,图片等资源为原材料,去生产一个<strong>可以运行的项目</strong>的过程</p>
<ol>
<li><strong>清理</strong>：将以前编译得到的旧的<strong>class字节码</strong>文件删除，为下一次编译做准备</li>
<li><strong>编译</strong>：将Java源程序编程<strong>编译成class字节码</strong>文件</li>
<li><strong>测试</strong>：自动测试，<strong>自动调用junit程序</strong></li>
<li><strong>报告</strong>：输出测试程序<strong>执行的结果</strong></li>
<li><strong>打包</strong>：动态Web工程打<strong>war包</strong>，Java工程打<strong>jar包</strong></li>
<li><strong>安装</strong>：Maven特定的概念——将打包得到的文件复制到“仓库”中的指定位置</li>
<li><strong>部署</strong>：将动态Web工程生成的war包<strong>复制到Servlet容器</strong>的指定目录下，使其可以运行</li>
</ol>
<h1 id="安装Maven核心程序"><a href="#安装Maven核心程序" class="headerlink" title="安装Maven核心程序"></a>安装Maven核心程序</h1><h2 id="下载maven核心程序"><a href="#下载maven核心程序" class="headerlink" title="下载maven核心程序"></a>下载maven核心程序</h2><ul>
<li>官网</li>
</ul>
<h2 id="检查JAVA-HOME环境变量"><a href="#检查JAVA-HOME环境变量" class="headerlink" title="检查JAVA_HOME环境变量"></a>检查JAVA_HOME环境变量</h2><p>maven也是java编写的程序,所以运行是也需要java的虚拟机</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/Maven-检查JAVAHOME图示.png"
                      style="zoom:130%;" /
                >

<h2 id="解压Maven核心程序"><a href="#解压Maven核心程序" class="headerlink" title="解压Maven核心程序"></a>解压Maven核心程序</h2><p>建议解压到一个非中文没有空格的目录下</p>
<h2 id="配置Maven环境变量"><a href="#配置Maven环境变量" class="headerlink" title="配置Maven环境变量"></a>配置Maven环境变量</h2><ol>
<li><p><strong>新增MAVEN_HOME或者是M2_HOME</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/Maven-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F1.png"
                     
                ></p>
<blockquote>
<p> 以前Maven的版本配置的变量为M2_HOME,为了向下兼容低版本,所以可以配置为M2_HOME,而且配置M2_HOME可以防止一些奇怪的错误)</p>
</blockquote>
</li>
</ol>
<ul>
<li><p><strong>添加PATH的环境变量</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/Maven-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F2.png"
                     
                ></p>
</li>
</ul>
<h2 id="检查配置结果"><a href="#检查配置结果" class="headerlink" title="检查配置结果"></a>检查配置结果</h2><p><code>mvn -v</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/Maven-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F3.png"
                     
                ></p>
<h1 id="约定目录结构"><a href="#约定目录结构" class="headerlink" title="约定目录结构"></a>约定目录结构</h1><h2 id="约定目录结构的意义"><a href="#约定目录结构的意义" class="headerlink" title="约定目录结构的意义"></a>约定目录结构的意义</h2><ul>
<li><p>maven要负责我们这个项目的<strong>自动化</strong>构建，以编译为例,maven要想进行<strong>自动编译</strong>，至少需要知道java源文件保存在哪里。可采取两种方式</p>
<ol>
<li>以<strong>配置文件</strong>的方式明确</li>
<li>遵守<strong>框架内部已存在的</strong>约定**.</li>
</ol>
</li>
<li><p>在开发中本着能用<strong>约定解决的问题</strong>就不用配置解决，能用配置解决的就不去编写代码。<code> 约定&gt;配置&gt;编码</code> </p>
</li>
<li><p>凡是符合maven约定目录结构的项目都可称为<strong>Maven工程</strong></p>
</li>
</ul>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>关键：工程名—&gt;src，pom.xml，<em>target</em></p>
<p>​            src—&gt;main，test</p>
<p>​            main/test —&gt; java、resources</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/Maven-%E7%BA%A6%E5%AE%9A%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png"
                     
                ></p>
<h1 id="Maven常用命令"><a href="#Maven常用命令" class="headerlink" title="Maven常用命令"></a>Maven常用命令</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li><p><strong>注意</strong>：执行与<strong>构建过程相关</strong>的Maven命令，<strong>必须进入</strong>pom.xml 所在的目录。</p>
<blockquote>
<p>如当使用CMD命令时候必须进入到能看到pom.xml目录路径才能执行构建相关的mvn 命令</p>
</blockquote>
</li>
<li><p><strong>常用命令</strong></p>
<ol>
<li><code>mvn clean</code> : 清理</li>
<li><code>mvn compile</code> : 编译主程序</li>
<li><code>mvn test-compile</code> : 编译测试程序</li>
<li><code>mvn test</code> : 执行测测试</li>
<li><code>mvn package</code> : 打包</li>
<li><code>mvn install</code> ： 安装</li>
<li><code>mvn site </code>：生成站点</li>
</ol>
<hr>
<ul>
<li>上述大部分命令第一次运行后都会产生一个<strong>target</strong>文件夹，之后所有构建相关产生的文件都在此目录下</li>
<li><code>mvn compile</code>：编译后会产生一个<strong>classes</strong>文件夹，包含主程序编译的结果</li>
<li><code>mvn test-compile</code> : 编译会产生一个<strong>test-classes</strong>文件夹，包含测试程序的编译结果</li>
<li><code>mvn package</code> : 产生、<strong>maven-archiver</strong>、<strong>surefire-reports</strong>、<strong>XXXX.jar</strong> <ul>
<li>maven-archiver文件夹：maven一个辅助性文件</li>
<li>surefire-reports：内含一个.txt测试报告</li>
<li>XXXX.jar：打包后的jar包</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="关于联网问题"><a href="#关于联网问题" class="headerlink" title="关于联网问题"></a>关于联网问题</h2><ol>
<li>Maven 的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须有特定的插件来完成。而插件本身不包含在Maven核心程序中。</li>
<li>当我们执行的Maven命令需要用到某些插件时，Maven核心程序会首先到本地仓库中查找。</li>
<li>本地仓库的默认位置：<code>[系统登陆用户的家目录] \ .m2\repository</code></li>
<li>Maven核心程序如果在本地仓库中找不到需要的插件，那么它会自动连接外网，到中央仓库下载。如果此时无法连接外网，则构建失败。</li>
<li>修改默认本地仓库的位置可以让Maven核心程序到我们<strong>事先准备好</strong>(插件与jar包全有)的目录下查找插件</li>
</ol>
<h2 id="修改本地仓库位置"><a href="#修改本地仓库位置" class="headerlink" title="修改本地仓库位置"></a>修改本地仓库位置</h2><ol>
<li><p>打开本地仓库位置的配置信息文件：<code>apache-maven-3.2.2\conf\settings.xml</code></p>
</li>
<li><p>找到<code>&lt;localRepository&gt;</code>标签，若在注释内，请去除注释使其生效。路径设置必须设置到能看到如下图示文件内容为止</p>
<ol>
<li><p>例如：应将路径配置成：<code>&lt;localRepository&gt;D:/ManageTools/maven/repository&lt;/localRepository&gt;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/Maven-%E4%BF%AE%E6%94%B9%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93.png"
                     
                ></p>
</li>
</ol>
</li>
</ol>
<p>对jar 包进行引用操作的先例</p>
<p>项目目录结构与编译后的目录结构对比</p>
<p>实际动态WEB项目运行是以编译后的目录结构</p>
<p>因此在开发过程中，所有的路径或配置文件中配置的类路径等都是以编译结果的目录结构为标准</p>
<h1 id="Maven核心概念"><a href="#Maven核心概念" class="headerlink" title="Maven核心概念"></a>Maven核心概念</h1><p> Maven 是如何实现自动化构建的 </p>
<ol>
<li><strong>POM</strong> </li>
<li><strong>约定的目录结构</strong> </li>
<li><strong>坐标</strong> </li>
<li><strong>依赖管理</strong> </li>
<li>仓库管理</li>
<li>生命周期 </li>
<li>插件和目标 </li>
<li>继承</li>
<li>聚合</li>
</ol>
<h1 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h1><h2 id="基本含义"><a href="#基本含义" class="headerlink" title="基本含义"></a>基本含义</h2><ol>
<li><p>含义：Project Object Model <strong>项目对象模型</strong><br>类似：DOM ：Document Object Model 文档对象模型</p>
</li>
<li><p>pom.xml：Maven工程是核心配置文件，与<strong>构建过程相关的一切设置</strong>都在这个文件中进行配置。</p>
</li>
</ol>
<h2 id="POM文件简述"><a href="#POM文件简述" class="headerlink" title="POM文件简述"></a>POM文件简述</h2><ul>
<li>注意：<strong>每一个java</strong>项目(Maven项目)本身也是一个<strong>jar包</strong>的存在(打包或安装(Maven概念))</li>
<li>一定程度上：<strong>Java/Maven工程 == jar包</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span> <span class="comment">&lt;!-- 从Maven2开始固定内容 --&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 坐标：唯一标识当前项目/Jar --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	  </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h1 id="坐标-GAV"><a href="#坐标-GAV" class="headerlink" title="坐标(GAV)"></a>坐标(GAV)</h1><ul>
<li><p>使用下面三个向量在仓库中唯一定位一个Maven工程：<strong>groupid、artifactid、version</strong></p>
<ol>
<li><p><strong>groupid</strong>：公司或组织域名倒序 + 项目名</p>
<p><code>&lt;groupid&gt;com.atguigu.maven&lt;/groupid&gt;</code></p>
</li>
<li><p><strong>artifactid</strong>：模块名</p>
<p><code>&lt;artifactid&gt;Hello&lt;/artifactid&gt;</code></p>
</li>
<li><p><strong>version</strong>：版本</p>
<p><code>&lt;version&gt;1.0.0&lt;/version&gt;</code></p>
<p>tips：关键字，SNAPSHOT快照版、RELEASE，分离版(较成熟版本)</p>
</li>
</ol>
</li>
<li><p>Maven工程的<strong>坐标信息</strong>与执行<code>mvn install</code>命令后生成文件在<strong>仓库中路径的</strong>对应关系，以spring为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;4.0.0.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">org&#x2F;springframework&#x2F;spring-core&#x2F;4.0.0.RELEASE&#x2F;spring-core-4.0.0.RELEASE.jar</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h1 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h1><h2 id="仓库的分类"><a href="#仓库的分类" class="headerlink" title="仓库的分类"></a>仓库的分类</h2><ol>
<li><p><strong>本地仓库</strong>：当前电脑上部署的仓库目录，为当前电脑上所有Maven工程服务</p>
</li>
<li><p><strong>远程仓库</strong> </p>
<ol>
<li><p><strong>私服</strong>：搭建在局域网环境中，为<strong>局域网</strong>范围内的所有Maven工程服务</p>
<p>以Nexus这个Maven仓库管理器来表示私服的工工作流程</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/Maven-%E7%A7%81%E6%9C%8D%E4%BB%93%E5%BA%93.png"
                     
                ></p>
</li>
</ol>
</li>
</ol>
<ol>
<li><p><strong>中央仓库</strong>：假设在<strong>Internet</strong>上，为<strong>全世界</strong>所有Maven工程服务 </p>
</li>
<li><p><strong>中央仓库镜像</strong>：为了<strong>分担中央仓库流量</strong>，提升用户访问速度</p>
</li>
</ol>
<h2 id="仓库中保存的内容"><a href="#仓库中保存的内容" class="headerlink" title="仓库中保存的内容"></a>仓库中保存的内容</h2><ol>
<li>Maven自身所需要的插件 </li>
<li>第三方框架或工具的jar包 </li>
<li>自己开发的Maven工程</li>
</ol>
<blockquote>
<p>不管是什么样的 jar 包，在仓库中都是按照坐标生成目录结构，所以可以通过统一的方式查询或依赖。</p>
</blockquote>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>​    当 A jar 包用到了 B jar 包中的某些类时，A 就对 B 产生了依赖。Maven解析依赖信息时会到仓库中查找被依赖的jar包。 </p>
<h2 id="依赖的使用"><a href="#依赖的使用" class="headerlink" title="依赖的使用"></a>依赖的使用</h2><ol>
<li><p>标签的使用：<code>&lt;dependency&gt; 坐标 + &lt;scope&gt;范围&lt;/scope&gt; &lt;/dependency&gt;</code></p>
<p><code>&lt;dependencies&gt;</code>内存放多个<code>&lt;dependency&gt;标签</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;scope&gt;</code>范围，常用取值有：<strong>compile</strong>、<strong>test</strong>、<strong>provided</strong></p>
<p>tips：若不添加<code>&lt;scope&gt;</code>标签<strong>默认是compile</strong></p>
<table>
<thead>
<tr>
<th><strong>范围效果\类型</strong></th>
<th><strong>compile</strong></th>
<th><strong>test</strong></th>
<th><strong>provided</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>对主程序是否有效</strong></td>
<td>有效</td>
<td>无效</td>
<td>有效</td>
</tr>
<tr>
<td><strong>对测试程序是否有效</strong></td>
<td>有效</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr>
<td><strong>是否参与打包</strong></td>
<td>参与</td>
<td>不参与</td>
<td>不参与</td>
</tr>
<tr>
<td><strong>是否参与部署</strong></td>
<td>参与</td>
<td>不参与</td>
<td>不参与</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td>自定义类/jar包</td>
<td>junit</td>
<td>servlet-api.jar</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>从开发和运行这两个阶段理解compile 和 provided 的区别</strong> </p>
<p><strong><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/Maven-compile-provided.png"
                     
                ></strong></p>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li>对于自己开发的Maven工程，要使用<code>mvn install</code>命令安装后就可以进入仓库。执行后产生如下文件</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/Maven-MVN-INSTALL.png"
                     
                ></p>
<h2 id="依赖的传递性"><a href="#依赖的传递性" class="headerlink" title="依赖的传递性"></a>依赖的传递性</h2><p>tips：依赖的深入特性，首次学习建议先浏览 <strong>Eclipse中使用Maven</strong></p>
<p><strong>注意</strong>：这里描述的是工程三层结构，即一个应用工程，包含多个功能模块，每个功能模块都是一个eclipse project</p>
<h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>eclipse项目中存在：A项目模块 —依赖—&gt; B项目模块 —依赖—&gt; C项目模块</p>
<ul>
<li>A与B，B与C关系为<strong>直接依赖</strong>，可点击pom.xml文件底部切换为Dependency窗口查看</li>
<li>A与C的关系为<strong>间接依赖</strong>，可点击pom.xml文件底部切换为Dependency Hierarchy窗口查看直接与间接依赖</li>
</ul>
<h3 id="依赖的传递效果"><a href="#依赖的传递效果" class="headerlink" title="依赖的传递效果"></a>依赖的传递效果</h3><ul>
<li><p>传递的条件：只有<strong>compile</strong>范围的依赖才能传递</p>
</li>
<li><p>当存在：A项目模块 —依赖—&gt; B项目模块 —依赖—&gt; C项目模块</p>
<p>若C项目再添加某一种依赖D后，A、B模块会自动添加依赖D</p>
</li>
<li><p>传递依赖的好处：可以传递的依赖不必在每个模块工程中都重复声明，在“最下面”的工程中依赖一次即可。</p>
</li>
</ul>
<h2 id="依赖的排除"><a href="#依赖的排除" class="headerlink" title="依赖的排除"></a>依赖的排除</h2><p>依赖的排除相当于依赖传递的反操作</p>
<ol>
<li><p><strong>依赖排除使用场景</strong>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210320172733.png"
                     
                ></p>
</li>
<li><p><strong>添加依赖排除标签</strong>：假定当前项目的依赖是由上层的直接依赖HelloFriend项目传递过来的，则排除指定依赖操作如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HelloFriend<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 依赖排除标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="依赖的原则"><a href="#依赖的原则" class="headerlink" title="依赖的原则"></a>依赖的原则</h2><h3 id="路径最短者优先原则"><a href="#路径最短者优先原则" class="headerlink" title="路径最短者优先原则"></a>路径最短者优先原则</h3><ol>
<li><p><strong>情景</strong>：若某个项目模块受到来自两个项目模块的同jar包不同版本依赖。因为某些特殊的原因，HelloFriend使用了非Hello传递下来的jar包版本，而使用了其他的一个版本。此时MakeFreidens则会同时接收啊斗HelloFriend与Hello传递下来的不同的两个版本</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210320173556.png"
                     
                ></p>
<ol start="2">
<li><strong>就近原则</strong>：maven对这种原则默认使用就近原则，因此MakeFriends最终受到传递的是 1.2.14版本</li>
</ol>
</li>
</ol>
<h3 id="路径相同时先声明者优先"><a href="#路径相同时先声明者优先" class="headerlink" title="路径相同时先声明者优先"></a>路径相同时先声明者优先</h3><ol>
<li><p>情景：路径相同时，如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210320174044.png"
                     
                ></p>
</li>
<li><p><strong>先声明者优先</strong>：先声明指的是dependency标签的声明顺序。即MakerFriends依赖HelloFriende与OurFriends的一个相对声明顺序</p>
</li>
</ol>
<h2 id="统一管理依赖版本"><a href="#统一管理依赖版本" class="headerlink" title="统一管理依赖版本"></a>统一管理依赖版本</h2><ol>
<li><p>场景：这里对Spring各个jar包的依赖版本都是4.0.0如果需要统一升级为4.1.1，怎么办？手动逐一修改不可靠。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210320174632.png"
                     
                ></p>
</li>
<li><p><strong>使用properties标签</strong>：</p>
<ol>
<li><p>使用properties标签内使用<strong>自定义标签统一声明版本号</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过自定义标签统一声明版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test.spring.version</span>&gt;</span>4.1.1.RELEASE<span class="tag">&lt;/<span class="name">test.spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在需要统一版本的位置，使用<code>$&#123;自定义标签名&#125;</code>引用声明的版本号</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 统一引用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;test.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;test.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;test.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;test.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;test.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种自定义标签和标签内容引用的方式，并不只适用于此场景，这是xml的特性，任何地方都可以通过</p>
<p>&lt;自定义标签&gt;&lt;/自定义标签&gt; 、 ${自定义标签} 这种方式进行声明和引用</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>tips：了解即可</p>
<h2 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p>生命周期：各个<strong>构建环节执行的顺序</strong>，必须按照既定的正确顺序来执行。</p>
</li>
<li><p>Maven的核心程序中定义了抽象的生命周期，生命周期中各个阶段的具体任务是由插件来完成的。</p>
</li>
<li><p>为更好的实现自动化构建，<strong>不论现在要执行生命周期</strong>中的哪一阶段，都是从<strong>某一个</strong>生命周期<strong>最初的位置开始执行</strong></p>
<blockquote>
<p>即不用担心打包之前要编译，要测试，直接执行打包命令，会重头完成这些必备功能</p>
</blockquote>
</li>
<li><p>Maven有三套相互独立的生命周期，分别是：</p>
<ol>
<li><strong>Clean Lifecycle</strong>：在进行真正的构建之前进行一些清理工作。</li>
<li><strong>Default Lifecycle</strong>：构建的核心部分，编译、测试、打包、安装、部署等等。</li>
<li><strong>Site Lifecycle</strong>：生成项目报告，站点，发布站点。</li>
</ol>
</li>
<li><p>他们相互独立。也可以直接运行<code>mvn clean install site</code> 运行所有这三套生命周期。</p>
</li>
<li><p>每套生命周期都由<strong>一组阶段</strong>(Phase)组成，平时在命令行输入的<strong>命令</strong>总会<strong>对应于一个特定的阶段</strong>。</p>
<p>比如，运行<code> mvn clean</code>，这个<code>clean</code>是 Clean 生命周期的一个阶段</p>
</li>
</ol>
<h2 id="Clean声明周期"><a href="#Clean声明周期" class="headerlink" title="Clean声明周期"></a>Clean声明周期</h2><ol>
<li>pre-clean 执行一些需要在clean之前完成的工作</li>
<li>clean 移除所有上一次构建生成的文件</li>
<li>post-clean 执行一些需要在clean 之后立刻完成的工作</li>
</ol>
<h2 id="Default声明周期"><a href="#Default声明周期" class="headerlink" title="Default声明周期"></a>Default声明周期</h2><p>Default 生命周期是 Maven 生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段：</p>
<ol>
<li>validate</li>
<li>generate-sources</li>
<li>process-sources</li>
<li>generate-resources</li>
<li>process-resources 复制并处理资源文件，至目标目录，准备打包。</li>
<li>compile 编译项目的源代码。</li>
<li>process-classes</li>
<li>generate-test-sources</li>
<li>process-test-sources</li>
<li>generate-test-resources</li>
<li>process-test-resources 复制并处理资源文件，至目标测试目录。</li>
<li>test-compile 编译测试源代码。</li>
<li>process-test-classes</li>
<li>test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。</li>
<li>prepare-package</li>
<li>package 接受编译好的代码，打包成可发布的格式，如 JAR。</li>
<li>pre-integration-test</li>
<li>integration-test</li>
<li>post-integration-test</li>
<li>verify</li>
<li>install 将包安装至本地仓库，以让其它项目依赖。</li>
<li>deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享或部署到服务器上运行。</li>
<li>…</li>
</ol>
<h2 id="Site生命周期"><a href="#Site生命周期" class="headerlink" title="Site生命周期"></a>Site生命周期</h2><ol>
<li>pre-site 执行一些需要在生成站点文档之前完成的工作</li>
<li>site 生成项目的站点文档</li>
<li>post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</li>
<li>site-deploy 将生成的站点文档部署到特定的服务器上</li>
</ol>
<p>这里经常用到的是 site 阶段和 site-deploy 阶段，用以生成和发布 Maven 站点，这可是 Maven 相当强大的功能，Manager 比较喜欢，文档及统计数据自动生成，很好看。命令<code>mvn site</code></p>
<h1 id="Eclipse中使用Maven"><a href="#Eclipse中使用Maven" class="headerlink" title="Eclipse中使用Maven"></a>Eclipse中使用Maven</h1><h2 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h2><ol>
<li><p>当今版本eclipse一般已内置Maven插件</p>
</li>
<li><p>Maven插件的设置： Window-&gt;Preferences-&gt;Maven</p>
<ol>
<li><p><strong>installations</strong> : 指定Maven核心程序的位置。默认是插件自带的Maven程序，一般改为我们自己解压的那个。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/Maven-ECLIPSE%E8%AE%BE%E7%BD%AE1.png"
                     
                ></p>
</li>
<li><p><strong>user settings</strong> : 指定Maven核心程序中 conf/settings.xml 文件的位置，进而获取本地仓库的位</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/Maven-ECLIPSE%E8%AE%BE%E7%BD%AE2.png"
                     
                ></p>
</li>
</ol>
</li>
</ol>
<h2 id="创建Maven版java工程"><a href="#创建Maven版java工程" class="headerlink" title="创建Maven版java工程"></a>创建Maven版java工程</h2><ol>
<li><p>创建Maven版的Java工程 </p>
</li>
<li><p>创建时勾选上 Create a simple project(skip archetype selection) ，然后点击 next</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210320153058.png"
                     
                ></p>
</li>
<li><p>输入前三行基本信息后，点击finish 即可创建</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210320153432.png"
                     
                ></p>
</li>
<li><p>创建的Maven工程格式如下，</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210320153635.png"
                     
                ></p>
</li>
<li><p>编写的java源程序放在，名为<code>src/main/java</code>的目录下，即上图的第二行</p>
</li>
<li><p>创建的Maven工程默认使用的是JDK1.5，改变方法有两种</p>
<ol>
<li>eclipse设置中修改</li>
<li>(推荐)打开Maven核心程序 <strong>settings.xml 文件</strong>，找到<strong>profiles</strong>标签，在该标签内加入如下配置，即可更改</li>
<li>注意，若想更高版本的JDK，除了修改如下配置文件版本号外，还需注意目前maven版本是否支持</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.7<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="执行Maven命令"><a href="#执行Maven命令" class="headerlink" title="执行Maven命令"></a>执行Maven命令</h2><ol>
<li><p>选中Maven工程中的pom.xml文件，右键Run As，则有一系列命令列出，点击即可执行某种命令</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210320154447.png"
                      style="zoom:80%;" /
                >
</li>
<li><p>若在Run As 中没有找到想要执行的命令如上图中没有编译命令，则点击 Run As 列表中含三个点的命令<code>Maven build...</code>直接在Goals：中输入命令执行即可</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210320155101.png"
                      style="zoom:80%;" /
                >

</li>
</ol>
<h2 id="创建Maven版Web工程"><a href="#创建Maven版Web工程" class="headerlink" title="创建Maven版Web工程"></a>创建Maven版Web工程</h2><ol>
<li><p>New Maven project时，Packaging 选择 war </p>
</li>
<li><p>调整web目录结构，在项目上点右键 -&gt; properties-&gt;Project Facets -&gt; 把Dynamic Web Module 勾选去掉，并Apply -&gt; 将Dynamic Web Module 重新勾选 -&gt; 点击Further configuration available -&gt; 修改 Content directory为src/main/webapp -&gt; Apply 即在Maven工程上生成动态Web目录结构 </p>
</li>
<li><p>新建jsp文件发现报错：The superclass “javax.servlet.http.HttpServlet” was not found on the Java Build Path“。因为缺少Tomcat 运行时环境，解决方法有两种</p>
<ol>
<li><p>经典的通过eclipse设置加入<strong>ServletAPI</strong>依赖依赖</p>
</li>
<li><p>以Maven方式添加：在pom.xml文件中添加 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>jsp写入EL表达式时发现报错：”javax.servlet.jsp cannot be resolved to a type”，将<strong>JSPAPI</strong>导入。在pom.xml文件中添加 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3-b06<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：像这种在部署的时候运行时环境会提供的jar包，开发阶段使用scope一定要设置成provided，不然待部署时，maven会将设置为compile的jar包一同部署到容器中，则会发生冲突，运行时会报空指针异常。</p>
</li>
</ol>
<h2 id="导入Maven工程"><a href="#导入Maven工程" class="headerlink" title="导入Maven工程"></a>导入Maven工程</h2><ol>
<li><strong>方式1</strong>：传统的项目导入方式，前提是必须是在eclipse中创建的项目(普通项目或maven项目)，即必须包含eclipse认可为java项目的.settings、.classpath、.project等文件</li>
<li><strong>方式2</strong>：通用的maven项目导入，只要maven项目含pom.xml文件即可</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210320161647.png"
                     
                ></p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>​    解决无法进行依赖传递的jar包版本统一问题。例如score为test的junit。由于test范围的依赖不能传递，所以必然会分散在各个模块工程中，很容易造成版本不一致。 </p>
<ul>
<li><p>如下情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello依赖的Junit：4.0</span><br><span class="line">HelloFriend依赖的Junit：4.0</span><br><span class="line">MakeFriends依赖的Junit：4.9</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>​    将Junit依赖统一提取到“父”工程中，在子工程中声明Junit依赖是不指定版本，以父工程中统一设定的为准。同时也便于修改。 </p>
<ol>
<li><p>创建一个<strong>新的</strong>Maven工程作为<strong>父工程</strong>。注意：<strong>打包的方式pom</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210320202115.png"
                     
                ></p>
<p>对应自动生成配置文件信息如下所示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>所有子工程中</strong>声明对父工程的引用：适用<code>&lt;parent&gt;&lt;/parent&gt;标签</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子工程中声明父工程 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1. 使用parent标签进行对父工程的引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2. 将父工程中的坐标信息复制过来 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3. 设置以当前文件为基准的父工程pom.xml文件的相对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../Parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 同级--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将子工程的坐标中与父工程坐标中重复的内容删除，报出以下错误信息的内容均删除即可</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210320203510.png"
                     
                ></p>
</li>
<li><p>在父工程中添加统一的junit的依赖</p>
</li>
<li><p>在子工程中删除junit依赖的版本标签<code>version</code></p>
</li>
</ol>
<p>tips：配置集成后，执行安装命令时要<strong>先安装父工程</strong></p>
<h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><ol>
<li><p><strong>功能</strong>：对一个工程中的多个功能项目进行一键安装</p>
</li>
<li><p>配置方式：在一个”总的聚合工程”中<strong>配置</strong>各个参与聚合的模块 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在作为总的聚合工程中配置聚合(不一定是父工程) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定各个子工程的相对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../HelloFriend<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../MakeFriends<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../Hello<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用方式：在<strong>聚合工程</strong>的pom.xml 上点右键 -&gt; run as -&gt; maven install </p>
</li>
</ol>
<h1 id="Web工程的自动化部署"><a href="#Web工程的自动化部署" class="headerlink" title="Web工程的自动化部署"></a>Web工程的自动化部署</h1><ol>
<li>在pom.xml 中添加如下配置：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置当前工程构建过程中的特殊设置   --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>AtguiguWeb<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置构建过程中需要使用的插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- cargo是一家专门从事启动Servlet容器的组织 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.cargo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cargo-maven2-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 针对插件进行的配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 配置当前系统中容器的位置 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">containerId</span>&gt;</span>tomcat6x<span class="tag">&lt;/<span class="name">containerId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">home</span>&gt;</span>D:\DevInstall\apache-tomcat-6.0.39<span class="tag">&lt;/<span class="name">home</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">type</span>&gt;</span>existing<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">home</span>&gt;</span>D:\DevInstall\apache-tomcat-6.0.39<span class="tag">&lt;/<span class="name">home</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 如果Tomcat端口为默认值8080则不必设置该属性 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">cargo.servlet.port</span>&gt;</span>8989<span class="tag">&lt;/<span class="name">cargo.servlet.port</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置插件在什么情况下执行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>cargo-run<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 以下总的意思是，当执行install声明周期时，执行插件run目标 --&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 生命周期的阶段 --&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>install<span class="tag">&lt;/<span class="name">phase</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 插件的目标 --&gt;</span>  </span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>执行<code>mvn deploy</code> 命令</li>
</ol>
<p>tips：一般这个命令不在eclipse中使用，因为eclipse中启动后无法停止(无法输入 ctrl + c取消)，一般在命令行中使用</p>
<h1 id="查找依赖信息网站"><a href="#查找依赖信息网站" class="headerlink" title="查找依赖信息网站"></a>查找依赖信息网站</h1><p>搜索需要的 jar 包的基本依赖信息：<a class="link"   href="http://mvnrepository.com/" >http://mvnrepository.com/<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>技术积累</tag>
        <tag>项目构建</tag>
      </tags>
  </entry>
  <entry>
    <title>html&amp;css&amp;js&amp;jq&amp;xml入门</title>
    <url>/2021/03/23/html&amp;css&amp;js&amp;jq&amp;xml%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="基本规范"><a href="#基本规范" class="headerlink" title="基本规范"></a>基本规范</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="comment">&lt;!-- 约束,声明 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- html标签表示html的开始   lang=&quot;zh_CN&quot;表示中文--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- html标签中一般分为两部分,分别是:head和body   --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 表示头部信息,一般包含三部分内容,title标签,css样式,js代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><span class="comment">&lt;!-- 表示当前页面使用UTF-8字符集 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>某东<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="comment">&lt;!--表示标题--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--body标签是整个html页面显示的主体内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> &gt;</span></span><br><span class="line"> Hello world!</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="HTML标签介绍"><a href="#HTML标签介绍" class="headerlink" title="HTML标签介绍"></a>HTML标签介绍</h2><ol>
<li>标签的格式： &lt;标签名&gt;封装的数据&lt;/标签名&gt; <code>&lt;html&gt;Hello&lt;/html&gt;</code></li>
<li><strong>标签名</strong>大小写<strong>不敏感</strong></li>
<li>标签拥有自己的属性：<strong>基本属性、事件属性</strong><ul>
<li><strong>基本属性</strong>：<code>bgcolor=&quot;red&quot;</code> 可以修改简单的样式效果</li>
<li><strong>事件属性</strong>：<code>onclick=&quot;alert(&#39;你好！&#39;);&quot;</code> 可以直接设置事件响应后的代码</li>
</ul>
</li>
<li>.标签又分为，<strong>单标签</strong>和<strong>双标签。</strong> <ul>
<li>单标签格式： &lt;标签名 /&gt; ，如<code>&lt;br/&gt; 换行 </code>，<code>&lt;hr/&gt; 水平线 </code> </li>
<li>双标签格式: &lt;标签名&gt; …封装的数据…&lt;/标签名&gt; </li>
</ul>
</li>
</ol>
<h2 id="常用标签介绍"><a href="#常用标签介绍" class="headerlink" title="常用标签介绍"></a>常用标签介绍</h2><h3 id="w3c手册"><a href="#w3c手册" class="headerlink" title="w3c手册"></a>w3c手册</h3><p><a class="link"   href="https://www.w3school.com.cn/" >https://www.w3school.com.cn/<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="comment">&lt;!-- 约束,声明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>某东<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1、标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">&quot;left&quot;</span>&gt;</span>标题 1左对齐<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>标题 2居中<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">align</span>=<span class="string">&quot;right&quot;</span>&gt;</span>标题 3右对齐<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2、a标签是 超链接</span></span><br><span class="line"><span class="comment">target属性：属性设置哪个目标进行跳转</span></span><br><span class="line"><span class="comment">	_self 表示当前页面(默认值)</span></span><br><span class="line"><span class="comment">	_blank 表示打开新页面来进行跳转</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://baidu.com&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--div、span、p标签</span></span><br><span class="line"><span class="comment">	div 标签 默认独占一行</span></span><br><span class="line"><span class="comment">	span 标签 它的长度是封装数据的长度</span></span><br><span class="line"><span class="comment">	p 段落标签 默认会在段落的上方或下方各空出一行来（如果已有就不再空）</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>div 标签 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>div 标签 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 标签 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 标签 2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p 段落标签 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p 段落标签 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 7、表单 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- action提交服务器地址、method提交方式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">一、单提交的时候，数据没有发送给服务器的三种情况：</span></span><br><span class="line"><span class="comment">	1、表单项没有 name 属性值</span></span><br><span class="line"><span class="comment">	2、单选、复选（下拉列表中的 option 标签）都需要添加 value 属性，以便发送给服务器</span></span><br><span class="line"><span class="comment">	3、表单项不在提交的 form 标签中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、GET 请求的特点是：</span></span><br><span class="line"><span class="comment">	1、浏览器地址栏中的地址是：action 属性[+?+请求参数]</span></span><br><span class="line"><span class="comment">	请求参数的格式是：name=value&amp;name=value</span></span><br><span class="line"><span class="comment">	2、不安全</span></span><br><span class="line"><span class="comment">	3、它有数据长度的限制</span></span><br><span class="line"><span class="comment">三、POST 请求的特点是：</span></span><br><span class="line"><span class="comment">	1、浏览器地址栏中只有 action 属性值</span></span><br><span class="line"><span class="comment">	2、相对于 GET 请求要安全</span></span><br><span class="line"><span class="comment">	3、理论上没有数据长度的限制</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;loginServlet/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">	用户名称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;默认值&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">	用户密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 提交按钮 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;login&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 单选：name属性分组成为单选, checked=&quot;checked&quot; 默认单选--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>/&gt;</span>男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span>女<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 复选 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>/&gt;</span>Java<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>/&gt;</span>C<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>/&gt;</span>C++</span><br><span class="line">	<span class="comment">&lt;!-- 下拉列表 selected=&quot;selected&quot; 表默认选中--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">option</span>&gt;</span>--请选择国籍--<span class="tag">&lt;/<span class="name">option</span>&gt;</span><span class="comment">&lt;!-- 选项 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>=<span class="string">&quot;selected&quot;</span> <span class="attr">value</span>=<span class="string">&quot;China&quot;</span>&gt;</span>--中国--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">option</span>&gt;</span>--美国--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 多行文本输入框 </span></span><br><span class="line"><span class="comment">		rows 属性设置可以显示几行的高度</span></span><br><span class="line"><span class="comment">		cols 属性设置每行可以显示几个字符宽度</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">textarea</span>&gt;</span></span><br><span class="line">		默认值</span><br><span class="line">	<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 重置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;重置&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 文件上传域 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fileUpload&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 隐藏域，这些信息不显示，但提交表单时会提交到后台服务器 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="常用特殊字符"><a href="#常用特殊字符" class="headerlink" title="常用特殊字符"></a>常用特殊字符</h3><ol>
<li>诸如’’&lt;’’ 与’’&gt;’’符号在HTML中拥有特殊含义，若显示这些特殊含义的字符则需使用特殊字符书写</li>
<li>HTML会默认裁掉连续的空白字符(空格,TAB…)</li>
</ol>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>实体字符</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;</td>
<td>&amp;lt</td>
<td>less than</td>
</tr>
<tr>
<td>&gt;</td>
<td>&amp;gt</td>
<td>great than</td>
</tr>
<tr>
<td>空格</td>
<td>&amp;nbsp</td>
<td>牛逼space</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 把&lt;br&gt;换行标签变成文本输出 --&gt;</span></span><br><span class="line">&amp;lt br &amp;gt</span><br></pre></td></tr></table></figure>



<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><p>三元组：选择器、属性、值</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210323220125.png"
                      style="zoom:67%;" /
                >

<h2 id="CSS和HTML的结合"><a href="#CSS和HTML的结合" class="headerlink" title="CSS和HTML的结合"></a>CSS和HTML的结合</h2><ol>
<li>html中直接使用style属性设置</li>
<li>style 标签专门用来定义 css 样式代码</li>
<li>把 css 样式写成一个单独的css 文件，再通过 link 标签引入即可复用</li>
</ol>
<h3 id="style属性"><a href="#style属性" class="headerlink" title="style属性"></a>style属性</h3><p>在标签的 style 属性上设置”<code>key:value value;</code>”修饰</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--需求 1：分别定义两个 div、span 标签，分别修改每个 div 标签的样式为：边框 1 个像素，实线，红色。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid red;&quot;</span>&gt;</span>div 标签 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid red;&quot;</span>&gt;</span>div 标签 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid red;&quot;</span>&gt;</span>span 标签 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid red;&quot;</span>&gt;</span>span 标签 2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="style标签"><a href="#style标签" class="headerlink" title="style标签"></a>style标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--style 标签专门用来定义 css 样式代码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css"><span class="comment">/* 需求 1：分别定义两个 div、span 标签，分别修改每个 div 标签的样式为：边框 1 个像素，实线，红色。*/</span></span></span><br><span class="line">    div&#123;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">    &#125;</span><br><span class="line">    span&#123;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>div 标签 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>div 标签 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 标签 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 标签 2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="css文件-amp-ink标签"><a href="#css文件-amp-ink标签" class="headerlink" title="css文件&amp;ink标签"></a>css文件&amp;ink标签</h3><ul>
<li><p>test.css文件如下</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">1px</span> solid yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span>&#123;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>test.html文件如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--link 标签专门用来引入 css 样式代码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;test.css&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>div 标签 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>div 标签 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 标签 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 标签 2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><ol>
<li>标签名选择器</li>
<li>id选择器</li>
<li>class选择器</li>
<li>组合选择器</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="comment">/*标签选择器*/</span></span></span><br><span class="line">    body&#123;</span><br><span class="line">        font-size: 30px;</span><br><span class="line">        border: 1px yellow solid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="comment">/*id 选择器*/</span></span></span><br><span class="line"><span class="css">    <span class="selector-id">#test1</span>&#123;</span></span><br><span class="line">        color: blue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="comment">/*class 选择器*/</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.test2</span>&#123;</span></span><br><span class="line">        color: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="comment">/*组合选择器*/</span></span></span><br><span class="line"><span class="css">    <span class="selector-id">#test1</span>,<span class="selector-class">.test2</span>&#123;</span></span><br><span class="line">       background: green;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test1&quot;</span>&gt;</span>id 001<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test2&quot;</span>&gt;</span>class 002<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test2&quot;</span>&gt;</span>class 002<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="常用样式"><a href="#常用样式" class="headerlink" title="常用样式"></a>常用样式</h2><ol>
<li><p>字体颜色 <code>color : red;</code></p>
<p>颜色可以写颜色名如：black, blue, red, green 等 颜色也可以写 rgb 值和十六进制表示值：如 rgb(255,0,0)，#00F6DE，如果写十六进制值必须加#</p>
</li>
<li><p>宽度 <code>width:19px;</code>宽度可以写像素值：19px； 也可以写百分比值：20%</p>
</li>
<li><p>高度 <code>height:20px;</code> 高度可以写像素值：19px； 也可以写百分比值：20%</p>
</li>
<li><p>背景颜色 <code>background-color:#0F2D4C;</code></p>
</li>
<li><p>字体样式： <code>color：#FF0000;</code>字体颜色红色<code> font-size：20px;</code> 字体大小 </p>
</li>
<li><p>红色 1 像素实线边框 <code>border：1px solid red; </code></p>
</li>
<li><p>DIV 居中: <code>margin-left: auto; margin-right: auto;</code></p>
</li>
<li><p>文本居中：<code> text-align: center;</code></p>
</li>
<li><p>超连接去下划线: <code>text-decoration: none; </code></p>
</li>
<li><p>表格细线</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black; <span class="comment">/*设置边框*/</span></span><br><span class="line">    <span class="attribute">border-collapse</span>: collapse; <span class="comment">/*将边框合并*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">td</span>,<span class="selector-tag">th</span> &#123;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">1px</span> solid black; <span class="comment">/*设置边框*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表去除修饰，兼容IE</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">	<span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>Javascript 语言诞生主要是完成页面的数据验证。因此它运行在客户端，需要运行浏览器来解析执行 JavaScript 代码。 JS 是 Netscape 网景公司的产品，最早取名为 LiveScript;为了吸引更多 java 程序员。更名为 JavaScript。</p>
<ul>
<li>JS 是弱类型(类型可变)，Java 是强类型(定义变量已确定且不可变)。 </li>
<li>特点：<ul>
<li>交互性（它可以做的就是信息的动态交互）</li>
<li>安全性（不允许直接访问本地硬盘）</li>
<li>跨平台性（只要是可以解释 JS 的浏览器都可以执行，和平台无关）</li>
</ul>
</li>
</ul>
<h2 id="js和html结合方式"><a href="#js和html结合方式" class="headerlink" title="js和html结合方式"></a>js和html结合方式</h2><ol>
<li>直接在html的head或 body 标签中， 使用 script 标签来书写JavaScript</li>
<li>通过script标签外部引入单独的 JavaScript 代码文件</li>
</ol>
<h3 id="script标签中书写"><a href="#script标签中书写" class="headerlink" title="script标签中书写"></a>script标签中书写</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// alert 是 JavaScript 语言提供的一个警告框函数。</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 它可以接收任意类型的参数，这个参数就是警告框的提示信息</span></span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&quot;hello javaScript!&quot;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="通过script标签引入js文件"><a href="#通过script标签引入js文件" class="headerlink" title="通过script标签引入js文件"></a>通过script标签引入js文件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--现在需要使用 script 引入外部的 js 文件来执行</span></span><br><span class="line"><span class="comment">    src 属性专门用来引入 js 文件路径（可以是相对路径，也可以是绝对路径）</span></span><br><span class="line"><span class="comment">    script 标签可以用来定义 js 代码，也可以用来引入 js 文件</span></span><br><span class="line"><span class="comment">    但是，一个script标签只能做一件事，作为引入则不能在里面书写JavaScript代码</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;1.js&quot;</span>&gt;</span>该领域书写js代码无效<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 若想在当前情况下还在htmlzh写js，必须再创建一个script标签作为js代码书写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&quot;国哥现在可以帅了&quot;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ul>
<li><strong>数值</strong>类型： <strong>number</strong>     (对应java：byte int short long float double等)</li>
<li><strong>字符串</strong>类型： <strong>string</strong> </li>
<li><strong>对象</strong>类型： <strong>object</strong> </li>
<li><strong>布尔</strong>类型： <strong>boolean</strong> </li>
<li><strong>函数</strong>类型： <strong>function</strong></li>
</ul>
<h3 id="JavaScript中特殊的值："><a href="#JavaScript中特殊的值：" class="headerlink" title="JavaScript中特殊的值："></a>JavaScript中特殊的值：</h3><ul>
<li><p><strong>undefined</strong>：未定义，所有 js 变量<strong>未赋于初始值</strong>的时候，<strong>默认值</strong>都是 undefined. </p>
</li>
<li><p><strong>null</strong>：<strong>空值</strong> </p>
</li>
<li><p><strong>NaN</strong>：全称是：Not a Number。”非数字,非数值”。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">alert(a * b);<span class="comment">//输出NaN</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="定义变量格式"><a href="#定义变量格式" class="headerlink" title="定义变量格式"></a>定义变量格式</h3><ul>
<li>声明：<code>var 变量名; </code></li>
<li>声明+初始化：<code>var 变量名 = 值;</code></li>
</ul>
<h3 id="关系-比较-运算符"><a href="#关系-比较-运算符" class="headerlink" title="关系(比较)运算符"></a>关系(比较)运算符</h3><p>特殊讲解</p>
<ul>
<li>== ：等于，是简单的做<strong>字面值的比较</strong></li>
<li>===：全等于，除了做<strong>字面值</strong>的比较之外，还会比较两个变量的<strong>数据类型</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;12&quot;</span>;</span><br><span class="line">alert(a == b);<span class="comment">//true</span></span><br><span class="line">alert(a === b);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><ul>
<li>在 JavaScript 语言中，<strong>所有的变量</strong>，<strong>都可以做为一个 boolean 类型的变量去使用</strong></li>
</ul>
<blockquote>
<p> 0 、null、 undefined、””(空串) 都认为是 false</p>
</blockquote>
<ul>
<li><p>逻辑运算后<strong>返回值</strong></p>
<ul>
<li>&amp;&amp; 与运算：有两种情况<ul>
<li>情况1：当表达式<strong>全为真</strong>的时候。返回<strong>最后一个表达式的值</strong></li>
<li>情况2：当表达式中，有<strong>一个为假</strong>的时候。<strong>返回第一个为假</strong>的表达式的值</li>
</ul>
</li>
<li>|| 或运算：<ul>
<li>情况1：当表达式<strong>全为假</strong>时，返回最后一个表达式的值</li>
<li>情况2：只要<strong>有一个表达式为真</strong>。就会把<strong>第一个为真</strong>的表达式的值 </li>
</ul>
</li>
<li>&amp;&amp; 和 ||运算有短路。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// &amp;&amp; 与运算</span></span><br><span class="line">alert( a &amp;&amp; b );<span class="comment">//true</span></span><br><span class="line">alert( b &amp;&amp; a );<span class="comment">//abc</span></span><br><span class="line">alert( a &amp;&amp; d ); <span class="comment">// false</span></span><br><span class="line">alert( a &amp;&amp; c ); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// || 或运算</span></span><br><span class="line">alert( d || c ); <span class="comment">// null</span></span><br><span class="line">alert( c || d ); <span class="comment">//false</span></span><br><span class="line">alert( a || c ); <span class="comment">//abc</span></span><br><span class="line">alert( b || c ); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 = []; <span class="comment">// 空数组</span></span><br><span class="line"><span class="keyword">var</span> 数组名 = [<span class="number">1</span> , ’abc’ , <span class="literal">true</span>]; <span class="comment">// 定义数组同时赋值元素</span></span><br></pre></td></tr></table></figure>

<ul>
<li>数组定义时可不指定长度、且可变长度</li>
<li>只要我们通过数组下标<strong>赋值</strong>(不赋值则不会扩容)，那么最大的下标值，就会自动的给数组做扩容操作</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="literal">true</span>,<span class="number">1</span>]; <span class="comment">// 定义一个空数组</span></span><br><span class="line"><span class="comment">// alert( arr.length ); // 0</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">12</span>;</span><br><span class="line">alert( arr[<span class="number">0</span>] );<span class="comment">//12</span></span><br><span class="line">alert( arr.length ); <span class="comment">// 0</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">alert(arr.length); <span class="comment">//3</span></span><br><span class="line">alert(arr[<span class="number">1</span>]);<span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">	alert(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="格式1"><a href="#格式1" class="headerlink" title="格式1"></a>格式1</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 无参无返回值函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">&quot;无参无返回值函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fun();<span class="comment">//函数调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.带形参函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">a ,b</span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">&quot;有参函数 fun2()被调用了 a=&gt;&quot;</span> + a + <span class="string">&quot;,b=&gt;&quot;</span>+b);</span><br><span class="line">&#125;</span><br><span class="line">fun1();<span class="comment">//函数调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 在 JavaScript 语言中，如何定义带有返回值的函数？</span></span><br><span class="line"><span class="comment">//只需要在函数体内直接使用 return 语句返回值即可！</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> result = num1 + num2;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">alert(sum(<span class="number">100</span>,<span class="number">50</span>) );</span><br></pre></td></tr></table></figure>

<h3 id="格式2"><a href="#格式2" class="headerlink" title="格式2"></a>格式2</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以把函数名忽略作为var变量的引用</span></span><br><span class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">&quot;无参函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fun();<span class="comment">//调用</span></span><br></pre></td></tr></table></figure>



<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>typeof()</td>
<td>传入变量，返回数据类型</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="comment">//Jq、页面加载完成后执行</span></span><br><span class="line">    $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//给注册按钮绑定单击事件</span></span><br><span class="line">    $(<span class="string">&quot;#sub_btn&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 验证用户名：必须由字母，数字下划线组成，并且长度为 5 到 12 位</span></span><br><span class="line">        <span class="comment">// 验证密码：必须由字母，数字下划线组成，并且长度为 5 到 12 位</span></span><br><span class="line">        <span class="comment">// 验证确认密码：和密码相同</span></span><br><span class="line">        <span class="comment">// 邮箱验证：xxxxx@xxx.com</span></span><br><span class="line">        <span class="comment">// 验证码：现在只需要验证用户已输入。因为还没讲到服务器。验证码生成</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、验证用户名：必须由字母，数字下划线组成，并且长度为 5 到12位</span></span><br><span class="line">        <span class="comment">//获取用户名内容</span></span><br><span class="line">        <span class="keyword">var</span> username = $(<span class="string">&quot;#username&quot;</span>).val();</span><br><span class="line">        <span class="comment">//创建正则表达式对象</span></span><br><span class="line">        <span class="keyword">var</span> usernamePatt = <span class="regexp">/^\w&#123;5,12&#125;$/</span>;</span><br><span class="line">        <span class="comment">//调用test方法进行测试</span></span><br><span class="line">        <span class="comment">//给非法输入进行提示</span></span><br><span class="line">        <span class="keyword">var</span> $errorMsg = $(<span class="string">&quot;.errorMsg&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!usernamePatt.test(username))&#123;</span><br><span class="line">            $errorMsg.text(<span class="string">&quot;用户名非法输入&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//终止提交</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、验证密码：必须由字母，数字下划线组成，并且长度为 5 到 12 位</span></span><br><span class="line">        <span class="comment">//同理如上</span></span><br><span class="line">        <span class="keyword">var</span> password = $(<span class="string">&quot;#password&quot;</span>).val();</span><br><span class="line">        <span class="comment">//创建正则表达式对象</span></span><br><span class="line">        <span class="keyword">var</span> passwordPatt = <span class="regexp">/^\w&#123;5,12&#125;$/</span>;</span><br><span class="line">        <span class="comment">//调用test方法进行测试</span></span><br><span class="line">        <span class="comment">//给非法输入进行提示</span></span><br><span class="line">        <span class="keyword">if</span>(!passwordPatt.test(password))&#123;</span><br><span class="line">            $errorMsg.text(<span class="string">&quot;密码非法输入&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、验证确认密码：和密码相同</span></span><br><span class="line">        <span class="comment">// 获取确认密码</span></span><br><span class="line">        <span class="keyword">var</span> repwd = $(<span class="string">&quot;#repwd&quot;</span>).val();</span><br><span class="line">        <span class="keyword">if</span>(password != repwd)&#123;</span><br><span class="line">            $errorMsg.text(<span class="string">&quot;两次密码输入不一致&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、邮箱验证：xxxxx@xxx.com</span></span><br><span class="line">        <span class="keyword">var</span> emalil = $(<span class="string">&quot;#email&quot;</span>).val();</span><br><span class="line">        <span class="keyword">var</span> emailPatt = <span class="regexp">/^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.&#123;1,2&#125;[a-z]+)+$/</span>;</span><br><span class="line">        <span class="keyword">if</span>(!emailPatt.test(emalil))&#123;</span><br><span class="line">            $errorMsg.text(<span class="string">&quot;邮箱格式非法&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、获取验证码信息，只要输入不为空(去除空格后)即可</span></span><br><span class="line">        <span class="comment">// 验证码：现在只需要验证用户已输入。因为还没讲到服务器。验证码生成</span></span><br><span class="line">        <span class="keyword">var</span> code = $(<span class="string">&quot;#code&quot;</span>).val();</span><br><span class="line">        code = $.trim(code);</span><br><span class="line">        <span class="keyword">if</span>(code == <span class="literal">null</span> || code == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">            $errorMsg.text(<span class="string">&quot;验证码输入为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//错误信息清除</span></span><br><span class="line">        $errorMsg.text(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p>xml是<strong>可扩展</strong>的标记性语言</p>
<h2 id="XML作用"><a href="#XML作用" class="headerlink" title="XML作用"></a>XML作用</h2><ol>
<li>用来保存数据，而且这些数据具有自我描述性</li>
<li>它还可以做为项目或者模块的配置文件</li>
<li>还可以做为网络传输数据的格式（现在 JSON 为主）</li>
</ol>
<h2 id="xml-语法"><a href="#xml-语法" class="headerlink" title="xml 语法"></a>xml 语法</h2><ol>
<li>文档声明</li>
<li>元素（标签） </li>
<li>xml 属性</li>
<li>xml 注释</li>
<li>文本区域（CDATA 区）</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- xml声明 version是版本的意思(自从除了第一版每更新过)   encoding是编码  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span> <span class="comment">&lt;!-- 这是xml注释,books标识多本图书 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">&quot;SN123123413241&quot;</span>&gt;</span> <span class="comment">&lt;!-- book标签描述一本图书   id属性描述 的是图书 的编号  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>java编程思想<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!-- name标签描述 的是图书 的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>华仔<span class="tag">&lt;/<span class="name">author</span>&gt;</span>		<span class="comment">&lt;!-- author单词是作者的意思 ，描述图书作者 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>9.9<span class="tag">&lt;/<span class="name">price</span>&gt;</span>		<span class="comment">&lt;!-- price单词是价格，描述的是图书 的价格 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">&quot;SN12341235123&quot;</span>&gt;</span>	<span class="comment">&lt;!-- book标签描述一本图书   id属性描述 的是图书 的编号  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>葵花宝典<span class="tag">&lt;/<span class="name">name</span>&gt;</span>	<span class="comment">&lt;!-- name标签描述 的是图书 的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>班长<span class="tag">&lt;/<span class="name">author</span>&gt;</span>	<span class="comment">&lt;!-- author单词是作者的意思 ，描述图书作者 --&gt;</span></span><br><span class="line">     	<span class="tag">&lt;<span class="name">price</span>&gt;</span>5.5<span class="tag">&lt;/<span class="name">price</span>&gt;</span>	<span class="comment">&lt;!-- price单词是价格，描述的是图书 的价格 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>XML标签对<strong>大小写敏感</strong></p>
</li>
<li><p>每个属性的值必须使用<strong>引号引起来</strong></p>
</li>
<li><p>XML某一种标签<strong>只能有一个顶级元素</strong>(没有父标签的元素)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span><span class="comment">&lt;!-- 没有父标签，为顶级元素 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">book</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span>出错<span class="tag">&lt;/<span class="name">books</span>&gt;</span> <span class="comment">&lt;!-- 与顶级元素books重复，错误 --&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>XML中的<strong>特殊字符</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">book</span>&gt;</span><span class="symbol">&amp;lt;</span>C语言<span class="symbol">&amp;gt;</span><span class="tag">&lt;/<span class="name">book</span>&gt;</span> <span class="comment">&lt;!--显示 &lt; C语言 &gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
<h2 id="文本区域"><a href="#文本区域" class="headerlink" title="文本区域"></a>文本区域</h2><p>若XML中有大量需要转义的字符，如想显示<code>&lt;&lt;&lt;&lt; A &gt;&gt;&gt;&gt;</code>则可使用CDATA语法。CDATA 语法可以告诉 xml 解析器，CDATA 里的文本内容，只是纯文本，不需要 xml 语法解析 </p>
<ul>
<li><p>CDATA 格式：<code>&lt;![CDATA[]]&gt;</code>在最里面的<code>[]</code>内输入指定不解析文本内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span><span class="comment">&lt;!-- 正常显示&lt;&lt;&lt;&lt; A &gt;&gt;&gt;&gt; --&gt;</span></span><br><span class="line">	&lt;![CDATA[</span><br><span class="line">		&lt;&lt;&lt;&lt; A &gt;&gt;&gt;&gt;</span><br><span class="line">    ]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="XML的解析技术"><a href="#XML的解析技术" class="headerlink" title="XML的解析技术"></a>XML的解析技术</h2><ul>
<li>不管是 html 文件还是 xml 文件它们都是标记型文档，都可以使用 w3c 组织制定的 dom 技术来解析。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210324163712.png"
                     
                ></p>
<p>早期 <strong>JDK</strong> 为我们提供了两种 xml 解析技术<strong>DOM</strong> 和 <strong>Sax</strong> 简介（已经过时，但我们需要知道这两种技术） </p>
<ul>
<li><p><strong>Dom</strong> ：解析技术是 W3C 组织制定的，而所有的编程语言都对这个解析技术使用了自己语言的特点进行实现。 Java 对 dom 技术解析标记也做了实现。</p>
</li>
<li><p><strong>SAX</strong>：Sun 公司在 JDK5 版本对 dom 解析技术进行升级：SAX（ Simple API for XML ） </p>
<p>SAX 解析，它跟 W3C 制定的解析不太一样。它是以类似事件机制通过回调告诉用户当前正在解析的内容。 它是<strong>一行一行的读取 xml</strong> 文件进行解析的。不会创建大量的 dom 对象。 所以它在解析 xml 的时候，在内存的使用上。和性能上。都优于 Dom 解析。</p>
</li>
<li><p><strong>第三方的解析</strong>： </p>
<ul>
<li>jdom 在 dom 基础上进行了封装 </li>
<li><strong>dom4j</strong> 又对 jdom 进行了封装。</li>
<li>pull 主要用在 Android 手机开发，是在跟 sax 非常类似都是事件机制解析 xml 文件。 </li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>xml</tag>
        <tag>html</tag>
        <tag>css</tag>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql基础总结</title>
    <url>/2020/09/17/mysql%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="本单元目标"><a href="#本单元目标" class="headerlink" title="本单元目标"></a>本单元目标</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">一、为什么要学习数据库</span><br><span class="line">二、数据库的相关概念      </span><br><span class="line">    DBMS、DB、SQL</span><br><span class="line">三、数据库存储数据的特点</span><br><span class="line">四、初始MySQL</span><br><span class="line">    MySQL产品的介绍        </span><br><span class="line">    MySQL产品的安装          ★        </span><br><span class="line">    MySQL服务的启动和停止     ★</span><br><span class="line">    MySQL服务的登录和退出     ★      </span><br><span class="line">    MySQL的常见命令和语法规范      </span><br><span class="line">五、DQL语言的学习   ★              </span><br><span class="line">    基础查询        ★             </span><br><span class="line">    条件查询       ★            </span><br><span class="line">    排序查询       ★                </span><br><span class="line">    常见函数        ★               </span><br><span class="line">    分组函数        ★              </span><br><span class="line">    分组查询           ★            </span><br><span class="line">    连接查询        ★           </span><br><span class="line">    子查询       √                  </span><br><span class="line">    分页查询       ★              </span><br><span class="line">    union联合查询   √           </span><br><span class="line"></span><br><span class="line">六、DML语言的学习    ★             </span><br><span class="line">    插入语句                        </span><br><span class="line">    修改语句                        </span><br><span class="line">    删除语句                        </span><br><span class="line">七、DDL语言的学习  </span><br><span class="line">    库和表的管理   √              </span><br><span class="line">    常见数据类型介绍  √          </span><br><span class="line">    常见约束      √         </span><br><span class="line">八、TCL语言的学习</span><br><span class="line">    事务和事务处理                 </span><br><span class="line">九、视图的讲解           √</span><br><span class="line">十、变量                      </span><br><span class="line">十一、存储过程和函数   </span><br><span class="line">十二、流程控制结构       </span><br></pre></td></tr></table></figure>

<h2 id="数据库的好处"><a href="#数据库的好处" class="headerlink" title="数据库的好处"></a>数据库的好处</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.持久化数据到本地</span><br><span class="line">2.可以实现结构化查询，方便管理</span><br></pre></td></tr></table></figure>

<h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、DB：数据库，保存一组有组织的数据的容器</span><br><span class="line">2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据</span><br><span class="line">3、SQL:结构化查询语言，用于和DBMS通信的语言</span><br></pre></td></tr></table></figure>

<h2 id="数据库存储数据的特点"><a href="#数据库存储数据的特点" class="headerlink" title="数据库存储数据的特点"></a>数据库存储数据的特点</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、将数据放到表中，表再放到库中</span><br><span class="line">2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。</span><br><span class="line">3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。</span><br><span class="line">4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”</span><br><span class="line">5、表中的数据是按行存储的，每一行类似于java中的“对象”。</span><br></pre></td></tr></table></figure>

<h2 id="MySQL产品的介绍和安装"><a href="#MySQL产品的介绍和安装" class="headerlink" title="MySQL产品的介绍和安装"></a>MySQL产品的介绍和安装</h2><h3 id="MySQL服务的启动和停止"><a href="#MySQL服务的启动和停止" class="headerlink" title="MySQL服务的启动和停止"></a>MySQL服务的启动和停止</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方式一：计算机——右击管理——服务</span><br><span class="line">方式二：通过管理员身份运行</span><br><span class="line">net start 服务名（启动服务）</span><br><span class="line">net stop 服务名（停止服务）</span><br></pre></td></tr></table></figure>

<h3 id="MySQL服务的登录和退出"><a href="#MySQL服务的登录和退出" class="headerlink" title="MySQL服务的登录和退出"></a>MySQL服务的登录和退出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方式一：通过mysql自带的客户端</span><br><span class="line">只限于root用户</span><br><span class="line"></span><br><span class="line">方式二：通过windows自带的客户端</span><br><span class="line">登录：</span><br><span class="line">mysql 【-h主机名 -P端口号 】-u用户名 -p密码</span><br><span class="line"></span><br><span class="line">退出：</span><br><span class="line">exit或ctrl+C</span><br></pre></td></tr></table></figure>

<h3 id="MySQL的常见命令"><a href="#MySQL的常见命令" class="headerlink" title="MySQL的常见命令"></a>MySQL的常见命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.查看当前所有的数据库</span><br><span class="line">show databases;</span><br><span class="line">2.打开指定的库</span><br><span class="line">use 库名</span><br><span class="line">3.查看当前库的所有表</span><br><span class="line">show tables;</span><br><span class="line">4.查看其它库的所有表</span><br><span class="line">show tables from 库名;</span><br><span class="line">5.创建表</span><br><span class="line">create table 表名(</span><br><span class="line"></span><br><span class="line">    列名 列类型,</span><br><span class="line">    列名 列类型，</span><br><span class="line">    。。。</span><br><span class="line">);</span><br><span class="line">6.查看表结构</span><br><span class="line">desc 表名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7.查看服务器的版本</span><br><span class="line">方式一：登录到mysql服务端</span><br><span class="line">select version();</span><br><span class="line">方式二：没有登录到mysql服务端</span><br><span class="line">mysql --version</span><br><span class="line">或</span><br><span class="line">mysql --V</span><br></pre></td></tr></table></figure>

<h3 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.不区分大小写,但建议关键字大写，表名、列名小写</span><br><span class="line">2.每条命令最好用分号结尾</span><br><span class="line">3.每条命令根据需要，可以进行缩进 或换行</span><br><span class="line">4.注释</span><br><span class="line">    单行注释：#注释文字</span><br><span class="line">    单行注释：-- 注释文字</span><br><span class="line">    多行注释：&#x2F;* 注释文字  *&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="SQL的语言分类"><a href="#SQL的语言分类" class="headerlink" title="SQL的语言分类"></a>SQL的语言分类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DQL（Data Query Language）：数据查询语言</span><br><span class="line">    select </span><br><span class="line">DML(Data Manipulate Language):数据操作语言</span><br><span class="line">    insert 、update、delete</span><br><span class="line">DDL（Data Define Languge）：数据定义语言</span><br><span class="line">    create、drop、alter</span><br><span class="line">TCL（Transaction Control Language）：事务控制语言</span><br><span class="line">    commit、rollback</span><br></pre></td></tr></table></figure>

<h3 id="SQL的常见命令"><a href="#SQL的常见命令" class="headerlink" title="SQL的常见命令"></a>SQL的常见命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show databases； 查看所有的数据库</span><br><span class="line">use 库名； 打开指定 的库</span><br><span class="line">show tables ; 显示库中的所有表</span><br><span class="line">show tables from 库名;显示指定库中的所有表</span><br><span class="line">create table 表名(</span><br><span class="line">    字段名 字段类型,   </span><br><span class="line">    字段名 字段类型</span><br><span class="line">); 创建表</span><br><span class="line"></span><br><span class="line">desc 表名; 查看指定表的结构</span><br><span class="line">select * from 表名;显示表中的所有数据</span><br></pre></td></tr></table></figure>

<h2 id="DQL语言的学习"><a href="#DQL语言的学习" class="headerlink" title="DQL语言的学习"></a>DQL语言的学习</h2><h3 id="进阶1：基础查询"><a href="#进阶1：基础查询" class="headerlink" title="进阶1：基础查询"></a>进阶1：基础查询</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">SELECT 要查询的东西</span><br><span class="line">【FROM 表名】;</span><br><span class="line"></span><br><span class="line">类似于Java中 :System.out.println(要打印的东西);</span><br><span class="line">特点：</span><br><span class="line">①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在</span><br><span class="line">② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数</span><br></pre></td></tr></table></figure>

<h3 id="进阶2：条件查询"><a href="#进阶2：条件查询" class="headerlink" title="进阶2：条件查询"></a>进阶2：条件查询</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">条件查询：根据条件过滤原始表的数据，查询到想要的数据</span><br><span class="line">语法：</span><br><span class="line">select </span><br><span class="line">    要查询的字段|表达式|常量值|函数</span><br><span class="line">from </span><br><span class="line">    表</span><br><span class="line">where </span><br><span class="line">    条件 ;</span><br><span class="line"></span><br><span class="line">分类：</span><br><span class="line">一、条件表达式</span><br><span class="line">    示例：salary&gt;10000</span><br><span class="line">    条件运算符：</span><br><span class="line">    &gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D; !&#x3D; &lt;&gt;</span><br><span class="line"></span><br><span class="line">二、逻辑表达式</span><br><span class="line">示例：salary&gt;10000 &amp;&amp; salary&lt;20000</span><br><span class="line"></span><br><span class="line">逻辑运算符：</span><br><span class="line"></span><br><span class="line">    and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false</span><br><span class="line">    or(||)：两个条件只要有一个成立，结果为true，否则为false</span><br><span class="line">    not(!)：如果条件成立，则not后为false，否则为true</span><br><span class="line"></span><br><span class="line">三、模糊查询</span><br><span class="line">示例：last_name like &#39;a%&#39;</span><br></pre></td></tr></table></figure>

<h3 id="进阶3：排序查询"><a href="#进阶3：排序查询" class="headerlink" title="进阶3：排序查询"></a>进阶3：排序查询</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">select</span><br><span class="line">    要查询的东西</span><br><span class="line">from</span><br><span class="line">    表</span><br><span class="line">where </span><br><span class="line">    条件</span><br><span class="line"></span><br><span class="line">order by 排序的字段|表达式|函数|别名 【asc|desc】</span><br></pre></td></tr></table></figure>

<h3 id="进阶4：常见函数"><a href="#进阶4：常见函数" class="headerlink" title="进阶4：常见函数"></a>进阶4：常见函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、单行函数</span><br><span class="line">1、字符函数</span><br><span class="line">    concat拼接</span><br><span class="line">    substr截取子串</span><br><span class="line">    upper转换成大写</span><br><span class="line">    lower转换成小写</span><br><span class="line">    trim去前后指定的空格和字符</span><br><span class="line">    ltrim去左边空格</span><br><span class="line">    rtrim去右边空格</span><br><span class="line">    replace替换</span><br><span class="line">    lpad左填充</span><br><span class="line">    rpad右填充</span><br><span class="line">    instr返回子串第一次出现的索引</span><br><span class="line">    length 获取字节个数</span><br><span class="line"></span><br><span class="line">2、数学函数</span><br><span class="line">    round 四舍五入</span><br><span class="line">    rand 随机数</span><br><span class="line">    floor向下取整</span><br><span class="line">    ceil向上取整</span><br><span class="line">    mod取余</span><br><span class="line">    truncate截断</span><br><span class="line">3、日期函数</span><br><span class="line">    now当前系统日期+时间</span><br><span class="line">    curdate当前系统日期</span><br><span class="line">    curtime当前系统时间</span><br><span class="line">    str_to_date 将字符转换成日期</span><br><span class="line">    date_format将日期转换成字符</span><br><span class="line">4、流程控制函数</span><br><span class="line">    if 处理双分支</span><br><span class="line">    case语句 处理多分支</span><br><span class="line">        情况1：处理等值判断</span><br><span class="line">        情况2：处理条件判断</span><br><span class="line"></span><br><span class="line">5、其他函数</span><br><span class="line">    version版本</span><br><span class="line">    database当前库</span><br><span class="line">    user当前连接用户</span><br></pre></td></tr></table></figure>

<p>二、分组函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum 求和</span><br><span class="line">max 最大值</span><br><span class="line">min 最小值</span><br><span class="line">avg 平均值</span><br><span class="line">count 计数</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">1、以上五个分组函数都忽略null值，除了count(*)</span><br><span class="line">2、sum和avg一般用于处理数值型</span><br><span class="line">    max、min、count可以处理任何数据类型</span><br><span class="line">3、都可以搭配distinct使用，用于统计去重后的结果</span><br><span class="line">4、count的参数可以支持：</span><br><span class="line">    字段、*、常量值，一般放1</span><br><span class="line"></span><br><span class="line">   建议使用 count(*)</span><br></pre></td></tr></table></figure>

<h2 id="进阶5：分组查询"><a href="#进阶5：分组查询" class="headerlink" title="进阶5：分组查询"></a>进阶5：分组查询</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">select 查询的字段，分组函数</span><br><span class="line">from 表</span><br><span class="line">group by 分组的字段</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">1、可以按单个字段分组</span><br><span class="line">2、和分组函数一同查询的字段最好是分组后的字段</span><br><span class="line">3、分组筛选</span><br><span class="line">        针对的表    位置          关键字</span><br><span class="line">分组前筛选：  原始表     group by的前面     where</span><br><span class="line">分组后筛选：  分组后的结果集 group by的后面     having</span><br><span class="line"></span><br><span class="line">4、可以按多个字段分组，字段之间用逗号隔开</span><br><span class="line">5、可以支持排序</span><br><span class="line">6、having后可以支持别名</span><br></pre></td></tr></table></figure>

<h2 id="进阶6：多表连接查询"><a href="#进阶6：多表连接查询" class="headerlink" title="进阶6：多表连接查询"></a>进阶6：多表连接查询</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">笛卡尔乘积：如果连接条件省略或无效则会出现</span><br><span class="line">解决办法：添加上连接条件</span><br></pre></td></tr></table></figure>

<p>一、传统模式下的连接 ：等值连接——非等值连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.等值连接的结果 &#x3D; 多个表的交集</span><br><span class="line">2.n表连接，至少需要n-1个连接条件</span><br><span class="line">3.多个表不分主次，没有顺序要求</span><br><span class="line">4.一般为表起别名，提高阅读性和性能</span><br></pre></td></tr></table></figure>

<p>二、sql99语法：通过join关键字实现连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">含义：1999年推出的sql语法</span><br><span class="line">支持：</span><br><span class="line">等值连接、非等值连接 （内连接）</span><br><span class="line">外连接</span><br><span class="line">交叉连接</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br><span class="line">select 字段，...</span><br><span class="line">from 表1</span><br><span class="line">【inner|left outer|right outer|cross】join 表2 on  连接条件</span><br><span class="line">【inner|left outer|right outer|cross】join 表3 on  连接条件</span><br><span class="line">【where 筛选条件】</span><br><span class="line">【group by 分组字段】</span><br><span class="line">【having 分组后的筛选条件】</span><br><span class="line">【order by 排序的字段或表达式】</span><br><span class="line"></span><br><span class="line">好处：语句上，连接条件和筛选条件实现了分离，简洁明了！</span><br></pre></td></tr></table></figure>

<p>三、自连接</p>
<p>案例：查询员工名和直接上级的名称</p>
<p>sql99</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT e.last_name,m.last_name</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN employees m ON e.&#96;manager_id&#96;&#x3D;m.&#96;employee_id&#96;;</span><br></pre></td></tr></table></figure>

<p>sql92</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT e.last_name,m.last_name</span><br><span class="line">FROM employees e,employees m </span><br><span class="line">WHERE e.&#96;manager_id&#96;&#x3D;m.&#96;employee_id&#96;;</span><br></pre></td></tr></table></figure>

<h2 id="进阶7：子查询"><a href="#进阶7：子查询" class="headerlink" title="进阶7：子查询"></a>进阶7：子查询</h2><p>含义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询</span><br><span class="line">在外面的查询语句，称为主查询或外查询</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、子查询都放在小括号内</span><br><span class="line">2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧</span><br><span class="line">3、子查询优先于主查询执行，主查询使用了子查询的执行结果</span><br><span class="line">4、子查询根据查询结果的行数不同分为以下两类：</span><br><span class="line">① 单行子查询</span><br><span class="line">    结果集只有一行</span><br><span class="line">    一般搭配单行操作符使用：&gt; &lt; &#x3D; &lt;&gt; &gt;&#x3D; &lt;&#x3D; </span><br><span class="line">    非法使用子查询的情况：</span><br><span class="line">    a、子查询的结果为一组值</span><br><span class="line">    b、子查询的结果为空</span><br><span class="line"></span><br><span class="line">② 多行子查询</span><br><span class="line">    结果集有多行</span><br><span class="line">    一般搭配多行操作符使用：any、all、in、not in</span><br><span class="line">    in： 属于子查询结果中的任意一个就行</span><br><span class="line">    any和all往往可以用其他查询代替</span><br></pre></td></tr></table></figure>

<h2 id="进阶8：分页查询"><a href="#进阶8：分页查询" class="headerlink" title="进阶8：分页查询"></a>进阶8：分页查询</h2><p>应用场景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句</span><br></pre></td></tr></table></figure>

<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 字段|表达式,...</span><br><span class="line">from 表</span><br><span class="line">【where 条件】</span><br><span class="line">【group by 分组字段】</span><br><span class="line">【having 条件】</span><br><span class="line">【order by 排序的字段】</span><br><span class="line">limit 【起始的条目索引，】条目数;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.起始条目索引从0开始</span><br><span class="line"></span><br><span class="line">2.limit子句放在查询语句的最后</span><br><span class="line"></span><br><span class="line">3.公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage</span><br><span class="line">假如:</span><br><span class="line">每页显示条目数sizePerPage</span><br><span class="line">要显示的页数 page</span><br></pre></td></tr></table></figure>

<h2 id="进阶9：联合查询"><a href="#进阶9：联合查询" class="headerlink" title="进阶9：联合查询"></a>进阶9：联合查询</h2><p>引入： union 联合、合并</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】</span><br><span class="line">.....</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、多条查询语句的查询的列数必须是一致的</span><br><span class="line">2、多条查询语句的查询的列的类型几乎相同</span><br><span class="line">3、union代表去重，union all代表不去重</span><br></pre></td></tr></table></figure>

<h2 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>语法： insert into 表名(字段名，…) values(值1，…);</p>
<p>特点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、字段类型和值类型一致或兼容，而且一一对应</span><br><span class="line">2、可以为空的字段，可以不用插入值，或用null填充</span><br><span class="line">3、不可以为空的字段，必须插入值</span><br><span class="line">4、字段个数和值的个数必须一致</span><br><span class="line">5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致</span><br></pre></td></tr></table></figure>

<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>修改单表语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 表名 set 字段&#x3D;新值,字段&#x3D;新值</span><br><span class="line">【where 条件】</span><br></pre></td></tr></table></figure>

<p>修改多表语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 表1 别名1,表2 别名2</span><br><span class="line">set 字段&#x3D;新值，字段&#x3D;新值</span><br><span class="line">where 连接条件</span><br><span class="line">and 筛选条件</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>方式1：delete语句 </p>
<p>单表的删除： ★ delete from 表名 【where 筛选条件】</p>
<p>多表的删除： delete 别名1，别名2 from 表1 别名1，表2 别名2 where 连接条件 and 筛选条件;</p>
<p>方式2：truncate语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">truncate table 表名</span><br></pre></td></tr></table></figure>

<p>两种方式的区别【面试题】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.truncate不能加where条件，而delete可以加where条件</span><br><span class="line"></span><br><span class="line">#2.truncate的效率高一丢丢</span><br><span class="line"></span><br><span class="line">#3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始</span><br><span class="line">#delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始</span><br><span class="line"></span><br><span class="line">#4.truncate删除不能回滚，delete删除可以回滚</span><br></pre></td></tr></table></figure>

<h2 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h2><h3 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h3><p>库的管理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、创建库</span><br><span class="line">create database 库名</span><br><span class="line">二、删除库</span><br><span class="line">drop database 库名</span><br></pre></td></tr></table></figure>

<p>表的管理： #1.创建表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS stuinfo(</span><br><span class="line">    stuId INT,</span><br><span class="line">    stuName VARCHAR(20),</span><br><span class="line">    gender CHAR,</span><br><span class="line">    bornDate DATETIME</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DESC studentinfo;</span><br><span class="line">#2.修改表 alter</span><br><span class="line">语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;</span><br><span class="line"></span><br><span class="line">#①修改字段名</span><br><span class="line">ALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;</span><br><span class="line"></span><br><span class="line">#②修改表名</span><br><span class="line">ALTER TABLE stuinfo RENAME [TO]  studentinfo;</span><br><span class="line">#③修改字段类型和列级约束</span><br><span class="line">ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;</span><br><span class="line"></span><br><span class="line">#④添加字段</span><br><span class="line"></span><br><span class="line">ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;</span><br><span class="line">#⑤删除字段</span><br><span class="line">ALTER TABLE studentinfo DROP COLUMN email;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3.删除表</span><br><span class="line"></span><br><span class="line">DROP TABLE [IF EXISTS] studentinfo;</span><br></pre></td></tr></table></figure>

<h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">整型：</span><br><span class="line"></span><br><span class="line">小数：</span><br><span class="line">    浮点型</span><br><span class="line">    定点型</span><br><span class="line">字符型：</span><br><span class="line">日期型：</span><br><span class="line">Blob类型：</span><br></pre></td></tr></table></figure>

<h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NOT NULL</span><br><span class="line">DEFAULT</span><br><span class="line">UNIQUE</span><br><span class="line">CHECK</span><br><span class="line">PRIMARY KEY</span><br><span class="line">FOREIGN KEY</span><br></pre></td></tr></table></figure>

<h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态</span><br></pre></td></tr></table></figure>

<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（ACID）</span><br><span class="line">原子性：要么都执行，要么都回滚</span><br><span class="line">一致性：保证数据的状态操作前和操作后保持一致</span><br><span class="line">隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰</span><br><span class="line">持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改</span><br></pre></td></tr></table></figure>

<p>相关步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、开启事务</span><br><span class="line">2、编写事务的一组逻辑操作单元（多条sql语句）</span><br><span class="line">3、提交事务或回滚事务</span><br></pre></td></tr></table></figure>

<h3 id="事务的分类："><a href="#事务的分类：" class="headerlink" title="事务的分类："></a>事务的分类：</h3><p>隐式事务，没有明显的开启和结束事务的标志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">比如</span><br><span class="line">insert、update、delete语句本身就是一个事务</span><br></pre></td></tr></table></figure>

<p>显式事务，具有明显的开启和结束事务的标志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、开启事务</span><br><span class="line">取消自动提交事务的功能</span><br><span class="line"></span><br><span class="line">2、编写事务的一组逻辑操作单元（多条sql语句）</span><br><span class="line">insert</span><br><span class="line">update</span><br><span class="line">delete</span><br><span class="line"></span><br><span class="line">3、提交事务或回滚事务</span><br></pre></td></tr></table></figure>

<h3 id="使用到的关键字"><a href="#使用到的关键字" class="headerlink" title="使用到的关键字"></a>使用到的关键字</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set autocommit&#x3D;0;</span><br><span class="line">start transaction;</span><br><span class="line">commit;</span><br><span class="line">rollback;</span><br><span class="line"></span><br><span class="line">savepoint  断点</span><br><span class="line">commit to 断点</span><br><span class="line">rollback to 断点</span><br></pre></td></tr></table></figure>

<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别:"></a>事务的隔离级别:</h3><p>事务并发问题如何发生？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当多个事务同时操作同一个数据库的相同数据时</span><br></pre></td></tr></table></figure>

<p>事务的并发问题有哪些？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">脏读：一个事务读取到了另外一个事务未提交的数据</span><br><span class="line">不可重复读：同一个事务中，多次读取到的数据不一致</span><br><span class="line">幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据</span><br></pre></td></tr></table></figure>

<p>如何避免事务的并发问题？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过设置事务的隔离级别</span><br><span class="line">1、READ UNCOMMITTED</span><br><span class="line">2、READ COMMITTED 可以避免脏读</span><br><span class="line">3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读</span><br><span class="line">4、SERIALIZABLE可以避免脏读、不可重复读和幻读</span><br></pre></td></tr></table></figure>

<p>设置隔离级别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set session|global  transaction isolation level 隔离级别名;</span><br></pre></td></tr></table></figure>

<p>查看隔离级别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure>

<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>含义：理解成一张虚拟的表</p>
<p>视图和表的区别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    使用方式    占用物理空间</span><br><span class="line"></span><br><span class="line">视图  完全相同    不占用，仅仅保存的是sql逻辑</span><br><span class="line"></span><br><span class="line">表   完全相同    占用</span><br></pre></td></tr></table></figure>

<p>视图的好处：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、sql语句提高重用性，效率高</span><br><span class="line">2、和表实现了分离，提高了安全性</span><br></pre></td></tr></table></figure>

<h3 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">CREATE VIEW  视图名</span><br><span class="line">AS</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure>

<h3 id="视图的增删改查"><a href="#视图的增删改查" class="headerlink" title="视图的增删改查"></a>视图的增删改查</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、查看视图的数据 ★</span><br><span class="line"></span><br><span class="line">SELECT * FROM my_v4;</span><br><span class="line">SELECT * FROM my_v1 WHERE last_name&#x3D;&#39;Partners&#39;;</span><br><span class="line"></span><br><span class="line">2、插入视图的数据</span><br><span class="line">INSERT INTO my_v4(last_name,department_id) VALUES(&#39;虚竹&#39;,90);</span><br><span class="line"></span><br><span class="line">3、修改视图的数据</span><br><span class="line"></span><br><span class="line">UPDATE my_v4 SET last_name &#x3D;&#39;梦姑&#39; WHERE last_name&#x3D;&#39;虚竹&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4、删除视图的数据</span><br><span class="line">DELETE FROM my_v4;</span><br></pre></td></tr></table></figure>

<h3 id="某些视图不能更新"><a href="#某些视图不能更新" class="headerlink" title="某些视图不能更新"></a>某些视图不能更新</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all</span><br><span class="line">常量视图</span><br><span class="line">Select中包含子查询</span><br><span class="line">join</span><br><span class="line">from一个不能更新的视图</span><br><span class="line">where子句的子查询引用了from子句中的表</span><br></pre></td></tr></table></figure>

<h3 id="视图逻辑的更新"><a href="#视图逻辑的更新" class="headerlink" title="视图逻辑的更新"></a>视图逻辑的更新</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方式一：</span><br><span class="line">CREATE OR REPLACE VIEW test_v7</span><br><span class="line">AS</span><br><span class="line">SELECT last_name FROM employees</span><br><span class="line">WHERE employee_id&gt;100;</span><br><span class="line"></span><br><span class="line">#方式二:</span><br><span class="line">ALTER VIEW test_v7</span><br><span class="line">AS</span><br><span class="line">SELECT employee_id FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT * FROM test_v7;</span><br></pre></td></tr></table></figure>

<h3 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP VIEW test_v1,test_v2,test_v3;</span><br></pre></td></tr></table></figure>

<h3 id="视图结构的查看"><a href="#视图结构的查看" class="headerlink" title="视图结构的查看"></a>视图结构的查看</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DESC test_v7;</span><br><span class="line">SHOW CREATE VIEW test_v7;</span><br></pre></td></tr></table></figure>

<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>含义：一组经过预先编译的sql语句的集合 好处：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、提高了sql语句的重用性，减少了开发程序员的压力</span><br><span class="line">2、提高了效率</span><br><span class="line">3、减少了传输次数</span><br></pre></td></tr></table></figure>

<p>分类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、无返回无参</span><br><span class="line">2、仅仅带in类型，无返回有参</span><br><span class="line">3、仅仅带out类型，有返回无参</span><br><span class="line">4、既带in又带out，有返回有参</span><br><span class="line">5、带inout，有返回有参</span><br><span class="line">注意：in、out、inout都可以在一个存储过程中带多个</span><br></pre></td></tr></table></figure>

<h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure 存储过程名(in|out|inout 参数名  参数类型,...)</span><br><span class="line">begin</span><br><span class="line">    存储过程体</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>类似于方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 返回类型 方法名(参数类型 参数名,...)&#123;</span><br><span class="line"></span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、需要设置新的结束标记</span><br><span class="line">delimiter 新的结束标记</span><br><span class="line">示例：</span><br><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)</span><br><span class="line">BEGIN</span><br><span class="line">    sql语句1;</span><br><span class="line">    sql语句2;</span><br><span class="line"></span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end</span><br><span class="line"></span><br><span class="line">3、参数前面的符号的意思</span><br><span class="line">in:该参数只能作为输入 （该参数不能做返回值）</span><br><span class="line">out：该参数只能作为输出（该参数只能做返回值）</span><br><span class="line">inout：既能做输入又能做输出</span><br></pre></td></tr></table></figure>

<h1 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call 存储过程名(实参列表)</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><p>学过的函数：LENGTH、SUBSTR、CONCAT等 语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型</span><br><span class="line">BEGIN</span><br><span class="line">    函数体</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 函数名（实参列表）</span><br></pre></td></tr></table></figure>

<h3 id="函数和存储过程的区别"><a href="#函数和存储过程的区别" class="headerlink" title="函数和存储过程的区别"></a>函数和存储过程的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        关键字     调用语法    返回值         应用场景</span><br><span class="line">函数      FUNCTION    SELECT 函数() 只能是一个       一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个</span><br><span class="line">存储过程    PROCEDURE   CALL 存储过程() 可以有0个或多个        一般用于更新</span><br></pre></td></tr></table></figure>

<h2 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h2><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>一、全局变量</p>
<p>作用域：针对于所有会话（连接）有效，但不能跨重启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看所有全局变量</span><br><span class="line">SHOW GLOBAL VARIABLES;</span><br><span class="line">查看满足条件的部分系统变量</span><br><span class="line">SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;</span><br><span class="line">查看指定的系统变量的值</span><br><span class="line">SELECT @@global.autocommit;</span><br><span class="line">为某个系统变量赋值</span><br><span class="line">SET @@global.autocommit&#x3D;0;</span><br><span class="line">SET GLOBAL autocommit&#x3D;0;</span><br></pre></td></tr></table></figure>

<p>二、会话变量</p>
<p>作用域：针对于当前会话（连接）有效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看所有会话变量</span><br><span class="line">SHOW SESSION VARIABLES;</span><br><span class="line">查看满足条件的部分会话变量</span><br><span class="line">SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;</span><br><span class="line">查看指定的会话变量的值</span><br><span class="line">SELECT @@autocommit;</span><br><span class="line">SELECT @@session.tx_isolation;</span><br><span class="line">为某个会话变量赋值</span><br><span class="line">SET @@session.tx_isolation&#x3D;&#39;read-uncommitted&#39;;</span><br><span class="line">SET SESSION tx_isolation&#x3D;&#39;read-committed&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>一、用户变量</p>
<p>声明并初始化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET @变量名&#x3D;值;</span><br><span class="line">SET @变量名:&#x3D;值;</span><br><span class="line">SELECT @变量名:&#x3D;值;</span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方式一：一般用于赋简单的值</span><br><span class="line">SET 变量名&#x3D;值;</span><br><span class="line">SET 变量名:&#x3D;值;</span><br><span class="line">SELECT 变量名:&#x3D;值;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方式二：一般用于赋表 中的字段值</span><br><span class="line">SELECT 字段名或表达式 INTO 变量</span><br><span class="line">FROM 表;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @变量名;</span><br></pre></td></tr></table></figure>

<p>二、局部变量</p>
<p>声明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare 变量名 类型 【default 值】;</span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方式一：一般用于赋简单的值</span><br><span class="line">SET 变量名&#x3D;值;</span><br><span class="line">SET 变量名:&#x3D;值;</span><br><span class="line">SELECT 变量名:&#x3D;值;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方式二：一般用于赋表 中的字段值</span><br><span class="line">SELECT 字段名或表达式 INTO 变量</span><br><span class="line">FROM 表;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 变量名</span><br></pre></td></tr></table></figure>

<p>二者的区别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">作用域         定义位置        语法</span><br></pre></td></tr></table></figure>

<p>用户变量    当前会话        会话的任何地方        加@符号，不用指定类型 局部变量    定义它的BEGIN END中     BEGIN END的第一句话    一般不用加@,需要指定类型</p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>一、if函数 语法：if(条件，值1，值2) 特点：可以用在任何位置</p>
<p>二、case语句</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">情况一：类似于switch</span><br><span class="line">case 表达式</span><br><span class="line">when 值1 then 结果1或语句1(如果是语句，需要加分号) </span><br><span class="line">when 值2 then 结果2或语句2(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line">else 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line">end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）</span><br><span class="line"></span><br><span class="line">情况二：类似于多重if</span><br><span class="line">case </span><br><span class="line">when 条件1 then 结果1或语句1(如果是语句，需要加分号) </span><br><span class="line">when 条件2 then 结果2或语句2(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line">else 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line">end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）</span><br></pre></td></tr></table></figure>

<p>特点： 可以用在任何位置</p>
<p>三、if elseif语句</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if 情况1 then 语句1;</span><br><span class="line">elseif 情况2 then 语句2;</span><br><span class="line">...</span><br><span class="line">else 语句n;</span><br><span class="line">end if;</span><br></pre></td></tr></table></figure>

<p>特点： 只能用在begin end中！！！！！！！！！！！！！！！</p>
<p>三者比较：         应用场合 if函数        简单双分支 case结构    等值判断 的多分支 if结构        区间判断 的多分支</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【标签：】WHILE 循环条件  DO</span><br><span class="line">    循环体</span><br><span class="line">END WHILE 【标签】;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">只能放在BEGIN END里面</span><br><span class="line"></span><br><span class="line">如果要搭配leave跳转语句，需要使用标签，否则可以不用标签</span><br><span class="line"></span><br><span class="line">leave类似于java中的break语句，跳出所在循环！！！</span><br></pre></td></tr></table></figure>



<blockquote>
<p>引用：尚硅谷—mysql基础语法总结</p>
</blockquote>
]]></content>
      <tags>
        <tag>技术积累</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>考试网油猴代码</title>
    <url>/2021/03/27/%E8%80%83%E8%AF%95%E7%BD%91%E6%B2%B9%E7%8C%B4%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name            考试资料网跳转显示答案</span></span><br><span class="line"><span class="comment">// @namespace       https://github.com/cuifeiran/ppkao/</span></span><br><span class="line"><span class="comment">// @version         0.1.7</span></span><br><span class="line"><span class="comment">// @description     对单个题目进行跳转，使得跳转后的页面显示题目的答案。期间可能需要验证,遇到问题可以在GitHub issue我～</span></span><br><span class="line"><span class="comment">// @author          Dave</span></span><br><span class="line"><span class="comment">// @match           *://www.ppkao.com/tiku/shiti/*</span></span><br><span class="line"><span class="comment">// @match           *://www.ppkao.com/kaoti/*</span></span><br><span class="line"><span class="comment">// @include         *://www.ppkao.com/tiku/shiti/*</span></span><br><span class="line"><span class="comment">// @include         *://www.ppkao.com/shiti/*</span></span><br><span class="line"><span class="comment">// @include         *://www.ppkao.com/kaoti/*</span></span><br><span class="line"><span class="comment">// @include         *://www.ppkao.com/daan/*</span></span><br><span class="line"><span class="comment">//@contributionURL</span></span><br><span class="line"><span class="comment">// @grant           none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="comment">//清除限制题目访问数量的cookie</span></span><br><span class="line">    <span class="keyword">var</span> Days = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">var</span> exp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    exp.setTime(exp.getTime() + Days*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">document</span>.cookie=<span class="string">&quot;PPKAO=PPKAOSTID=&amp;PPKAOCEID=&amp;PPKAOSJID=&amp;UserName=&amp;EDays=; domain=ppkao.com;expires=&quot;</span>+exp.toGMTString()+<span class="string">&quot;;path=/&quot;</span>;</span><br><span class="line">    <span class="comment">//获取当前页面URL</span></span><br><span class="line">    <span class="keyword">var</span> iSite = <span class="built_in">window</span>.location.href;</span><br><span class="line">    <span class="keyword">var</span> reg = <span class="regexp">/[1-9][0-9]*/g</span>;</span><br><span class="line">    <span class="keyword">var</span> numList = iSite.match(reg);</span><br><span class="line">    <span class="keyword">var</span> isKaoti =<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;kaoti&quot;</span>).test(iSite);</span><br><span class="line">    <span class="keyword">var</span> isTiku =<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;tiku&quot;</span>).test(iSite);</span><br><span class="line">    <span class="keyword">var</span> isShiti =<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;shiti&quot;</span>).test(iSite);</span><br><span class="line">    <span class="keyword">var</span> isDaan =<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;daan&quot;</span>).test(iSite);</span><br><span class="line">    <span class="keyword">var</span> sUrl=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (isKaoti===<span class="literal">true</span>)&#123;sUrl=<span class="string">&#x27;https://api.ppkao.com/mnkc/kaoti/?id=&#x27;</span>+ numList;<span class="built_in">window</span>.location.href =sUrl;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isTiku===<span class="literal">true</span>)&#123;sUrl=<span class="string">&#x27;https://api.ppkao.com/mnkc/tiku/?id=&#x27;</span>+ numList;<span class="built_in">window</span>.location.href =sUrl;&#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isShiti===<span class="literal">true</span>)&#123;sUrl=<span class="string">&#x27;https://newapi.ppkao.com/mnkc/shiti/?id=&#x27;</span>+ numList;<span class="built_in">window</span>.location.href =sUrl;&#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(isDaan===<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">var</span> html = <span class="string">&#x27;&lt;div id=&quot;showQRcode&quot; style=&quot;position: fixed;right:30px;bottom: 0px;&quot;&gt;&lt;a style=&quot;font-size:14px;color:red;background-color: white;display:block;&quot; href=&quot;https://raw.githubusercontent.com/cuifeiran/ppkao/master/donations&quot;&gt;[捐助名单]我在考研二战,愁于房租,致谢捐助者！&lt;/a&gt;&lt;a style=&quot;font-size: 14px;display:block;color:black;background-color: white;&quot; onclick=&quot;$(this).parent().remove();&quot; hidden=&quot;javascripe:void(0)&quot; &gt;[不想捐助点击这里]&lt;/a&gt;&lt;img width=&quot;420&quot; height=&quot;210&quot; src=&quot;https://s1.ax1x.com/2018/12/11/FJ47an.jpg&quot;&gt;&lt;/img&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line">                    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">                    div.setAttribute(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;showQRcode&#x27;</span>);</span><br><span class="line">                    div.innerHTML = html;</span><br><span class="line">                    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>娱乐</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 第三章 单链表</title>
    <url>/2020/09/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<ul>
<li><strong>读物</strong>：<a class="link"   href="https://book.douban.com/subject/6424904/" >《大话数据结构》<i class="fas fa-external-link-alt"></i></a></li>
<li><strong>印次</strong>：2020年5月第25次印刷(2020.5重印)</li>
</ul>
<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ol>
<li><strong>线性表链式存储结构定义</strong></li>
<li><strong>单链表的创建</strong></li>
<li><strong>单链表的读取</strong></li>
<li><strong>单链表的插入和删除</strong></li>
<li><strong>总结</strong></li>
</ol>
<h1 id="线性表链式存储结构定义"><a href="#线性表链式存储结构定义" class="headerlink" title="线性表链式存储结构定义"></a>线性表链式存储结构定义</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>为<strong>保持线性结构“前驱后继，一对一”逻辑结构</strong>前提下，同时<strong>避免</strong>顺序存储结构中对<strong>相邻关系的依赖性</strong>。链式结构，除了要存<strong>数据元素信息</strong>外，还要存储它的<strong>后继元素</strong>的存储<strong>地址</strong>。</p>
<ul>
<li><strong>数据域</strong>：存储<strong>数据</strong>元素信息的域</li>
<li><strong>指针域</strong>：存储<strong>直接后继位置</strong>的域，其中存储的信息称做<strong>指针或链</strong></li>
<li><strong>结点(Node)：数据域和指针域</strong>组成数据元素a<sub>i</sub>的存储映像</li>
<li><strong>链表</strong>：由n个结点链成的一个链表</li>
<li><strong>单链表</strong>：链表中的<strong>每个结点</strong>只包含<strong>一个指针域</strong></li>
</ul>
<p>单链表正是通过每个结点的<strong>指针域</strong>将线性表的数据元素按其逻辑次序链接在一起，如图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD.png"
                      alt="链式存储结构"
                ></p>
<h2 id="线性表链式存储结构代码描述"><a href="#线性表链式存储结构代码描述" class="headerlink" title="线性表链式存储结构代码描述"></a>线性表链式存储结构代码描述</h2><ol>
<li>相关规定，线性链表的<strong>最后一个结点</strong>为“<strong>空</strong>”(用NULL或“^”符号表示)</li>
<li><strong>头结点</strong>：在单链表的<strong>第一个结点</strong>前附设的一个结点，<strong>指针域指向第一个结点</strong>，若指针域为“<strong>空</strong>”，表示<strong>线性表为空</strong></li>
</ol>
<blockquote>
<p>头结点主要作用是为便于对链表进行统一操作，头结点的数据域可不存储信息，或者存储线性表长度等附加信息。</p>
</blockquote>
<h2 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线性表的单链表存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span><span class="comment">//定义LinkList，指针变量的typedef</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong><code>typedef struct Node &#123;...&#125;Node;</code></strong>中的Node同名对象(实例)<strong>Node</strong>的作用：常用于为sizeof()函数传参。</p>
</li>
<li><p><strong><code>typedef struct Node *LinkList;</code></strong> <strong>语法</strong>理解：如<code>typedef int Status;</code> ‘<strong>Status</strong>‘等价于<strong>int</strong>，在这里可以看作类似变量的声明，即</p>
<p>声明一个int类型变量Status <code>int Status</code>，而<code>int *Status</code>表示定义一个int型的<strong>指针变量</strong>。同样类比在typedef中，<strong>“*”</strong>表示typedef的对象是Node <strong>结构体的指针变量</strong>，即LinkList 等价于 <strong><code>struct Node *linkList;</code></strong> (不过写法上确实有点新颖，有点融合着写)</p>
</li>
</ol>
<h1 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h1><p><strong>工作指针</strong>：对于链表的元素定位操作，常常需要通过计数器<strong>从头到尾</strong>遍历计数而确定某一元素位置的指针，而<strong>“从头”</strong>不能直接用头结点直接指针后移遍历的，因为这样会失去了头结点原本的意义与功能。  </p>
<p><strong>因此常声明一个变量p存储头结点指针域来完成之后的指针偏移遍历操作</strong>，一般将这个从头开始复杂遍历的指针称为<strong>工作指针</strong>  </p>
<p><strong>“工作指针后移”</strong>则是工作指针通常的工作状态。</p>
<h2 id="GetElem"><a href="#GetElem" class="headerlink" title="GetElem"></a>GetElem</h2><p>思路：</p>
<ol>
<li>声明一个<strong>工作指针 p</strong>，指向链表的<strong>第一个结点</strong>(查询不查头结点)。</li>
<li>设置计时器变量 j，并初始化为1，通过<strong>重新数数</strong>的方式找到序号位置。</li>
<li>当j&lt;i时，遍历链表，让p的<strong>指针向后移动</strong>，称为<strong>“工作指针后移”</strong>，计时器j累加1.</li>
<li>若到链表末尾p为空，则说明第i个结点不存在。</li>
<li>否则查找成功，返回结点p的数据。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span></span><br><span class="line"><span class="comment">/* 操作结果：用e返回L中第i个数据元素的值 */</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType *e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//--------------查询部分---------------</span></span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	LinkList p;			<span class="comment">/* 声明工作指针p */</span></span><br><span class="line">	p = L-&gt;next;		<span class="comment">/* 让p指向链表L的第一个结点 */</span></span><br><span class="line">	j = <span class="number">1</span>;				<span class="comment">/*  j为计数器 */</span></span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; j&lt;i)&#123;  	<span class="comment">/* p不为空或者计数器j还没有等于i时，循环继续 */</span></span><br><span class="line">		p = p-&gt;next;  	<span class="comment">/* 让p指向下一个结点 */</span></span><br><span class="line">		++j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ( !p || j&gt;i ) 	<span class="comment">//注意这里是 大于 &gt; 符号</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;  <span class="comment">/*  第i个元素不存在 */</span></span><br><span class="line">     <span class="comment">//--------------查询部分---------------</span></span><br><span class="line">	*e = p-&gt;data;   <span class="comment">/*  取第i个元素的数据 */</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>链式存储<strong>没有表长</strong>，更加没有序号。事先不知循环次数，只能设置计数器，使用while循环解决;</li>
<li>最坏情况复杂度是O(n);</li>
</ul>
<h1 id="单链表的创建"><a href="#单链表的创建" class="headerlink" title="单链表的创建"></a>单链表的创建</h1><h2 id="单链表的初始化"><a href="#单链表的初始化" class="headerlink" title="单链表的初始化"></a>单链表的初始化</h2><p>单链表的初始化，即空表的建立</p>
<h3 id="InitList"><a href="#InitList" class="headerlink" title="InitList"></a>InitList</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化顺序线性表 */</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(LinkList *L)</span> </span>&#123; </span><br><span class="line">    *L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">/* 产生头结点(向内存申请一个结点的空间),并使L指向此头结点 */</span></span><br><span class="line">    <span class="keyword">if</span>(!(*L)) 	<span class="comment">/* 存储分配失败 */</span></span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">    (*L)-&gt;next=<span class="literal">NULL</span>;	 <span class="comment">/* 指针域为空 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>malloc</strong>函数：<code>void *malloc(long NumBytes)</code>向<strong>内存</strong>申请NumBytes个字节的空间，并返回了指向这块内存的指针。若分配失败，则返回一个空指针(NULL）,如系统空间不足等失败情况。使用malloc函数需注意如下几点：</p>
<ul>
<li><p>申请了内存空间后，必须<strong>检查是否分配成功</strong>。</p>
</li>
<li><p>当不需要再使用申请的内存时，记得<strong>释放</strong>；并把这块内存的指针<strong>指向NULL</strong>，防止程序后面不小心使用了它。</p>
</li>
<li><p><strong>malloc与free</strong>这两个函数应该是<strong>配对使用</strong>。如果申请后不释放就是<strong>内存泄露</strong>；如果无故释放那就是什么也没有做。释放只能一次，如果释放两次及两次以上会出现错误（释放空指针例外，释放空指针其实也等于啥也没做，所以释放空指针释放多少次都没有问题）。</p>
</li>
<li><p>虽然malloc()函数的<strong>类型是(void *)</strong>，任何类型的指针都可以转换成(void *),但是最好还是在前面进行<strong>强制类型转换</strong>，因为这样可以躲过一些编译器的检查。</p>
<blockquote>
<p>参考链接：<a class="link"   href="https://blog.csdn.net/Rex_WUST/article/details/88343311" >malloc()和free()的基本概念以及基本用法<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>LinkList *L<strong>形参的理解</strong>：</p>
<ul>
<li><p><code>Status InitList(LinkList *L)</code>注意，此时传入形参L已是<strong>二级指针</strong>(指针的指针)。</p>
</li>
<li><p>一级指针与二级指针的区别与使用： </p>
<p>形参传递永远是<strong>值传递</strong>(临时变量)，想要<strong>通过调用函数</strong>去改变传入<strong>实参的内容</strong>，<strong>则需要至少传入欲修改参数类型基础上的一级指针</strong>，<strong>并且</strong>通过<strong>“*” 调用实体内容进行修改</strong>。而并不能仅修改传入新参的内容，因为新参内容本身怎么修改都不会影响传入的实参。(值传递原则)</p>
<ul>
<li><p>当<strong>传值</strong>时，只可以引用值而<strong>不可以改变值</strong>，</p>
</li>
<li><p>当你<strong>传指针</strong>时，只可以改变指针所指的内容，<strong>不可以改变指针本身</strong></p>
</li>
<li><p>但<strong>传指针的指针</strong>时，即可以改变指针<strong>所指的内容</strong>，又<strong>可以改变指针本身</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>LinkList *L<strong>二级指针的用处</strong>：<br><strong>回归目的本身，很明确。即想要<code>LinkList L;</code>这个指针变量L最终指向通过malloc函数申请空间后返回的地址值</strong>(即地址的赋值)。理应<code>L=malloc(sizeof(Node));</code>即可，从一条语句操作上是完全正确的，类型也是一致的。<strong>但</strong>问题在于如今想要<strong>通过调用函数且把L作为实参传入修改其地址值</strong>。这样的前提下，若只传入想要修改内容类型的本身(这里就是指针变量/一级指针)，安装<strong>值传递</strong>原则是<strong>达不到效果</strong>的，代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(LinkList L)</span> </span>&#123; <span class="comment">//形参修改成一级指针</span></span><br><span class="line">	L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); </span><br><span class="line">	<span class="keyword">if</span> (!(L)) 	</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	L-&gt;next = <span class="literal">NULL</span>;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LinkList L = <span class="literal">NULL</span>;</span><br><span class="line">	InitList(L);</span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;L=NULL&quot;</span>);<span class="comment">//最终L还是NULL被打印出来，没有被改变</span></span><br><span class="line">	getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>“想要<strong>通过调用函数</strong>去改变传入<strong>实参的内容</strong>，则需要<strong>至少传入欲修改参数类型基础上的一级指针</strong>”</strong>，即先要修改指针值本身，则至少需要传入该参数类型上的一级指针，即指针的指针，这就是<code>Status InitList(LinkList L) &#123;...&#125; </code>二级指针形参的意义。</p>
<blockquote>
<p>参考链接：</p>
<ul>
<li><p><a class="link"   href="https://www.cnblogs.com/AndyJee/p/4630153.html" >(C++)函数参数传递中的一级指针和二级指针<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://www.kanzhun.com/mianshiti/236837.html" >引用传递和值传递以及链表中的LinkList L、LinkList *L、LinkList &amp;L<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h2><p>单链表的整表创建又分为<strong>“头插法”，“尾插法”</strong>两种。</p>
<h3 id="CreateListHead"><a href="#CreateListHead" class="headerlink" title="CreateListHead"></a>CreateListHead</h3><p><strong>“头插法”</strong>即新结点的指针域通过<strong>修改i - 1结点的后继节点指向</strong>完成结点的插入。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（头插法） */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateListHead</span><span class="params">(LinkList *L, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	LinkList s;<span class="comment">//初始化一个即将插入新结点</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	srand(time(<span class="number">0</span>));                         <span class="comment">/* 初始化(修改)随机数种子 */</span></span><br><span class="line">	*L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	(*L)-&gt;next = <span class="literal">NULL</span>;                      <span class="comment">/*  先建立一个带头结点的单链表 */</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">/*  生成新结点 */</span></span><br><span class="line">		s-&gt;data = rand()%<span class="number">100</span>+<span class="number">1</span>;             <span class="comment">/*  随机生成100以内的数字填充数据域 */</span></span><br><span class="line">        </span><br><span class="line">		s-&gt;next = (*L)-&gt;next;    </span><br><span class="line">		(*L)-&gt;next = p;						<span class="comment">/*  插入到表头 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>srand函数与rand函数使用</strong>(stdio.h)</p>
<ul>
<li><p><code>void srand(unsigned int seed)</code>：设置随机数种子</p>
<p>srand函数用来<strong>设置</strong>rand函数产生随机数时的随机数种子，参数seed必须是整数，通常可以用time(0)的返回值作为seed。<strong>如果每次seed都设置相同的值，rand()产生</strong> <strong><em>一系列</em></strong> <strong>随机数值每次都一样</strong>。当计算机正常开机后，随机种子的值是定了的，除非你破坏了系统，或者通过srand函数修改。</p>
</li>
<li><p><code>int rand(void)</code>：生成随机数</p>
<p>在0到RAND_MAX之间的整数值生成一个随机数，rand的内部是用线性同余法做的，不是真的随机数，只不过因为其周期特别长，所以在一定范围内可以看成是随机的。(RAND_MAX的范围最少在32767之间（int），即双字节（16位）。若unsigned int双字节是65535)</p>
</li>
</ul>
<blockquote>
<p>参考链接：<a class="link"   href="https://blog.csdn.net/qq_15020543/article/details/80656784" >C语言的srand与rand函数浅谈<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
</li>
<li><p><strong>time函数的使用</strong></p>
<p>函数原型：<code>time_t time(time_t *seconds)</code></p>
<p>time函数用于返回格林尼治时间(1970年1月1日00:00:00到当前时刻的时长)，单位是秒。存在与&lt;time.h&gt;库，一般使用方式<code>t1=time(NULL) 或 t1=time(0)</code>来获取当前格林尼治时间。</p>
</li>
</ol>
<h3 id="CreateListTail"><a href="#CreateListTail" class="headerlink" title="CreateListTail"></a>CreateListTail</h3><p><strong>“尾插法”</strong>，符合日常排队思维，后到的排在后。为了方便操作，<strong>需要引入尾指针概念</strong></p>
<p><strong>尾指针</strong>：</p>
<ul>
<li><p><strong>功能</strong>：用于指向当前链表的<strong>终端结点</strong></p>
</li>
<li><p><strong>初始化</strong>：与头结点一致，均指向头指针。(<strong>类似队列初始化</strong>)</p>
</li>
<li><p><strong>基于尾指针功能的插入逻辑</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">r-&gt;next = s;<span class="comment">//英文尾指针就是指向链表的终端结点，而实现向后插入，则直接插入在尾结点后即可</span></span><br><span class="line">r = s; <span class="comment">//而从尾指针后面插入的新元素必将是新的尾结点，所以把它定义为新的尾指针即可</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>CreateListTail</strong>尾插法实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateListTail</span><span class="params">(LinkList *L, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	LinkList s,r;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	srand(time(<span class="number">0</span>));                      <span class="comment">/* 初始化随机数种子 */</span></span><br><span class="line">	*L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">/* L为整个线性表 */</span></span><br><span class="line">	r=*L;                                <span class="comment">/* 尾指针初始化 */</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		s = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">/*  生成新结点 */</span></span><br><span class="line">		s-&gt;data = rand()%<span class="number">100</span>+<span class="number">1</span>;           <span class="comment">/*  随机生成100以内的数字 */</span></span><br><span class="line">		r-&gt;next=s;                        <span class="comment">/* 将表尾终端结点的指针指向新结点 */</span></span><br><span class="line">		r = s;                            <span class="comment">/* 将当前的新结点定义为表尾终端结点 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	r-&gt;next = <span class="literal">NULL</span>;                       <span class="comment">/* 表示当前链表结束 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><del>除了首次循环r是头结点，其余r成为了永远的尾结点。</del></p>
</li>
<li><p><del><strong><code>r = p;</code></strong>功能是，注意这里<strong>没有真正修改了地址值</strong>，而是局部变量顺应循环设计的<strong>循环变换</strong>，变换内容是<strong>将最新插入的结点成为下次循环的尾结点</strong>。</del></p>
<p><strong>删除内容说明</strong>：</p>
<ol>
<li>通过学习“《数据结构》——从概念到C++实现(第3版)” 认识实现结点从后面插入的<strong>逻辑实现原理</strong>是基于到对尾插法是利用<strong>尾指针功能的本身</strong>。—— 2020年9月26日</li>
</ol>
</li>
</ul>
<hr>
<h1 id="GetElem与链式插入操作小结"><a href="#GetElem与链式插入操作小结" class="headerlink" title="GetElem与链式插入操作小结"></a>GetElem与链式插入操作小结</h1><h2 id="工作指针："><a href="#工作指针：" class="headerlink" title="工作指针："></a>工作指针：</h2><ul>
<li>常表<strong>定位指针</strong>，定位方式通常为<strong>工作指针后移</strong> <code>p = p-&gt;next;</code></li>
</ul>
<table>
<thead>
<tr>
<th>GetElem</th>
<th>头插法</th>
<th>尾插法</th>
<th>删除</th>
</tr>
</thead>
<tbody><tr>
<td>初始为<strong>头指针</strong>，<strong>同步定位 i</strong></td>
<td>初始为<strong>头结点</strong>，定位 i 的<strong>前继结点</strong></td>
<td>同左</td>
<td>同左</td>
</tr>
<tr>
<td><code>LinkList p = L-&gt;next</code></td>
<td><code>LinkList p = *L</code></td>
<td>同左</td>
<td>同左</td>
</tr>
</tbody></table>
<p>tip：i 表示顺序表的位置</p>
<h2 id="头插法实质："><a href="#头插法实质：" class="headerlink" title="头插法实质："></a>头插法实质：</h2><p>头插法：<strong>利用头指针“插入逻辑”</strong>进行插入的方法</p>
<ul>
<li><strong>插入逻辑</strong>：<strong>“逆序操作”</strong>，防止与<strong>当前操作结点的后继结点失去联系的操作</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s-&gt;next = p-&gt;next; <span class="comment">//p表示工作指针，在插入操作，p是定位到i-1位置，即插入位置的前继结点。</span></span><br><span class="line">				 <span class="comment">//s表示即将插入的新结点</span></span><br><span class="line">p-&gt;next = s;</span><br></pre></td></tr></table></figure>



<h2 id="尾插法实质："><a href="#尾插法实质：" class="headerlink" title="尾插法实质："></a>尾插法实质：</h2><p>尾插法：<strong>基于尾指针“功能”</strong>的插入逻辑进行插入的方法</p>
<ul>
<li><strong>功能</strong>：用于指向当前链表的<strong>终端结点</strong></li>
<li><strong>初始化</strong>：与头结点一致，均指向头指针。(<strong>类似队列初始化</strong>)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">r-&gt;next = s;<span class="comment">//英文尾指针就是指向链表的终端结点，而实现向后插入，则直接插入在尾结点后即可</span></span><br><span class="line">r = s; <span class="comment">//而从尾指针后面插入的新元素必将是新的尾结点，所以把它定义为新的尾指针即可</span></span><br></pre></td></tr></table></figure>


<h2 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h2><p><strong>思路</strong>：</p>
<ol>
<li>声明一结点p和q；</li>
<li>将第一个结点赋值给p；</li>
<li>循环：<ul>
<li>将下一个结点赋值给q；</li>
<li>释放p；</li>
<li>将q赋值给p</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */</span></span><br><span class="line"><span class="function">Status <span class="title">ClearList</span><span class="params">(LinkList *L)</span></span>&#123; </span><br><span class="line">	LinkList p,q;</span><br><span class="line">	p=(*L)-&gt;next;           <span class="comment">/*  p指向第一个结点 */</span></span><br><span class="line">	<span class="keyword">while</span>(p)&#123;               <span class="comment">/*  没到表尾 */</span></span><br><span class="line">		q=p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		p=q;</span><br><span class="line">	&#125;</span><br><span class="line">	(*L)-&gt;next=<span class="literal">NULL</span>;        <span class="comment">/* 头结点指针域为空 */</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>free函数，它的作用就是让系统回收一个Node结点，释放内存。</p>
<h1 id="单链表的插入和删除"><a href="#单链表的插入和删除" class="headerlink" title="单链表的插入和删除"></a>单链表的插入和删除</h1><h2 id="ListInsert"><a href="#ListInsert" class="headerlink" title="ListInsert"></a>ListInsert</h2><p>思路：</p>
<ol>
<li>按照插入原理，首先需定位到<strong>i -1</strong>结点位置，即插入位置的<strong>前继结点</strong>，调整GetElem函数查询部分代码即可；</li>
<li>创建<strong>空节点s</strong>，并把数据元素e填充到数据域；</li>
<li>插入原理(<strong>头插法</strong>)：<strong><code>s-&gt;next = p-&gt;next;   P-&gt;next=s;</code></strong>；</li>
<li>返回成功；</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */</span></span><br><span class="line"><span class="comment">/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(LinkList *L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	LinkList p,s;</span><br><span class="line">	p = *L;   </span><br><span class="line">	j = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; j &lt; i)&#123;     <span class="comment">/* 寻找第i-1个结点 */</span></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		++j;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (!p || j &gt; i) </span><br><span class="line">		<span class="keyword">return</span> ERROR;   <span class="comment">/* 第i个元素不存在 */</span></span><br><span class="line">	s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">/*  生成新结点(C语言标准函数) */</span></span><br><span class="line">	s-&gt;data = e;  </span><br><span class="line">	s-&gt;next = p-&gt;next;      <span class="comment">/* 将p的后继结点赋值给s的后继  */</span></span><br><span class="line">	p-&gt;next = s;          <span class="comment">/* 将s赋值给p的后继 */</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">**要点**：</span><br><span class="line"></span><br><span class="line">- ListInsert函数巧妙将p赋值为**头结点地址**`p = *L;`来实现定位**i - <span class="number">1</span>**结点位置功能(插入位置的前继结点)。有别于GetElem函数`p = (*L)-&gt;next;`。</span><br><span class="line">- 插入原理：新结点的指针域通过**修改i - <span class="number">1</span>结点的后继节点指向**完成结点的插入。</span><br><span class="line">- 插入原理的两条语句**不能颠倒执行顺序**。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## ListDelete</span><br><span class="line"></span><br><span class="line">**思路**：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 按照删除原理，同样需定位到**i <span class="number">-1</span> **结点位置，并且**不能删除头结点**；</span><br><span class="line"><span class="number">1.</span> 定位成功后，创建一个用于临时存放的节点指针q，将欲删除的节点p-&gt;next赋值给q；</span><br><span class="line"><span class="number">1.</span> 将q节点中的数据赋值给e，作为返回；</span><br><span class="line"><span class="number">1.</span> 释放q节点；</span><br><span class="line"><span class="number">1.</span> 返回成功；</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span></span><br><span class="line"><span class="comment">/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(LinkList *L,<span class="keyword">int</span> i,ElemType *e)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	LinkList p,q;</span><br><span class="line">	p = *L;</span><br><span class="line">	j = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i)&#123;	<span class="comment">/* 遍历寻找第i个元素 */</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!(p-&gt;next) || j &gt; i) </span><br><span class="line">	    <span class="keyword">return</span> ERROR;           <span class="comment">/* 第i个元素不存在 */</span></span><br><span class="line">	q = p-&gt;next;</span><br><span class="line">	p-&gt;next = q-&gt;next;			<span class="comment">/* 将q的后继赋值给p的后继 */</span></span><br><span class="line">	*e = q-&gt;data;               <span class="comment">/* 将q结点中的数据给e */</span></span><br><span class="line">	<span class="built_in">free</span>(q);                    <span class="comment">/* 让系统回收此结点，释放内存 */</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>要点</strong>：</p>
<ul>
<li>有别于GetElem与ListInsert函数while或if条件<code>p</code>，ListDelete函数的条件改为<code>p-&gt;next</code>。<ul>
<li>GetElem条件判断<code>p</code>是否为NULL，是因为p的初始值就定义成 <code>p = (*)L-&gt;next</code>，不存在对头结点操作的可能性;</li>
<li>ListInsert条件判断<code>p</code>是否为NULL，是因为插入数据是<strong>允许空表插入</strong>;</li>
<li>ListDelete条件判断<code>p</code>是否为NULL，是因为删除<strong>不允许空表删除</strong>。</li>
</ul>
</li>
<li>与整表删除要点一致，均需要通过一个变量<code>q</code>去记录将要删除的结点地址，不然会丢失地址，造成内存泄漏。</li>
</ul>
<h2 id="插入和删除复杂度分析"><a href="#插入和删除复杂度分析" class="headerlink" title="插入和删除复杂度分析"></a>插入和删除复杂度分析</h2><ul>
<li>当<strong>不知第i个结点指针位置</strong>(首次插入/删除)，时间复杂度为<strong>O(n)</strong>；</li>
<li>若需要在i个位置插入若干个结点，则<strong>除了第一次外其余结点</strong>插入或删除的时间复杂度为<strong>O(1)</strong>；</li>
</ul>
<p>结论：<strong>插入或删除数据越频繁的操作，单链表的效率优势就越明显</strong>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="单链表各方法实现思路"><a href="#单链表各方法实现思路" class="headerlink" title="单链表各方法实现思路"></a>单链表各方法实现思路</h2><ul>
<li><strong>GetEelm</strong>：<strong>计数器</strong> + <strong>while循环匹配</strong> + <strong>工作指针后移</strong> <code>p-&gt;next = p</code>;；</li>
<li><strong>ListInsert</strong> / <strong>CreateListHead</strong>：均采用了插入的方法，`s-&gt;next=p-&gt;next;  p-&gt;next=s;；</li>
<li><strong>ListInsert</strong>/ <strong>ListDelete</strong>：均需要定位到欲操作位置的<strong>前继结点</strong>，通过初始赋值头结点地址<code>p=(*L)</code>；</li>
<li><strong>ListDelete</strong>：<ul>
<li><strong>“绕指针删除”</strong><code>q=p-&gt;next; p-&gt;next=q-&gt;next;</code>；</li>
<li>ListDelete / <strong>ClearList</strong>：均需将欲删除结点用另一个变量暂存后再删除，不然会丢失地址，造成内存泄漏；</li>
</ul>
</li>
<li><strong>CreateListTail</strong> / <strong>ClearList</strong>：同样在循环内通过局部变量直接交换节点地址实现，节点操作按序进行(从前到后)，如尾插法<code>r-&gt;next=p; r =p;</code>或整表删除<code>q=p-&gt;next; free(p); p=q;</code></li>
</ul>
<h2 id="不同操作中指针类型的要求"><a href="#不同操作中指针类型的要求" class="headerlink" title="不同操作中指针类型的要求"></a>不同操作中指针类型的要求</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>形参传递永远是<strong>值传递</strong>(临时变量)，想要<strong>通过调用函数</strong>去改变传入<strong>实参的内容</strong>必须：</p>
<ol>
<li><strong>至少传入欲修改参数类型基础上的一级指针</strong></li>
<li>*<em>通过<strong>“</em>” 调用实体内容进行修改</strong>。</li>
</ol>
<h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><ul>
<li>当<strong>传值</strong>时，只可以引用值而<strong>不可以改变值</strong>，</li>
<li>当你<strong>传指针</strong>时，只可以改变指针所指的内容，<strong>不可以改变指针本身</strong></li>
<li>但<strong>传指针的指针</strong>时，即可以改变指针<strong>所指的内容</strong>，又<strong>可以改变指针本身</strong></li>
</ul>
<hr>
<ul>
<li><strong>初始化链表</strong>需要用<strong>二级指针</strong>；</li>
<li><strong>销毁链表</strong>(头结点也销毁)需要用到<strong>二级指针</strong>；</li>
<li><strong>插入、删除、遍历、清空</strong>结点用<strong>一级指针</strong>即可；</li>
</ul>
<h2 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h2><table>
<thead>
<tr>
<th>存储结构</th>
<th align="left">存储分配方式</th>
<th align="left">时间性能</th>
<th align="center">空间性能</th>
</tr>
</thead>
<tbody><tr>
<td>顺序存储</td>
<td align="left">连续存储单元</td>
<td align="left">查找：O(1)，插删：O(n)</td>
<td align="center">需预定分配存储空间，而大小不好掌握</td>
</tr>
<tr>
<td>链式存储</td>
<td align="left">任意存储单元</td>
<td align="left">查找：O(n)，插删：O(n) 或 O(1)</td>
<td align="center">无需事先预定，内存有空间即可，不限数量</td>
</tr>
</tbody></table>
<ul>
<li>若线性表需要<strong>频繁查找</strong>且<strong>很少进行插入和删除操作</strong>，宜采用<strong>顺序存储结构</strong>；<ul>
<li>如用户注册的个人信息，除了注册时插入数据外，绝大多数都是读取而且</li>
</ul>
</li>
<li>若线性表需要<strong>频繁增加和删除</strong>，宜采用<strong>链式存储结构</strong>；<ul>
<li>如游戏中玩家的武器装备仓库列表等</li>
</ul>
</li>
<li>若线性表<strong>元素个数</strong>变化较大，或者根本不知道有多大时，最好用<strong>单链表结构</strong>不用考虑空间分配问题；</li>
</ul>
]]></content>
      <tags>
        <tag>技术积累</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 第六章 树</title>
    <url>/2020/10/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%A0%91/</url>
    <content><![CDATA[<ul>
<li><strong>读物</strong>：<a class="link"   href="https://book.douban.com/subject/6424904/" >《大话数据结构》<i class="fas fa-external-link-alt"></i></a></li>
<li><strong>印次</strong>：2020年5月第25次印刷(2020.5重印)</li>
</ul>
<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ol>
<li><strong>树的定义</strong></li>
<li><strong>树的相关概念</strong></li>
<li><strong>树的存储结构</strong></li>
<li><strong>二叉树</strong></li>
<li><strong>二叉树的性质</strong></li>
</ol>
<h1 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h1><ol>
<li>树(Tree)是n(n ≥ 0)个结点的<strong>有限集</strong>，n = 0则为<strong>空树</strong></li>
<li>在任意一颗树中，<strong>有且仅有一个</strong>称为<strong>根</strong>(Root)的结点</li>
<li>当结点 n &gt; 1，<strong>其余结点</strong>可分为m个<strong>互不相交</strong>的有限集T<sub>1</sub>、T<sub>2</sub>、…T<sub>m</sub></li>
<li>其中每个互不相交的有限集本身<strong>又是一颗树</strong>，并称为<strong>根的子树</strong>(SubTree)</li>
</ol>
<p>核心：有且仅有一个<strong>称为</strong>根**整个树的根结点唯一，子树互不相交</p>
<h1 id="树的相关概念"><a href="#树的相关概念" class="headerlink" title="树的相关概念"></a>树的相关概念</h1><h2 id="结点类型"><a href="#结点类型" class="headerlink" title="结点类型"></a>结点类型</h2><p><strong>度(Degree)：结点 拥有的子树的数量，所有结点最大的度称为该数的度</strong></p>
<ol>
<li><strong>叶结点(Leaf)或终端节点</strong>：度 = <strong>0</strong>；</li>
<li><strong>非终端结点或分支结点</strong>：度 <strong>≠ 0</strong>；，此类结点<strong>除根结点外</strong>，也可称为<strong>内部结点</strong></li>
</ol>
<h2 id="结点间的关系"><a href="#结点间的关系" class="headerlink" title="结点间的关系"></a>结点间的关系</h2><ol>
<li><strong>孩子(Child) 与 双亲(Parent) </strong>：结点的<strong>子树的根</strong>称为该结点的<strong>孩子(Child)</strong>，相应地，该节点称为孩子的双亲</li>
<li><strong>兄弟(Sibling)</strong>：同一个双亲的孩子之间互称兄弟</li>
<li><strong>祖先</strong>：结点的祖先是<strong>从根到该结点所经历分支上的所有结点</strong></li>
<li><strong>子孙</strong>：以某结点为根，的子树中的任一结点都称为该结点的子孙</li>
</ol>
<h2 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h2><ol>
<li><strong>层次(Level)</strong>：<strong>从根开始定义，根为第一层</strong></li>
<li><strong>堂兄弟</strong>：<strong>双亲在同一层结点</strong></li>
<li><strong>深度(Depth)或高度</strong>：树种结点最大的层次，称为树的深度</li>
<li><strong>宽度</strong>：每一层结点个数的<strong>最大值</strong></li>
<li><strong>路径</strong>：略</li>
</ol>
<h2 id="树的类型"><a href="#树的类型" class="headerlink" title="树的类型"></a>树的类型</h2><ol>
<li>森林(forest)：是m颗(m≥0)颗互不相交的树的集合。对树种的每个结点而言，<strong>其子树的集合</strong>即为森林</li>
<li>有序树 与 无序树：</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.jpg"
                      alt="树的基本概念"
                ></p>
<h1 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h1><p>有别于线性表，树是一对多的结构，无论哪一种顺序存储结构的不能体现出这个关系，所以必须与链式存储结构结合起来表示。</p>
<ul>
<li><strong>双亲表示法</strong></li>
<li><strong>孩子表示法</strong></li>
<li><strong>孩子兄弟表示法</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg"
                      alt="树的存储结构"
                ></p>
<h2 id="双亲表示法实现"><a href="#双亲表示法实现" class="headerlink" title="双亲表示法实现"></a>双亲表示法实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 树的双亲表示法结点结构定义 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="comment">/* 树结点的数据类型，目前暂定为整型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> TElemType;              </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结点结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>&#123;</span></span><br><span class="line">   </span><br><span class="line">    TElemType data; <span class="comment">/* 结点数据 */</span>                 </span><br><span class="line">    <span class="keyword">int</span> parent;   <span class="comment">/* 双亲位置 */</span>             </span><br><span class="line">&#125; PTNode;</span><br><span class="line"><span class="comment">/* 树结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE]; <span class="comment">/* 结点数组 */</span> </span><br><span class="line">    <span class="keyword">int</span> r, n; <span class="comment">/* 根的位置和结点数 */</span>                      </span><br><span class="line">&#125; PTree;</span><br></pre></td></tr></table></figure>





<h2 id="孩子表示法实现"><a href="#孩子表示法实现" class="headerlink" title="孩子表示法实现"></a>孩子表示法实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 树的孩子表示法结构定义 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="comment">/* 孩子结点 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *ChildPtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 表头结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">&#125; CTBox;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 树结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE]; <span class="comment">/* 结点数组 */</span>  </span><br><span class="line">    <span class="keyword">int</span> r,n; <span class="comment">/* 根的位置和结点数 */</span>                      </span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure>

<h2 id="孩子兄弟表示法实现"><a href="#孩子兄弟表示法实现" class="headerlink" title="孩子兄弟表示法实现"></a>孩子兄弟表示法实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 树的孩子兄弟表示法结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">rightsib</span>;</span></span><br><span class="line">&#125; CSNode, *CSTree;</span><br></pre></td></tr></table></figure>



<h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><p><strong>树的遍历</strong>：<strong>按照某种次序</strong>，访问树中<strong>所有结点</strong>，且每个结点<strong>有且只有一次被访问</strong>。若<strong>规定从左到右遍历</strong>，树的遍历一般存在<strong>三种</strong></p>
<ul>
<li>前序(根)遍历</li>
<li>后序(根)遍历</li>
<li>层序(跟)遍历</li>
</ul>
<p>tips：若树为<strong>二叉树</strong>，则还有一种<strong>中序遍历</strong></p>
<p>注意：</p>
<ol>
<li>前提规定“从左到右”表示，无论哪种遍历，都是决定<strong>从左子树，到右子树</strong></li>
</ol>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>​    从根节点开始<strong>遍历</strong>，从<strong>上到下</strong>，按<strong>先左子树</strong>，<strong>后右子树</strong>的顺序遍历<strong>每一颗子树</strong></p>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>​    从根结点<strong>出发(不遍历)</strong>，从<strong>下到上</strong>，同样按<strong>先左子树</strong>，<strong>后右子树</strong>的顺序遍历<strong>每一颗子树</strong>。最后再遍历每颗子树的根结点</p>
<h3 id="层序遍历-广度遍历"><a href="#层序遍历-广度遍历" class="headerlink" title="层序遍历/广度遍历"></a>层序遍历/广度遍历</h3><p>​    从根结点开始，<strong>自上而下，从左到右，逐层遍历</strong></p>
<p><del>### 前序遍历</del></p>
<ol>
<li><del>访问树的根结点</del></li>
<li><del>从左到右的顺序前序遍历(从上到下)，遍历分别为根结点的每一颗子树</del><ul>
<li><del>访问根结点，从左到右遍历根结点的孩子，若孩子又存在子树(即根节点)，从1开始循环</del></li>
</ul>
</li>
</ol>
<h3 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a><del>后序遍历</del></h3><ol>
<li><del>从左到右的顺序后序遍历(从下到上)，遍历分别为根结点的每一颗子树</del></li>
<li><del>最后访问根结点</del><ul>
<li><del>从左到右，从下到上，即从最下底层左子树开始，从左到右遍历。每颗子树的根结点总是最后遍历</del></li>
</ul>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%A0%91%E7%9A%84%E4%B8%89%E5%A4%A7%E5%9F%BA%E7%A1%80%E9%81%8D%E5%8E%86.png"
                      alt="树的遍历"
                ></p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><ol>
<li><strong>二叉树(Binary Tree)</strong>的每个结点<strong>最多只有两颗子树</strong>(即可以没有子树，或者有一颗也行，即树的度最大为2)</li>
<li>左子树和右子树是<strong>有顺序</strong>的，注意区别。因此二叉树存在<strong>五种基本状态</strong><ul>
<li>空二叉树</li>
<li>只有一个根节点</li>
<li>根结点只有左子树</li>
<li>根结点只有右子树</li>
<li>根结点既有左子树又有右子树</li>
</ul>
</li>
</ol>
<h2 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h2><ul>
<li><strong>斜树</strong></li>
<li><strong>满二叉树</strong></li>
<li><strong>完全二叉树</strong></li>
</ul>
<h3 id="斜树"><a href="#斜树" class="headerlink" title="斜树"></a>斜树</h3><ul>
<li>左斜树：<strong>所有结点</strong>都<strong>只有</strong>左子树</li>
<li>右斜树：<strong>所有结点</strong>都<strong>只有</strong>左子树</li>
</ul>
<p>斜树特点总结：<strong>每一层</strong>都<strong>只有一个结点</strong>，结点的<strong>个数</strong>与二叉树的<strong>深度相同</strong>。</p>
<h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><ul>
<li>所有分支结点<strong>都存在左子树和右子树</strong></li>
<li><strong>所有叶结点</strong>都在同一层</li>
</ul>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>判断方法1：</p>
<ul>
<li>一颗具有n个结点的二叉树按层序编号(从上到下，从左到右，)</li>
<li>每个结点按照满二叉树的结构逐层顺序编号，如果编号出现空挡，就说明不是完全二叉树，否则就是</li>
</ul>
<p>判单方法2：</p>
<ul>
<li>如果二叉树中除去最后一层节点为满二叉树，且最后一层的每个结点依次从左到右分布，则此二叉树被称为完全二叉树。</li>
</ul>
<p>特点：满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树</p>
<h1 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h1><p>注意：以下二叉树性质，均以1开始从上到下，从左到右编号</p>
<h2 id="二叉树性质1"><a href="#二叉树性质1" class="headerlink" title="二叉树性质1"></a>二叉树性质1</h2><p><strong>性质1</strong>：在二叉树的<strong>第 i 层</strong>上<strong>至多</strong>有 2<sup>i-1</sup>个结点 ( i ≥ 1)，即单层上的至多节点数。</p>
<p>解析：纯数量关系推导</p>
<h2 id="二叉树的性质2"><a href="#二叉树的性质2" class="headerlink" title="二叉树的性质2"></a>二叉树的性质2</h2><p><strong>性质2</strong>：<strong>深度</strong>为k的二叉树<strong>至多</strong>有 2<sup>k</sup>-1 个结点( k ≥ 1)</p>
<p>解析：纯数量关系推导</p>
<h2 id="二叉树的性质3"><a href="#二叉树的性质3" class="headerlink" title="二叉树的性质3"></a>二叉树的性质3</h2><p><strong>性质3</strong>：对于任何一颗二叉树T，如果其终端结点数为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>。则n<sub>0</sub> = n<sub>2</sub> +1 </p>
<p>即，所有叶结点数  = 所有根节点数 + 1</p>
<h2 id="二叉树的性质4"><a href="#二叉树的性质4" class="headerlink" title="二叉树的性质4"></a>二叉树的性质4</h2><p><strong>性质4</strong>：具有n个结点得<strong>完全二叉树</strong>的深度为    |_ log<sub>2</sub>n _| + 1     (|__ x _|)表示不大于x的最大整数</p>
<p>解析：暂时略《数据结构》从概念到C++的实现，王红梅 P137</p>
<h2 id="二叉树的性质5"><a href="#二叉树的性质5" class="headerlink" title="二叉树的性质5"></a>二叉树的性质5</h2><p><strong>性质5</strong>：具有<strong>n</strong>个结点<strong>完全二叉树</strong>存在如下性质</p>
<ul>
<li>如果 i = 1，则结点 i 是二叉树的<strong>根</strong>；如果 i &gt; 1，则<strong>双亲结点</strong>是  i/2」</li>
<li>如果 2i &gt; n，则结点 i <strong>无左孩子</strong>，即结点i为叶结点。反之 2i &lt; n 则i结点的左孩子是2i</li>
<li>如果 2i + 1 &gt; n，则结点 i <strong>无右孩子</strong>，反之其右孩子是结点 2i + 1</li>
</ul>
<p>正序的先左到底后右</p>
<p>也是先左到底，但是从左到底处出发，先左后右</p>
<h1 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h1><h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>由于二叉树定义严格，是一种特殊的树，所以可以仅使用顺序存储结构实现，仅通过数组下标的数量关系就能体现结点之间的逻辑关系</p>
<ul>
<li>将二叉树从根节点编号为1开始，从上到小，左到右全部编号。直接按序存入数组，若是非完全二叉树，缺少部分填入空指针，但序号依然按照完全二叉树的顺序编号。</li>
<li>对于<strong>完全二叉树</strong>，数组下标的数量关系<strong>足够体现</strong>结点的<strong>所有逻辑关系</strong>(双亲，孩子，兄弟)</li>
<li>对于<strong>非完全二叉树/一般二叉树</strong>，按完全二叉树顺序编号，空缺部分均填入空指针</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"
                      alt="二叉树的顺序存储结构"
                ></p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>若二叉树表现出一条<strong>深度为k的 左/右斜树</strong>，则需开辟 2<sup>k</sup>-1 个空间存储，<strong>造成大量空间的浪费</strong>，因此<strong>二叉树的顺序存储结构</strong>一般只用于<strong>完全二叉树</strong></p>
<h2 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h2><ul>
<li><strong>二叉链表</strong>：由于二叉表每个结点<strong>最多只有两个孩子</strong>，则<strong>一个数据域 + 两个 指针域(左右孩子)</strong>的存储结构</li>
<li><strong>三叉链表</strong>：data + parent + lchild + rchild</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的二叉链表结点结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data; <span class="comment">/* 数据域*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>	<span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>



<h1 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>二叉树的遍历<strong>不同于线性表</strong>，即使确保“<strong>从根结点出发，依次访问二叉树的所有结点</strong>”，对于<strong>每个结点</strong>都可以有<strong>不同的选择</strong>，从而遍历的次序完全不一样。因此，可得出两个角度：</p>
<ol>
<li>鉴于二叉树存在多种遍历次序，通常将其<strong>限制从左到右</strong>的习惯方式遍历。</li>
<li>鉴于可存在多种遍历次序，且处理困难，而<strong>计算机只能处理线性序列(循环,判断)**，通常利用与树的递归定义相同的</strong>递归方式<strong>来遍历。某种意义上</strong>将树的结点遍历变成线性序列**</li>
</ol>
<h2 id="二叉树的遍历方法"><a href="#二叉树的遍历方法" class="headerlink" title="二叉树的遍历方法"></a>二叉树的遍历方法</h2><p>限制<strong>按从左到右</strong>遍历的，会存在<strong>四种遍历方式</strong>，前序遍历、中序遍历、后序遍历、层序遍历。</p>
<ul>
<li>“<strong>限制从左到右</strong>”，即调用<strong>左子树的递归</strong>操作一定在，调用<strong>右子树的递归</strong>操作<strong>之前！</strong></li>
<li>前、中、后序遍历的意思是，<strong>输出语句</strong>相对在左右子树递归调用的前、中、后位置</li>
</ul>
<p>注意：无论前、中、后、层序遍历都是<strong>从根节点开始。但，从根节点开始，不等于先输出根节点！</strong></p>
<h3 id="前序-根-遍历"><a href="#前序-根-遍历" class="headerlink" title="前序(根)遍历"></a>前序(根)遍历</h3><ol>
<li>访问根结点</li>
<li>前序遍历根结点的左子树</li>
<li>前序遍历根结点的右子树</li>
</ol>
<h3 id="中序-根-遍历"><a href="#中序-根-遍历" class="headerlink" title="中序(根)遍历"></a>中序(根)遍历</h3><ol>
<li>中序遍历根结点的左子树</li>
<li>访问根结点</li>
<li>中序遍历根结点的右子树</li>
</ol>
<h3 id="后序-根-遍历"><a href="#后序-根-遍历" class="headerlink" title="后序(根)遍历"></a>后序(根)遍历</h3><ol>
<li>后序遍历根结点的左子树</li>
<li>后序遍历根结点的右子树</li>
<li>访问根结点</li>
</ol>
<p>理解的演变：</p>
<ol>
<li>大话数据结构代码版，通过递归代码去推演：复杂，慢，易错。唯一好处，更加理解递归-回推</li>
<li>课堂聆听1，上下左右顺序描述更加复杂，无效</li>
<li>课堂聆听2，教材描述。纯文字理解(内含递归)</li>
</ol>
<p>关键：</p>
<ol>
<li>除“从根结点<strong>开始</strong>”这个根结点特指root这一个结点外，其他描述中的“<strong>根结点</strong>”均指<strong>每一颗子树的根结点</strong></li>
<li>xxx遍历法下的描述“xxx遍历根节点的x子树”，其实表示后面的子树用于定位，可以把文字中xxx的描述递归函数的调用，即回到定义的本身，重头开始执行。即把<strong>概念描述，和递归理念结合在一起</strong></li>
</ol>
<p>技巧：</p>
<ol>
<li>前根遍历：<ol>
<li>方式1：根左、根左…根右、根左…</li>
<li>方式2(快)：每一棵树都是先根再输出左右(结点嵌套根)</li>
</ol>
</li>
<li>中序遍历：<ol>
<li>技巧是，直接从root结点深度最大的左子数开始。遍历完root结点左子孙后再从右子孙中从深度最大左子树开始。直至遍历中序遍历全部结点</li>
<li>每一棵树都是左到底后，访问根，再去到下一个右结点(结点嵌套，即又每一颗数左道底后，访问根…)…</li>
</ol>
</li>
<li>后序遍历：<ol>
<li>根结点肯定是最后访问的，找到深度大，先左输出后右输出。然后依次嵌套重复</li>
<li>方式2(快)：从最底层开始，从下往上推。每一棵树都是根结点最后访问，先左后右(结点嵌套根)</li>
</ol>
</li>
</ol>
<p>遍历次序记忆关键：</p>
<ol>
<li>优先采取“树的遍历”中对三种遍历次序的文字主观描述</li>
<li>其次结合三行代码的顺序，结合递归执行思想，去记忆</li>
</ol>
<h3 id="前序遍历算法"><a href="#前序遍历算法" class="headerlink" title="前序遍历算法"></a>前序遍历算法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的前序遍历递归算法 */</span></span><br><span class="line"><span class="comment">/* “前”序遍历，输出语句在左子树递归和右子树递归之前，即第一行 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%C&quot;</span>,T-&gt;data);	    <span class="comment">//先输出</span></span><br><span class="line">    PreOrderTraverse(T-&gt;lchild);<span class="comment">//再左子树递归</span></span><br><span class="line">    PreOrderTraverse(T-&gt;rchild);<span class="comment">//最后右边子树递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>前序遍历算法，遍历次序如下图所示</strong>：<strong>ABDGHCEIF</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86(%E6%94%B9).jpg"
                     
                ></p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的中序遍历递归算法 */</span></span><br><span class="line"><span class="comment">/* “中”序遍历，输出语句在左子树递归和右子树递归之“中”，即第二行 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    InOrderTraverse(T-&gt;lchild);<span class="comment">//先左子树递归</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%C&quot;</span>,T-&gt;data);	   <span class="comment">//再输出</span></span><br><span class="line">    InOrderTraverse(T-&gt;rchild);<span class="comment">//最后右子树递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>中序遍历，遍历次序如下图所示</strong>：<strong>GDHBAEICF</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.jpeg"
                      alt="中序遍历"
                ></p>
<h3 id="后序遍历-2"><a href="#后序遍历-2" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的后序遍历递归算法 */</span></span><br><span class="line"><span class="comment">/* “后”序遍历，输出语句在左子树递归和右子树递归之“后”，即最后行 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    PostOrderTraverse(T-&gt;lchild);<span class="comment">//先左子树递归</span></span><br><span class="line">    PostOrderTraverse(T-&gt;rchild);<span class="comment">//再右子树递归</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%C&quot;</span>,T-&gt;data);	   <span class="comment">//最后才输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>后序遍历，遍历次序如下图所示</strong>：<strong>GHDBIEFCA</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.jpeg"
                      alt="后续遍历"
                ></p>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>与前三种遍历方式不同，<strong>层序遍历</strong>更多是<strong>由人的主观遍历次序，到对应的代码的实现</strong>。而其他三种更倾向于代码的递归逻辑设计到实际的遍历次序。</p>
<p><strong>实现逻辑</strong></p>
<ol>
<li>初始化：创建队列，根结点入队</li>
<li>若队列不为空，队头出队。让队头的左右孩子入队</li>
<li>以此循环第2步即可</li>
</ol>
<h2 id="推导二叉树的遍历结果"><a href="#推导二叉树的遍历结果" class="headerlink" title="推导二叉树的遍历结果"></a>推导二叉树的遍历结果</h2><p><strong>推导逻辑</strong>：(具体案例细节可参详P184~P186)</p>
<ol>
<li>确定根节点：从前序遍历(首位)，或后序遍历(尾)</li>
<li>循环推导<ol>
<li>从某一遍历推导出的某一条件出发</li>
<li>使用上一轮得出的条件，与上一轮不同的遍历方式结合再推出一个新条件，以此循环</li>
<li>注意：一般每一轮会都要<strong>利用</strong>孩子集范围，<strong>缩减</strong>孩子集范围，<strong>作为判断的条件之一</strong></li>
</ol>
</li>
<li>经验总结：<ol>
<li><strong>必须含中序遍历</strong>的条件则<strong>才能唯一确定</strong>一颗二叉树</li>
<li><strong>前序遍历</strong>，用于<strong>确定根后</strong>与<strong>中序遍历占位</strong>后，<strong>来确定左孩子</strong>(同时也确定子树的根，再中序域划分…)</li>
<li><strong>中序遍历</strong>，主要用于，<strong>范围划分，且占位！</strong></li>
<li><strong>后序遍历</strong>，只要用于，<strong>被划分范围后，确定根结点(范围尾部)</strong></li>
</ol>
</li>
</ol>
<p><strong>实战演示</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%8E%A8%E5%AF%BC.png"
                     
                ></p>
<h1 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h1><h2 id="扩展二叉树"><a href="#扩展二叉树" class="headerlink" title="扩展二叉树"></a>扩展二叉树</h2><p>为了能<strong>让每个结点确认是否有左右孩子</strong>，在二叉树建立前，将其每个结点的<strong>空指针处引出一个虚结点</strong>。这种扩展后的二叉树称为<strong>扩展二叉树</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E6%89%A9%E5%B1%95%E4%BA%8C%E5%8F%89%E6%A0%91.jpeg"
                      alt="扩展二叉树"
                ></p>
<h2 id="二叉树的建立-1"><a href="#二叉树的建立-1" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h2><p>二叉树的建立步骤如下</p>
<ol>
<li>画出拟建立二叉树</li>
<li>画出对应的扩展二叉树</li>
<li>以某种遍历方式写出扩展二叉树的遍历次序</li>
<li>以同类型的遍历方式创建按次序输入实现二叉树的建立</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 按前序输入二叉树中结点的值（一个字符） */</span></span><br><span class="line"><span class="comment">/* #表示空树，构造二叉链表表示二叉树T。 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	TElemType ch = null;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* scanf(&quot;%c&quot;,&amp;ch); */</span></span><br><span class="line">	ch=str[index++];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>) </span><br><span class="line">		*T=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		*T=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">		<span class="keyword">if</span>(!*T)</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		(*T)-&gt;data=ch; <span class="comment">/* 生成根结点 */</span></span><br><span class="line">		CreateBiTree(&amp;(*T)-&gt;lchild); <span class="comment">/* 构造左子树 */</span></span><br><span class="line">		CreateBiTree(&amp;(*T)-&gt;rchild); <span class="comment">/* 构造右子树 */</span></span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>**C++**实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">BiNode&lt;DataType&gt;* BiTree&lt;DataType&gt;::Creat()&#123;</span><br><span class="line">	<span class="comment">//声明一个新结点</span></span><br><span class="line">	BiThrNode&lt;DataType&gt; *btn = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">	<span class="keyword">if</span> (ch != <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">		btn = <span class="keyword">new</span> BiThrNode&lt;DataType&gt;;</span><br><span class="line">		btn-&gt;data = ch;</span><br><span class="line"></span><br><span class="line">		btn-&gt;lchild = Creat();</span><br><span class="line">		btn-&gt;rchild = Creat();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> btn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><ol>
<li>二叉树的<strong>链式存储</strong>会存在大量<strong>空指针域</strong>，n个结点的二叉树就会存在 n+1个空指针域。</li>
<li>可以利用这些空指针域存储以某种次序创建的二叉树<strong>结点之间的前驱后继</strong>指针信息。<ul>
<li>指向<strong>前驱和后继</strong>的指针称为<strong>线索</strong>。加上线索的二叉链表称为线索链表，相应的二叉树称为<strong>线索二叉树</strong></li>
<li>二叉树<strong>以某种次序遍历使其</strong>变为线索二叉树<strong>的过程称做</strong>线索化**。</li>
</ul>
</li>
</ol>
<h2 id="线索二叉树的存储结构"><a href="#线索二叉树的存储结构" class="headerlink" title="线索二叉树的存储结构"></a>线索二叉树的存储结构</h2><p>为区分，rchild/lchild是指向线索还是指向树结构的指针，通过<strong>两个Tag枚举变量标志</strong>，Thread为线索指针，Link为树指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;Link,Thread&#125; PointerTag;	<span class="comment">/* Link==0表示指向左右孩子指针, */</span></span><br><span class="line">										<span class="comment">/* Thread==1表示指向前驱或后继的线索 */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span>	/* 二叉线索存储结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	TElemType data;	<span class="comment">/* 结点数据 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>	<span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">	PointerTag LTag;</span><br><span class="line">	PointerTag RTag;		<span class="comment">/* 左右标志 */</span></span><br><span class="line">&#125; BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure>



<h2 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h2><p>通过中序遍历实现中序线索化。代码如下，需注意：</p>
<ul>
<li>全局变量 pre 在外初始化为 root</li>
<li>线索二叉树初始化需把结点置为Link，因为中序线索化只修改Thread；</li>
<li>令某种次序序列中的<strong>第一个结点</strong>其lchild指向二叉树的<strong>根结点</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//必须以全局变量的方式参与递归操作</span></span><br><span class="line">BiThrNode&lt;<span class="keyword">char</span>&gt; *pre = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//中序线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrNode&lt;<span class="keyword">char</span>&gt; *p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//左子树递归至最后结点(非null结点)</span></span><br><span class="line">	<span class="keyword">if</span> (p) &#123;</span><br><span class="line">		InThreading(p-&gt;lchild);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//(!p-&gt;lchild)：表若当前结点左孩子为null，则lchild(前驱)线索化，</span></span><br><span class="line">		<span class="comment">//即为pre结点</span></span><br><span class="line">		<span class="keyword">if</span> (!p-&gt;lchild) &#123;<span class="comment">//为null</span></span><br><span class="line">			p-&gt;LTag = PoinTerTag::Thread;</span><br><span class="line">			p-&gt;lchild = pre;					</span><br><span class="line">		&#125;					</span><br><span class="line">		<span class="comment">//(!pre-&gt;rchild)：表，若当前结点遍历的上一个结点的rchild(后继)为null，</span></span><br><span class="line">		<span class="comment">//则线索化的后继结点，为当前结点p</span></span><br><span class="line">		<span class="keyword">if</span> (!pre-&gt;rchild) &#123;<span class="comment">//为null</span></span><br><span class="line">			pre-&gt;RTag = PoinTerTag::Thread;</span><br><span class="line">			pre-&gt;rchild = p;</span><br><span class="line">		&#125;</span><br><span class="line">		pre = p;<span class="comment">//存储以某种递归次序线索化(遍历)的上一个结点位置</span></span><br><span class="line">				<span class="comment">//因为固定从左到右，所以pre用于LTag的lchild,也用于pre结点本身的有孩子线索化</span></span><br><span class="line">		InThreading(p-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BiThrTree&lt;<span class="keyword">char</span>&gt; btt&#123;&#125;;	<span class="comment">//P189二叉树 ABDH##I##EJ###CF##G##</span></span><br><span class="line">	<span class="comment">//pre全局遍历的变量环境是 pre = root;</span></span><br><span class="line">	pre = btt.root;</span><br><span class="line">	InThreading(btt.root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="遍历线索二叉树"><a href="#遍历线索二叉树" class="headerlink" title="遍历线索二叉树"></a>遍历线索二叉树</h2><h3 id="线索二叉树与双向链表"><a href="#线索二叉树与双向链表" class="headerlink" title="线索二叉树与双向链表"></a>线索二叉树与双向链表</h3><p>线索二叉树的结构<strong>类似双链表结构</strong>，因此为了方便线索二叉树的遍历等操作，对线索二叉树<strong>添加一个头结点</strong>。添加头结点这个操作常常在<strong>线索化的时候实现</strong>，因此要对上面的中序线索化代码的基础上稍作修改——添加一个头结点，并设定初始状体如下：</p>
<ol>
<li>头结点的<strong>lchild域</strong>指向二叉树的<strong>根结点</strong>，<strong>rchild域</strong>指向遍历时访问的<strong>最后一个结点</strong>。</li>
<li>遍历的第一个元素的<strong>lchild域</strong>指向<strong>头结点</strong>，<strong>最后一个结点</strong>的<strong>rchild域</strong>同样指向<strong>头结点</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 备注：遍历代码是重点，而对线索化的改进代码。这个是次要，还未分析学习 */</span></span><br><span class="line"><span class="comment">/* 中序遍历二叉树T,并将其中序线索化,Thrt指向头结点 */</span></span><br><span class="line"><span class="function">Status <span class="title">InOrderThreading</span><span class="params">(BiThrTree *Thrt,BiThrTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	*Thrt=(BiThrTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiThrNode));</span><br><span class="line">	<span class="keyword">if</span>(!*Thrt)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	(*Thrt)-&gt;LTag=Link; <span class="comment">/* 建头结点 */</span></span><br><span class="line">	(*Thrt)-&gt;RTag=Thread;</span><br><span class="line">	(*Thrt)-&gt;rchild=(*Thrt); <span class="comment">/* 右指针回指 */</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span>(!T) <span class="comment">/* 若二叉树空,则左指针回指 */</span></span><br><span class="line">		(*Thrt)-&gt;lchild=*Thrt;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		(*Thrt)-&gt;lchild=T;</span><br><span class="line">		pre=(*Thrt);</span><br><span class="line">		InThreading(T); <span class="comment">/* 中序遍历进行中序线索化 */</span></span><br><span class="line">		pre-&gt;rchild=*Thrt;</span><br><span class="line">		pre-&gt;RTag=Thread; <span class="comment">/* 最后一个结点线索化 */</span></span><br><span class="line">		(*Thrt)-&gt;rchild=pre;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历线索二叉树-非递归版"><a href="#中序遍历线索二叉树-非递归版" class="headerlink" title="中序遍历线索二叉树(非递归版)"></a>中序遍历线索二叉树(非递归版)</h3><ol>
<li>BiThrTree T 表示头结点，则按带头结点的线索化，p = T-&gt;lchild; 则表示p等于根结点</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 中序遍历二叉线索树T(头结点)的非递归算法 */</span></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree T)</span></span>&#123; </span><br><span class="line">	BiThrTree p;</span><br><span class="line">	p=T-&gt;lchild; <span class="comment">/* p指向根结点 */</span></span><br><span class="line">	<span class="keyword">while</span>(p!=T)&#123; <span class="comment">/* 空树或遍历结束时,p==T */</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">while</span>(p-&gt;LTag==Link)</span><br><span class="line">			p=p-&gt;lchild;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!visit(p-&gt;data)) <span class="comment">/* 访问其左子树为空的结点 */</span></span><br><span class="line">			<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(p-&gt;RTag==Thread&amp;&amp;p-&gt;rchild!=T)&#123;<span class="comment">//防空树操作</span></span><br><span class="line">			p=p-&gt;rchild;</span><br><span class="line">			visit(p-&gt;data); <span class="comment">/* 访问后继结点 */</span></span><br><span class="line">		&#125;</span><br><span class="line">		p=p-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码分析</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.jpg"
                     
                ></p>
<p>这段代码<strong>相当于一个链表的扫描</strong>，所以<strong>时间复杂度O(n)</strong></p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul>
<li>线索二叉树充分利用了二叉树链式存储结构的空指针域空间(<strong>节省空间</strong>)，仅需创建时的一次遍历就可终生受用的前驱后继信息(<strong>节省时间</strong>)。</li>
<li>若二叉树需要<strong>经常遍历</strong>或<strong>查找结点时</strong>需要某种遍历序列的<strong>前驱和后继</strong>，则线索二叉树的存储结构是非常不错的选择。</li>
</ul>
]]></content>
      <tags>
        <tag>技术积累</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 第三章 线性表及其顺序存储结构</title>
    <url>/2020/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%8F%8A%E5%85%B6%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<ul>
<li><strong>读物</strong>：<a class="link"   href="https://book.douban.com/subject/6424904/" >《大话数据结构》<i class="fas fa-external-link-alt"></i></a></li>
<li><strong>印次</strong>：2020年5月第25次印刷(2020.5重印)</li>
</ul>
<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ol>
<li><strong>线性表的定义</strong></li>
<li><strong>线性表的抽象数据类型</strong></li>
<li><strong>线性表的顺序存储结构</strong></li>
<li><strong>地址计算方法</strong></li>
<li><strong>顺序存储结构的存入与取出</strong></li>
<li><strong>顺序存储结构的插入与删除</strong></li>
<li><strong>线性表顺序存储结构的优缺点</strong></li>
</ol>
<h1 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h1><p>线性表（List）：<strong>零个(空表)或多个</strong>数据元素的<strong>有限序列</strong>。即线性表的<strong>长度n≧0</strong>。关键点如下：</p>
<ol>
<li><p><strong>序列</strong>：表示元素之间是有严格的顺序。元素之间的关系是一对一的关系。</p>
<blockquote>
<ul>
<li><p>若线性表记为(a1，…ai-1，ai，ai+1，…，an)，称ai-1是ai的<strong>直接前驱元素</strong>，ai+1则是ai的<strong>直接后继元素</strong></p>
</li>
<li><p><strong>第一个元素无前驱，最后一个元素无后继，其他元素有且只有一个前驱和后继</strong></p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>有限</strong></p>
</li>
<li><p><strong>元素类型相同</strong></p>
</li>
</ol>
<h1 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h1><p>线性表的<strong>抽象</strong>数据类型<strong>定义</strong>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADT 线性表（List）</span><br><span class="line">Data</span><br><span class="line">	&#123;a1,a2,…,an&#125;</span><br><span class="line">Operation</span><br><span class="line">	InitList(*L): 		初始化操作，建立一个空的线性表L。</span><br><span class="line">	ListEmpty(L): 		判断线性表是否为空表，若线性表为空，返回true，否则返回false。</span><br><span class="line">	ClearList(*L): 		将线性表清空。</span><br><span class="line">	GetElem(L,i,*e): 	将线性表L中的第i个位置元素值返回给e。</span><br><span class="line">	LocateElem(L,e): 	在线性表L中查找与给定值e相等的元素，如果查找成功，</span><br><span class="line">					  返回该元素在表中序号表示成功；否则，返回0表示失败。</span><br><span class="line">	ListInsert(*L,i,e): 	在线性表L中第i个位置插入新元素e。</span><br><span class="line">	ListDelete(*L,i,*e): 删除线性表L中第i个位置元素，并用e返回其值。</span><br><span class="line">	ListLength(L): 		返回线性表L的元素个数。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>

<p><strong>ps</strong>：上述为<strong>最基本操作</strong>，其他更复杂的操作完全可以通过这些基本操作<strong>组合实现</strong>。</p>
<h1 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h1><h2 id="线性表的顺序存储定义"><a href="#线性表的顺序存储定义" class="headerlink" title="线性表的顺序存储定义"></a>线性表的顺序存储定义</h2><p>线性表的顺序存储结构：指的是用<strong>一段地址连续</strong>的存储单元<strong>依次存储线性表</strong>的数据元素。</p>
<blockquote>
<p>最常见的就是用一维数组来<strong>实现</strong>顺序存储结构</p>
</blockquote>
<p><strong>线性表的顺序存储结构代码</strong>如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20		<span class="comment">//存储空间处时分配量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType	<span class="comment">//数据类型根据实际情况而定，这里假设为int</span></span><br><span class="line"><span class="keyword">typedef</span> strcuct&#123;		</span><br><span class="line">	ElemType data [MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> length;			<span class="comment">//线性表当前长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<p>据上述可知，描述<strong>顺序存储结构</strong>需要<strong>三个属性</strong>：</p>
<ul>
<li>存储空间的起始位置：其实就是数组<strong>data</strong>(首地址)</li>
<li>线性表的<strong>最大存储容量</strong>：数组长度<strong>MaxSize</strong></li>
<li>线性表的<strong>当前长度</strong>：<strong>length</strong></li>
</ul>
<h2 id="顺序线性表的初始化"><a href="#顺序线性表的初始化" class="headerlink" title="顺序线性表的初始化"></a>顺序线性表的初始化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化顺序线性表 */</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(SqList *L)</span> </span>&#123; </span><br><span class="line">    L-&gt;length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="地址计算方法"><a href="#地址计算方法" class="headerlink" title="地址计算方法"></a>地址计算方法</h1><h2 id="数组长度与线性表长度的区别"><a href="#数组长度与线性表长度的区别" class="headerlink" title="数组长度与线性表长度的区别"></a>数组长度与线性表长度的区别</h2><ul>
<li><strong>数组长度</strong>：是指存放线性表<strong>存储空间</strong>的长度，一般是<strong>固定值</strong>。int data[3]={1,2,3}长度为3。</li>
<li><strong>线性表长度</strong>：线性表中存在<strong>数据元素个数</strong>，是经常<strong>变化</strong>的。</li>
<li>数组下标从“0”开始，线性表是从“<strong>1</strong>”数起的。</li>
</ul>
<h2 id="地址计算方法-1"><a href="#地址计算方法-1" class="headerlink" title="地址计算方法"></a>地址计算方法</h2><p>数据元素的序号和存放它的数组下标之间对应关系如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95.png"
                      alt="线性表"
                ></p>
<ul>
<li><p>对于第i个数据元素a<del>i</del>的<strong>存储地址</strong>可由a<del>1</del>推算出：</p>
<p><strong>LOC(a<sub>i</sub>) = LOC(a<sub>1</sub>)+(i-1)*c </strong></p>
</li>
</ul>
<blockquote>
<p>LOC表示获得存储位置的函数，c表示数据元素的类型的存储单元</p>
</blockquote>
<ul>
<li><p>对于第 i 个数据元素a<del>i</del>的<strong>存取位置</strong>关系：</p>
<p><strong>a<del>i</del> = data[i - 1]</strong></p>
</li>
</ul>
<h1 id="顺序存储结构的存入与取出"><a href="#顺序存储结构的存入与取出" class="headerlink" title="顺序存储结构的存入与取出"></a>顺序存储结构的存入与取出</h1><h2 id="GetElem"><a href="#GetElem" class="headerlink" title="GetElem"></a>GetElem</h2><p>思路：</p>
<ol>
<li>线性表必须存在数据;</li>
<li><strong>i</strong> 的数值在数组下标范围内;</li>
<li>返回数组的第 <strong>i-1</strong> 下标的值即可;</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本说明：Status是函数的类型，其值是函数结果状态代码，如OK等</span></span><br><span class="line"><span class="comment">//初始条件(输入条件)：线性表L已存在，位置参数i范围应处于： 1 ≤ i ≤ ListLength(L)</span></span><br><span class="line"><span class="comment">//操作结果：用e返回L中的第i个元素</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L,<span class="keyword">int</span> i,ElemType *e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L.length == <span class="number">0</span> || i &lt; <span class="number">1</span> || i &gt; L.length)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	*e = L.data[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任意位置的<strong>存取</strong>时间复杂度都为<strong>O(1)**，即存取性能为O(1)，称为“</strong>随机存取结构**”。</p>
<blockquote>
<ul>
<li>“<strong>存取</strong>”，<strong>不等于</strong>“<em>插删</em>”</li>
<li>顺序线性表的存取仅需要知道存入的位置逻辑即可，因此查询位置的复杂度决定了存取的复杂度</li>
</ul>
</blockquote>
<h1 id="顺序存储结构的插入与删除"><a href="#顺序存储结构的插入与删除" class="headerlink" title="顺序存储结构的插入与删除"></a>顺序存储结构的插入与删除</h1><p>存在线性表定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	</span><br><span class="line">	ElemType data[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>



<h2 id="ListInsert"><a href="#ListInsert" class="headerlink" title="ListInsert"></a>ListInsert</h2><p>思路：</p>
<ol>
<li>如果<strong>线性表的长度等于数组长度</strong>，则抛出异常或者动态增加容量;</li>
<li>如果插入位置不合理，抛出异常;</li>
<li>从<strong>最后一个元素</strong>开始向前遍历到第i个位置，分别将它们都<strong>向后移动</strong>一个位置;</li>
<li>将要插入元素填入位置 <strong>i</strong> 中;</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */</span></span><br><span class="line"><span class="comment">/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;length==MAXSIZE)  <span class="comment">/* 顺序线性表已经满 */</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length+<span class="number">1</span>)<span class="comment">/* 当i比第一位置小或者比最后一位置后一位置还要大时 */</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i&lt;=L-&gt;length)&#123;        <span class="comment">/* 若插入数据位置不在表尾 */</span></span><br><span class="line">		<span class="keyword">for</span>(k=L-&gt;length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--)  <span class="comment">/* 将要插入位置之后的数据元素向后移动一位 */</span></span><br><span class="line">			L-&gt;data[k+<span class="number">1</span>]=L-&gt;data[k];</span><br><span class="line">	&#125;</span><br><span class="line">     <span class="comment">/*索引改良</span></span><br><span class="line"><span class="comment">    for (k = L-&gt;length; k &gt;= i; k--) &#123;	</span></span><br><span class="line"><span class="comment">		L-&gt;data[k] = L-&gt;data[k - 1];</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	L-&gt;data[i<span class="number">-1</span>]=e;          <span class="comment">/* 将新元素插入 */</span></span><br><span class="line">	L-&gt;length++;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ListDelete"><a href="#ListDelete" class="headerlink" title="ListDelete"></a>ListDelete</h2><p>思路：</p>
<ol>
<li>线性表必须存在数据;</li>
<li>如果删除位置不合理，抛出异常;</li>
<li>从<strong>删除元素位置开始</strong>遍历到最后一个元素位置，分别将它们都<strong>向前移动</strong>一个位置;</li>
<li>表的长度减少1;</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span></span><br><span class="line"><span class="comment">/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType *e)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (L-&gt;length==<span class="number">0</span>)               <span class="comment">/* 线性表为空 */</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length)         <span class="comment">/* 删除位置不正确 */</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    *e=L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;L-&gt;length)&#123;            <span class="comment">/* 如果删除不是最后位置 */</span></span><br><span class="line">        <span class="keyword">for</span>(k=i;k&lt;L-&gt;length;k++)<span class="comment">/* 将删除位置后继元素前移 */</span></span><br><span class="line">			L-&gt;data[k<span class="number">-1</span>]=L-&gt;data[k];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线性表顺序存储结构的优缺点"><a href="#线性表顺序存储结构的优缺点" class="headerlink" title="线性表顺序存储结构的优缺点"></a>线性表顺序存储结构的优缺点</h1><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><h3 id="存入与取出"><a href="#存入与取出" class="headerlink" title="存入与取出"></a>存入与取出</h3><p>查询<strong>任意位置</strong>可由公式直接查出，从而决定<strong>存取</strong>的时间复杂度**均为O(1)**。</p>
<h3 id="插入与删除"><a href="#插入与删除" class="headerlink" title="插入与删除"></a>插入与删除</h3><ol>
<li><strong>最优情况复杂度</strong>：插入与删除位置为<strong>最后一个元素</strong>，复杂度为<strong>O(1)</strong></li>
<li><strong>最坏情况复杂度</strong>：插入与删除位置为<strong>第一个位置</strong>，复杂度为<strong>O(n)</strong></li>
<li><strong>平均情况复杂度</strong>：位置靠前，移动元素多。位置靠后，移动元素少。平均为<strong>(n-1)/2</strong>，复杂度即为<strong>O(n)</strong></li>
</ol>
<h2 id="优缺点总结"><a href="#优缺点总结" class="headerlink" title="优缺点总结"></a>优缺点总结</h2><p><strong>优点</strong>：</p>
<ol>
<li>无须为表示表中元素之间的逻辑关系而增加额外的存储空间(即可由公式直接关联)</li>
<li>可以快速地存取表中任意位置的元素</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><p>插入和删除操作需要移动大量的元素</p>
<blockquote>
</blockquote>
</li>
<li><p>当线性表长度变化较大时，难以确定存储空间的容量。即难以确定<strong>MAXSIZE</strong>属性的大小</p>
</li>
<li><p>造成存储空间的“碎片”</p>
</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>顺序存储结构的线性表，适合于元素个数<strong>不太需要变化</strong>，更多<strong>用于存取数据</strong>的应用。</li>
<li>插入和删除效率低的原因在于，相邻两元素之间的<strong>存储位置</strong>也<strong>依赖于邻居关系</strong>本身。</li>
</ul>
]]></content>
      <tags>
        <tag>技术积累</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE核心积累</title>
    <url>/2021/03/04/JavaSE%E6%A0%B8%E5%BF%83%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<p><strong>JavaSE核心积累</strong></p>
<hr>
<p>[TOC]</p>
<hr>
<h1 id="常用DOS命令"><a href="#常用DOS命令" class="headerlink" title="常用DOS命令"></a>常用DOS命令</h1><ul>
<li><strong>快速进入特定路径下的命令窗体</strong>：在拟进入文件路径的地址栏中直接输入cmd</li>
<li><strong>复制与黏贴</strong><ul>
<li>win7：任意位置<strong>右键“标记”</strong>，<strong>选中</strong>要复制的内容，再<strong>点击右键</strong>，剪贴板里面了</li>
<li>win10：<strong>左键</strong>直接选中，然后<strong>右键单击一下</strong>就到剪贴板里面了</li>
</ul>
</li>
<li><strong>D:</strong> 切换盘符直接输入“<strong>盘符</strong>”</li>
<li><strong>md</strong>：mkdir make director创建目录</li>
<li><strong>cd</strong>：change directory切换目录<ul>
<li><strong>cd</strong>：相对路径或绝对路径</li>
<li>**cd ..**：回到上级路径</li>
<li><strong>cd \</strong> ：直接回到根路径</li>
<li><strong>.</strong> ：一个点，代表当前路径。（常用与配置环境变量）</li>
</ul>
</li>
<li><strong>cls：</strong>清屏</li>
<li><strong>dir</strong> directory：查看当前路径文件目录：</li>
<li><strong>exit</strong>：退出DOS命令窗口</li>
<li><strong>rd</strong>：只能删除空文件夹：</li>
<li><strong>de</strong>：删除文件目录内所有内容</li>
<li><strong>echo</strong> content(内容)&gt;1.doc：输入流</li>
</ul>
<h1 id="语言概述"><a href="#语言概述" class="headerlink" title="语言概述"></a>语言概述</h1><h2 id="语言历史"><a href="#语言历史" class="headerlink" title="语言历史"></a>语言历史</h2><p>​    创始人：java之父<strong>James Gosling</strong></p>
<ul>
<li><p><strong>SUN</strong>(Stanford University Network，斯坦福大学网络公司 )<strong>1995</strong>推出</p>
</li>
<li><p><strong>1991</strong>年 Green项目，开发语言<strong>最初版本</strong>命名为<strong>Oak (橡树)</strong></p>
<p>…</p>
</li>
<li><p><strong>2004年，发布里程碑式版本：JDK 1.5，</strong>为突出此版本的重要性，**<em>更名为JDK 5.0**</em></p>
</li>
<li><p>2005年，改名J2SE -&gt; <strong>JavaSE(桌面级)**，J2EE -&gt; **JavaEE(企业WEB)**，J2ME -&gt; **JavaME</strong></p>
</li>
<li><p>2009年，<strong>Oracle公司收购</strong>SUN，交易价格74亿美元</p>
<p>…                              </p>
</li>
<li><p><strong>2014</strong>年，**<em>发布JDK 8.0**</em>，<strong>是继JDK 5.0以来</strong>变化最大的版本**</p>
<p>…</p>
</li>
<li><p>2018年3月，发布JDK <strong>10.0</strong>，版本号也称为<strong>18.3</strong>(<strong>改为时间命名</strong>)号称<strong>每月一更</strong></p>
</li>
<li><p>2018年9月，发布JDK 11.0，版本号也称为18.9</p>
</li>
</ul>
<h2 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h2><ol>
<li><strong>面向对象</strong>：类、对象、<strong>封装、继承、多态</strong></li>
<li><strong>健壮性</strong>：<strong>垃圾回收机制</strong>(<strong>GC</strong>机制)，<em>但仍存在内存泄漏与溢出</em>。c通过malloc与free手动管理)</li>
<li><strong>跨平台性</strong>：<strong>java虚拟</strong>(<strong>JVM</strong>)，write once,run anywhere 一次编译，到处运行</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7.png"
                     
                ></p>
<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><ul>
<li><p><strong>JDK</strong> ：<strong>Java开发工具包</strong> (Java Development Kit), 用与<strong>开发及运行</strong></p>
<ul>
<li><strong>JDK = JRE+开发工具集</strong></li>
</ul>
</li>
<li><p><strong>Java开发工具</strong>：<strong>javac.exe</strong> (编译工具) ，<strong>jar</strong>.<strong>exe</strong>(打包工具)等</p>
</li>
<li><p><strong>JRE</strong>：<strong>Java运行环境</strong>(Java Runtime Environment)，仅用于<strong>运行</strong>java项目</p>
<ul>
<li><strong>JRE = JVM+Java SE标准类库</strong></li>
</ul>
</li>
<li><p><strong>JVM：Java虚拟机</strong>(JVM Java Virtual Machine)和Java程序所需的<strong>核心类库</strong>等</p>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE回炉-JDK-JRE-JVM.png"
                      style="zoom: 80%;" /
                >

<h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><ol>
<li><p><strong>下载安装JDK</strong>:，官网，一键式傻瓜安装。可自定义安装路径，但注意安装软件的路径中不能包含中文、空格。(建议安装文件夹保留JDK版本号)</p>
</li>
<li><p><strong>配置环境变量path</strong>：</p>
<ol>
<li>进入<strong>系统变量设置</strong>：(win10)计算机，右键属性，高级系统变量，环境变量</li>
<li>把安装<strong>JDK</strong>的<strong>bin目录路径</strong>添加到环境变量<strong>path</strong>中(若不存在path则新建)<ul>
<li><strong>方式1</strong>：直接把JDK下的bin目录路径添加到path变量中</li>
<li><strong>方式2</strong>(<strong>推荐</strong>)：<ol>
<li>在<strong>系统变量</strong>中<strong>新建</strong>名为<strong>JAVA_HOME</strong>，值为<strong>JDK目录</strong>路径的环境变量</li>
<li>在path中<strong>通过引用</strong>的方式添加，即在path中添加 <strong>%JAVA_HOME%\bin;</strong> </li>
</ol>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>Tips：推荐使用方式2，后续tomcat运行环境需识别JAVA_HOME</p>
</blockquote>
</li>
<li><p><strong>验证</strong>：<strong>重新</strong>进入cmd输入<strong>javac</strong>程序如下内容显示或输入<strong>java –version</strong> 若出现安装JDK的版本号信息则安装成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-JDK%E5%AE%89%E8%A3%852.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-JDK%E5%AE%89%E8%A3%851.png"
                     
                ></p>
</li>
<li><p><strong>常见问题：(待收集)</strong></p>
<p>尝试把java的环境变量的位置以至最前面(防止部分功能失效)</p>
</li>
</ol>
<h2 id="JDK内容概要"><a href="#JDK内容概要" class="headerlink" title="JDK内容概要"></a>JDK内容概要</h2><p>默认安装路径：C:\Program Files\Java\jdk1.8.0_144</p>
<ul>
<li><strong>bin</strong>  – 开发工具（常用，javac.c 编译，java.exe 解析运行，javadoc.exe，生成文档）</li>
<li><strong>db</strong>  – java 实现的数据库</li>
<li><strong>include</strong> – 含c语言编写的头文件</li>
<li><strong>jre</strong> – java运行时环境</li>
<li><strong>lib</strong> – 存放jar包</li>
<li><strong>src.zip</strong> – 存放java开源代码，一些常用的类库(IDE中查看源码可引用它)</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-java8-JDK%E5%9B%BE.png"
                     
                ></p>
<ul>
<li><strong>JDK主要的包</strong>(packed)介绍<ul>
<li><strong>java.lang</strong>(language)：包含一些Java语言的<strong>核心类</strong>，如String、Math、Integer、 System和 Thread，提供常用功能</li>
<li><strong>java.net</strong>：包含执行与<strong>网络相关</strong>的操作的类和接口</li>
<li><strong>java.io</strong>：包含能提供多种<strong>输入/输出</strong>功能的类</li>
<li>j<strong>ava.util</strong>：包含一些实用<strong>工具类</strong>，如定义<strong>系统特性</strong>、接口的<strong>集合</strong>框架类、使用与<strong>日期日历</strong>相关的函数</li>
<li><strong>java.text</strong>：包含了一些java<strong>格式化</strong>相关的类</li>
<li><strong>java.sql</strong>：包含了java进行<strong>JDBC数据库编程</strong>的相关类/接口</li>
<li>j<strong>ava.awt</strong>：包含了构成<strong>抽象窗口</strong>工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 B/S C/S</li>
</ul>
</li>
</ul>
<h2 id="环境变量详解"><a href="#环境变量详解" class="headerlink" title="环境变量详解"></a>环境变量详解</h2><ol>
<li><p><strong>path环境变量</strong>：<strong>windows</strong>系统在cmd内执行命令时要<strong>搜寻的路径</strong>。配置path环境变量可实现在<strong>任何目录下</strong>都可以执行配置在path内容里的程序的效果。</p>
<ul>
<li><strong>环境变量类型</strong>：<strong>用户变量</strong>针对当前用户有效。<strong>系统变量</strong>，针对所有用户有效</li>
<li><strong>cmd命令的搜索逻辑</strong>：从当前目录—&gt;path路径(<strong>从前往后</strong>)</li>
<li><strong>环境变量值格式</strong>：由<strong>绝对路径</strong>组成。多个值用<strong>分号“;”</strong> (win7)隔开或(win10) 通过” 新建”的方式直接添加。</li>
<li><strong>%**JAVA_HOME</strong>%<strong>\bin;中</strong>“%%”<strong>表示</strong>获取<strong>这个</strong>环境变量的值**</li>
</ul>
</li>
<li><p>一台电脑允许同时安装多个版本JDK，实际使用哪个，却决与环境变量的指定</p>
</li>
<li><p>官方JDK安装过程会弹出两个安装框，一个是JDK安装，一个是独立的JRE安装，其实理论上安装JDK已经包含JRE，这个多出来的独立安装的JRE为了方便eclipse识别而安装，建议安装。</p>
</li>
</ol>
<h1 id="Java程序运行逻辑"><a href="#Java程序运行逻辑" class="headerlink" title=".Java程序运行逻辑"></a>.Java程序运行逻辑</h1><h2 id="java程序执行逻辑"><a href="#java程序执行逻辑" class="headerlink" title="java程序执行逻辑"></a>java程序执行逻辑</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-java%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.png"
                     
                ></p>
<h2 id="编译及运行命令的使用"><a href="#编译及运行命令的使用" class="headerlink" title="编译及运行命令的使用"></a>编译及运行命令的使用</h2><ul>
<li><p><strong>编译.java文件</strong>：<code>javac XXX.java</code>    (需含.java后缀)</p>
<blockquote>
<p>同目录下会编译出.class字节码文件，该<strong>字节码文件名</strong>由代码中<strong>class类名</strong>决定的</p>
</blockquote>
</li>
<li><p><strong>运行.class文件</strong>：<code>java .class文件名</code> (无需.class后缀)</p>
</li>
</ul>
<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><ol>
<li><p>新建一个<strong>HelloWorld.java</strong>结尾的文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloChina</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello,world!&quot;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译及运行</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-%E7%BC%96%E8%AF%91%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95.png"
                     
                ></p>
<ol start="3">
<li><strong>补充说明</strong><ol>
<li>javac命令<strong>因在</strong>Windows<strong>平台下执行，因此</strong>不区分<strong>大小写</strong></li>
<li>java命令<strong>是涉及java中的的执行，java是</strong>严格区分<strong>大小写的</strong></li>
<li>任何书写语法都没错，但还是报出“<strong>错误：找不到或无法加载主类</strong>”，有可能电脑配置了classpath的环境变量，classpath的配置表示使所有**.class文件**的执行都往该路径去寻找，导致在classpath路径下找不到对于执行的.class文件，因此提示错误。只需要删除classpath环境变量即可</li>
<li>在一个java源文件中可以声明多个类，但<strong>只有一个</strong>类能<strong>声明public</strong>，而且声明public的类的<strong>类名</strong>必须与源文件<strong>文件名相同</strong></li>
<li>存在多个class的源文件编译会生成对应的多个字节码文件，<strong>java.exe只需执行</strong>含<strong>main方法</strong>的类即可</li>
</ol>
</li>
</ol>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>​    java包含三种注释：单行注释、多行注释、<strong>文档注释</strong>(java特有)</p>
<ul>
<li><p><strong>文档注释</strong>：通过指定的注释格式，使注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。可以进入生成的文件夹，打开index.html即可。</p>
<ol>
<li><p><strong>注释格式</strong>：javadoc 工具默认只处理以 <strong>public 或 protected</strong> 修饰的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	<span class="doctag">@author</span> 指定java程序的作者</span></span><br><span class="line"><span class="comment">	<span class="doctag">@version</span> 指定源文件的版本</span></span><br><span class="line"><span class="comment">	文本内容，在类头部形成对class的文档注释</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXX</span></span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		在方法头部形成对方法的一个文档注释</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		method();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>javadoc命令使用</strong>：<code>javadoc –d filename –author –version javaFile.java</code></p>
<p>bug：</p>
<p>错误提示：javadoc 编码GBK的不可映射字符</p>
<p>原因：由于jdk是国际版的, 在编译时, 如果没有使用-encoding参数指定java源程序的编码格式, javac.exe则会获取操作系统默认的编码格式.</p>
<p>解决方案：</p>
<p>方案1：追加指定编码命令：<code>javadoc -d filename -author -version -encoding utf-8 HelloWorld.java</code></p>
<p>​    </p>
</li>
</ol>
</li>
</ul>
<h2 id="关键字、保留字、标识符"><a href="#关键字、保留字、标识符" class="headerlink" title="关键字、保留字、标识符"></a>关键字、保留字、标识符</h2><ul>
<li><p><strong>关键字</strong>：被Java语言赋予了特殊含义，用做<strong>专门用途</strong>的字符串。如**int、for、class…**（小写单词）</p>
</li>
<li><p><strong>保留字</strong>：现Java版本<strong>尚未使用</strong>，但以后版本<strong>可能会作为关键字</strong>使用。如：<strong>goto 、const</strong></p>
</li>
<li><p><strong>标识符(Unicode编码)**：凡是自己可以起名字的地方都叫标识符 (为了提高阅读性，要尽量意义，“</strong>见名知意**”)</p>
<p><strong>规则</strong>：</p>
<ul>
<li>由26个<strong>英文</strong>字母大小写，<strong>0-9</strong>，**_或$**组成</li>
<li><strong>数字不可以开头</strong>，不可以使用关键字和保留字，但能包含关键字和保留字</li>
<li>Java中<strong>严格区分大小写</strong>，长度无限制。</li>
<li>标识符不能包含空格。</li>
</ul>
<p><strong>规范</strong>：</p>
<ul>
<li><strong>包名</strong>：多单词组成，所有字母<strong>小写</strong>，xxxyyyzzz</li>
<li><strong>类名、接口名</strong>：多单词组成时，所有单词的<strong>首字母大写</strong>，XxxYyyZzz(大驼峰)</li>
<li><strong>变量名、方法名</strong>：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写，xxxYyyZzz(小驼峰)</li>
<li><strong>常量名</strong>：所有<strong>字母都大写</strong>。多单词时每个单词用<strong>下划线连接</strong>，XXX_YYY_zzz</li>
</ul>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li><strong>数据类型</strong></li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE回炉-数据类型.png"
                      style="zoom:80%;" /
                >

<table>
<thead>
<tr>
<th>数据类型</th>
<th>内存空间</th>
<th>默认值</th>
<th>表示范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1 byte (2<sup>0</sup>)</td>
<td>0</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>short /char</td>
<td>2 byte (2<sup>1</sup>)</td>
<td>0</td>
<td>-2<sup>15</sup>~2<sup>15</sup>-1 / 无符号整型</td>
</tr>
<tr>
<td>int</td>
<td>4 byte (2<sup>2</sup>)</td>
<td>0</td>
<td>-2<sup>31</sup>~2<sup>31</sup>-1(约21亿)</td>
</tr>
<tr>
<td>long</td>
<td>8 byte (2<sup>3</sup>)</td>
<td>0L 或 0l</td>
<td>-2<sup>63</sup>~2<sup>63</sup>-1</td>
</tr>
<tr>
<td>float</td>
<td>4 byte</td>
<td>0.0F 或 0.0f</td>
<td></td>
</tr>
<tr>
<td>double</td>
<td>8 byte</td>
<td>0.0</td>
<td></td>
</tr>
</tbody></table>
<ol start="2">
<li><p><strong>补充说明</strong></p>
<ul>
<li>Java的<strong>整型常量</strong>默认为 <strong>int 型</strong>，因此<strong>声明long</strong>型常量须后加 <strong>‘l’或‘L’</strong></li>
<li>Java 的<strong>浮点型常量</strong>默认为<strong>double型</strong>，因此<strong>声明float</strong>型常量，须后加<strong>‘f’或‘F’</strong></li>
</ul>
<blockquote>
<p>无论是赋值语句的数字还是字面常量的数字，只要是整型数字 java就认为是int，只要浮点数字就认为double</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译成功，但bigValue并非long型，而是int型</span></span><br><span class="line"><span class="keyword">long</span> bigValue = <span class="number">100</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译失败 ，系统不会把 9999999999999 当成long类型处理</span></span><br><span class="line"><span class="comment">所以超出 int 的表数范围，从而引起错误</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">long</span> bigValue1 = <span class="number">9999999999999</span>;</span><br><span class="line"><span class="comment">//下面代码是正确的，在巨大的整数值后使用 L 后缀 ，强制使用long 类型</span></span><br><span class="line"><span class="keyword">long</span> bigVa1ue2 = <span class="number">9223372036854775807L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译失败，12.3默认是double型，大类型转小类型必须加强制转换符，或改为12.3f</span></span><br><span class="line"><span class="keyword">float</span> f1 = <span class="number">12.3</span>;</span><br></pre></td></tr></table></figure>

<hr>
</li>
</ol>
<ul>
<li><p><strong>整数值</strong>的<strong>4种</strong>表示方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义两个 8 位的二进制整数</span></span><br><span class="line"><span class="comment">// 注意，计算机底层都是以补码的方式存储数据的</span></span><br><span class="line"><span class="keyword">int</span> binVal1 = <span class="number">0b11010100</span>; </span><br><span class="line"><span class="keyword">byte</span> bnVal2= <span class="number">0B01101001</span>;</span><br><span class="line"><span class="comment">//以 0 开头的整数值是八进制的整数</span></span><br><span class="line"><span class="keyword">int</span> octa1Va1ue = <span class="number">013</span> ; </span><br><span class="line"><span class="comment">//0~9组成的十进制整数</span></span><br><span class="line"><span class="keyword">int</span> decValue = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//以 0x 或0X 开头的整数值是十六进制的整数</span></span><br><span class="line"><span class="keyword">int</span> hexVa1uel = <span class="number">0x13</span> ; </span><br><span class="line"><span class="keyword">int</span> hexVa1ue2 = <span class="number">0XaF</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>编程中进制间的转换，调用 Integer 的toHexString()，toOctalString()等方法</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>字符型</strong>的<strong>3种</strong>表示方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接指定单个字符作为字符值</span></span><br><span class="line"><span class="keyword">char</span> aChar = <span class="string">&#x27;a&#x27;</span>; </span><br><span class="line"><span class="comment">//使用转义字符来作为字符值</span></span><br><span class="line"><span class="keyword">char</span> enterChar = <span class="string">&#x27;\r&#x27;</span>; </span><br><span class="line"><span class="comment">//使用 Unicode 编码值来指定字符值</span></span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;\u9999&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>常用acsii编码字符</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>ASCII码</th>
</tr>
</thead>
<tbody><tr>
<td>a ~ z</td>
<td>97 ~ 122</td>
</tr>
<tr>
<td>A ~ Z</td>
<td>65 ~ 90</td>
</tr>
<tr>
<td>0 ~ 9</td>
<td>48 ~ 57</td>
</tr>
</tbody></table>
<ul>
<li>常见编码积累<ol>
<li>Windows CMD 默认编码是：ANSI编码，即GBK编码</li>
<li>UTF-8 是 Unicode 编码的一种形式，是国际最通用的编码</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>浮点型</strong>的<strong>2种</strong>表示方式</p>
<ul>
<li>十进制数形式:如5.12 、512.0 、.512 。浮点数必须包含一个小数点</li>
<li>科学计数法形式:例如 5.12e2 (即 5.12x10<sup>2</sup>)，5.12E2 也是5.12x10<sup>2</sup></li>
</ul>
</li>
<li><p>float:单精度，尾数可以精确到<strong>7位有效数字</strong>。很多情况下，精度很难满足需求</p>
<ul>
<li>虽说float只占4个字节，但因为尾数表示方式，表示数值的范围比long还大</li>
</ul>
</li>
<li><p>double:双精度，精度是float的两倍。通常采用此类型。</p>
<ul>
<li>小结：整型通常使用int类型，浮点型通常使用double</li>
</ul>
</li>
</ul>
<ol start="3">
<li><p><strong>类型间运算及其转换(不含boolean)</strong></p>
<ol>
<li><p><strong>自动类型转换</strong>：当不同数据类型之间运算时，结果自动<strong>提升为容量大的数据类型</strong>。</p>
<p>注意，当<strong>byte、char、short</strong>三种类型之间<strong>任何两种</strong>，<strong>包括自身两种</strong>变量做运算时，结果都转换为<strong>int型</strong></p>
<p>byte + byte = int….、byte + short = int 、char + byte = int 、char + short = int </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png"
                     
                ></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//相关练习与测试</span></span><br><span class="line">System.out.println(<span class="string">&quot;*	*&quot;</span>); 			<span class="comment">//*	   *</span></span><br><span class="line">System.out.print1n(<span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&#x27;*&#x27;</span>);	 <span class="comment">//93</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&quot;\t&quot;</span> + <span class="string">&#x27;*&#x27;</span>); 	 <span class="comment">//*	*</span></span><br><span class="line">System.out.printin(<span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&quot;*&quot;</span>); 	 <span class="comment">//51*</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + (<span class="string">&#x27;\t&#x27;</span> + <span class="string">&quot;*&quot;</span>));  <span class="comment">//*	*</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p><strong>强制类型转换</strong>：自动类型转换的逆运算，加强制转换符 ()，注意精度损失，或溢出</p>
</li>
<li><p><strong>String与其他类型的运算</strong>：String可以和8种基本数据类型变量做+运算，且运算只能是<strong>连接运算</strong>，运算的结果<strong>仍然是String类</strong>型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> number = <span class="number">100</span>;</span><br><span class="line">String numberStr = <span class="string">&quot;学号&quot;</span>;</span><br><span class="line">System.out.println(numberStr + number);<span class="comment">//输出 &quot;学号100&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>无论是自动转换还是<strong>强制转换</strong>，只能<strong>适用数值间</strong>的转换<strong>，即强制类型转换符()也</strong>只适用数值的数据类型</p>
</blockquote>
</li>
</ol>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ol>
<li><p><strong>算术运算符</strong></p>
<ol>
<li><p><strong>前至++与后至++</strong></p>
<ul>
<li><p>前置++：++i，先自增，后使用</p>
</li>
<li><p>后置++：i++，先使用，后自增</p>
</li>
<li><p>++与–的特点：<strong>不改变原数据类型</strong>的情况下进行++与–，<strong>效率高</strong></p>
</li>
<li><p>无论前置还是后置++还是–，<strong>均改变变量</strong>，i++ == i = i +1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">10</span>;</span><br><span class="line">s1 = s1 + <span class="number">1</span>;<span class="comment">//编译失败，int不能直接转换为short</span></span><br><span class="line">s1 = (<span class="keyword">short</span>)s1 + <span class="number">1</span> <span class="comment">//正确写法，效率低，截断方式</span></span><br><span class="line">s1++; <span class="comment">//编译运行均通过，正确写法，效率高</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>/除运算</strong>：</p>
<ul>
<li><p>无论在什么地方，<strong>两个int型相除</strong>，结果一定为<strong>整型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> result = <span class="number">12</span> / <span class="number">5</span>; <span class="comment">// result = 2.0;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>%模运算</strong>/取余：</p>
<ul>
<li><strong>模运算 = 前除后，求余数</strong></li>
<li>java规定，结果的符号与<strong>被模数</strong>(前面的数)的符号相同</li>
</ul>
</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>模运算式</th>
<th>结果</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>0 % 1</td>
<td>0</td>
<td><strong>0除以任何数=0</strong>，<strong>不会存在余数</strong></td>
</tr>
<tr>
<td>1 % 0</td>
<td>error</td>
<td>0<strong>不能作除数</strong>，作分母，溢出</td>
</tr>
<tr>
<td>2 % 1</td>
<td>0</td>
<td>整除余0</td>
</tr>
<tr>
<td>7 % 5</td>
<td>2</td>
<td>够除 1余2</td>
</tr>
<tr>
<td>2 % 3</td>
<td>3</td>
<td>不够除：0余2</td>
</tr>
<tr>
<td>12 % -5</td>
<td>2</td>
<td>符号由被<strong>模数决定</strong></td>
</tr>
<tr>
<td>-12 % -5</td>
<td>-2</td>
<td>同上</td>
</tr>
</tbody></table>
<ol start="2">
<li><p><strong>赋值运算符</strong></p>
<ul>
<li><p>复合/扩展运算符：</p>
<ul>
<li><p>基本原理：<code>num1 +=2; 等价 num1 = num1 + 2;</code></p>
</li>
<li><p>特点，同++一样，复合赋值运算符同样可以在<strong>不改变原数据类型</strong>情况下运算，更加高效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>; s1 += <span class="number">2</span>;<span class="comment">//编译运行均通过</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>; i *= <span class="number">0.1</span>; <span class="comment">//编译运行均通过 输出0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>综合练习</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">n += (n++) + (++n); <span class="comment">//n = n + (n++) + (++n); n = 10 + 10 + 12</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>逻辑运算符</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>布尔</th>
<th>数值(按位与)</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>if( true &amp; num++ )，全部执行</td>
<td>二进制按位与</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>短路与：if ( true &amp;&amp; num++ )，可得出结果就停止执行，即num++不执行</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>注意：**&amp;，|，^<strong>这三个运算符</strong>同为逻辑运算符与位运算符<strong>，具体表示哪种，</strong>取决于参与运算对象**是数值还是布尔值</li>
</ul>
</li>
<li><p><strong>位运算符</strong></p>
<table>
<thead>
<tr>
<th>位运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
</tr>
<tr>
<td>~</td>
<td>按位取反</td>
</tr>
<tr>
<td>&lt;&lt;n</td>
<td>左移n位右<strong>补零</strong></td>
</tr>
<tr>
<td>&gt;&gt;n</td>
<td>按位右移n位，<strong>补最高位</strong>(正数0，负数1)</td>
</tr>
<tr>
<td>&gt;&gt;&gt;</td>
<td>无符号右移，空缺位<strong>均补零</strong></td>
</tr>
</tbody></table>
<p>tips：注意，真正对计算机<strong>数值数据移位</strong>也是移动该数值的<strong>补码</strong>，如 -5 &lt;&lt; 2结果如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-%E8%B4%9F%E6%95%B0%E7%A7%BB%E4%BD%8D.png"
                     
                ></p>
<ul>
<li><p>位运算符常见应用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-j%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8.png"
                     
                ></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、你能否写出最高效的2 * 8的实现方式？ </span></span><br><span class="line"><span class="number">2</span> &lt;&lt; <span class="number">3</span>  或  <span class="number">8</span> &lt;&lt; <span class="number">1</span></span><br><span class="line"><span class="comment">//2、交换两个数值变量的几种方式</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1 + <span class="string">&quot;,num2 = &quot;</span> + num2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式一：定义临时变量的方式</span></span><br><span class="line"><span class="comment">//推荐的方式</span></span><br><span class="line"><span class="comment">//int temp = num1;</span></span><br><span class="line"><span class="comment">//num1 = num2;</span></span><br><span class="line"><span class="comment">//num2 = temp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：好处：不用定义临时变量  </span></span><br><span class="line"><span class="comment">//弊端：① 相加操作可能超出存储范围 ② 有局限性：只能适用于数值类型</span></span><br><span class="line"><span class="comment">//num1 = num1 + num2;</span></span><br><span class="line"><span class="comment">//num2 = num1 - num2;</span></span><br><span class="line"><span class="comment">//num1 = num1 - num2;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*方式三：使用位运算符</span></span><br><span class="line"><span class="comment">	num1=(numl ^ num2)^num2;</span></span><br><span class="line"><span class="comment">	num2=(num2 ^ num1)^num1;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//有局限性：只能适用于数值类型</span></span><br><span class="line">num1 = num1 ^ num2;</span><br><span class="line">num2 = num1 ^ num2;</span><br><span class="line">num1 = num1 ^ num2;<span class="comment">//此时num2 == num1</span></span><br><span class="line">System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1 + <span class="string">&quot;,num2 = &quot;</span> + num2);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>三元/目表达式</strong></p>
<ul>
<li>格式：表达式1 ? 表达式2 : 表达式3</li>
</ul>
<p>​       含义：若表达式1为真，整个条件表达式返回表达式2的结果反之表达式3的结果</p>
<ul>
<li><p>三元运算符可以嵌套使用</p>
</li>
<li><p>若程序使用三元运算符，又可以使用if-else结构，优先选择三元运算符。原因：简洁、执行效率高。</p>
</li>
<li><p>表达式1和表达式2不要求完全一致，但必须可兼容为其中一种类型</p>
</li>
<li><p>对于数值基本数据类型，使用三元运算符还会想使用比较运算符那样进行自动类型转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="keyword">true</span> ? <span class="number">3</span> : <span class="number">4.0</span>);<span class="comment">//输出3.0，自动转换为double型</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<ol start="5">
<li><p><strong>比较运算符</strong></p>
<ul>
<li>‘==，&gt;，&lt;，&gt;=，&lt;= ‘：粗略来说，比较运算符只能用于<strong>数值类型</strong>(类型不一定完全相同，底层是数值即可)</li>
<li>特别说明，’==’ 也可以在<strong>引用类型中使用</strong>，但也聚焦在<strong>数值上</strong>(地址值)</li>
</ul>
</li>
</ol>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ol>
<li><p><strong>顺序结构</strong></p>
</li>
<li><p><strong>分支结构</strong></p>
<ul>
<li><p><strong>if-else结构</strong></p>
<ul>
<li>if：符合则执行</li>
</ul>
</li>
<li><p>if - else：2选1</p>
</li>
<li><p>if - else if - else ：n选1</p>
<hr>
<ul>
<li><p>若if-else结构中只有<strong>一条执行语句</strong>，则可以省略{}</p>
</li>
<li><p>同时，省略{}的if语句的else总是与<strong>最近</strong>的未匹配的if匹配</p>
</li>
</ul>
</li>
<li><p><strong>switch结构</strong></p>
<ul>
<li><strong>执行逻辑</strong>：根据switch表达式的值，依次匹配各个case中的常量。一旦匹配成功，则执行case结构中语句。若此时没有遇到break语句，则<strong>不判断地</strong>直接继续向下执行其他case结构中的执行语句，直到遇到break关键字或末尾结束为止。(为更好理解，表达式与case 后语句划上等号进行的判断)</li>
<li>表达式支持<strong>6种</strong>数据类型：<strong>byte 、short、char、int、枚举类型</strong>(JDK5.0新增)、<strong>String</strong>类型(JDK7.0新增)</li>
<li>把<strong>default</strong>语句理解成为一个<strong>无条件case</strong>语句则一切明了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例1：常见方式</span></span><br><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 常量表达式<span class="number">1</span> : 语句<span class="number">1</span>;<span class="comment">//break;</span></span><br><span class="line">	…</span><br><span class="line">	<span class="keyword">case</span> 常量表达式n : 语句n;<span class="comment">//break;</span></span><br><span class="line">	<span class="keyword">default</span> : 语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出1，2，3，4</span></span><br><span class="line"><span class="keyword">int</span> i =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(i)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:System.out.println(<span class="string">&quot;2&quot;</span>);		</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:System.out.println(<span class="string">&quot;3&quot;</span>);		</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例2：多个case共用一条语句</span></span><br><span class="line"><span class="comment">//应理解为，每个case的执行语句都为空，且没有break，因此连续执行</span></span><br><span class="line"><span class="comment">//不应该理解为内嵌case语句</span></span><br><span class="line"><span class="comment">//值为‘A\B\C’都执行语句1</span></span><br><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> ‘A’ :</span><br><span class="line">	<span class="keyword">case</span> ‘B’ :</span><br><span class="line">	<span class="keyword">case</span> ‘C’ : 语句<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">	…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编写经验</strong></p>
<ul>
<li><p>若多个条件表达式之间是</p>
<ul>
<li><p>“<strong>互斥</strong>“关系(或没有交集的关系),哪个判断和执行语句声明在上面还是下面，无所谓</p>
</li>
<li><p>交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面</p>
</li>
<li><p><strong>有包含</strong>的关系，通常情况下，需要将<strong>范围小</strong>的声明<strong>在范围大的上面</strong>。<strong>否则，范围小的就没机会执行了</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例1：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graduate</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		InstanceTest test = <span class="keyword">new</span> InstanceTest();</span><br><span class="line">		test.method(<span class="keyword">new</span> Student());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Person e)</span></span>&#123;</span><br><span class="line">		<span class="comment">//错误写法,每次执行第一个if</span></span><br><span class="line">        <span class="comment">//if(e instanceof Person)&#123;</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;a graduated student&quot;);</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;a student&quot;);</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;a person&quot;);</span></span><br><span class="line"><span class="comment">//		&#125;else if(e instanceof Student)&#123;</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;a student&quot;);</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;a person&quot;);</span></span><br><span class="line"><span class="comment">//		&#125;else if(e instanceof Graduate)&#123;</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;a person&quot;);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">       </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//方式一，包含关系应将范围小的在范围大前判断</span></span><br><span class="line">		<span class="keyword">if</span>(e <span class="keyword">instanceof</span> Graduate)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;a graduated student&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a student&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a person&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a student&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;a person&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a person&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//方式二</span></span><br><span class="line">		<span class="keyword">if</span>(e <span class="keyword">instanceof</span> Graduate)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a graduated student&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(e <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a student&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(e <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a person&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p><strong>循环结构</strong></p>
<ul>
<li><p>循环相关关键字使用：</p>
<ul>
<li><p><strong>break</strong>：结束<strong>当前</strong>循环体的循环</p>
</li>
<li><p><strong>continue</strong>：结束<strong>当次</strong>循环体当的循环</p>
<hr>
</li>
<li><p>break与continue<strong>语句后</strong>均<strong>不能声明执行语句</strong></p>
</li>
<li><p>break与continue只作用在离关键字<strong>最近的循环体</strong></p>
<hr>
</li>
<li><p><strong>带标签break与continue</strong>语句使用：可指定作用在哪一层循环结构</p>
<ol>
<li>在拟作用循环体前<strong>声明标签</strong>：<strong>label :  for</strong>()</li>
<li>在break或continue语句后追加标签民：<strong>break label;</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">label:<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">10</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">//break;//默认跳出包裹此关键字最近的一层循环。</span></span><br><span class="line">			<span class="comment">//continue;</span></span><br><span class="line">			<span class="keyword">break</span> label;<span class="comment">//结束指定标识的一层循环结构</span></span><br><span class="line">             <span class="comment">//continue labe1；//结束指定标识的一层循环结构当次循环  </span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(j);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>for循环</strong></p>
<ul>
<li><p>for内的变量只在for中有效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首次执行：1-&gt;2-&gt;3-&gt;4</span></span><br><span class="line"><span class="comment">//循环执行：2-&gt;3-&gt;4，2-&gt;3-&gt;4...</span></span><br><span class="line"><span class="comment">//可输入多个语句用逗号“，”</span></span><br><span class="line"><span class="keyword">for</span>( <span class="number">1</span>,?,? ; <span class="number">2</span> ; <span class="number">4</span>)&#123;</span><br><span class="line">	<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>while循环</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首次执行：1-&gt;2-&gt;3</span></span><br><span class="line"><span class="comment">//循环执行：2-&gt;3,2-&gt;3...</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">2</span>)&#123;</span><br><span class="line">	<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>do-while循环</strong></p>
<ul>
<li><p>do-while循环至少会执行一次循环体！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首次执行：1 - 3 - 4 </span></span><br><span class="line"><span class="comment">//循环执行：2 - 3 - 4 </span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	<span class="number">3</span>;</span><br><span class="line">	<span class="number">4</span>;</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>





</li>
</ul>
</li>
</ul>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><ul>
<li><p><strong>基本概念</strong></p>
<ul>
<li>数组的类型可以是<strong>基本数据类型</strong>，也可<strong>引用数据类型</strong></li>
<li>数组是<strong>引用数据类型</strong>，必须含<strong>new</strong>，含方法，含属性(常用length)</li>
</ul>
</li>
<li><p>数组长度一旦确定，就不可修改</p>
</li>
<li><p><strong>声明与初始化</strong>：静态初始化，动态初始化</p>
<ul>
<li><p><strong>静态初始化</strong>：<strong>指定</strong>数组元素的<strong>初始值</strong>，由<strong>系统决定</strong>数组<strong>长度</strong> </p>
</li>
<li><p><strong>动态初始化</strong>：<strong>指定数组长度</strong>(可以是<strong>变量</strong>)，由<strong>系统</strong>为数组元素<strong>分配初始值</strong></p>
<blockquote>
<pre><code>整型：0
浮点型：0.0
char型：0或&#39;\u0000&#39;，而非&#39;0&#39;
boolean型：false
用数据类型：null</code></pre>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> [] ids;<span class="comment">//声明</span></span><br><span class="line">ids = <span class="keyword">new</span> ids[]&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>&#125;;<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;<span class="comment">//简化语法格式</span></span><br><span class="line"></span><br><span class="line">String[] names = <span class="keyword">new</span> String[<span class="number">4</span>];<span class="comment">//动态初始化，数组长度可以是变量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数组的内存解析</strong></p>
<p>待补充，暂时不需要</p>
</li>
</ul>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><ol>
<li><p><strong>基础认知</strong></p>
<ul>
<li>从数组底层的运行机制上来看(线性内存，多维映射)，没有多维数组</li>
</ul>
</li>
</ol>
<ul>
<li>把多维数组看成多个一维数组的内嵌，如二维数组是一个一维数组，每个数组元素也是一个数组</li>
</ul>
<ol start="2">
<li><p><strong>二维数组的使用</strong></p>
<ul>
<li><p><strong>初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;<span class="comment">//静态初始化</span></span><br><span class="line">String[][] arr2 = <span class="keyword">new</span> String[<span class="number">2</span>][<span class="number">3</span>];<span class="comment">//动态初始化</span></span><br><span class="line"></span><br><span class="line">String[][] arr3 = <span class="keyword">new</span> String[<span class="number">3</span>][];<span class="comment">//动态初始化，但不能直接使用，还需指定列</span></span><br><span class="line"><span class="comment">//指定列后才可以使用，否则报空指针异常。注意，指定哪个(实例化哪个)用哪个可用</span></span><br><span class="line">arr3[<span class="number">0</span>] = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>长度</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">arr1.length;<span class="comment">//3</span></span><br><span class="line">arr1[<span class="number">0</span>].length;<span class="comment">//3</span></span><br><span class="line">arr1[<span class="number">1</span>].length;<span class="comment">//2</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>内存解析</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//规定：二维数组分为外层数组的元素，内层数组的元素</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">//外层元素：arr[0],arr[1]等</span></span><br><span class="line"><span class="comment">//内层元素：arr[0][0],arr[1][2]等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组元素的默认初始化值 </span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">//外层元素的初始化值为：地址值</span></span><br><span class="line"><span class="comment">//内层元素的初始化值为：与一维数组初始化情况相同</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][];</span><br><span class="line"><span class="comment">//外层元素的初始化值为：null</span></span><br><span class="line"><span class="comment">//内层元素的初始化值为：不能调用，否则报错。</span></span><br></pre></td></tr></table></figure>

<p>   <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-java8-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90.jpg"
                     
                ></p>
</li>
</ul>
<h2 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h2><ul>
<li><strong>ArrayIndexOutOfBoundsException</strong>：角标越界异常</li>
<li><strong>NullPointerException</strong>：空指针异常</li>
</ul>
<h1 id="内存结构与变量"><a href="#内存结构与变量" class="headerlink" title="内存结构与变量"></a>内存结构与变量</h1><p>JVM基本结构</p>
<ul>
<li><p><strong>虚拟机堆</strong>(heap)：存放<strong>数组</strong>、<strong>对象实例</strong>(含非static属性)</p>
</li>
<li><p><strong>虚拟机栈</strong>(stack)：存放<strong>局部变量</strong>、<strong>对象引用</strong></p>
</li>
<li><p><strong>方法区</strong>(method area)：存储虚拟机<strong>已加载</strong>的、<strong>类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>编译后的代码</strong></p>
</li>
<li><p>本地方法栈(native method stack)：</p>
</li>
<li><p>程序计数器(PC)：</p>
</li>
<li><p>加载流程：<strong>编译</strong> —&gt; 一个或多个<strong>字节码文件</strong>(class) —&gt; JVM<strong>类加载器</strong>和<strong>解析器</strong>进行<strong>解析运行</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE回炉-JVM内存结构图.jpge.bmp"
                      style="zoom:120%;" /
                >



</li>
</ul>
<h2 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型"></a>变量的类型</h2><h2 id="变量的初始化及默认值"><a href="#变量的初始化及默认值" class="headerlink" title="变量的初始化及默认值"></a>变量的初始化及默认值</h2><h2 id="不同变量的内存结构"><a href="#不同变量的内存结构" class="headerlink" title="不同变量的内存结构"></a>不同变量的内存结构</h2><ul>
<li><p>Java变量的类型**：局部变量，成员变量</p>
<ul>
<li><p><strong>局部变量</strong>：形参、方法内变量、代码块内变量</p>
</li>
<li><p><strong>成员变量</strong>：类中方法外的变量</p>
<ul>
<li>实例变量(非static修饰)</li>
<li>类变量(static修饰)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>不同变量的内存结构</strong></li>
</ul>
<ul>
<li><strong>变量的默认值</strong></li>
</ul>
<ul>
<li><p>声明一个变量后，必须用赋值语句对变量进行<strong>显式初始化</strong>(赋值)<strong>才能使用</strong>，使用未初始化的变量，出现<strong>编译错误</strong></p>
<p><strong>注意</strong>：对于<strong>引用数据类型</strong>，有别于基本数据类型。如初始化的<strong>数组</strong>元素，类中属性等，系统<strong>会默认给予初始值</strong>。</p>
<ul>
<li>整型（byte、short、int、long：0）</li>
<li>浮点型（float、double：0.0）</li>
<li>字符型（char：0  （或’\u0000’））</li>
<li>布尔型（boolean：false）</li>
<li>引用数据类型（类、数组、接口：null）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure>
</li>
<li><p>变量的作用域：其定义所在的一对{ }内 ，变量只有在其作用域内才有效 ，同一个作用域内，不能定义重名的变量</p>
</li>
</ul>
<p>掌握局部变量和全局变量： 局部变量： 定义：在函数内定义的变量，包括形式变量，程序块，都属于局部变量。只在函数内有效 存储特性：仅在需要时才开辟内存单元，使用完毕后释放。 注意：程序块是由{}构成的，它的作用范围更加小，程序块里定义的变量只在程序块{}内有效13 全局变量： 定义：函数外定义的变量属于外部变量/全局变量。有效范围从定义位置到当前源文件(.c)结束。 存储特性：在程序的全部执行过程中始终占用存储单元 注意：变量名习惯第首字母用大写 2、理解数据的存储类别含义：指数据在内存中的存储方式 1、变量存储类别的两种方式：静态存储方式和动态存储方式 (都是在内存中开辟空间) 静态存储区：在程序开始执行时就开始分配存储单元，程序执行完才释放。在程序执行过程 中始终占据固定的存储单元，而不是动态地进行分配和释放。如全局变量 动态存储区：仅在使用(函数调用，实参传入等)的时分配空间。代码功能执行完后就释放。 如：形参，自动变量(未加 static 声明的局部变量)，函数调用现场保护和返回地址</p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类成员及内存结构"><a href="#类成员及内存结构" class="headerlink" title="类成员及内存结构"></a>类成员及内存结构</h2><p><strong>类成员</strong>：属性、方法、构造器、代码块、内部类</p>
<ul>
<li><p><strong>基础概念</strong></p>
<ul>
<li><strong>类</strong>：对一类事物的描述，是抽象的，概念上的定义</li>
<li><strong>对象</strong>：某个类的具体实体，也成为<strong>实例</strong>(instance)，创建一个对象 == <strong>实例化</strong></li>
<li><strong>属性</strong>：类中的<strong>成员的变量</strong>(field)，调用 <code>对象.属性;</code></li>
<li><strong>行为</strong>：类的<strong>成员的方法</strong>(method)，调用 <code>对象.方法()</code></li>
</ul>
</li>
<li><p><strong>属性</strong>与<strong>局部变量</strong>异同点</p>
<ul>
<li><strong>属性</strong>：<ul>
<li><strong>直接定义</strong>在<strong>类</strong>的一对{}内</li>
<li>声明属性可<strong>指明其权限</strong>：<strong>private</strong>、<strong>public</strong>、<strong>缺省</strong>(默认不写权限)、<strong>protected</strong></li>
</ul>
</li>
<li><strong>局部变量</strong>：<ul>
<li>声明在<strong>方法</strong>内、<strong>方法形参</strong>、<strong>代码块内</strong>、<strong>构造器形参、构造器内部</strong>的变量</li>
<li><strong>不可使用</strong>权限修饰符</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method(<span class="string">&quot;Tom&quot;</span>);<span class="comment">//传入的为实参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String name)</span></span>&#123;&#125;<span class="comment">//方法参数。形式参数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方法(method)</strong></p>
<ul>
<li><p><strong>创建</strong>：<code>public static void method(String name)&#123;&#125;</code></p>
</li>
<li><p><strong>重载</strong>：“两同一不同”。与<strong>权限修饰符、返回值类型、形参变量名、方法体均无关</strong>(按<strong>可区分调用角度</strong>理解即可)</p>
<ul>
<li>同一个<strong>类</strong>、相同<strong>方法名</strong></li>
<li>参数列表不同：参数<strong>个数不同</strong>，参数<strong>类型不同</strong></li>
</ul>
</li>
<li><p><strong>可变个数形参</strong>(jdk 5.0)： </p>
<ul>
<li><p><strong>格式</strong>：<code>数据类型 ... 变量名,如 String...strs </code></p>
<p>tips：当方法<strong>不止一个形参</strong>且<strong>含可变形参</strong>时，可变形参<strong>只能置于末尾</strong>，否则编译不通过(不可区分变量类型)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public void show(String...strs,int i); //错误情况，</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i,String...strs)</span></span>;<span class="comment">// 正确情况</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>内在逻辑：除与数组作为新参的<strong>实参传入格式不一样</strong>外(可变形参用逗号)，可变个数形参<strong>等价于数组</strong></p>
</li>
<li><p>因此可与数组类型构成<strong>重写</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">show(<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Wang&quot;</span>,<span class="string">&quot;Deng&quot;</span>)<span class="comment">//可连续传入多个数据，用逗号隔开。</span></span><br><span class="line">show(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Wang&quot;</span>,<span class="string">&quot;Deng&quot;</span>&#125;);<span class="comment">//同样可以通过数组的方式传入实参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String...strs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; stes.length;i++)&#123;<span class="comment">//等价与数组</span></span><br><span class="line">        System.out.println(strs[i]);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String name)</span></span>&#123;&#125;<span class="comment">//可以构成重载</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>return</strong>关键字：</p>
<ul>
<li><strong>无返回值</strong>：结束当前方法</li>
<li><strong>有返回值</strong>：结束当前方法且返回指定变量</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>匿名对象</strong>：<code>new Person().run();</code></p>
<ul>
<li>匿名对象<strong>只能调用一次</strong></li>
</ul>
</li>
<li><p><strong>变量类型及其内存结构</strong></p>
</li>
</ul>
<ul>
<li><p><strong>方法传递机制</strong>：Java方法参数传递方式<strong>只有一种</strong>，<strong>值传递！</strong></p>
<ul>
<li>基本数据类型：变量<strong>值</strong></li>
<li>引用数据类型：地址<strong>值</strong></li>
</ul>
<hr>
<ul>
<li><p><strong>String与值传递机制</strong></p>
<ul>
<li>字符串是存储在字符串常量池，是<strong>不可变</strong>(特性)的字符序列</li>
</ul>
</li>
<li><p>当字符串常量池中已经有相同的字符串，则直接复用执行该字符串的地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s1);<span class="comment">//仍输出hello </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    str = <span class="string">&quot;hi~&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* String确实是**引用数据类型**，值传递也确实在传递s1的**地址值**，但由于字**符串常量池的特性**(不可变序列)导致没有改变</span><br><span class="line">* 由于字符串在java中大量使用，因此JVM特意开辟一个空间专门用于存储字符串，若同时又两个相同的字符串，常量池只记录一个</span><br><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;gitee.com&#x2F;yihangdeng&#x2F;blogImage&#x2F;raw&#x2F;master&#x2F;img&#x2F;javaSE回炉-String内存与值传递机制.png)</span><br><span class="line"></span><br><span class="line">1. 在字符串常量池创建字符串&quot;hello&quot;，因为字符串底层是通过char[]存储的，确定后是不可变的字符序列</span><br><span class="line">1. 把“hello”字符串与s1关联起来</span><br><span class="line">1. 调用方法时，实参传入s1的地址值，并赋值给str</span><br><span class="line">1. 由于字符串常量池不可变的特性，拟赋值的“hi~~”字符串只能新建一份</span><br><span class="line">1. 并将“hi~~”字符串与赋值语句中的str关联</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>值传递机制例题分析</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//需实现调用method方法后，打印除a=100,b=200,请写出method方法代码</span></span><br><span class="line">        method(a,b);</span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;b=&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>由于Java基本数据类型<strong>无指针操作</strong>，若想通过<strong>方法调用</strong>实现交换两个<strong>基本数据类型</strong>的值。严格来说是<strong>不行的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现方式1：方法内打印，立即终止程序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        a = a*<span class="number">10</span>;</span><br><span class="line">        b = b*<span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;b=&quot;</span> + b);</span><br><span class="line">    	System.exit(<span class="number">0</span>);<span class="comment">//终止程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现方式2：方法重写/覆盖</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    PrintStream ps = <span class="keyword">new</span> PrintStream(System.out)&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span></span>&#123;</span><br><span class="line">              <span class="keyword">if</span>(<span class="string">&quot;a=10&quot;</span>.equals(x))&#123;</span><br><span class="line">                  x = <span class="string">&quot;a=100&quot;</span>;</span><br><span class="line">              &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;b=10&quot;</span>.equals(x))&#123;</span><br><span class="line">                  x = <span class="string">&quot;b=200&quot;</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">super</span>.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    System.setOut(ps);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>若想通过调用一个方法实现数组两个元素值交换，则必须通过<strong>引用类型</strong>作为<strong>引导媒介</strong>进行交换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例：若想通过调用一个方法的形式交换数组中某两个值，只能如下写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = arr[i];   </span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul>
<li><p><strong>基本概念</strong></p>
<ul>
<li><strong>高内聚</strong> ：类的内部数据操作细节自己完成，不允许外部干涉；</li>
<li><strong>低耦合</strong> ：仅对外暴露少量的方法用于使用</li>
</ul>
</li>
<li><p><strong>封装性的一些体现</strong>：具体体现在面向对象程序设计上</p>
<ul>
<li>属性私有化(private)、公共(public)方法来调用</li>
<li>不对外暴露的私有方法</li>
<li>单例模式…</li>
</ul>
</li>
<li><p><strong>权限修饰符</strong>：<strong>private</strong>、<strong>缺省</strong>(默认不写权限)、<strong>protected</strong>、<strong>public</strong>(从小到大)，可添加到<strong>类的成员</strong>与<strong>类</strong>(class)前</p>
<ul>
<li><p><strong>类的成员</strong>(全支持)：属性、方法、构造器、内部类、<del>代码块</del></p>
<ul>
<li>注意：以下权限范围的调用对象是<strong>类的成员可以不可被调用，不是类可不可以创建</strong></li>
<li>常用private与public，需注意是(缺省)与protected的对比</li>
</ul>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类内部</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>同一工程</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>(缺省)</td>
<td>Yes</td>
<td><strong>Yes</strong>(需注意)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>Yes</td>
<td>Yes</td>
<td><strong>Yes</strong>(需注意)</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>df</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p><strong>类</strong>(仅public与缺省可用)：<strong>缺省情况</strong>下可通过<strong>import</strong>在不同包中调用类</p>
</li>
</ul>
</li>
<li><p><strong>构造器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建类的对象：new + 构造器</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person(); <span class="comment">//new Person()就是调用构造器</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果<strong>没显式</strong>的定义类的构造器的话，则系统默认提供一个<strong>空参的构造器</strong></li>
<li>构造器<strong>不可定义返回值</strong>，其实构造器的作用就是返回引用的地址值，因此不能自定义</li>
<li>定义构造器的格式：<code>权限修饰符  类名(形参列表)&#123;&#125;</code></li>
<li>一个类中定义的<strong>多个构造器</strong>，彼此<strong>构成重载</strong></li>
<li>一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</li>
<li>一个类中，<strong>至少会有一个构造器</strong></li>
</ul>
<hr>
<ul>
<li><p><strong>属性赋值</strong>的先后顺序：默认初始化 —&gt; 显示初始化 —&gt; 构造器初始化 —&gt; 属性或方法调用赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>);<span class="comment">//name：null - &gt; &quot;Tom&quot;</span></span><br><span class="line">p.setName(<span class="string">&quot;Deng&quot;</span>);<span class="comment">//name: &quot;Deng&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        name = str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        name = str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>JavaBean</strong>：由java语言编写的<strong>可重用组件</strong></p>
<ul>
<li>类是公共的</li>
<li>有一个公共的无参构造器</li>
<li>有属性，且含属性对应的get和set方法</li>
</ul>
</li>
<li><p><strong>this关键字</strong>：this理解为“<strong>当前创建的对象</strong>”，谁掉它，谁就是this</p>
<ul>
<li><p><strong>调用的结构</strong>：适用于，<strong>属性、方法；构造器</strong></p>
<ul>
<li><p><strong>属性、方法</strong>：解决形参与属性<strong>同名</strong>时，通过<strong>this特指类成员</strong>的属性/方法</p>
<ul>
<li>格式：<code>this.field; 或 this.method();</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;<span class="comment">//同名解决</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>* **构造器**：用于**构造器中调用其他重载构造器**，常用于解决重载构造器代码冗余问题

  * 格式：`this(); //调用空参构造器`
  * 构造器中**不能**通过this调用构造器产生**死循环回调**
    1. 构造器中不能通过调用自己
    1. 同理如类中有n个构造器，则最多有 n - 1构造器中使用了&quot;this(形参列表)&quot;
  * 构造器中&quot;this(形参列表)&quot;必须声明在当前**构造器的首行**
  * 构造器内部，**只能使用一次**this调用其他构造器

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需求：&quot;Person初始化时，需要考虑如下的1,2,3,4...(共40行代码)&quot;;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//通过在空参构造器中书写“1,2,3,4...(共40行代码)”</span></span><br><span class="line">		System.out.println(info);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>();<span class="comment">//其他构造器调用空参构造器逻辑即可</span></span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>();<span class="comment">//其他构造器调用空参构造器逻辑即可</span></span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(age);<span class="comment">//还可以通过形参指定构造器调用</span></span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li><p><strong>UML简述</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE回炉-UML简述.png"
                      style="zoom:80%;" /
                >
</li>
<li><p><strong>package关键字</strong></p>
<ul>
<li>为了<strong>方便管理</strong>项目中的<strong>类</strong>，提供包的概念，一个包含多个类</li>
<li>使用package声明类或接口所属的包时，应声明在<strong>头部</strong></li>
</ul>
<hr>
<ul>
<li><strong>MVC设计常用包定义</strong><ul>
<li><strong>Model</strong> 模型层：处理数据<ul>
<li>数据对象封装：model.bean/domain</li>
<li>数据库操作类：model.dao</li>
<li>数据库：model.db</li>
</ul>
</li>
<li><strong>Controller</strong> 控制层：处理业务逻辑<ul>
<li>应用界面相关：controller.activity</li>
<li>存放fragment：controller.fragment</li>
<li>显示列表的适配器：controller.adapter</li>
<li>服务相关的：controller.service</li>
<li>抽取的基类：controller.base</li>
</ul>
</li>
<li><strong>View</strong> 视图层： 显示数据<ul>
<li>相关工具类：view.utils</li>
<li>自定义view：view.ui</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>import关键字</strong></p>
<ul>
<li><p>在源文件中显式的使用import结构<strong>导入指定包</strong>下的<strong>类、接口</strong></p>
</li>
<li><p>声明在<strong>包</strong>的声明和<strong>类</strong>的声明<strong>之间</strong></p>
</li>
<li><p>可以使用”xxx.*”的(通配符)方式，表示可以导入xxx包下的**所有结构 **<code>import java.util.*;</code></p>
</li>
<li><p>如果使用的类或接口是<strong>java.lang包</strong>下定义的，则<strong>可以省略import</strong>结构</p>
</li>
<li><p>如果在源文件中，使用了<strong>不同包</strong>下的<strong>同名的类</strong>，则必须<strong>至少一个</strong>类需要以<strong>全类名</strong>的方式显示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//若存在com.test.java1.Account与com.test.java2.Account</span></span><br><span class="line"><span class="comment">//想同时使用不同包下的Account类则至少一个使用全类名的方式使用</span></span><br><span class="line"><span class="keyword">import</span> com.test.java1;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Account acct = <span class="keyword">new</span> Account();<span class="comment">//使用了com.test.java1</span></span><br><span class="line">        <span class="comment">//通过全类名的方式指定使用</span></span><br><span class="line">        com.test.java2.Account acct2 = <span class="keyword">new</span> com.test.java2.Account();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用”xxx.*”方式表明可以调用xxx包下的所结构。但是如果使用的是<strong>xxx子包下的结构</strong>，则仍需要<strong>显式导入</strong></p>
<ul>
<li><p><strong>子包</strong>：如存在<code>存在 com.test.java1与com.test.java1.son</code>，则son属于<code>com.test.java1</code>的子包</p>
<p>即就算<code>import com.test.java1;</code>若使用<code>com.test.java1.son</code>仍需显式导入</p>
</li>
</ul>
</li>
<li><p>import static:<strong>导入</strong>指定类或接口中的<strong>静态结构</strong>(非类结构)，而是静态的<strong>属性和方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如JDK中System类</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;<span class="comment">//此时所有System静态的书写和方法都被导入</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//此时使用打印语句可以省略System</span></span><br><span class="line">out.println(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li><strong>继承的效果</strong>(extends：<strong>延展、扩展</strong>)：<ul>
<li>若子类继承父类后，子类A中就<strong>获取</strong>了父类B中声明的<strong>所有</strong>的<strong>属性和方法</strong>(包括间接父类)。包括<strong>private私有</strong>属性和方法。</li>
<li>注意，子类获取父类属性和方法肯定是<strong>全部获取</strong>到了，但<strong>子类调用</strong>父类的属性和方法时<strong>受父类的权限修饰符影响</strong>。不能直接调用private修是的类成员。<strong>因此</strong>，继承应理解为子类对父类在<strong>调用角度上</strong>的<strong>扩展</strong>，<strong>而非代码的直接import，或copy</strong>。</li>
<li><strong>创建子类</strong>的对象，在<strong>堆空间</strong>中，就会<strong>加载</strong>所有<strong>父类中声明的属性和方法</strong></li>
</ul>
</li>
<li><strong>继承的作用</strong><ul>
<li><strong>减少</strong>了代码的<strong>冗余</strong>，<strong>提高</strong>了代码的<strong>复用性</strong><ul>
<li>便于<strong>功能的扩展</strong></li>
<li>为之后<strong>多态性</strong>的使用，提供了<strong>前提</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p><strong>继承的使用</strong></p>
<ul>
<li><p><strong>继承的格式</strong>：<code>class A extends B&#123;&#125;</code>，若B is A == true ，在逻辑上符合继承</p>
<ul>
<li>A：子类、派生类、<strong>sub</strong>class</li>
<li>B：父类、超类、基类、<strong>super</strong>class</li>
</ul>
<ul>
<li><p><strong>Java的单继承性</strong>：一个类<strong>只能有一个父类</strong>，但可<strong>多层单继承</strong>。</p>
<ul>
<li>子类<strong>直接继承</strong>的父类称为，<strong>直接父类</strong></li>
<li>子类<strong>间接继承</strong>的父类称为，<strong>间接父类</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-java%E7%B1%BB%E5%8D%95%E7%BB%A7%E6%89%BF%E6%80%A7.jpg"
                     
                ></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Object类</strong></p>
<ul>
<li>若<strong>没显式的声明</strong>一个类的父类的话，则<strong>此类继承于java.lang.Object类</strong></li>
</ul>
<ol start="2">
<li>因此除java.lang.Object类，<strong>所有java类</strong>都<strong>直接或间接</strong>的继承于java.lang.<strong>Object类</strong></li>
<li>意味着，所有java类具有java.lang.Object类声明的功能。</li>
</ol>
</li>
<li><p><strong>重写</strong>(override/overwrite)：子类继承父类以后，可以<strong>对父类</strong>中<strong>同名同参</strong>的<strong>方法</strong>，进行<strong>覆盖操作</strong></p>
<ul>
<li><p><strong>只能重写方法，</strong>属性无重写之说</p>
<blockquote>
<p>若<strong>子类</strong>与<strong>父类</strong>声明<strong>同名属性</strong>，则子类非多态实例化时，按就近原则调用<strong>自己(子类)定义</strong>的同名属性</p>
</blockquote>
<ul>
<li><strong>子类重写</strong>的方法的<strong>权限修饰符</strong>  <strong>≥ 父类</strong>被重写方法的权限修饰符</li>
</ul>
</li>
<li><p><strong>子类不能重写</strong>，父类中声明为<strong>private</strong>权限的方法</p>
<ul>
<li><p>返回值类型</p>
<ul>
<li><strong>父类</strong>被重写的返回值类型<strong>是void</strong>，则子类重写的方法的返回值类型<strong>只能是void</strong></li>
<li><strong>父类</strong>被重写的返回值类型是<strong>A类型</strong>(引用数据类型)，则<strong>子类</strong>重写的返回值类型可以是<strong>A类或A类的子类</strong></li>
<li>父类被重写的返回值类型是<strong>基本数据类型</strong>(如double)，则子类重写的返回值类型<strong>必须是相同</strong>(必需是double)</li>
</ul>
</li>
<li><p><strong>子类重写</strong>的方法<strong>抛出的异常类型</strong> <strong>≤ 父类</strong>被重写的方法<strong>抛出的异常类型</strong></p>
</li>
<li><p>父类被<strong>static</strong>修饰的属性和方法<strong>不能被重写</strong>。但<strong>可以</strong>在子类中声明<strong>同名同参的static</strong>属性和方法(但此时<strong>不是重写</strong>)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>super关键字</strong>：指调用父类的结构</p>
<ul>
<li><p><strong>调用的结构</strong>：类this关键字，同样适用于，<strong>属性、方法；构造器</strong></p>
</li>
<li><p>super关键字定位父类结构，默认先按直接父类到间接父类一层层往上找，一旦匹配则结束</p>
<hr>
</li>
<li><p><strong>属性，方法相关</strong>：</p>
</li>
<li><p>常用于在子类中调用<strong>父类同名的属性</strong>(属性无重写之说)</p>
</li>
<li><p>常用在子类中调用<strong>父类被重写的方法</strong></p>
<hr>
</li>
<li><p><strong>构造器相关</strong>：</p>
</li>
<li><p>可以在子类的构造器中显式的使用”super(形参列表)”的方式，<strong>调用父类</strong>中声明的<strong>指定的构造器</strong></p>
</li>
<li><p>super(形参列表)”的使用，必须声明在<strong>子类构造器</strong>的<strong>首行</strong></p>
</li>
<li><p>this与super调用构造器<strong>只能二选一</strong>，<strong>不能同时出现</strong></p>
<hr>
<p>在子类构造器的首行，没显式的声明”this(形参列表)”或”super(形参列表)”，则<strong>默认调用</strong>的是<strong>父类中空参的构造器</strong></p>
</li>
<li><p>在类的多个构造器中，<strong>至少一个构造器</strong>中使用了”super(形参列表)”，<strong>调用父类中的构造器</strong></p>
</li>
</ul>
</li>
<li><p><strong>子类对象实例化过程</strong></p>
<ul>
<li>子类对象创建时，<strong>系统一定</strong>会<strong>直接或间接</strong>的<strong>调用其父类的构造器</strong>，进而调用父类的父类的构造器，…<strong>直到</strong>调用了java.lang.<strong>Object类</strong>中<strong>空参的构造器</strong>为止。同时，正因为加载过所有直接或间接父类的结构，所以才可以看到内存中这些父类中的结构，子类对象也才可以调用所有父类的属性和方法</li>
<li>虽然创建子类对象时，调用了父类的构造器，但是<strong>自始至终就创建过一个对象</strong>，即为new的子类对象。</li>
</ul>
</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li><p><strong>何为多态</strong>：多态是<strong>一个行为</strong>具有<strong>多个不同</strong>表现<strong>形式或形态</strong>的能力</p>
<ul>
<li>代码语法层面看，多态指，<strong>父类的引用</strong>指向<strong>子类的对象</strong>，同时对<strong>父类</strong>进行<strong>虚拟方法调用</strong></li>
<li>菜鸟教程：多态就是<strong>同一个接口</strong>，使用<strong>不同的实例</strong>而<strong>执行不同操作</strong></li>
</ul>
</li>
<li><p><strong>多态性的使用</strong>：</p>
<ul>
<li><p>多态使用书写：<strong>父类的引用</strong>指向<strong>子类的对象</strong>，<code>Person p = new Man();</code></p>
</li>
<li><p>编译期，<strong>只能</strong>调用<strong>父类中</strong>声明<strong>属性和方法</strong></p>
</li>
<li><p>运行期：</p>
<ul>
<li><p>属性：<strong>父类的属性</strong>(属性无重写即无多态 ; 可通过向下转型调用子类的内容)</p>
</li>
<li><p>方法：<strong>父类</strong>声明的方法，若方法<strong>被子类重写</strong>则<strong>调用子类重写的方法</strong>(虚拟方法调用)</p>
<blockquote>
<p>一般多态的使用，主要集中在虚拟方法的调用，因为一般子类继承父类都常重写父类的特定方法。因此粗略归纳多态的使用条件可以有两点</p>
<ul>
<li>类的继承关系</li>
<li>方法的重写</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>注意，内存实际上加载了子类特有的属性和方法，但是由于变量声明为父类类型，导致编译时只能调用父类声明的属性和方法</p>
</li>
</ul>
</li>
<li><p><strong>多态的作用</strong></p>
<ul>
<li><p>消除类型之间的耦合关系</p>
</li>
<li><p>可替换性</p>
</li>
<li><p>可扩充性，(自带，归类分配控制器，减少编写重载方法)</p>
</li>
<li><p>接口性</p>
</li>
<li><p>灵活性</p>
</li>
<li><p>简化性</p>
<blockquote>
<p>多态的作用与优点不仅几段文字描述，需从面向对象程序设计思想中学习多态的作用</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;动物，在进食&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;动物，在跑&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Dog，在进食&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Dog，在跑&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Cat，在进食&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Cat，在跑&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Animal a = <span class="keyword">new</span> Dog();</span><br><span class="line">		active(a);<span class="comment">//输出：Dog，在进食，Dog，在跑</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//多态的使用，只需编写一个方法，减少重载方法的编写</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">active</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">		animal.eat();</span><br><span class="line">		animal.run();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//若不使用多态</span></span><br><span class="line"><span class="comment">//	public static void active(Dog dog)&#123;</span></span><br><span class="line"><span class="comment">//		dog.eat();</span></span><br><span class="line"><span class="comment">//		dog.run();</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	public static void active(Cat cat)&#123;</span></span><br><span class="line"><span class="comment">//		cat.eat();</span></span><br><span class="line"><span class="comment">//		cat.run();</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重载与重写的区别</strong></p>
<ul>
<li><p><strong>重载</strong>：不表现为多态性</p>
<p>​    对于编译器而言，这些同名方法就成了不同的方法。在方法调用之前，<strong>编译器</strong>就已经确定了所要调用的方法，这称为“<strong>早绑定</strong>”或“<strong>静态绑定</strong>”；属于一个<strong>编译型行为</strong>。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。</p>
</li>
<li><p><strong>重写</strong>：表现为多态性</p>
<p>​    对于多态，只有等到方法调用的那一刻，<strong>解释运行器</strong>才会确定所要调用的具体方法，这样的方法调用在编译时其无法确定，称为“<strong>晚绑定</strong>”或“<strong>动态绑定</strong>”。属于一个<strong>运行时行为</strong></p>
</li>
</ul>
<blockquote>
<p>引用一句Bruce Eckel的话：“不要犯傻，如果它不是<strong>晚绑定</strong>，它就不是<strong>多态</strong>！”</p>
</blockquote>
</li>
<li><p><strong>多态的向下转型</strong></p>
<ul>
<li>多态的Java类可通过 <code>()</code>进行强制向下转型，通常情况，强转之前先用<code>instanceof</code> 关键字判别一下再转，否则不兼容类型强转会报出 ClassCastException 异常</li>
<li>向下转型后的对象是子类对象的引用与实例，此时则可调用子类特用的属性和方法</li>
<li><strong>instancof关键字</strong>：<ul>
<li><code>a instanceof A</code>：判断<strong>对象a</strong>是否是<strong>类A的实例</strong>。如果是，<strong>返回true</strong>；否则返回false。</li>
<li>若<code>a instanceof A == true</code>，则A类及其A类<strong>所有直接间接父类</strong>(顶级父类Object)<strong>都返回true</strong>，多态实例也是实例</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE回炉-java8-多态向下上转型.jpg"
                      style="zoom: 80%;" /
                >

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用上述例子的Animal、Dog、Cat类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Animal a = <span class="keyword">new</span> Dog();</span><br><span class="line">        <span class="comment">//强制向下转型</span></span><br><span class="line">        Dog dog = (Dog)a;<span class="comment">//通过</span></span><br><span class="line">        Cat cat = (Cat)a;<span class="comment">//报错</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;向下转型成功，此对象为Dog&quot;</span>);<span class="comment">//正常输出</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练习</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//问题一：编译时通过，运行时不通过</span></span><br><span class="line">		<span class="comment">//举例一：</span></span><br><span class="line"><span class="comment">//	Person p3 = new Woman();</span></span><br><span class="line"><span class="comment">//	Man m3 = (Man)p3;</span></span><br><span class="line">	<span class="comment">//举例二：</span></span><br><span class="line"><span class="comment">//	Person p4 = new Person();</span></span><br><span class="line"><span class="comment">//	Man m4 = (Man)p4;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//问题二：编译通过，运行时也通过</span></span><br><span class="line"><span class="comment">//	Object obj = new Woman();</span></span><br><span class="line"><span class="comment">//	Person p = (Person)obj;</span></span><br><span class="line">		</span><br><span class="line">	<span class="comment">//问题三：编译不通过</span></span><br><span class="line"><span class="comment">//	Man m5 = new Woman();</span></span><br><span class="line"><span class="comment">//	String str = new Date();</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldMethodTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Sub s = <span class="keyword">new</span> Sub();</span><br><span class="line">		System.out.println(s.count);<span class="comment">//20</span></span><br><span class="line">		s.display();<span class="comment">//20</span></span><br><span class="line">		</span><br><span class="line">		Base b = s;<span class="comment">//多态性</span></span><br><span class="line">		<span class="comment">//==：对于引用数据类型来讲，比较的是两个引用数据类型变量的地址值是否相同</span></span><br><span class="line">		System.out.println(b == s);<span class="comment">//true</span></span><br><span class="line">		System.out.println(b.count);<span class="comment">//10</span></span><br><span class="line">		b.display();<span class="comment">//20</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><ul>
<li><p><strong>基础说明</strong></p>
<ul>
<li>java.lang.Object类是所Java类的<strong>根父类</strong>，<strong>所有类</strong>的直接或间接地继承它<ul>
<li>因此Object类中的功能(属性、方法)就具<strong>通用性</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Object部分功能</strong>：无属性，方法 + 构造器</p>
<ul>
<li><p>Object类只声明了一个空参的构造器(所有对象实例化都调用)</p>
<hr>
</li>
<li><p><strong>clone</strong>()：对象克隆</p>
</li>
<li><p><strong>finalize</strong>()：对象垃圾回收之前被系统自动调用，一般不主动调用</p>
</li>
<li><p><strong>getClass</strong>()：获取对象的类，反射相关</p>
</li>
<li><p>hashCode()：集合相关</p>
</li>
<li><p>wait、notify、notifyAll：线程相关</p>
</li>
<li><p>…</p>
<hr>
</li>
</ul>
</li>
<li><p><strong>当前重点的Object功能</strong>：equals(Object)、toString()</p>
<ul>
<li><p>两者重写都可以通过eclipse快速生成</p>
</li>
<li><p><strong>equals</strong> 与 == 的使用</p>
<hr>
<ul>
<li><strong>Object类</strong>equals功能：与 == 的<strong>作用是相同</strong>的，比较<strong>两个对象</strong>的<strong>地址值是否相同</strong></li>
<li>常重写equals后功能：比较两个引用类型<strong>实体内容</strong>是否相等</li>
</ul>
<hr>
<ul>
<li><p><strong>==</strong> ： 是个<strong>运算符</strong>、可以使用在<strong>基本数据</strong>类型和<strong>引用数据</strong>类型</p>
<ul>
<li><p><strong>基本数据类型</strong>：<strong>数值</strong>上的相等(类型不一定一样，底层是数值即可、因为会自动类型转换)</p>
</li>
<li><p><strong>引用数据类型</strong>：引用的地址值是否相等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、基本数据类型：数值</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">10.0</span>;</span><br><span class="line">System.out.println(i == d);<span class="comment">//输出true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、引用数据类型：地址值(数值)</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>,<span class="number">21</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>,<span class="number">21</span>);</span><br><span class="line">System.out.println(p1 == p2);<span class="comment">//输出false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>boolean <strong>equals</strong>(Object)：是个<strong>方法</strong>，<strong>只能</strong>使用在<strong>引用数据类型中</strong>，只要用于(自定义)对比<strong>引用数据类型</strong>中<strong>内容</strong>是否相等。常提供子类对equals方法进行重写来实现自定义实体内容相等判别效果</p>
<ul>
<li><p>Object类中的equals(<strong>)源码</strong>定义：Object原生功能与 == 的<strong>作用是相同</strong>的，比较<strong>两个对象</strong>的<strong>地址值是否相同</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>String、Date、File、包装类等都重写了Object类中的equals()方法：被重写成<strong>实体内容</strong>是否相等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//1、未重写Object equals()方法：等同==，比较两个引用地址值</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>,<span class="number">21</span>);</span><br><span class="line">    Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>,<span class="number">21</span>);</span><br><span class="line">    System.out.println(p1.equals(p2));<span class="comment">//输出false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、某java提供类重写了equals()实现了比较实体内容是否相等的功能</span></span><br><span class="line">    String s1 = <span class="keyword">new</span> String(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">    String s2 = <span class="keyword">new</span> String(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">    System.out.println(s1.equals(s2));<span class="comment">//输出true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里主要通过String new的方式说明源码重写了String的equals方法</span></span><br><span class="line">    <span class="comment">//但通过 == 的方式直接创建字符串会因字符串常量池原理而出现== 为true情况</span></span><br><span class="line">    <span class="comment">//String s3 = &quot;ABC&quot;;</span></span><br><span class="line">    <span class="comment">//String s4 = &quot;ABC&quot;;</span></span><br><span class="line">    <span class="comment">//System.out.println(s3 == s4);//输出true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、自定义重写equals方法实现自定义类实体内容上的比较</span></span><br><span class="line">    <span class="comment">//简陋版</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">if</span>(<span class="keyword">this</span> == obj)</span><br><span class="line">    			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    		</span><br><span class="line">    		<span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">    			Person anObj = (Person)obj;</span><br><span class="line">    			<span class="keyword">return</span> <span class="keyword">this</span>.name.equals(anObj.name) &amp;&amp; <span class="keyword">this</span>.age == anObj.age;</span><br><span class="line">    		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(p1.equals(p2));<span class="comment">//输出true</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//eclipse自动生成equals方法(标准高效参考)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">        Person other = (Person) obj;</span><br><span class="line">        <span class="keyword">if</span> (age != other.age)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (other.name != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>String，equals方法重写源代码分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line"> 		<span class="comment">//1、若引用地址都一样，则内容肯定一样(重写equals通用代码)</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    	<span class="comment">//2、若与String比较的传入类型不是String，则不允许，返回false</span></span><br><span class="line">   <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">           String anotherString = (String)anObject;</span><br><span class="line">       <span class="keyword">int</span> n = value.length;<span class="comment">//String底层通过char [] value;数组存储</span></span><br><span class="line">           <span class="comment">//3、若字符序列的长度都不一样，则内容肯定不一样</span></span><br><span class="line">           <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">               <span class="keyword">char</span> v1[] = value;</span><br><span class="line">               <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">               <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">               <span class="comment">//4、挨个字符比较</span></span><br><span class="line">             <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                   i++;</span><br><span class="line">             &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>eclipse自动生成equals重写源码分析</strong>：</p>
<ul>
<li><p>SSS</p>
</li>
<li><p><strong>重写equals()方法原则</strong></p>
</li>
<li><p><strong>Null-false</strong>：任何情况下，x.equals(null)，永远返回是“false” </p>
<ul>
<li><strong>类型一致</strong>：x.equals(和x不同类型的对象)永远返回是“false”</li>
</ul>
</li>
<li><p><strong>对称性</strong>：如果x.equals(y)返回是“true” ，那么y.equals(x)也应该返回是 “true”</p>
<ul>
<li><strong>自反性</strong>：x.equals(x)必须返回是“true”</li>
<li><strong>传递性</strong>：如果x.equals(y)返回是“true” ，而且y.equals(z)返回是“true” ， 那么z.equals(x)也应该返回是“true”</li>
<li><strong>一致性</strong>：如果x.equals(y)返回是“true” ，只要x和y内容一直不变，不管你 重复x.equals(y)多少次，返回都是“true”</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>toString</strong>：</p>
<hr>
<ul>
<li><strong>Object类</strong>toString功能：输出<strong>类名及其堆空间存储地址</strong>(虚拟地址)<ul>
<li>System.out.<strong>println</strong>(引用数据类型)输出语句，底层也是<strong>调用toString</strong></li>
</ul>
</li>
<li>常重写toString后功能：<strong>打印</strong>引用类型<strong>实体的内容</strong></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>当<strong>输出</strong>一个<strong>对象的引用</strong>时，实际上就是调用当前对象的<strong>toString</strong>()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;ABV&quot;</span>, <span class="number">10</span>);</span><br><span class="line">System.out.println(p1); <span class="comment">//输出：com.yhd.test.Person@15db9742</span></span><br><span class="line">System.out.println(p1.toString()); <span class="comment">//输出：com.yhd.test.Person@15db9742</span></span><br></pre></td></tr></table></figure>

<ul>
<li>源码分析</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PrintStream.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">      String s = String.valueOf(x); <span class="comment">//主要通过调用了String.valueOf();</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            print(s);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//String.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (obj == <span class="keyword">null</span>) ? <span class="string">&quot;null&quot;</span> : obj.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>Object</strong>类中toString()的<strong>源码</strong>定义：输出<strong>类名及其堆空间存储地址</strong>(虚拟地址)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//类名 + 堆空间存储地址(通过hashCode计算出来数值并转换为十六进制的)</span></span><br><span class="line">   <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：Java中的地址都是虚拟地址，操作系统之上的JVM，非真实的物理地址</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>String、Date、File、包装类等都重写了Object类中的toString()方法</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul>
<li><p><strong>基本含义</strong>：为了使基本数据类型的变量具有类的特征。java提供8种基本数据类型的包装类，这些包装类可以完成对应基本数据类型的所有功能操作(都含对应基本数据类型的value属性)。同时，因为封装成类，还可提供各种丰富的方法调用。</p>
</li>
<li><p><strong>自动装箱与拆箱</strong>(JDK5.0)：</p>
</li>
<li><p>小结：</p>
<ul>
<li>基本数据类型 &lt;—&gt; 包装类：自动/手动(构造器)装拆箱</li>
<li>数值(基本数据+包装) &lt;—&gt; String：调类(包装类/String类)的重载方法，</li>
</ul>
</li>
</ul>
<p>​    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-%E5%8C%85%E8%A3%85%E7%B1%BB.png"
                     
                ></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、基本数据类型 ——&gt; 包装类</span></span><br><span class="line">    <span class="comment">//1、手动装箱：构造器封装/创建</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    Integer itg1 = <span class="keyword">new</span> Integer(i);</span><br><span class="line">    Integer itg2 = <span class="keyword">new</span> Integer(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="comment">//Integer itg3 = new Integer(&quot;2B&quot;);//异常：数字格式/匹配异常</span></span><br><span class="line">    System.out.println(<span class="string">&quot;itg1: &quot;</span> + itg1 + <span class="string">&quot; , itg2：&quot;</span> + itg2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、自动装箱</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    Integer j_itg1 = j;</span><br><span class="line">    System.out.println(<span class="string">&quot;j_itg1: &quot;</span> + j_itg1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、包装类 ——&gt; 基本数据类型(多种类型)</span></span><br><span class="line">    <span class="comment">//1、手动拆箱：调用包装类的 xxxValue();方法</span></span><br><span class="line">    Float flt = <span class="keyword">new</span> Float(<span class="number">1F</span>);</span><br><span class="line">    <span class="keyword">float</span> f = flt.floatValue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、自动拆箱</span></span><br><span class="line">    <span class="keyword">float</span> f2 = flt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有了自动拆装箱的便利，基本可以成整体</span></span><br><span class="line"><span class="comment">//3、[数值型] —— &gt; String</span></span><br><span class="line">    <span class="comment">//方式1：与空串 &quot;&quot; 进行连接运算</span></span><br><span class="line">    String s1 = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式2：调用String重载的valueOf(XXX xxx) 重载方法</span></span><br><span class="line">    String s2 = String.valueOf(i);<span class="comment">//基本数据类型</span></span><br><span class="line">    s2 = String.valueOf(itg1);<span class="comment">//包装类/obj多态传入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式3：调用包装类的toStrin方法</span></span><br><span class="line">    s2 = itg1.toString();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、String ——&gt; [数值型]</span></span><br><span class="line">    <span class="comment">//方式1：调用包装类parseXxx()方法</span></span><br><span class="line">    String s3 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> num1 = Integer.parseInt(s3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//tips：除了boolean，其他有关字符串的装拆箱，与转换若存在字符匹配问题都会报错，需注意</span></span><br></pre></td></tr></table></figure>



<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul>
<li><strong>可修饰结构</strong>：属性、方法、代码块、内部类</li>
</ul>
<h3 id="修饰属性"><a href="#修饰属性" class="headerlink" title="修饰属性"></a>修饰属性</h3><ul>
<li><p>被static修饰的变量称为<strong>静态变量</strong>或<strong>类变量</strong>，该变量将会被同一个类多个对象共享。某个对象改变该静态变量，类中所有对象的该变量斗会被改变(因为共用一份)</p>
</li>
<li><p>静态变量随着<strong>类的加载而加载</strong>。可以<strong>直接通过类名</strong>进行调用”<code>类.静态变量</code>“</p>
<ul>
<li>静态变量的加载要<strong>早于对象的创建</strong></li>
<li>由于<strong>类只会加载一次</strong>，则静态变量在内存中也<strong>只会存在一份</strong>：存在<strong>方法区的静态域</strong>中</li>
<li>静态属性举例：<code>System.out; Math.PI;</code></li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE回炉-静态变量内存解析.jpg"
                      style="zoom:80%;" /
                >



<h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h3><ul>
<li>同样随着类的加载而加载，可以通过”<code>类.静态方法</code>“的方式进行调用</li>
<li><strong>静态方法</strong>中，<strong>只能</strong>调用<strong>静态的方法或属性</strong>(因为静态方法和属性比对象<strong>加载的早</strong>)<ul>
<li>同理：在静态的方法内，<strong>不能使用this关键字、super</strong>关键字(因为这些都是创建对象使用的关键字)</li>
</ul>
</li>
<li><strong>非静态方法</strong>中，<strong>既可</strong>以调用非静态的方法或属性，<strong>也可</strong>以调用静态的方法或属性</li>
</ul>
<h3 id="静态属性和方法应用场景"><a href="#静态属性和方法应用场景" class="headerlink" title="静态属性和方法应用场景"></a>静态属性和方法应用场景</h3><ul>
<li><p><strong>属性</strong>：</p>
<ul>
<li>当属性是可以被多个<strong>对象共享</strong>的，<strong>不会随着对象的不同而不同</strong>的</li>
<li>类中的<strong>常量</strong>也常常声明为static</li>
</ul>
</li>
<li><p><strong>方法</strong>：</p>
<ul>
<li><strong>操作静态属性</strong>的方法，通常设置为static的</li>
<li><strong>工具类</strong>中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections</li>
</ul>
<hr>
</li>
<li><p><strong>常见应用</strong>：单例模式，懒汉式、饿汉式</p>
<ul>
<li><strong>单例模式</strong>：采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</li>
</ul>
<blockquote>
<p>若让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为<strong>private</strong>，这样，就不能用new操作符在类的外部产生 类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的<strong>某个静态方法</strong>以返回类内部创建的对象， <strong>静态方法只能访问类中的静态成员变量</strong>，所以，指向类内部产生的该类对象 的变量也必须定义成静态的。</p>
</blockquote>
<ul>
<li><strong>两种单例模式编写</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、(简单/不安全)懒汉式：什么时候用，什么时候创建</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//1、构造器私有化</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Bank instance;<span class="comment">//2、静态化</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="comment">//2、静态化</span></span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">			instance = <span class="keyword">new</span> Bank();</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、饿汉式：不管什么，先创建再说</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//1、构造器私有化</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">new</span> Order();<span class="comment">//2、直接实例化(静态只有一份)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>懒汉式和饿汉式的对比<ul>
<li><strong>饿汉式</strong>：<ul>
<li>缺点：对象加载时间过长</li>
<li>优点：线程安全</li>
</ul>
</li>
<li><strong>懒汉式</strong>：<ul>
<li>缺点：目前写法线程不安全(两个线程挤入if == null)</li>
<li>优点：延迟对象的创建</li>
</ul>
</li>
</ul>
</li>
<li><strong>常见单例模式应用场景</strong><ul>
<li>网站的计数器，一般也是单例模式实现，否则难以同步</li>
<li>应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志 文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加</li>
<li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库 资源</li>
<li>项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置 文件数据，都生成一个对象去读取</li>
<li>Application 也是单例的典型应用</li>
<li>Windows的Task Manager (任务管理器)就是很典型的单例模式</li>
<li>Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程 中，回收站一直维护着仅有的一个实例。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><p><strong>基本含义</strong>：</p>
<ul>
<li>main()方法作为程序的入口</li>
<li>main()方法也是一个普通的静态方法</li>
<li>main()方法可以作为我们与控制台<strong>交互的方式</strong>（如之前使用Scanner的方式）</li>
</ul>
<p><strong>将控制台获取的数据传入main函数形参</strong>String[] args：</p>
<ul>
<li><p>eclipse交互：</p>
<ul>
<li><strong>1</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-eclipse%E6%96%B9%E5%BC%8F%E4%B8%8Emain%E5%BD%A2%E5%8F%82%E4%BA%A4%E4%BA%921.jpg"
                     
                ></p>
<ul>
<li><p><strong>2</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-eclipse%E6%96%B9%E5%BC%8F%E4%B8%8Emain%E5%BD%A2%E5%8F%82%E4%BA%A4%E4%BA%922.jpg"
                     
                ></p>
</li>
</ul>
</li>
</ul>
<p>​    </p>
<ul>
<li><p>控制台交互：</p>
<ul>
<li><p>注意：记事本方式javac编译需把 packeage 代码去掉</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE回炉-控制台方式与main形参交互.jpg"
                      style="zoom:150%;" /
                >



</li>
</ul>
</li>
</ul>
<p>运行时：java 类名 “Tom” “Jerry” “123” “true”</p>
<p>sysout(args[0]);//“Tom”<br>sysout(args[3]);//“true”  –&gt;Boolean.parseBoolean(args[3]);<br>sysout(args[4]);//报异常</p>
<p>小结：一叶知秋<br>public static void main(String[] args){//方法体}</p>
<p>权限修饰符：private 缺省 protected pubilc —-&gt;封装性<br>修饰符：static \ final \ abstract \native 可以用来修饰方法<br>返回值类型： 无返回值 / 有返回值 –&gt;return<br>方法名：需要满足标识符命名的规则、规范；”见名知意”<br>形参列表：重载 vs 重写；参数的值传递机制；体现对象的多态性<br>方法体：来体现方法的功能</p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ul>
<li><p><strong>代码块使用</strong>：如同方法一般的声明位置，格式为<code>&#123;&#125;</code></p>
</li>
<li><p><strong>代码块的作用</strong>：用来初始化类、对象的信息</p>
</li>
<li><p><strong>代码块的修饰</strong>：只能用static修饰</p>
<ul>
<li>静态代码块：<ul>
<li><strong>随着类的加载</strong>而执行，<strong>且只执行一次</strong></li>
<li>类中定义了多个静态代码块，则按照声明的先后顺序执行(一般只写一个)</li>
</ul>
</li>
<li>非静态代码块<ul>
<li>随着<strong>对象的创建而执行</strong>，每创建一次执行一次</li>
<li>多个非静态代码块，则按照声明的先后顺序执行(一般只写一个)</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>static修饰类同性质<ul>
<li>静态代码块随类的加载而加载一次，非静态随对象创建而加载</li>
<li>静态代码块的执行要优先于非静态代码块的执行</li>
<li>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</li>
<li>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>应用场景</strong></p>
<ul>
<li>静态代码块：常用于不以创建对象而调用方法，即为<strong>静态方法</strong>提供的看似为”<strong>静态构造器</strong>“的作用，完成一种静态的初始化(一次性初始化)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如JDBC连接池</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//一次性初始化/实例化，DataSource 数据库连接池</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		InputStream is = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			is = DBCPTest.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;);</span><br><span class="line">			Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">			pros.load(is);</span><br><span class="line">			<span class="comment">//调用BasicDataSourceFactory的静态方法，获取数据源。</span></span><br><span class="line">			dataSource = BasicDataSourceFactory.createDataSource(pros);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(is != <span class="keyword">null</span>)&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					is.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//使用DBCP数据库连接池获取数据库的连接</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">		Connection conn = dataSource.getConnection();</span><br><span class="line">		System.out.println(conn);</span><br><span class="line">		<span class="keyword">return</span> conn;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>再谈子类对象实例化加载顺序</strong>：</p>
<ul>
<li>无论使静态还是非静态，<strong>代码块</strong>都在<strong>构造器前</strong>执行</li>
<li>由父及子，静态先行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java3;</span><br><span class="line"><span class="comment">//总结：由父及子，静态先行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Root</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的无参数的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mid</span> <span class="keyword">extends</span> <span class="title">Root</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的无参数的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		<span class="comment">//通过this调用同一类中重载的构造器</span></span><br><span class="line">		<span class="keyword">this</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的带参数构造器，其参数值：&quot;</span></span><br><span class="line">			+ msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Mid</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//通过super调用父类中有一个字符串参数的构造器</span></span><br><span class="line">		<span class="keyword">super</span>(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeafTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Leaf(); </span><br><span class="line">		System.out.println();</span><br><span class="line">		<span class="keyword">new</span> Leaf();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果如下：</span></span><br><span class="line"><span class="comment">Root的静态初始化块</span></span><br><span class="line"><span class="comment">Mid的静态初始化块</span></span><br><span class="line"><span class="comment">Leaf的静态初始化块</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Root的普通初始化块</span></span><br><span class="line"><span class="comment">Root的无参数的构造器</span></span><br><span class="line"><span class="comment">Mid的普通初始化块</span></span><br><span class="line"><span class="comment">Mid的无参数的构造器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Mid的带参数构造器，其参数值：尚硅谷</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Leaf的普通初始化块</span></span><br><span class="line"><span class="comment">Leaf的构造器</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代码块属性赋值执行顺序</strong>：系统初始化 —&gt; 显示初始化 / <strong>代码块初始化</strong> —&gt; 构造器初始化 —&gt;外部调用初始化</p>
</li>
</ul>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul>
<li><strong>可修饰结构</strong>：类、方法、变量</li>
</ul>
<hr>
<ul>
<li><strong>类</strong>：此类<strong>不能被其他类所继承</strong>(无子类)，如：String类、System类、StringBuffer类</li>
</ul>
<ul>
<li><p><strong>方法</strong>：表明此方法<strong>不可以被重写</strong>，如：Object类中getClass()</p>
<ul>
<li><p><strong>变量</strong>：称为是一个<strong>常量</strong></p>
<ul>
<li><p><strong>属性</strong>：</p>
<ul>
<li>常量赋值的位置：(只能自动化初始化)显式初始化、代码块中初始化、构造器中初始化</li>
<li>必须初始化，只能使用，不能重新赋值</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>局部变量/形参</strong>：必须初始化，只能使用，不能重新赋值</p>
<ul>
<li>可以数据类型，也可引用类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本数据类型形参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="comment">//i++; //报错，只能使用不能赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用数据类型形参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">(<span class="keyword">final</span> Person p)</span></span>&#123;</span><br><span class="line">    p.age++;<span class="comment">//通过</span></span><br><span class="line">    p = <span class="keyword">new</span> Person();<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>static final 同时修饰</strong>结构交集：属性与方法</p>
<ul>
<li><strong>属性</strong>：全局常量(常见)</li>
<li><strong>方法</strong>：静态方法且不可重写</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="抽像类"><a href="#抽像类" class="headerlink" title="抽像类"></a>抽像类</h2><p>关键字：<strong>abstract</strong>，可修饰结构，<strong>类、方法</strong></p>
<ul>
<li><p>修饰类：<strong>抽象类</strong></p>
<ul>
<li>此类<strong>虽不能实例化，但一定要有构造器</strong>，便于子类实例化时调用（涉及：子类对象实例化的全过程）</li>
<li>开发中，都会<strong>提供抽象类的子类</strong>，让子类对象实例化，完成相关的操作 —&gt;抽象的使用前提：继承性</li>
</ul>
</li>
<li><p>除此之外，抽象类可以定义一般类的成员，如，属性、方法、代码块…</p>
</li>
<li><p>修饰方法：<strong>抽象方法</strong></p>
<ul>
<li><p>抽象方法只有声明，没方法体</p>
<p><code>public abstract void eat();</code></p>
</li>
<li><p>抽象方法只能声明在<strong>抽像类中</strong>。反之，抽象类中可以没有抽象方法的。</p>
</li>
<li><p>继承抽象类的子类<strong>必须强制实现</strong>(重写)所有抽象父类中的<strong>所有的抽象方法</strong>，若<strong>子类也是抽象</strong>类则不用。</p>
</li>
<li><p>补充说明</p>
<ul>
<li><p>abstract不能用来修饰<strong>私有方法</strong>(子类无法重写)、静态方法、final的方法、final的类</p>
</li>
<li><p>抽线类除不能被实例化外，如下<code>Person p = new Person();</code>符合面向对象类的其他定义操作，如继承，多态，子类自身实例化等等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person p = new Person();//不允许</span></span><br><span class="line">Person p = <span class="keyword">new</span> Man();<span class="comment">//允许，假设class Man extends Person </span></span><br><span class="line">Man m = <span class="keyword">new</span> Man();<span class="comment">//允许</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>创建抽象类的匿名子类</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽线类Person</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//书写步骤：Person p = new Person()&#123;&lt;回车&gt;&#125;;</span></span><br><span class="line"><span class="comment">//创建一个匿名子类对象(其实是通过多态的一种方式实现了匿名实例化)</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个匿名子类的匿名对象</span></span><br><span class="line"><span class="comment">//书写：method(new Person()&#123;&lt;回车&gt;&#125;);</span></span><br><span class="line">method(<span class="keyword">new</span> Person()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>常见应用场景</strong></p>
<ul>
<li><p>IO流中设计到的抽象类：InputStream/OutputStream / Reader /Writer。在其内部<br>定义了抽象的read()、write()方法。</p>
</li>
<li><p><strong>模板方法的设计模式</strong></p>
</li>
</ul>
<blockquote>
<p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模 板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象 类的行为方式。 </p>
<p>解决的问题：</p>
<ul>
<li>当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以 把不确定的部分暴露出去，让子类去实现。</li>
<li>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用， 这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽 象出来，供不同子类实现。这就是一种模板模式</li>
</ul>
</blockquote>
<ul>
<li>例1</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		TemplateSub ts = <span class="keyword">new</span> TemplateSub();</span><br><span class="line">		ts.spendTime();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模板方法设计模式体现</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spendTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		code();<span class="comment">//易变部分，不确认部分</span></span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;运行时间：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemplateSub</span> <span class="keyword">extends</span> <span class="title">Template</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j=<span class="number">0</span>;i &lt; <span class="number">100000</span>;i++)</span><br><span class="line">			j+=j;</span><br><span class="line">		System.out.println(<span class="string">&quot;代码执行中...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>例2</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类的应用：模板方法的设计模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethodTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		BankTemplateMethod btm = <span class="keyword">new</span> DrawMoney();</span><br><span class="line">		btm.process();</span><br><span class="line"></span><br><span class="line">		BankTemplateMethod btm2 = <span class="keyword">new</span> ManageMoney();</span><br><span class="line">		btm2.process();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTemplateMethod</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 具体方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;取号排队&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">transact</span><span class="params">()</span></span>; <span class="comment">// 办理具体的业务 //钩子方法</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evaluate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;反馈评分&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模板方法，把基本操作组合到一起，子类一般不能重写</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.takeNumber();</span><br><span class="line">		<span class="keyword">this</span>.transact();<span class="comment">// 像个钩子，具体执行时，挂哪个子类，就执行哪个子类的实现代码</span></span><br><span class="line">		<span class="keyword">this</span>.evaluate();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DrawMoney</span> <span class="keyword">extends</span> <span class="title">BankTemplateMethod</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我要取款！！！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManageMoney</span> <span class="keyword">extends</span> <span class="title">BankTemplateMethod</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我要理财！我这里有2000万美元!!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>场景应用场景</li>
</ul>
<p>模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的 影子，比如常见的有：</p>
<ul>
<li>数据库访问的封装</li>
<li>Junit单元测试</li>
<li>JavaWeb的Servlet中关于doGet/doPost方法调用</li>
<li>Hibernate中模板程序</li>
<li>Spring中JDBCTemlate、HibernateTemplate等</li>
</ul>
</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote>
<ul>
<li>一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又 没有is-a的关系，仅仅是具有<strong>相同的行为特征</strong>而已。例如：鼠标、键盘、打 印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都 支持USB连接。</li>
<li>另一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。</li>
</ul>
<p>接口就是<strong>规范</strong>，定义的是<strong>一组规则</strong>，体现了现实世界中“如果你是/要…则 必须能…”的思想。继承是一个”是不是”的关系，而接口实现则是 “能不能” 的关系。 </p>
<p>接口的本质是<strong>契约，标准，规范</strong>，就像我们的法律一样。制定好后大家都要遵守</p>
<p>接口聚焦点在<strong>行为</strong>，是相同的<strong>行为</strong></p>
<p>同抽象类，接口也体现多态性</p>
</blockquote>
<ul>
<li><p><strong>例1</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-%E6%8E%A5%E5%8F%A3%E4%B8%BE%E4%BE%8B01.jpg"
                     
                ></p>
</li>
<li><p><strong>例2</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-%E6%8E%A5%E5%8F%A3%E4%B8%BE%E4%BE%8B02.jpg"
                     
                ></p>
</li>
</ul>
<ul>
<li><p><strong>接口的使用</strong></p>
<ul>
<li><p>接口使用<strong>interface</strong>来定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口内可定义成员：</p>
<ul>
<li><strong>JDK7</strong>前：只能定义<strong>全局常量</strong>与<strong>抽像方法</strong><ul>
<li><strong>全局常量</strong>：<code>public static final</code> ，书写时，可省略不写。<ul>
<li><code>public static final int MAX;等价于 int MAX </code></li>
</ul>
</li>
<li><strong>抽象方法</strong>：<code>public abstract void method();</code>，书写时，可省略不写。<ul>
<li><code>public abstract void  method();等价于 void method();</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接口中<strong>不能定义构造器</strong>的！即接口不可以实例化</p>
</li>
<li><p><strong>接口和类</strong>是<strong>并列</strong>的两个结构，接口通过让类去<strong>实现</strong>(<strong>implements</strong>)的方式来使用</p>
<ul>
<li><p>实现接口后类<strong>同继承效果</strong>，拥有了接口定义的成员</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//习题</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">小结：单继承与实现中出现同名属性或方法</span></span><br><span class="line"><span class="comment">属性：编译错误</span></span><br><span class="line"><span class="comment">方法：类优先原则，调用父类同名方法而非接口同名方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//编译不通过。类与接口是并列关系，导致属性x是不明确的</span></span><br><span class="line">		<span class="comment">// System.out.println(x);</span></span><br><span class="line">		System.out.println(<span class="keyword">super</span>.x);<span class="comment">//1</span></span><br><span class="line">		System.out.println(A.x);<span class="comment">//0，切勿忘记接口属性的public static final 修饰</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> C().pX();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>同理抽象类</p>
<ul>
<li>若<strong>实现类非抽像</strong>类，则必须<strong>实现接口所有抽象方法</strong>，才可实例化</li>
<li>若实现类为<strong>抽像类</strong>，则不要求实现接口的抽象方法</li>
</ul>
<ul>
<li><p>Java类可以<strong>实现多个接口</strong>(弥补了Java单继承性的局限性)</p>
<p><code>class AA extends BB implements CC,DD,EE&#123;&#125;</code></p>
</li>
<li><p><strong>接口与接口</strong>之间可以<strong>多继承</strong></p>
<p><code>interface CC entends AA,BB&#123;&#125; </code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>接口匿名实现类</strong>：同抽象类的匿名实现类创建方式</p>
</li>
<li><p><strong>接口应用场景</strong></p>
<ul>
<li><p><strong>代理模式</strong>(Proxy)</p>
<blockquote>
<p>应用场景：</p>
<ul>
<li>安全代理：屏蔽对真实角色的直接访问</li>
<li>远程代理：通过代理类处理远程方法调用（RMI） </li>
<li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象 比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有 100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理 模式，当需要查看图片时，用proxy来进行大图片的打开。 </li>
<li>分类 <ul>
<li>静态代理（静态定义代理类） </li>
<li>动态代理（动态生成代理类）<ul>
<li>JDK自带的动态代理，需要反射等知识</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>工厂模式</strong></p>
</li>
</ul>
</li>
<li><p><strong>JDK8</strong>接口特性：还可以定义<strong>静态方法、默认方法</strong></p>
<ul>
<li><p>接口中定义的<strong>静态方法</strong>，<strong>只能通过接口</strong>来调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.prnitln();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/****************************/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">implements</span> <span class="title">CompareA</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CompareA.method();</span><br><span class="line">        <span class="keyword">new</span> SubClass().method();<span class="comment">//错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>应用场景：</p>
<ul>
<li>在标准库中 找到像Collection(接口)/Collections(工具类)或者Path/Paths这样成对的接口和类</li>
<li>在JDK8中，可以将Collection与Collections工具类提供的静态方法合并一起</li>
</ul>
</blockquote>
</li>
<li><p>通过实现类的对象，可以调用接口中的<strong>默认方法</strong>，通过<strong>default</strong>关键字修饰(public可以省略)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareA</span></span>&#123;</span><br><span class="line">	<span class="comment">//默认方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123; <span class="comment">//public可以省略</span></span><br><span class="line">         System.out.prnitln();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>若实现类<strong>重写</strong>了接口中的默认方法，调用时，仍然<strong>调用的是重写</strong>以后的方法</p>
</li>
<li><p>若实现类实现了多个接口，多个接口中存在同名同参数的<strong>默认方法</strong>，且实现类没重写此方法的情况下，出现编译错误。接口冲突。这就需要我们必须在实现类中重写此方法</p>
</li>
<li><p>在子类(或实现类)的方法中调用父类、接口中被重写的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    method3();<span class="comment">//调用自己定义的重写的方法</span></span><br><span class="line">    <span class="keyword">super</span>.method3();<span class="comment">//调用的是父类中声明的</span></span><br><span class="line">    <span class="comment">//调用接口中的默认方法</span></span><br><span class="line">    CompareA.<span class="keyword">super</span>.method3();</span><br><span class="line">    CompareB.<span class="keyword">super</span>.method3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
</li>
</ul>
</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul>
<li><p><strong>使用场景</strong>：当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的结构又只为该事物提供服务，那么整个内部的完整结构最好使用内部类。</p>
</li>
<li><p><strong>内部类的类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 内部类类型，对应变量类型</span></span><br><span class="line"><span class="comment"> * 1、成员变量：属性(成员内部类)</span></span><br><span class="line"><span class="comment"> * 		非静态成员变量：属性(非静态内部类)</span></span><br><span class="line"><span class="comment"> * 		静态变量：类变量(静态内部类)</span></span><br><span class="line"><span class="comment"> * 2、局部变量：方法、构造器、代码块内</span></span><br><span class="line"><span class="comment"> * 		(局部内部类)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestInClass</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//非静态成员内部类</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员内部类</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BB</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">EE</span></span>&#123;<span class="comment">//局部内部类</span></span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TestInClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//局部内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">CC</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#123;	<span class="comment">//局部内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">DD</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>成员内部类</strong></p>
<ul>
<li>作为外部类的成员(属性理解)：<ul>
<li>可以<strong>调用外部类</strong>的结构</li>
<li>可以<strong>被static修饰</strong>(外部类-普通类不可以)</li>
<li>可以被<strong>4种权限修饰符修饰</strong>(普通类只有缺省和public)<ul>
<li>作为类：拥有普通类的常见情况</li>
</ul>
</li>
<li>类内可以定义属性、方法、构造器等</li>
<li>可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</li>
<li>可以被abstract修饰</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p><strong>实例化成员内部类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建静态的Dog内部类的实例(静态的成员内部类):</span></span><br><span class="line">Person.Dog dog = <span class="keyword">new</span> Person.Dog();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建非静态的Bird内部类的实例(非静态的成员内部类):</span></span><br><span class="line"><span class="comment">//Person.Bird bird = new Person.Bird();//错误的</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person.Bird bird = p.<span class="function">new <span class="title">Bird</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内部类与外部类同名属性调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	String name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//非静态成员内部类</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">		String name = <span class="string">&quot;杜鹃&quot;</span>;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		System.out.println(name);<span class="comment">//方法的形参</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);<span class="comment">//内部类的属性</span></span><br><span class="line">        System.out.println(Person.<span class="keyword">this</span>.name);<span class="comment">//外部类的属性</span></span><br><span class="line">        <span class="comment">//Person.this.eat();</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>局部内部类</strong></p>
<ul>
<li><p>在局部内部类的方法中的调用方法的局部变量话,要求此局部变量声明为final的。</p>
<ul>
<li>jdk 7及之前版本：要求此局部变量显式的声明为final的</li>
<li>jdk 8及之后的版本：可以省略final的声明</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="comment">//num = 20;//错误，num默认为final</span></span><br><span class="line">				System.out.println(num);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<pre><code>   * 成员内部类和局部内部类，在编译以后，都会生成字节码文件。</code></pre>
<ul>
<li><p>成员内部类：<code>外部类$内部类名.class</code></p>
</li>
<li><p>局部内部类：<code>外部类$数字 内部类名.class</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个实现了Comparable接口的类的对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Comparable <span class="title">getComparable</span><span class="params">()</span></span>&#123;</span><br><span class="line">  		</span><br><span class="line">  	<span class="comment">//创建一个实现了Comparable接口的类:局部内部类</span></span><br><span class="line">  	<span class="comment">//方式一：</span></span><br><span class="line">  	<span class="class"><span class="keyword">class</span> <span class="title">MyComparable</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">  		<span class="meta">@Override</span></span><br><span class="line">  		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  		&#125;</span><br><span class="line">  			</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">new</span> MyComparable();</span><br><span class="line">  		</span><br><span class="line">  	<span class="comment">//方式二：</span></span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">new</span> Comparable()&#123;</span><br><span class="line">  		<span class="meta">@Override</span></span><br><span class="line">  		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  		&#125;	</span><br><span class="line">  	&#125;;	</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>







</li>
</ul>
<h1 id="Java基础类库"><a href="#Java基础类库" class="headerlink" title="Java基础类库"></a>Java基础类库</h1><h2 id="JUnitTest"><a href="#JUnitTest" class="headerlink" title="JUnitTest"></a>JUnitTest</h2><ul>
<li><p><strong>JUnitTest单元测试类</strong>：</p>
</li>
<li><p><strong>快捷步骤</strong>：</p>
<ol>
<li>直接在想要测试的方法上添加<code>@Test</code>注解，通过eclipse提示导入相关内容</li>
</ol>
</li>
<li><p><strong>详细步骤与细节</strong></p>
<ol>
<li>中当前工程 - 右键择：build path - add libraries - JUnit 4 - 下一步</li>
<li>单元测试类要求：public、供公共的无参的构造器</li>
<li>单元测试方法的要求：public、无返回值，无形参</li>
<li>单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test;</li>
<li>左键双击单元测试方法名，右键：run as - JUnit Test</li>
</ol>
<hr>
<ul>
<li>执行结果没任何异常：绿条</li>
<li>执行结果出现异常：红条</li>
</ul>
</li>
</ul>
<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.exit(<span class="number">0</span>);<span class="comment">//终止JVM的执行</span></span><br></pre></td></tr></table></figure>





<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><ul>
<li><p>操作数组的工具类：有封装好的快排，二分排等操作(可查看源码学习)</p>
<table>
<thead>
<tr>
<th>method</th>
<th>meaning</th>
</tr>
</thead>
<tbody><tr>
<td>boolean equals(int[] a,int[] b)</td>
<td>判断两个数组是否相等。</td>
</tr>
<tr>
<td>String toString(int[] a)</td>
<td>输出数组信息</td>
</tr>
<tr>
<td>void fill(int[] a,int val)</td>
<td>将指定值均填充到数组之中</td>
</tr>
<tr>
<td>void sort(int[] a)</td>
<td>对数组进行排序</td>
</tr>
<tr>
<td>int binarySearch(int[] a,int key)</td>
<td>对排序后的数组进行二分法检索指定的值</td>
</tr>
<tr>
<td>…..详细查看API</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">//如一些二分查找等都有封装好</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">boolean equals</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br></pre></td></tr></table></figure>



<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.random();<span class="comment">//[0.0,1.0)</span></span><br><span class="line">Math.PI;</span><br><span class="line"><span class="keyword">long</span> Math.round(<span class="keyword">double</span> d)<span class="comment">//四舍五入取整</span></span><br></pre></td></tr></table></figure>









<p>复用：方法，继承</p>
<p>可扩展性：继承，多态(自带，归类分配控制器，减少编写重载方法)</p>
<p>解耦：封装</p>
<p>封装：</p>
<p>继承：复用，易扩展</p>
<p>多态性：提高代码的通用性，如Object 的equals方法</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h1 id="有关源码的题"><a href="#有关源码的题" class="headerlink" title="有关源码的题"></a>有关源码的题</h1><h2 id="包装类相关"><a href="#包装类相关" class="headerlink" title="包装类相关"></a>包装类相关</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    Integer m = <span class="number">1</span>;</span><br><span class="line">    Integer n = <span class="number">1</span>;</span><br><span class="line">    System.out.println(m == n);<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意，如果数值不一样是肯定不一样的</span></span><br><span class="line">    Integer a = <span class="number">210</span>;</span><br><span class="line">    Integer b = <span class="number">211</span>;</span><br><span class="line">    System.out.println(a == b);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    Integer x = <span class="number">128</span>;</span><br><span class="line">    Integer y = <span class="number">128</span>;</span><br><span class="line">    System.out.println(x == y);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[],</span></span><br><span class="line"><span class="comment">//  保存了从-128~127范围的整数。如果我们使用自动装箱的方式，给Integer赋值的范围在</span></span><br><span class="line"><span class="comment">//  -128~127范围内时，可以直接使用数组中的元素，不用再去new了。目的：提高效率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Integer m = 1; //-128~127范围内相当于同一个数组地址</span></span><br><span class="line"><span class="comment">//  Integer n = 1;</span></span><br><span class="line"><span class="comment">//  Integer x = 128;//相当于new了一个Integer对象</span></span><br><span class="line"><span class="comment">//  Integer y = 128;//相当于new了一个Integer对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>原理</strong></li>
</ul>
]]></content>
      <tags>
        <tag>技术积累</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
</search>
