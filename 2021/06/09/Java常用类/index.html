<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="yhd">
    
    <title>
        
            Java常用类 |
        
        DyhBlog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/MyLogo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"yoursite.com","root":"/","language":"en","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.jpg","favicon":"/images/MyLogo.svg","article_img_align":"left","left_side_width":"230px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.jpeg"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.1"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.1.1"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                DyhBlog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Java常用类</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">yhd</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-06-09 20:20:23
    </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/JavaSE/">JavaSE</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>15.7k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>65 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p><strong>引言</strong>：本文主要基于JDK8介绍JavaSE中常用的java类，含字符串相关类，String及其底层原理、StringBuffer、StringBuilder。JDK 8之前的日期时间API，System静态方法、Date、SimpleDateFormat、Calendar、JDK 8日期的时机API、LocalDate、LocalTime、LocalDateTime、Instant、DateTimeFormatter。以及Java比较器Comparable接口、Comparator接口、System类、Math类、BigInteger与BigDecimal等等…</p>
<h1 id="String">String</h1>
<h2 id="不可变特性">不可变特性</h2>
<h3 id="双final特性">双final特性</h3>
<ol>
<li>
<p>String是一个<strong>final</strong>类，是一个<strong>不可被继承</strong>引用类型。</p>
</li>
<li>
<p>String内部定义 <strong>final</strong> char value[]中(<strong>核心</strong>)用于存储字符串数据，因此值在<strong>创建之后不能更改</strong>，代表”<strong>不可变字符序列</strong>“。</p>
<hr>
</li>
<li>
<p>String实现了Serializable接口：表示字符串是支持序列化的。</p>
</li>
<li>
<p>String实现了Comparable接口：表示String可以比较大小</p>
</li>
</ol>
<hr>
<ul>
<li>部分源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];<span class="comment">//字符串存储特性核心：不可变字符序列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特性的体现">特性的体现</h3>
<h4 id="错误体现">错误体现</h4>
<ul>
<li><strong>注意</strong>：如下代码<strong>不能体现字符串不可变特性</strong>。因为以下代码的直接原无关乎字符串的存储特性，而是编程语言中<strong>通用引用数据类型无返回值调用原理</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    method(str1);</span><br><span class="line">    System.out.println(<span class="string">&quot;str1 = &quot;</span> + str1);<span class="comment">//仍然输出abc</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    str = <span class="string">&quot;hi~~&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于引用数据类型，<strong>即使不是String也无法修改</strong>。(基本数据类型更加无法修改)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    method(person);</span><br><span class="line">    System.out.println(person.getName());<span class="comment">//仍然输出Tom，不可修改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">    person = <span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Person.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="正确体现">正确体现</h4>
<ul>
<li>对于<strong>引用数据类型</strong>来说，无返回值方法调用，<strong>仅能修改引用指向的内容，而不能修改引用本身</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    method(person);</span><br><span class="line">    System.out.println(person.getName());<span class="comment">//Jack，可以修改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">    person.setName(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>但是String作为引用数据类型，<strong>连修改引用指向的内容都不行</strong></li>
<li>因为<strong>指向的内容是 final char[] values</strong>中，是一个常量，一个不可改变的数据。</li>
<li>这才是真正体现&quot;不可变字符序列&quot;特性的代码</li>
<li>总体效果，引用类型的String，调用方法进行操作时，<strong>如同退化成了基本数据类型一样</strong>，只能通过返回值重新赋值的方式改变String的内容。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    method(str1);</span><br><span class="line">    System.out.println(<span class="string">&quot;str1 = &quot;</span> + str1);<span class="comment">//仍然输出abc</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    str.replace(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="存储原理">存储原理</h2>
<h3 id="背景">背景</h3>
<ul>
<li>由于字符串在java中大量使用，因此JVM特意开辟一个空间(<strong>字符串常量池</strong>)专门用于存储字符串。当存在两个相同的字符串时，常量池<strong>只存储一个</strong>，而让两个引用类型变量都引用它。从而达到节约内存资源的目的。</li>
<li>由于字符串数据存储存储在字符串常量池，且存储机制不一样，因此和常规引用类型的堆栈存储关系不一样，有时候会创建数据、有时候就不创建了。</li>
<li>结论：<strong>因此看待字符串的存储结构，要结合字符串常量池存储机制，引用类型堆栈的存储机制</strong>。</li>
</ul>
<h3 id="存储机制">存储机制</h3>
<h4 id="核心机制">核心机制</h4>
<ul>
<li>创建字符串变量时，<strong>变量的引用</strong>存储在<strong>栈空间</strong>。</li>
<li>若<strong>字符串常量池</strong>存在相同(equal)的字符串，则只引用不创建。反之创建一个新的字符串。</li>
</ul>
<h5 id="测试代码">测试代码</h5>
<ul>
<li>字符串常量池共用一份数据，与创建新的数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="comment">//String是引用数据类型，== 比较的是地址值，</span></span><br><span class="line">    System.out.println(str1 == str2);<span class="comment">//true，同一份资源</span></span><br><span class="line"></span><br><span class="line">    str2 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    System.out.println(str1 == str2);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>引用数据类型值传递机制与字符串存储机制：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    method(str1);</span><br><span class="line">    System.out.println(<span class="string">&quot;str1 = &quot;</span> + str1);<span class="comment">//仍然输出abc</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    str = <span class="string">&quot;hi~~&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>分析：传递的确实是地址值，也确实创建了&quot;hi~~&quot;字符串</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210606233205.png"
                      alt=""
                ></p>
</li>
</ul>
<h4 id="字面量机制">字面量机制</h4>
<ul>
<li>
<p>示例代码：<code>String str = &quot;abc&quot;;</code></p>
</li>
<li>
<p><strong>存储机制</strong>：**栈空间的变量直接引用，字符串常量池中的字符串(地址)**进行操作，<strong>完全遵循核心机制</strong>。</p>
</li>
</ul>
<h5 id="测试代码-2">测试代码</h5>
<ul>
<li>字面量方式创建、拼接、方法调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//字面量创建</span></span><br><span class="line">    String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String str3 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    System.out.println((str1 == str2) &amp;&amp; (str2 == str3));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    str1 = str1 + <span class="string">&quot;def&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;str1 = &quot;</span> + str1);<span class="comment">//abcdef，在常量池新建了一份</span></span><br><span class="line">    System.out.println(<span class="string">&quot;str2 = &quot;</span> + str2);<span class="comment">//abc，因此abc在常量池没有被修改</span></span><br><span class="line">    System.out.println(str1 == str2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    str2 = str2.replace(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;str2 = &quot;</span> + str2);<span class="comment">//1bc，在常量池新建了一份</span></span><br><span class="line">    System.out.println(<span class="string">&quot;str3 = &quot;</span> + str3);<span class="comment">//abc，因此abc在常量池没有被修改</span></span><br><span class="line">    System.out.println(str2 == str3);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="new-构造器机制">new+构造器机制</h4>
<ul>
<li>
<p><strong>示例代码</strong>：<code>String str = new String(&quot;abc&quot;);</code></p>
</li>
<li>
<p><strong>存储机制</strong>：</p>
<ul>
<li><strong>不管什么情况</strong>，先在堆空间中<strong>开辟新的空间</strong>，用于<strong>存储values的引用数据</strong>(地址)</li>
<li><strong>采用核心机制</strong>，在字符串常量池中搜寻相同的字符串
<ul>
<li>若<strong>找到</strong>则将其<strong>引用</strong>赋值到堆空间的values中</li>
<li>找不到则先在字符串<strong>常量池中创建新的字符串</strong>，后将其<strong>引用</strong>赋值到堆空间的values中</li>
</ul>
</li>
</ul>
</li>
<li>
<p>示例：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两者的区别？</span></span><br><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>分析：</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210607082224.png"
                      alt=""
                ></p>
<h5 id="测试代码-3">测试代码</h5>
<ul>
<li>示例代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line">    String s4 = <span class="keyword">new</span> String(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(s1 == s2);<span class="comment">//true：常量池地址比较</span></span><br><span class="line">    System.out.println(s1 == s3);<span class="comment">//false：常量池地址与堆地址比较</span></span><br><span class="line">    System.out.println(s1 == s4);<span class="comment">//false：常量池地址与堆地址比较</span></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//false：堆地址比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分析：</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/new%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E6%9E%90.png"
                      alt=""
                ></p>
<h5 id="源码赋值原理">源码赋值原理</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本质上this.value = new char[0];</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = original.value;</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(String original); </span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = Arrays.copyOf(value, value.length);</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="keyword">char</span>[] a); </span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="keyword">char</span>[] a,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> count);</span><br></pre></td></tr></table></figure>
<h4 id="非静态类属性机制">非静态类属性机制</h4>
<ul>
<li><strong>示例代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>存储机制</strong>：由于<strong>类的非静态资源</strong>都是在<strong>堆空间开辟</strong>的，因此<strong>同第三种</strong>“<strong>new + 构造器字符串</strong>”方式</li>
</ul>
<h5 id="测试代码-4">测试代码</h5>
<ul>
<li>示例代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;<span class="comment">//非静态类属性字符串</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(p1 == p2);<span class="comment">//true</span></span><br><span class="line">    System.out.println(p1.getName() == p2.getName());<span class="comment">//true，最终存储都在常量池中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分析</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9D%9E%E9%9D%99%E6%80%81%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%88%86%E6%9E%90.png"
                      alt=""
                ></p>
<h4 id="字符串操作机制">字符串操作机制</h4>
<h5 id="字符串拼接">字符串拼接</h5>
<ul>
<li>
<p><strong>仅字面量或常量(final Sting)参与</strong>操作：操作结果<strong>按普通核心机制</strong>，先检查字符串常量池是否存在，存在则引用，否则创建。</p>
</li>
<li>
<p><strong>涉及变量名参与</strong>操作：，则<strong>属于new的形式创建机制</strong>，同样也做二次引用。因此<strong>操作结果返回的是堆空间的地址值</strong>，因此无论怎么和字符串常量池中的字符串比较(地址)都不会相同。</p>
<blockquote>
<ul>
<li>
<p>由于变量的状态是会改变的，JVM是无法时刻判断出结果匹配字符串常量池中不变的字符串</p>
</li>
<li>
<p>无论什么形式字符串本体都只存储在字符串常量池中，new也是做二次引用而已。</p>
</li>
</ul>
</blockquote>
</li>
<li>
<p>当字符串调用<strong>intern</strong>()方法时：<strong>返回该字符串在字符串常量池中的地址</strong>。</p>
</li>
</ul>
<hr>
<ul>
<li>测试代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String s3 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">    String s4 = <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    String s5 = s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    String s6 = <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">    String s7 = s1 + s2;</span><br><span class="line"></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">    System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    String s8 = s6.intern();<span class="comment">//返回值字符串在字符串常量池中的地址</span></span><br><span class="line">    System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分析</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210607084135.png"
                      alt=""
                ></p>
<ul>
<li>字面量与常量(包含final String)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;JavaSEabc&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> String str1 = <span class="string">&quot;JavaSE&quot;</span>;</span><br><span class="line">    String str2 = str1 + <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    System.out.println(str == str2);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="String方法调用">String方法调用</h5>
<ul>
<li><strong>无论是字面量还是new+String结构</strong></li>
<li>调用String方法返回的结果<strong>均为堆空间的地址值，即属于new+构造器类型机制，二次引用</strong></li>
</ul>
<hr>
<ul>
<li><strong>代码测试</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;1bc&quot;</span>;</span><br><span class="line">    s2 = s2.replace(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;a&#x27;</span>);<span class="comment">//即使替换成一样的字符串</span></span><br><span class="line">    System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">    String s4 = <span class="keyword">new</span> String(<span class="string">&quot;1ef&quot;</span>);</span><br><span class="line">    s4 = s4.replace(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;d&#x27;</span>);<span class="comment">//即使替换成一样的字符串</span></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="未解决问题">未解决问题</h4>
<ul>
<li>猜测是由于toString是Object的方法，操作之后数据存储在方法区？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;<span class="comment">//未解决问题，第二个输出为什么是false？toString的内容存储在哪？</span></span><br><span class="line">    String str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">char</span>[] ch = &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    System.out.println(str == ch.toString());<span class="comment">//false</span></span><br><span class="line">    System.out.println(str == (ch.toString()).intern());<span class="comment">//false ?</span></span><br><span class="line"></span><br><span class="line">    System.out.println(str == String.valueOf(ch));<span class="comment">//false：变量参与new形式</span></span><br><span class="line">    System.out.println(str == String.valueOf(ch).intern());<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    System.out.println(str == String.valueOf(i));<span class="comment">//false：变量参与new形式</span></span><br><span class="line">    System.out.println(str == String.valueOf(i).intern());<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="核心总结">核心总结</h3>
<ul>
<li>存储机制：
<ul>
<li>无论是哪种字符串创建机制，通过String方式创建的，<strong>字符串的本体都是存储在字符串常量池中</strong>，只是<strong>构造器的方式在堆空间做了二次引用</strong>。
<ul>
<li><strong>字面量</strong>：<strong>一次引用</strong>(直接引用)，返回字符串常量池的地址</li>
<li><strong>new+构造器</strong>：<strong>二次引用</strong>(间接引用)，返回堆空间的地址</li>
</ul>
</li>
<li>注意：<strong>只是</strong>String中定义的是 final char [] values，遵循字符串常量池机制。而其他<strong>自定义的字符数组变量</strong>，是遵循引用类型栈堆开辟空间机制的，即字符数组内容的<strong>本体都存储在堆空间中</strong>。</li>
</ul>
</li>
<li>操作机制：
<ul>
<li>仅<strong>字面量或常量</strong>(final String)参与的操作，一次引用</li>
<li>有变量名参与的操作，二次引用</li>
<li>调用String方法，二次引用</li>
</ul>
</li>
</ul>
<h2 id="涉及JVM结构部分">涉及JVM结构部分</h2>
<ul>
<li>JDK 1.6：字符串常量池在方法区(具体实现是：永久代)</li>
<li>JDK 1.7：字符串常量池在堆空间中</li>
<li>JDK 1.8：字符串常量池在方法去(具体实现：元空间)</li>
</ul>
<hr>
<ul>
<li>JVM官方架构规范，会随JDK版本提升而有所变化，</li>
<li>具体虚拟机实现公司有多个，随JVM规范变化，也会有所变化
<ul>
<li>Sun公司的HotSpot</li>
<li>BEA公司的JRockit</li>
<li>IBM公司的J9VM</li>
</ul>
</li>
</ul>
<h2 id="高频API">高频API</h2>
<ul>
<li>由于字符串底层的<strong>不可变字符序列特性</strong>，<code>final char [] values</code></li>
<li>字符串任何内置的方法都<strong>无法只通过调用方法而不重新赋值来修改字符串的内容</strong></li>
<li>字符串所有内置方法<strong>操作后</strong>都是<strong>返回一个新创建的字符串</strong>(堆方式)，<strong>原字符串不变</strong>。</li>
<li>调用者<strong>必须通过返回值重新赋值</strong>的方式才能<strong>修改字符串的内容</strong>(实际修改引用)</li>
</ul>
<hr>
<ul>
<li>由于字符串底层用<strong>数组存储</strong>，因此涉及<strong>索引的操作，均从0开始</strong></li>
<li>字符索引<strong>不分中文英文</strong>或其他语言字符，只要占一个字符位置，就是一个索引值</li>
<li>凡是涉及字符串匹配操作，搜索，替换，都是<strong>区分大小写的</strong></li>
</ul>
<hr>
<ul>
<li><strong>CharSequence</strong>是一个字符序列接口，String实现类该接口，<strong>因此CharSequence形参可传入String类型</strong></li>
</ul>
<hr>
<ul>
<li><strong>高频API</strong></li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>int <strong>length</strong>()</td>
<td>返回字符串的长度： return value.length，无字符串结束符概念</td>
</tr>
<tr>
<td>char <strong>charAt</strong>(int index)</td>
<td>返回某索引处的字符：return value[index]，按数组下标<strong>从0开始</strong></td>
</tr>
<tr>
<td>boolean <strong>isEmpty</strong>()</td>
<td>判断是否是空字符串：return value.length == 0，不是null</td>
</tr>
<tr>
<td>String <strong>toLowerCase</strong>()</td>
<td>使用默认语言环境，将 String中的所有字符转换为<strong>小写</strong></td>
</tr>
<tr>
<td>String <strong>toUpperCase</strong>()</td>
<td>使用默认语言环境，将 String 中的所有字符转换为<strong>大写</strong></td>
</tr>
<tr>
<td>String <strong>trim</strong>()</td>
<td>去除字符串<strong>首尾空格</strong>(字符串之间的空格不去)</td>
</tr>
<tr>
<td>boolean <strong>equals</strong>(Object obj)</td>
<td>比较字符串的内容是否相同</td>
</tr>
<tr>
<td>boolean <strong>equalsIgnoreCase</strong>(String anotherString)</td>
<td>与equals方法类似，忽略大小写</td>
</tr>
<tr>
<td>String <strong>concat</strong>(String str)</td>
<td>等价于用“+”，将指定字符串连接到此字符串的结尾。</td>
</tr>
<tr>
<td>int <strong>compareTo</strong>(String anotherString)</td>
<td><strong>比较两个字符串的大小</strong>，每个字符对应相减(ASCII码)，直至返回0(相同字符串)或返回某个字符相减后不等于0的结果。</td>
</tr>
<tr>
<td>String <strong>substring</strong>(int beginIndex)</td>
<td>它是此字符串的从 beginIndex(<strong>包含</strong>)开始截取到末尾的字符串<strong>索引从0开始</strong>，[<strong>左闭右开原则</strong>)</td>
</tr>
<tr>
<td>String <strong>substring</strong>(int beginIndex, int endIndex)</td>
<td>从beginIndex(<strong>包含</strong>)开始截取到endIndex(<strong>不包含</strong>)的一个子字符串，<strong>索引从0开始</strong>，[<strong>左闭右开原则</strong>)</td>
</tr>
<tr>
<td>String <strong>replace</strong>(char oldChar, char newChar)</td>
<td>通过用 newChar <strong>替换</strong>此字符串中<strong>出现的所有</strong> oldChar得到的</td>
</tr>
<tr>
<td>boolean <strong>endsWith</strong>(String suffix)</td>
<td>测试此字符串是否以<strong>指定的后缀结束</strong></td>
</tr>
<tr>
<td>boolean <strong>startsWith</strong>(String prefix)</td>
<td>测试此字符串是否以<strong>指定的前缀开始</strong></td>
</tr>
<tr>
<td>boolean <strong>startsWith</strong>(String prefix, int toffset)</td>
<td>测试此字符串从指定<strong>索引开始</strong>(包含)的 子字符串是否以指定前缀开始</td>
</tr>
<tr>
<td>boolean <strong>contains</strong>(CharSequence s)</td>
<td>当且仅当此字符串包含指定的 char 值序列时，返回 true</td>
</tr>
<tr>
<td>int <strong>indexOf</strong>(String str)</td>
<td>返回指定子字符串在此字符串中<strong>第一次出现处的索引</strong><br><strong>未找到返回-1</strong></td>
</tr>
<tr>
<td>int <strong>indexOf</strong>(String str, int fromIndex)</td>
<td>返回指定子字符串在此字符串中从<strong>指定的索引开始</strong>(包含)，第一次出现处的索引，<strong>未找到返回-1</strong></td>
</tr>
<tr>
<td>int <strong>lastIndexOf</strong>(String str)</td>
<td>返回指定子字符串在此字符串中<strong>反向搜索</strong>第一次出现的索引<br><strong>未找到返回-1</strong>，<strong>区分大小写</strong></td>
</tr>
<tr>
<td>int <strong>lastIndexOf</strong>(String str, int fromIndex)：</td>
<td>返回指定子字符串在此字符串从指定的索引开始<strong>反向搜索</strong>，第一次出现处的索引(完整匹配字符串的<strong>正序第一个字符</strong>位置)，<strong>未找到返回-1</strong></td>
</tr>
<tr>
<td>String <strong>replace</strong>(CharSequence target, CharSequence replacement)</td>
<td>将字符串中，将<strong>所有</strong>指定的字符串，替换成指定的字符串<br>target：用于匹配的子串<br>replacement：匹配后替换的字符串</td>
</tr>
<tr>
<td>String <strong>replaceAll</strong>(String regex, String replacement)</td>
<td>同replace方法，不同在于通过regex正则表达式去<strong>匹配替换所有</strong></td>
</tr>
<tr>
<td>String <strong>replaceFirst</strong>(String regex, String replacement)</td>
<td>使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串</td>
</tr>
<tr>
<td>boolean <strong>matches</strong>(String regex)</td>
<td>告知此字符串是否匹配给定的正则表达式</td>
</tr>
<tr>
<td>String[] <strong>split</strong>(String regex)</td>
<td>根据给定正则表达式的匹配<strong>拆分</strong>此字符串</td>
</tr>
<tr>
<td>String[] <strong>split</strong>(String regex, int limit)</td>
<td>根据匹配给定的正则表达式来拆分此 字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中</td>
</tr>
</tbody>
</table>
<ul>
<li>笔记</li>
</ul>
<hr>
<ul>
<li>charAt(int index)，由于String不可变字符序列，我们无法操作字符串中的字符串，也无法获取里面的values，因此只能通过charAt方法获取指定字符</li>
</ul>
<hr>
<ul>
<li>从哪个索引开始start，包含</li>
<li>endIndex，到哪结束，则不包含</li>
<li>size，多少个，则包含</li>
</ul>
<hr>
<ul>
<li>indexOf 和 lastIndexOf返回结果一样
<ul>
<li>情况1：存在唯一的子串</li>
<li>情况2：不存在该子串</li>
</ul>
</li>
</ul>
<h3 id="API算法利用">API算法利用</h3>
<h4 id="返回子串在主串出现次数">返回子串在主串出现次数</h4>
<p>indexOf(String str) + indexOf(String str,int fromIndex)</p>
<h2 id="String类型转换">String类型转换</h2>
<h3 id="包装类之间">包装类之间</h3>
<ul>
<li>String ——&gt; 基本数据类型、包装类：调用包装类的静态方法，<code>parseXxx(str)</code></li>
<li>基本数据类型、包装类 —— &gt; String：调用String重载的方法<code>valueOf(xxx)</code></li>
</ul>
<h3 id="char数组之间">char数组之间</h3>
<ul>
<li>String —— &gt; char[]：<code>toCharArray();</code></li>
<li>char[] —— &gt;：构造器方式 <code>new String(char[] ch)</code></li>
</ul>
<hr>
<ul>
<li>因为<em>Java</em>用的是<strong>Unicode</strong>编码，因此<em>char</em>在<em>Java</em>中占用<strong>2Byte</strong>，因此任意语言字符<strong>都是只占一个字符位置</strong>。</li>
</ul>
<h3 id="byte数组之间">byte数组之间</h3>
<ul>
<li>
<p>String ——&gt; byte[] ：<strong>编码操作</strong>(懂——&gt;不懂)</p>
<ul>
<li>
<p><code>getBytes();</code>：使用默认字符集，进行转换。(取决当前.java源文件的编码设置)</p>
</li>
<li>
<p><code>getBytes(String charsetName);</code>：使用指定编码集转换为字节数组。有可能存在异常，因为有可能用户输入的字符集不存在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;abc123中国&quot;</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = str1.getBytes(<span class="string">&quot;gbk&quot;</span>);<span class="comment">//中文支持</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>由于byte数组每个元素只占1个字节，世界上很多字符都不能仅用1个字节能存储，编码类型也众多。因此String转换为byte数组时，<strong>受编码类型</strong>影响，</p>
</blockquote>
</li>
</ul>
<hr>
<ul>
<li>byte[] ——&gt; String：<strong>解码操作</strong>(不懂——&gt;懂)
<ul>
<li><code>new String(char[] chars);</code>：用默认字符集，进行转换。(取决当前.java源文件的编码设置)</li>
<li><code>new String(char[] chars,String charsetName);</code>：使用指定解码集转换为字符串，同上</li>
</ul>
</li>
</ul>
<h3 id="可变字符序列之间">可变字符序列之间</h3>
<p>调用各自的构造器</p>
<ul>
<li>String ——&gt; StringBuffer、StringBuilder：调用StringBuffer、StringBuilder构造器</li>
<li>StringBuffer、StringBuilder —— &gt; String：调用String构造器，或调用StringBuffer、StringBuilder的toString方法</li>
</ul>
<h1 id="可变字符序列">可变字符序列</h1>
<ul>
<li>JDK提供的可变字符串有StringBuffer、StringBuilder两种</li>
<li>StringBuffer从JDK 1.0开始就有，后续因为性能低(线程安全)，在JDK 5.0的时候新增了StringBuilder</li>
</ul>
<h2 id="基本特性">基本特性</h2>
<p>String、StringBuffer、StringBuilder三者的异同？</p>
<ul>
<li><strong>String</strong>：不可变的字符序列；底层使用<code>final char[] value</code>存储</li>
<li><strong>StringBuffer</strong>：可变字符序列；线程安全，但效率低；底层使用<code>char[] value</code>存储</li>
<li><strong>StringBuilder</strong>：jdk5.0新增的可变的字符序列；线程不安全，效率高；底层使用<code>char[] value</code>存储</li>
</ul>
<h2 id="可变性原理">可变性原理</h2>
<h3 id="底层存储">底层存储</h3>
<ul>
<li>StringBuffer与StringBuilder底层<strong>都是使用 <code>char[] value</code> 存储</strong>的</li>
<li>与String类型底层存储的字符数组不一样，<strong>没有<code>final</code>修饰</strong></li>
<li>因此为<strong>可变字符序列</strong>的实现<strong>提供了可能性</strong>。</li>
</ul>
<h3 id="自动扩容">自动扩容</h3>
<ul>
<li>虽然StringBuffer与StringBuilder底层存储的字符数组没有final修饰</li>
<li>但是对于数组来说，一定声明了，长度就是固定的，再往其添加过多的元素是不可能</li>
<li>因此StringBuffer、StringBuilder底层是<strong>存在自动扩容机制的</strong></li>
</ul>
<h4 id="初始容量">初始容量</h4>
<ul>
<li>StringBuffer与StringBuilder的<strong>空参构造器</strong>创建的字符数组<strong>容量</strong>长度默认为：<strong>16</strong></li>
<li>StringBuffer与StringBuilder的**(String str)构造器<strong>创建</strong>容量**长度默认为：<strong>str.length() + 16</strong></li>
</ul>
<hr>
<ul>
<li>new StringBuffer()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>new StringBuffer(String str)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">    append(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="扩容机制">扩容机制</h4>
<h5 id="简述">简述</h5>
<p>假设，原有数据长度 + 拟添加数据长度 = 添加后数据总长度</p>
<ol>
<li>
<p>默认初级拟扩容量为：<strong>(原来容量 * 2) + 2</strong></p>
</li>
<li>
<p>若拟扩容量<strong>还小于</strong>添加后数据总长度，则<strong>以添加后总长度为最终扩容长度</strong></p>
<p><em>特殊情况：拟扩容长度超出int类型等…，暂时不分析</em></p>
</li>
<li>
<p>最后将原有数组中的元素复制到扩容后的新数组中</p>
</li>
</ol>
<hr>
<ul>
<li><strong>示例代码</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();<span class="comment">//空参默认容量为16，长度为0</span></span><br><span class="line"></span><br><span class="line">    sb.append(<span class="string">&quot;123456789&quot;</span>);<span class="comment">//容量为16，长度9</span></span><br><span class="line">    <span class="comment">//容量为16，数据长度为9，9 &lt; 16，无需扩容</span></span><br><span class="line"></span><br><span class="line">    sb.append(<span class="string">&quot;123456789&quot;</span>);<span class="comment">//容量为34，长度18</span></span><br><span class="line">    <span class="comment">//原容量：16</span></span><br><span class="line">    <span class="comment">//原数据长度：9</span></span><br><span class="line">    <span class="comment">//增加数据长度：9</span></span><br><span class="line">    <span class="comment">//增加数据后长度：18，18 &gt; 16，需扩容</span></span><br><span class="line">    <span class="comment">//计算拟扩容量：16*2+2 = 34，34 &gt; 18，扩容至34</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">80</span>];</span><br><span class="line">    Arrays.fill(chars,<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line">    sb.append(chars);<span class="comment">//容量为98，长度98</span></span><br><span class="line">    <span class="comment">//原容量：34</span></span><br><span class="line">    <span class="comment">//原数据长度：18</span></span><br><span class="line">    <span class="comment">//增加数据长度：80</span></span><br><span class="line">    <span class="comment">//增加数据后长度：98，98 &gt; 34，需扩容</span></span><br><span class="line">    <span class="comment">//计算拟扩容量：34*2+2 = 70，70 &lt; 98，直接采取98为扩容后的容量</span></span><br><span class="line">    System.out.println(sb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="源码分析">源码分析</h5>
<p>以StringBuffer的append方法为例</p>
<ol>
<li>
<p>StringBuffer的append(String str)方法<strong>调用了父类的append</strong>(str)方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>父类的AbstractStringBuilder的append方法</p>
<ol>
<li>首先检查是否传入null，然后<strong>获取要添加进来的字符串长度</strong></li>
<li>将当前字符数组数据长度 (count + 要添加进来的字符串长度) 作为参数传入ensureCapacityInternal()方法，检测是否需要扩容。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>AbstractStringBuilder的<strong>ensureCapacityInternal</strong>方法</p>
<ol>
<li>
<p>添加后总数据量 &gt; 当前字符数组容量，则需要调用<strong>newCapacity</strong>方法进行扩容</p>
<ol>
<li>首先将原有容量左移1位，再加2。实际上就是×2+2，移位操作效率更高</li>
<li>若扩容好的容量还不足以存储添加后的数据长度，则直接以添加后的数据长度位扩容长度</li>
<li>还有一些超过int大小溢出负数的情况， 暂且略</li>
<li>最后返回真正扩容的长度</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        ? hugeCapacity(minCapacity)</span><br><span class="line">        : newCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>最后通过copyOf方法把原有数据以返回的扩容的长度创建新数组，并把原有数据复制新字符数组中</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        value = Arrays.copyOf(value,</span><br><span class="line">                              newCapacity(minimumCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="父类实现">父类实现</h2>
<ul>
<li>StringBuffer与StringBuilder的方法都是<strong>直接调用父类AbstractStringBuilder</strong>方法实现的。</li>
<li>StringBuffer其实是把StringBuilder的方法全部使用<strong>synchronized</strong>关键字修饰了一遍，<strong>使其线程安全</strong>。</li>
<li>因此StringBuffer和StringBuilder其实<strong>共用一套代码</strong>，因此分析其一源码即可</li>
</ul>
<hr>
<ul>
<li>StringBuffer定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuffer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br></pre></td></tr></table></figure>
<ul>
<li>StringBuilder定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br></pre></td></tr></table></figure>
<h2 id="指导意义">指导意义</h2>
<p>通过源码分析，String、StringBuilder、StringBuffer三种字符串比较，目的在不同场景选择最高效率的使用方式，归结为如下几点：</p>
<ul>
<li>
<p><strong>性能优势</strong>：StringBuilder &gt; StringBuffer &gt; String，也是开发优先选择的顺序</p>
<blockquote>
<ul>
<li>由于可变字符序列还存在空间重用，String则每次不同都要创建新的。因此可变字符性能总体 &gt; 不可变字符。</li>
<li>线程安全，要申请锁并且使其多线程变成单线程运行，总体均比线程不安全性能要低。</li>
</ul>
</blockquote>
</li>
<li>
<p><strong>避免自动扩容次数</strong>：使用可变字符串最高境界即，使用过程尽可能避免让其自动扩容</p>
<ol>
<li>从应用场景中，先预判总的操作字符串范围，如(append次数*每次字符串数量)</li>
<li>使用带容量设置的可变字符构造器，自定义初始化其容量。
<ul>
<li>如：StringBuffer(int capacity) 或 StringBuillder(int capacity)</li>
</ul>
</li>
<li>目的是在整个使用场景中减少自动扩容的机率</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li>性能测试代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer的执行时间：<span class="number">7</span></span><br><span class="line">StringBuilder的执行时间：<span class="number">3</span></span><br><span class="line">String的执行时间：<span class="number">2158</span></span><br></pre></td></tr></table></figure>
<ul>
<li>源代码：让三者均从1~20000 进行一个字符拼凑</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始设置</span></span><br><span class="line">    <span class="keyword">long</span> startTime = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">long</span> endTime = <span class="number">0L</span>;</span><br><span class="line">    String text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//开始对比</span></span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        buffer.append(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuffer的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        builder.append(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuilder的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        text = text + i;</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;String的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用API">常用API</h2>
<ul>
<li>StringBuilder与StringBuffer共用一套代码，因此仅举一例说明</li>
<li>String原有的很多方法StringBuilder与StringBuffer都有</li>
<li>现如今主要说明体现可变字符的一些新增的方法</li>
<li>可变字符char[]作为一个可变数据的属性，<strong>大部分(不是全部)方法直接调用即可修改，不用接收返回值</strong></li>
</ul>
<hr>
<ul>
<li>由于底层仍是使用数组存储，因此<strong>索引均从0开始</strong></li>
</ul>
<h3 id="支持方法链方法">支持方法链方法</h3>
<ul>
<li>方法链原理：方法的返回是调用方法的对象，即<strong>返回this</strong>，使其能<strong>连续调用方法</strong>。</li>
<li>append方法示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法链连续调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">&quot;a&quot;</span>).append(<span class="string">&quot;b&quot;</span>).append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    System.out.println(sb);<span class="comment">//abc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>API：增、删、改、查、插、长度、遍历</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>StringBuffer <strong>append</strong>(xxx)</td>
<td>很多重载的append()方法，用于进行字符串拼接</td>
</tr>
<tr>
<td>StringBuffer <strong>delete</strong>(int start,int end)</td>
<td>删除 [start,end) 指定位置的内容</td>
</tr>
<tr>
<td>StringBuffer <strong>replace</strong>(int start, int end, String str)</td>
<td>把[start,end)位置的字符串替换为str</td>
</tr>
<tr>
<td>public void <strong>setCharAt</strong>(int n ,char ch)</td>
<td>修改指定索引位置的字符为指定字符</td>
</tr>
<tr>
<td>public char <strong>charAt</strong>(int n )</td>
<td>返回指定位置的字符</td>
</tr>
<tr>
<td>public String <strong>substring</strong>(int start,int end)</td>
<td>提取并<strong>返回</strong> [start,end) 位置的子串(需接收返回值)</td>
</tr>
<tr>
<td>StringBuffer <strong>insert</strong>(int offset, Object xxx)</td>
<td>重载方法，在指定位置插入数据。插入，是<strong>插在之前</strong></td>
</tr>
<tr>
<td>public int <strong>length</strong>()</td>
<td>返回可变字符当前数据长度(非容量)</td>
</tr>
<tr>
<td>StringBuffer <strong>reverse</strong>()</td>
<td>把当前字符序列逆转</td>
</tr>
<tr>
<td>public int <strong>indexOf</strong>(String str)</td>
<td>返回指定字符串在主串中首次出现的位置</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="日期时间">日期时间</h1>
<h2 id="JDK8前API">JDK8前API</h2>
<ul>
<li>JDK 8前API的结构体系</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/java%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9FAPI%E7%BB%93%E6%9E%84%E5%9B%BE.png"
                      alt=""
                ></p>
<h3 id="System">System</h3>
<ul>
<li>System类提供静态方法用来返回当前<strong>时间戳</strong></li>
<li><strong>时间戳</strong>：即当前时间，与1970年1月1日0时0分0秒之间以毫秒为单位的时间差</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static long <strong>currentTimeMillis</strong>()</td>
<td>来返回当前<strong>时间戳</strong>，<strong>单位ms</strong></td>
</tr>
</tbody>
</table>
<h3 id="Date">Date</h3>
<ul>
<li>Java中含有<strong>两个Date类</strong>，分别为java.<strong>util</strong>.Date与java.<strong>sql</strong>.Date</li>
<li>java.sql.Date是java.util.Date的<strong>子类</strong></li>
</ul>
<hr>
<ul>
<li>Date是用于<strong>记录某个时刻的瞬时时间</strong>，一旦创建对象，<strong>时间就记录下来了</strong>。</li>
</ul>
<h4 id="java-util-Date">java.util.Date</h4>
<h5 id="构造器">构造器</h5>
<table>
<thead>
<tr>
<th>构造器</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>new <strong>Date</strong>();</td>
<td>创建当前时刻的Date对象，时间格式默认为，年月日、时分秒、时区信息</td>
</tr>
<tr>
<td>new <strong>Date</strong>(long date)</td>
<td>创建指定时间戳的Date对象</td>
</tr>
</tbody>
</table>
<h5 id="方法">方法</h5>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>toString</strong>()</td>
<td>获取date对象的时间信息，格式为：年月日、时分秒、时区信息</td>
</tr>
<tr>
<td><strong>getTime</strong>()</td>
<td>返回date对象的时间戳</td>
</tr>
</tbody>
</table>
<ul>
<li>Date是用于<strong>记录某个时刻的瞬时时间</strong>，一旦创建对象，<strong>时间就记录下来了</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    System.out.println(date.getTime());</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(date.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出：任意时刻调用都是一样</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1623118447736</span><br><span class="line">1623118447736</span><br></pre></td></tr></table></figure>
<h4 id="java-sql-Date">java.sql.Date</h4>
<ul>
<li>java.sql.Date是<strong>对应数据库</strong>中日期类型的变量，javaBean与<strong>数据库映射</strong>的时候使用</li>
<li>java.sql.Date的构造器<strong>只有带参</strong>的： <code>new Date(long date)</code></li>
<li>java.sql.Date的toString()输出时间格式为：”年月日“</li>
<li>其余和java.util.Date一致</li>
</ul>
<hr>
<ul>
<li>
<p><strong>java.util.Date转换为java.sql.Date的方法</strong></p>
<ul>
<li>
<p>情况一：该java.util.Date本来就就是<strong>多态</strong>与java.sql.Date</p>
<ul>
<li>直接强制转换即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况一：多态情况(很少出现)，直接强制类型向下转换</span></span><br><span class="line">Date date1 = <span class="keyword">new</span> java.sql.Date(<span class="number">1623118805527L</span>);</span><br><span class="line">java.sql.Date date2 = (java.sql.Date) date1;</span><br><span class="line">System.out.println(date2.toString());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>情况二：无多态关系</p>
<ul>
<li>先获取java.util.Date的时间戳，再作为参数传入java.sql.Date</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况二：无多态关系，通过时间戳作为桥梁创建</span></span><br><span class="line">Date date3 = <span class="keyword">new</span> Date();</span><br><span class="line">java.sql.Date date4 = <span class="keyword">new</span> java.sql.Date(date3.getTime());</span><br><span class="line">System.out.println(date4.toString());</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="小结">小结</h4>
<p>Java中的Date类一般三种用途</p>
<ol>
<li>记录(获取)瞬时(当前)时间：<code>new Date();</code>
<ul>
<li>或者直接用System.获取当前时间戳</li>
</ul>
</li>
<li>任意Date日期与时间戳之间相互转换：
<ul>
<li>Date日期——&gt;时间戳：<code>date.getTime()</code></li>
<li>时间戳——&gt;Date日期：<code>new Date(long time);</code></li>
</ul>
</li>
<li>日期数据转换为java.sql.Date的桥梁：桥梁就是利用第2点的转换时间戳功能，作为new java.sql.Date(long time)的桥梁。</li>
</ol>
<hr>
<ul>
<li>
<p>tips：若创建一个<strong>自定义日期时间的Date</strong>，则官方已经不推荐使用<code>new Date(String date)</code>实现了。而是通过SimpleDateFormat定义后，解析返回Date类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>).parse(<span class="string">&quot;1990-01-01&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="SimpleDateFormat">SimpleDateFormat</h3>
<ul>
<li>由于Date类的API<strong>不易于国际化</strong>，大部分被废弃了</li>
<li><strong>SimpleDateFormat</strong>类译为”简单日期格式化“，是一个不与语言环境有关的方式来格式化和解析日期的类</li>
<li>SimpleDateFormat可以<strong>对日期Date</strong>类进行<strong>格式化和对格式化后的内容进行解析</strong>
<ul>
<li><strong>格式化</strong>：日期——&gt;文本</li>
<li><strong>解析</strong>：文本——&gt;日期</li>
</ul>
</li>
<li>格式化与解析的指定格式，都是通过构造器设置</li>
</ul>
<h4 id="格式化">格式化</h4>
<p>格式化方法：SimpleDateFormat对象的<strong>format方法</strong></p>
<ul>
<li><strong>默认格式日期格式化</strong>：new SimpleDateFormat();</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//准备Date时间</span></span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    System.out.println(<span class="string">&quot;date = &quot;</span> + date);<span class="comment">//Tue Jun 08 17:19:52 CST 2021</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认格式格式化，空参构造器</span></span><br><span class="line">    SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line">    String format = simpleDateFormat.format(date);</span><br><span class="line">    System.out.println(<span class="string">&quot;format = &quot;</span> + format);<span class="comment">//21-6-8 下午5:19</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>指定pattern格式日期格式化</strong>：new SimpleDateFormat(<strong>String pattern</strong>)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//准备Date时间</span></span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    System.out.println(<span class="string">&quot;date = &quot;</span> + date);<span class="comment">//Tue Jun 08 17:20:58 CST 2021</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认格式格式化，空参构造器</span></span><br><span class="line">    SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy_MM_dd hh:mm:ss&quot;</span>);</span><br><span class="line">    String format = simpleDateFormat.format(date);</span><br><span class="line">    System.out.println(<span class="string">&quot;format = &quot;</span> + format);<span class="comment">//2021_06_08 05:20:58</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="pattern">pattern</h5>
<ul>
<li>
<p><strong>常用格式含义</strong>：</p>
<ul>
<li>y：年，常用yyyy</li>
<li>M：月，常用MM</li>
<li>d：日，常用dd</li>
<li>h：小时，常用hh</li>
<li>m：分，常用mm</li>
<li>s：秒，常用ss</li>
</ul>
</li>
<li>
<p><strong>API</strong>：具体说明查看官方API</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210608171425.png"
                      alt=""
                ></p>
</li>
<li>
<p>官方示例：“给定的日期和时间是2001-07-04 12:08:56当地时间在美国太平洋时间时区”</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210608171536.png"
                      alt=""
                ></p>
<h4 id="解析">解析</h4>
<p>解析方法：SimpleDateFormat对象的<strong>parse方法</strong></p>
<ul>
<li>传入的<strong>被解析字符串</strong>日期格式是<strong>SimpleDateFormat格式化后的字符串</strong>，<strong>并非Date的日期的字符串</strong>。</li>
<li>传入格式必须与解析格式一致，否则抛出异常。</li>
<li><strong>默认格式解析</strong>：new SimpleDateFormat();</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    <span class="comment">//准备Date时间</span></span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    System.out.println(<span class="string">&quot;date = &quot;</span> + date);<span class="comment">//Tue Jun 08 17:33:00 CST 2021</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认格式格式化，空参构造器</span></span><br><span class="line">    SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line">    String format = simpleDateFormat.format(date);</span><br><span class="line">    System.out.println(<span class="string">&quot;format = &quot;</span> + format);<span class="comment">//21-6-8 下午5:33</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//必须匹配simpleDateFormat定义的解析格式</span></span><br><span class="line">    Date parse = simpleDateFormat.parse(<span class="string">&quot;21-6-8 下午5:33&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;parse = &quot;</span> + parse);<span class="comment">//Tue Jun 08 17:33:00 CST 2021</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>指定格式解析</strong>：new SimpleDateFormat(<strong>String pattern</strong>)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    <span class="comment">//准备Date时间</span></span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    System.out.println(<span class="string">&quot;date = &quot;</span> + date);<span class="comment">//Tue Jun 08 17:28:36 CST 2021</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认格式格式化，空参构造器</span></span><br><span class="line">    SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    String format = simpleDateFormat.format(date);</span><br><span class="line">    System.out.println(<span class="string">&quot;format = &quot;</span> + format);<span class="comment">//2021-06-08</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//必须匹配simpleDateFormat定义的解析格式</span></span><br><span class="line">    Date parse = simpleDateFormat.parse(<span class="string">&quot;2021-06-08&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;parse = &quot;</span> + parse);<span class="comment">//Tue Jun 08 17:28:00 CST 2021</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Calendar">Calendar</h3>
<ul>
<li>Calendar是JDK提供的一个封装类<strong>日历相关信息操作</strong>的<strong>抽象类</strong>，可以进行一些常用日历相关操作</li>
<li>Calendar可以返回Calendar对象实例化的时间是<strong>这一个月的第几天，这一年的第几天</strong>等操作…</li>
</ul>
<h4 id="实例化">实例化</h4>
<ul>
<li>
<p>Calendar是一个<strong>抽象类</strong>，实际使用的是其(实现)<strong>子类GregorianCalendar</strong>类</p>
</li>
<li>
<p>获取Calendar(<strong>GregorianCalendar</strong>)实例的方式有两种：</p>
<ol>
<li>
<p><strong>Calendar静态方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar.getInstance();<span class="comment">//实质也是GregorianCalendar实例</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>new GregorianCalendar()构造器方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GregorianCalendar gregorianCalendar = <span class="keyword">new</span> GregorianCalendar();</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li><strong>tips</strong>：没经过setTime()设置的Calendar所表示的时间就是Calendar对象实例化时候的时间</li>
</ul>
<h4 id="常用API-2">常用API</h4>
<h5 id="get-set">get&amp;set</h5>
<ul>
<li>get和set方法可以<strong>获取或修改</strong>Calendar对象持有的时间，根据<strong>field</strong>所指定的意义的<strong>数量(日/月/年…)</strong></li>
<li>int <strong>field</strong>：传入的是<strong>Calendar的静态常量</strong>，表示部分常量意义如下，详情查看API
<ul>
<li>Calendar.<strong>DAY_OF_MONTH</strong>：当前<strong>月</strong>的第几<strong>天</strong></li>
<li>Calendar.<strong>DAY_OF_WEEK</strong>：当前<strong>星期</strong>的第几<strong>天</strong>(星期几)</li>
<li>Calendar.<strong>WEEK_OF_MONTH</strong>：当前<strong>月份</strong>的第几个<strong>星期</strong></li>
<li>…</li>
</ul>
</li>
<li><strong>get返回值set设置值意义</strong>：
<ul>
<li>DAY_OF_WEE(星期)： <strong>1是周日</strong>，2周一，3周二 ， 。。。。7是周六</li>
<li>获取月份：<strong>一月是0</strong>，二月是1，以此类推，12月是11</li>
<li>由于不同国家，多星期一或星期日是第一天理解不同。其他的Calendar类一些常量还具有很多特殊情况，具体问题请查阅相关资料。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>示例代码：</li>
<li><strong>获取</strong>当前时间是这个月、或这个星期的第几天，这个月的第几周</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Calendar calendar = Calendar.getInstance();</span><br><span class="line">    System.out.println(calendar.getTime());<span class="comment">//Wed Jun 09 07:39:41 CST 2021</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">    <span class="keyword">int</span> dayOfMonth = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">    <span class="keyword">int</span> weekOfMonth = calendar.get(Calendar.WEEK_OF_MONTH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前测试时间是：2021年06月09日,星期三</span></span><br><span class="line">    System.out.println(<span class="string">&quot;dayOfWeek = &quot;</span> + dayOfWeek);<span class="comment">//4，4表示星期三</span></span><br><span class="line">    System.out.println(<span class="string">&quot;dayOfMonth = &quot;</span> + dayOfMonth);<span class="comment">//9</span></span><br><span class="line">    System.out.println(<span class="string">&quot;weekOfMonth = &quot;</span> + weekOfMonth);<span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>修改</strong>当前时间是这个星期的第几天</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Calendar calendar = Calendar.getInstance();</span><br><span class="line">    System.out.println(calendar.getTime());<span class="comment">//Wed Jun 09 07:39:41 CST 2021</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">    System.out.println(<span class="string">&quot;dayOfWeek = &quot;</span> + dayOfWeek);<span class="comment">//4,星期三</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改当前时间是这一周的第几天(星期几)</span></span><br><span class="line">    calendar.set(Calendar.DAY_OF_WEEK,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">    <span class="comment">//当前测试时间是：2021年06月09日，星期三</span></span><br><span class="line">    System.out.println(<span class="string">&quot;dayOfWeek = &quot;</span> + dayOfWeek);<span class="comment">//3，星期二</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="add">add</h5>
<ul>
<li>add方法可以使Calendar对象时间根据<strong>field</strong>所指定的意义<strong>增加或减少</strong>或指定的<strong>数量(日/月/年…)</strong>
<ul>
<li><strong>加</strong>：传入正数</li>
<li><strong>减</strong>：传入负数</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>示例代码</li>
<li>对当前时间是这个星期的第几天进行加减修改操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Calendar calendar = Calendar.getInstance();</span><br><span class="line">    System.out.println(calendar.getTime());<span class="comment">//Wed Jun 09 07:39:41 CST 2021</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前测试时间是：2021年06月09日，星期三</span></span><br><span class="line">    <span class="keyword">int</span> dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">    System.out.println(<span class="string">&quot;dayOfWeek = &quot;</span> + dayOfWeek);<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将这一周的第几天数量增加2</span></span><br><span class="line">    calendar.add(Calendar.DAY_OF_WEEK,<span class="number">2</span>);<span class="comment">//加两天</span></span><br><span class="line">    System.out.println(calendar.get(Calendar.DAY_OF_WEEK));<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将这一周的第几天数量减少2</span></span><br><span class="line">    calendar.add(Calendar.DAY_OF_WEEK,-<span class="number">2</span>);<span class="comment">//减两天</span></span><br><span class="line">    System.out.println(calendar.get(Calendar.DAY_OF_WEEK));<span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="getTime">getTime</h4>
<ul>
<li>返回当前Calendar实例的时间对应的java.util.Date类</li>
<li>示例代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">Date date = calendar.getTime();</span><br></pre></td></tr></table></figure>
<h4 id="setTime">setTime</h4>
<ul>
<li>通过java.util.Date类修改Calendar实例持有的时间</li>
<li>示例代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">calendar.setTime(date);</span><br></pre></td></tr></table></figure>
<h3 id="综合应用">综合应用</h3>
<h4 id="字符串日期转sql-Date">字符串日期转sql.Date</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    String strDate = <span class="string">&quot;2020-09-08&quot;</span>;</span><br><span class="line">    <span class="comment">//对应日期字符串格式编写对应的pattern</span></span><br><span class="line">    SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    Date utilDate = simpleDateFormat.parse(strDate);</span><br><span class="line">    java.sql.Date date = <span class="keyword">new</span> java.sql.Date(utilDate.getTime());</span><br><span class="line">    System.out.println(date.getClass() + <span class="string">&quot; = &quot;</span> + date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总天数计算">总天数计算</h4>
<p>例题：计算任意日期从1990-01-01开始的天数</p>
<ul>
<li>方法1：分别计算起始日期的时间戳与目的日期的时间戳，进行相减后除出天数</li>
<li>方法2：先算整数年份日，再算当年年份如： 1990-01-01—2019-12-31 + 2020-01-01 — 2020-09-08</li>
<li>方法2的Calendar类辅助：如计算2020-01-01 — 2020-09-08，可以设置Calendar为2020-09-08计算</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1：现在规定是从1990年1月1日开始计算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDayCount</span><span class="params">(java.util.Date date)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> beginTime = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>).parse(<span class="string">&quot;1990-01-01&quot;</span>).getTime();</span><br><span class="line">    <span class="keyword">long</span> dateTime = date.getTime();</span><br><span class="line">    <span class="keyword">if</span>(dateTime &lt; beginTime)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> time = dateTime - beginTime;</span><br><span class="line">    <span class="keyword">int</span> dayCount = (<span class="keyword">int</span>)(time / <span class="number">1000</span> / <span class="number">3600</span> / <span class="number">24</span>) + <span class="number">1</span>;<span class="comment">//整数除法省去余数需加1</span></span><br><span class="line">    <span class="keyword">return</span> dayCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>扩展例题：有一个渔夫，从1990-01-01日起，开始&quot;三天打渔两天嗮网&quot;，请问日期为 xxxx-xx-xx 时，渔夫是在打渔还是在嗮网？转换来说就是一个求总天数的问题。
<ul>
<li>总天数 % 5 == 4，5：嗮网</li>
<li>总天数 % 5 == 1，2，3：打渔</li>
</ul>
</li>
</ul>
<h2 id="JDK8后API">JDK8后API</h2>
<h3 id="背景-2">背景</h3>
<h4 id="旧API缺陷">旧API缺陷</h4>
<ul>
<li>JDK 1.0中包含了 一个java.util.Date类，但它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用。</li>
<li>但Calendar并不比Date好多少…，它们面临的问题总共有如下几个方面：
<ul>
<li>Calendar<strong>的可变性</strong>：calendar的set方法能任意修改一个星期第几天，理应是不允许做这些修改的</li>
<li><strong>偏移量</strong>：通过构造器设置Date时间，实际调用Calendar操作年份+1900偏移，月份从0开始(设置当前年份 - 1990，当前月份 -1)，由于偏移量与月份从0开始的设定，使其不方便，易错</li>
<li><strong>格式化</strong>：Date可通过废弃的构造器或者基于simpleDateFormat可进行格式化，被推祟替换Date的Calendar却不支持格式化操作</li>
<li><strong>线程不安全</strong>：Date与Calendar均线程不安全</li>
<li><strong>不支持处理闰秒</strong></li>
</ul>
</li>
<li>总结：对日期和时间的操作一直是Java程序员最痛苦的地方之一</li>
</ul>
<h4 id="新API">新API</h4>
<p>​	Java 8 吸收了 <strong>Joda-Time 的精华</strong>(第三方库)，以一个新的开始为 Java 创建优秀的 API。 新的 <strong>java.time</strong> 中包含了所有关于本地日期（<strong>LocalDate</strong>）、本地时间 （<strong>LocalTime</strong>）、本地日期时间（<strong>LocalDateTime</strong>）、时区（<strong>ZonedDateTime</strong>） 和持续时间（<strong>Duration</strong>）的类。历史悠久的 <strong>Date 类新增了 toInstant()</strong> 方法， 用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简 化了日期时间和本地化的管理。</p>
<ul>
<li>没有偏移量，直接获取或设置</li>
<li>不可变性：JDK8 中如Calendar的类的修改有返回值，但不影响对象原有数据</li>
<li>由于新时间API结构庞大，本文章只介绍部分常用的API，有需求另查API</li>
</ul>
<h3 id="本地日期时间">本地日期时间</h3>
<p>描述本地日期与时间涉及三个类：</p>
<ul>
<li>本地日期（<strong>LocalDate</strong>）：代表<strong>IOS格式</strong>（yyyy-MM-dd）的日期,可以存储 生日、纪念日等日期</li>
<li>本地时间 （<strong>LocalTime</strong>）：LocalTime表示一个时间，而不是日期</li>
<li>本地日期时间（<strong>LocalDateTime</strong>）：LocalDateTime是用来表示日期和时间的，<strong>最常用的类之一</strong>。</li>
</ul>
<p><strong>注</strong>：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法，也就是<strong>公历</strong>。</p>
<h4 id="实例化-2">实例化</h4>
<ul>
<li>
<p>实例化操作均为<strong>对应类的静态方法</strong>，分别有<strong>now</strong>()与<strong>of</strong>(形参)两种方式</p>
<ul>
<li><strong>now</strong>()：空参方法，返回<strong>当前时间</strong></li>
<li><strong>of</strong>(形参列表)：多个重载构造器，可以直接<strong>设置指定的年月日时分秒时间</strong></li>
</ul>
</li>
<li>
<p>示例代码</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//now()方式，获取当前时间的对应类对象</span></span><br><span class="line">    LocalDate localDate = LocalDate.now();</span><br><span class="line">    LocalTime localTime = LocalTime.now();</span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;localDate = &quot;</span> + localDate);<span class="comment">//2021-06-09</span></span><br><span class="line">    System.out.println(<span class="string">&quot;localTime = &quot;</span> + localTime);<span class="comment">//08:46:34.606</span></span><br><span class="line">    System.out.println(<span class="string">&quot;localDateTime = &quot;</span> + localDateTime);<span class="comment">//2021-06-09T08:46:34.606</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//of(形参列表)方式，自定义任意时间创建对应类对象(不存在偏移量，直接设置)</span></span><br><span class="line">    LocalDateTime localDateTime1 = LocalDateTime.of(<span class="number">2099</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">20</span>, <span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;localDateTime1 = &quot;</span> + localDateTime1);<span class="comment">//2099-03-01T05:45:20.000000003</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法-2">方法</h4>
<ul>
<li>基于表示内容的范围<strong>LocalDateTime</strong>涵盖了大部分方法，因此主要以LocalDateTime说明方法</li>
<li>JDK 8后的本地时间日期类都<strong>没有偏移量设定</strong>，<strong>可直接获取与设置</strong></li>
<li>JDK 8后的API<strong>将其Calender不同field意义的操作直接封装在每一个对应的方法</strong>中</li>
<li><strong>不可变性</strong>：withXxx()、plusXxx()、minusXxx()方法
<ul>
<li>这些方法修改后是<strong>有修改后的返回值</strong>，本身的日期时间<strong>对象不会被修改数据</strong>。</li>
<li>Calendar的set()方法，是没返回值，直接修改了对象的数据</li>
</ul>
</li>
</ul>
<h5 id="getXxx">getXxx()</h5>
<ul>
<li>
<p><strong>getXxxx</strong>()系列的方法可以如Calendar的<strong>get</strong>(int field)方法一样<strong>获取</strong>各种日历意义的参数。</p>
<ul>
<li>getDayOfMonth()：返回当前月的第几天</li>
<li>getDayOfWeek()：返回当前周的第几天</li>
<li>getMonth()：返回月份信息</li>
<li>…</li>
</ul>
</li>
<li>
<p><strong>getValue()</strong>：可以返回某个时间日期子对象<strong>实际的数值</strong>。</p>
</li>
</ul>
<hr>
<ul>
<li><strong>示例代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;localDateTime = &quot;</span> + localDateTime);<span class="comment">//2021-06-09T08:53:20.896</span></span><br><span class="line"></span><br><span class="line">    System.out.println(localDateTime.getDayOfMonth());<span class="comment">//9</span></span><br><span class="line">    System.out.println(localDateTime.getDayOfWeek());<span class="comment">//WEDNESDAY(星期三)</span></span><br><span class="line">    System.out.println(localDateTime.getDayOfYear());<span class="comment">//160</span></span><br><span class="line"></span><br><span class="line">    System.out.println(localDateTime.getMonth());<span class="comment">//JUNE(六月)</span></span><br><span class="line">    System.out.println(localDateTime.getMonth().getValue());<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line">    System.out.println(localDateTime.getMinute());<span class="comment">//53</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="withXxx">withXxx()</h5>
<ul>
<li><strong>withXxxx</strong>()系列的方法可以如Calendar的<strong>set</strong>(int field,int i)方法一样<strong>设置</strong>各种日历意义的参数。
<ul>
<li>对应getXxx()提供意义的方法，基本对应有withXxx()方法，详情查看API</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>示例代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LocalDateTime originTime = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置当前时间在一个月中第几天的数据。有新对象，原对象数据不修改</span></span><br><span class="line">    LocalDateTime localDateTime1 = originTime.withDayOfMonth(<span class="number">12</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;localDateTime1 = &quot;</span> + localDateTime1.getDayOfMonth());<span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;originTime = &quot;</span> + originTime.getDayOfMonth());<span class="comment">//9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="plusXxx">plusXxx()</h5>
<ul>
<li><strong>plusXxx</strong>()系列的方法可以如Calendar的<strong>add</strong>(int field,int i)方法一样<strong>增加</strong>各种日历意义的参数。
<ul>
<li>对应getXxx()提供意义的方法，基本对应有plusXxx()方法，详情查看API</li>
</ul>
</li>
<li><strong>示例代码</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LocalDateTime originTime = LocalDateTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;originTime = &quot;</span> + originTime.getDayOfMonth());<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加基于当前时间的天数。有新对象，原对象数据不修改</span></span><br><span class="line">    LocalDateTime localDateTime1 = originTime.plusDays(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;localDateTime1 = &quot;</span> + localDateTime1.getDayOfMonth());<span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="minusXxx">minusXxx()</h5>
<ul>
<li><strong>minusXxx()<strong>系列的方法可以如Calendar的</strong>add</strong>(int field,int <strong>-i</strong>)方法一样<strong>减少</strong>各种日历意义的参数。
<ul>
<li>对应getXxx()提供意义的方法，基本对应有minusXxx()方法，详情查看API</li>
</ul>
</li>
<li><strong>示例代码</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LocalDateTime originTime = LocalDateTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;originTime = &quot;</span> + originTime.getDayOfMonth());<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加基于当前时间的天数。有新对象，原对象数据不修改</span></span><br><span class="line">    LocalDateTime localDateTime1 = originTime.minusDays(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;localDateTime1 = &quot;</span> + localDateTime1.getDayOfMonth());<span class="comment">//8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Instant">Instant</h3>
<ul>
<li>Instant：时间线上的一个<strong>瞬时点</strong>，即<strong>时间戳</strong>。<strong>面向机器</strong>的连续的时间数值量。</li>
<li>为java.time包是基于<strong>纳秒</strong>计算的，所以<strong>Instant的精度</strong>可以达到<strong>纳秒级</strong>(秒-毫秒-微妙-纳秒)</li>
<li>类似于java.util.Date()类</li>
</ul>
<h4 id="实例化-3">实例化</h4>
<ul>
<li>API</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>now</strong>()</td>
<td><strong>静态方法</strong>，返回<strong>默认UTC时区</strong>的Instant类的对象</td>
</tr>
<tr>
<td><strong>atOffset</strong>(ZoneOffset offset)</td>
<td>结合即时的偏移来创建一个 OffsetDateTime</td>
</tr>
<tr>
<td><strong>ofEpochMilli</strong>(long epochMilli)</td>
<td><strong>静态方法</strong>，通过给定时间戳创建Instant类的对象</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>注</strong>：时区*:*UTC/GMT 0 (零时区) 与北京时差相差8个小时</li>
</ul>
<hr>
<ul>
<li>now()方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//当前测试时间为：2021-06-09T09:50:47</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now()：默认获取UTC时间，零时区(本初子午线的标准时间)</span></span><br><span class="line">    Instant instant = Instant.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;instant = &quot;</span> + instant);<span class="comment">//2021-06-09T01:50:47.757Z</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于UTC 零时区与北京东八区相差8小时，可通过偏移量方式设置回去</span></span><br><span class="line">    OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;offsetDateTime = &quot;</span> + offsetDateTime);<span class="comment">//2021-06-09T09:50:47.757+08:00</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ofEpochMilli(long epochMilli)方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Instant instant = Instant.ofEpochMilli(<span class="number">1623203887637L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;instant = &quot;</span> + instant);<span class="comment">//2021-06-09T01:58:07.637Z</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常用方法">常用方法</h4>
<ul>
<li><strong>API</strong></li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>toEpochMilli</strong>()</td>
<td>返回instant对象的时间戳，单位毫秒</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>示例代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Instant instant = Instant.now();</span><br><span class="line">    <span class="keyword">long</span> time = instant.toEpochMilli();</span><br><span class="line">    System.out.println(<span class="string">&quot;time = &quot;</span> + time);<span class="comment">//1623204005225</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DateTimeFormat">DateTimeFormat</h3>
<ul>
<li>DateTimeFormat用于<strong>格式化或解析</strong>日期、时间</li>
<li>类似SimpleDateFormat</li>
</ul>
<h4 id="实例化-格式设置">实例化/格式设置</h4>
<p>DateTimeFormat提供众多的实例化方式(设置格式化与解析格式)，常用如下三种</p>
<ul>
<li><strong>预定义的标准格式</strong>：如，全局静态常量，ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</li>
<li><strong>本地化相关格式</strong>：如，ofLocalizedDateTime(FormatStyle.LONG)</li>
<li><strong>自定义的格式</strong>：如，ofPattern(“yyyy-MM-dd hh:mm:ss”)，<strong>最常用！！！</strong></li>
</ul>
<h5 id="预定义标准格式">预定义标准格式</h5>
<ul>
<li>通过DateTimeFormat提供的<strong>全局静态常量</strong>提供的标准格式，来定义格式并实例化其对象</li>
<li>如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIM</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采取ISO_DATE_TIME格式</span></span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ISO_DATE_TIME;</span><br></pre></td></tr></table></figure>
<h5 id="本地化相关格式">本地化相关格式</h5>
<ul>
<li>
<p><strong>API</strong>：静态方法，<code>DateTimeFormatter.ofLocalizedXxxx(FormatStyle value)</code>，</p>
</li>
<li>
<p><strong>Xxx不同的方法对应</strong>，LocalDate、LocalTime、LocalDateTime</p>
<ul>
<li>如：ofLocalizedDate(FormatStyle value)、ofLocalizedDateTime(FormatStyle value)…</li>
</ul>
</li>
<li>
<p><strong>FormatStyle</strong>：是一个本地内置日期实际格式枚举类，提供多种常用的内置的格式标识</p>
<ul>
<li><strong>LONG</strong>：通用的长格式如，<strong>2021年6月9日</strong></li>
<li><strong>MEDIUM</strong>：通用的中等格式如，<strong>2021-6-9</strong></li>
<li><strong>SHORT</strong>：通用的短格式如，<strong>21-6-9</strong></li>
</ul>
<hr>
<ul>
<li><strong>FULL</strong>：仅适用于ofLocalizedDate()的一种格式如，<strong>2021年6月9日 星期三</strong></li>
</ul>
</li>
<li>
<p><strong>示例代码</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//ofLocalizedDate 对应 LocalDate</span></span><br><span class="line">    DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL);</span><br><span class="line">    String format = dateTimeFormatter.format(LocalDate.now());</span><br><span class="line">    System.out.println(<span class="string">&quot;format = &quot;</span> + format);<span class="comment">//2021年6月9日 星期三</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ofLocalizedDateTime 对应 LocalDateTime</span></span><br><span class="line">    DateTimeFormatter dateTimeFormatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM);</span><br><span class="line">    String format1 = dateTimeFormatter1.format(LocalDateTime.now());</span><br><span class="line">    System.out.println(<span class="string">&quot;format1 = &quot;</span> + format1);<span class="comment">//2021-6-9 10:42:29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="自定义格式">自定义格式</h5>
<ul>
<li><strong>API</strong>：静态方法，<code>DateTimeFormatter.ofPattern(String pattern);</code></li>
<li>一般开发都是自定义格式使用多。</li>
<li>pattern格式与SimpleDateFormat的pattern格式一致</li>
<li><strong>示例代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy_MM_dd&quot;</span>);</span><br><span class="line">    String format = dateTimeFormatter.format(LocalDate.now());</span><br><span class="line">    System.out.println(<span class="string">&quot;format = &quot;</span> + format);<span class="comment">//2021_06_09</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="格式化-2">格式化</h4>
<ul>
<li>格式化即通过DateTimeFormat格式定义，将LocalXxx类的时间转换为字符串</li>
<li>API</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>format</strong>(TemporalAccessor t)</td>
<td>格式化一个日期、时间，返回字符串</td>
</tr>
</tbody>
</table>
<p><strong>注</strong>：<strong>TemporalAccessor对象</strong>实际就是<strong>LocalDate、LocalTime、LoclDateTime对象</strong>。它们多实现Temporal接口，Temporal接口继承于TemporalAccessor。</p>
<hr>
<ul>
<li>示例代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//采取ISO_DATE_TIME格式</span></span><br><span class="line">    DateTimeFormatter formatter = DateTimeFormatter.ISO_DATE_TIME;</span><br><span class="line"></span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;localDateTime = &quot;</span> + localDateTime);<span class="comment">//2021-06-09T10:20:09.903</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    String format = formatter.format(localDateTime);</span><br><span class="line">    System.out.println(<span class="string">&quot;format = &quot;</span> + format);<span class="comment">//2021-06-09T10:20:09.903</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解析-2">解析</h4>
<ul>
<li>
<p>解析即通过DateTimeFormat格式定义，将字符串转换为LocalXxx类的时间</p>
</li>
<li>
<p>同理SimpleDateFormat解析概念，解析的格式要和格式化的格式统一，否则失败</p>
</li>
<li>
<p><strong>API</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>parse</strong>(CharSequence text)</td>
<td>将指定格式的字符序列解析为一个日期、时间</td>
</tr>
</tbody>
</table>
<p><strong>注</strong>：CharSequence字符串格式</p>
<hr>
<ul>
<li><strong>示例代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String dateStr = <span class="string">&quot;2021_06_09&quot;</span>;</span><br><span class="line">    DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy_MM_dd&quot;</span>);</span><br><span class="line">    TemporalAccessor temporalAccessor = dateTimeFormatter.parse(dateStr);</span><br><span class="line">    System.out.println(<span class="string">&quot;temporalAccessor = &quot;</span> + temporalAccessor);<span class="comment">//&#123;&#125;,ISO resolved to 2021-06-09</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Date间转换">Date间转换</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210609110255.png"
                      alt=""
                ></p>
<h3 id="其他API">其他API</h3>
<ul>
<li>ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris</li>
<li>ZonedDateTime：一个在ISO-8601日历系统时区的日期时间，如 2007-12- 03T10:15:30+01:00 Europe/Paris。
<ul>
<li>其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，例如： Asia/Shanghai等</li>
</ul>
</li>
<li>Clock：使用时区提供对当前即时、日期和时间的访问的时钟。</li>
<li>持续时间：Duration，用于计算两个“时间”间隔</li>
<li>日期间隔：Period，用于计算两个“日期”间隔</li>
<li>TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整 到“下一个工作日”等操作</li>
<li>TemporalAdjusters : 该类通过静态方法 (firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用 TemporalAdjuster 的实现。</li>
</ul>
<h2 id="小结-2">小结</h2>
<table>
<thead>
<tr>
<th>JDK 8前时间类相关</th>
<th>类似JDK 8时间类相关</th>
</tr>
</thead>
<tbody>
<tr>
<td>Date</td>
<td>Instant</td>
</tr>
<tr>
<td>Calendar</td>
<td>LocalDate、LocalTime、localDateTime</td>
</tr>
<tr>
<td>SimpleDateFormat</td>
<td>DateTimeFromat</td>
</tr>
</tbody>
</table>
<h1 id="Java比较器">Java比较器</h1>
<h2 id="基础概念">基础概念</h2>
<ul>
<li>在Java中经常会涉及到<strong>多个对象(数组/集合)的排序问题</strong>，那么就涉及到<strong>对象之间的比较问题</strong>。</li>
<li>Java实现对象排序的方式有两种：
<ul>
<li><strong>自然排序</strong>：java.lang.Comparable</li>
<li><strong>定制排序</strong>：java.util.Comparator</li>
</ul>
</li>
<li>Comparable与Comparator<strong>都是接口</strong>，即规范，即定义<strong>比较标准的规范</strong></li>
</ul>
<h2 id="Comparable">Comparable</h2>
<h3 id="实现原理">实现原理</h3>
<ul>
<li>对于<strong>对象与对象之间</strong>，或者说<strong>非数值型数据</strong>比较，<strong>真正比较</strong>的<strong>还是得基于某个具体的属性数值比较</strong></li>
<li>一个对象的<strong>属性有多种</strong>，因此比较之前需要<strong>定义比较的基准</strong></li>
<li>这个<strong>比较的标准</strong>正是通过<strong>Comparable接口</strong>的待实现方法<strong>compareTo</strong>()所规范的</li>
<li><strong>compareTo()定义规范如下</strong>：<code>public int compareTo(Object obj)</code>
<ul>
<li>返回<strong>正整数</strong>：this &gt; obj</li>
<li>返回<strong>负整数</strong>：obj &gt; this</li>
<li>返回<strong>零</strong>：this = obj</li>
</ul>
</li>
<li>有了<strong>compareTo</strong>(Object obj)方法就相当于<strong>有了用于比较非数值数据</strong>的 &quot;<strong>&gt;,&lt;,=</strong>&quot;号</li>
<li>此时非数值类型对象也可以像数值类型之间<strong>两两进行比较</strong></li>
<li>最后如同编写数值类型的排序算法一样，实现排序即可。</li>
</ul>
<h4 id="String示例">String示例</h4>
<p>例如：字符串之间的比较，字符串属于非数值型数据。比较之前必须定义一个比较的基准。String本身有去实现<strong>Comparable</strong>接口，进而也就是实现了描述比较基准的<strong>compareTo</strong>()方法。</p>
<ul>
<li>String实现compareTo()源码：
<ul>
<li>通过浏览源码可知，String的比较基准是一个个字符的Unicode数值进行比较(相减)。</li>
<li>若出现不同字符返回的比较结果就是两者之间的差，负数obj大，正数this大</li>
<li>否则就是相同字符串，长度相等返回0，表示comparaTo()规范中的相等含义</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="已实现比较类">已实现比较类</h3>
<p>除原理介绍所说的String类已经实现了Comparable接口外JDK还有很多类已经实现了该接口，可进行排序</p>
<ul>
<li><strong>String</strong>：按照字符串中<strong>字符的Unicode值</strong>进行比较</li>
<li><strong>Character</strong>/<strong>char</strong>：按照<strong>字符的Unicode值</strong>来进行比较</li>
<li><strong>数值类型、包装类及BigInteger、BigDecimal</strong>：按照它们对应的<strong>数值大小</strong>进行比较</li>
<li><strong>Boolean</strong>：true对应的包装类实例大于 false 对应的包装类实例</li>
<li><strong>Date、Time</strong>：后面的日期时间比前面的日期时间大</li>
<li>…</li>
</ul>
<h3 id="自定义类排序">自定义类排序</h3>
<h4 id="实现步骤">实现步骤</h4>
<p>基于Comparable规范完成的一套比较流程如下：</p>
<ol>
<li>非数值型数据<strong>实现Comparable&lt;T&gt;接口</strong>，泛型T为该实现排序接口的类</li>
<li>实现compareTo方法，基于compareTo方法规范，编写比较的标准。作为比较用的&quot;<strong>&gt;,&lt;,=</strong>&quot;符号
<ul>
<li>返回<strong>正整数</strong>：this &gt; obj</li>
<li>返回<strong>负整数</strong>：obj &gt; this</li>
<li>返回<strong>零</strong>：this == obj</li>
</ul>
</li>
<li>此时<strong>非数值型数据</strong>的比较可以直接<strong>调用compareTo</strong>(Object obj)方法<strong>进行两两比较</strong>(如数值型比较一般)</li>
<li><strong>编写排序算法</strong>
<ul>
<li>此时可以选择自己写一个方法通过调用compareTo()实现对一组对象(数组/集合)进行排序，如同数值型数据写排序算法一般。</li>
<li>也可以选择调用JDK提供号的排序方法sort实现(底层快排实现，默认<strong>从小到大</strong>)：
<ul>
<li><strong>数组型</strong>：<code>Arrays.sort(Object[] a);</code></li>
<li><strong>集合型</strong>：<code>Collections.sort(List&lt;T&gt; list);</code></li>
<li>new TreeSet()</li>
<li>new TreeMap()</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<p><strong>注</strong>：最终的排序结果的顺序，<strong>取决两个因素</strong>：</p>
<ul>
<li>一是，compareTo()中返回判断是正序还是逆序，(如将返回的<strong>数值取反</strong>，<strong>可颠倒一次顺序</strong>)</li>
<li>二是，排序算法是基于从小到大还是从大到小进行排序</li>
<li>补充：<strong>compareTo</strong>规范原本用意也是<strong>从小到大</strong>，JDK内置<strong>sort</strong>排序也是从<strong>小到大</strong></li>
</ul>
<h4 id="示例代码">示例代码</h4>
<ul>
<li><strong>Goods类</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.compare;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-09 15:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Goods</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略get、set方法与toString方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//自编写Goods对象的比较规则：默认价格从低到高排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Goods o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.getPrice() &gt; o.getPrice())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//this &gt; another</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.getPrice() &lt; o.getPrice())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//another &gt; this</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//this == another</span></span><br><span class="line">            <span class="comment">//还可以进行二级排序：当价格一样时，比较两商品名</span></span><br><span class="line">            <span class="comment">//return this.name.compareTo(another.getName());</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//也可以直接不写上面代码，用内置，实现是一样</span></span><br><span class="line">        <span class="comment">//return Double.compare(this.getPrice(),another.getPrice());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>测试代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Goods[] goodses = <span class="keyword">new</span> Goods[<span class="number">4</span>];</span><br><span class="line">    goodses[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;abc&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">    goodses[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;ttt&quot;</span>, <span class="number">55</span>);</span><br><span class="line">    goodses[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;qaa&quot;</span>, <span class="number">900</span>);</span><br><span class="line">    goodses[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;pris&quot;</span>, <span class="number">2300</span>);</span><br><span class="line"></span><br><span class="line">    Arrays.sort(goodses);</span><br><span class="line">    System.out.println(Arrays.toString(goodses));</span><br><span class="line">    <span class="comment">//[Goods&#123;name=&#x27;ttt&#x27;, price=55.0&#125;, </span></span><br><span class="line">    <span class="comment">// Goods&#123;name=&#x27;qaa&#x27;, price=900.0&#125;, </span></span><br><span class="line">    <span class="comment">// Goods&#123;name=&#x27;abc&#x27;, price=1000.0&#125;, </span></span><br><span class="line">    <span class="comment">// Goods&#123;name=&#x27;pris&#x27;, price=2300.0&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Comparator">Comparator</h2>
<h3 id="使用场景">使用场景</h3>
<ul>
<li>当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码</li>
<li>或者实现了java.lang.Comparable接口的排序规则不适合当前的操作</li>
<li>此时可以考虑使用Comparator的对象来进行定制化的排序，强行对多个对象进行整体排序的比较</li>
</ul>
<hr>
<ul>
<li>如此时，我希望String字符从大到小排序</li>
</ul>
<h3 id="原理">原理</h3>
<ul>
<li>由于比较器不是待比较数据类型内置的一个排序规则(即非自然排序)</li>
<li>比较器是一个外置的、定制化的排序。因此接口的实现者自然不是待排序数据类型</li>
<li>但<strong>核心的原理是一样</strong>，即<strong>都是规范化一个比较基准定义方法</strong>，<code>int compare(T o1, T o2);</code>，因为这是非数值类型进行比较的一个基础，是通用的一个基底。</li>
<li>相比与Comparable/自然排序，比较器的设计的核心就在于把这种<strong>比较基准的规范方</strong>法<strong>与待比较数据类型的关系分离开来，独立开来</strong>。使其外界可进行一个任意定制化的排序，这就是比较器！</li>
</ul>
<h3 id="自定义比较器">自定义比较器</h3>
<ol>
<li><strong>创建一个定制化排序类</strong>，实现<strong>Comparator</strong>&lt;T&gt;接口及其方法。泛型T指明比较的类型，若是调用JDK排序方法，也可用匿名的方式创建。</li>
<li>实现int <strong>compare</strong>(T o1, T o2)方法，由于非数值类型比较实现原理是一致的，遵循统一规范
<ul>
<li>返回<strong>正整数</strong>：o1 &gt; o2</li>
<li>返回<strong>负整数</strong>：o2 &gt; o1</li>
<li>返回<strong>零</strong>：o1 == o2</li>
</ul>
</li>
<li>此时<strong>非数值型数据</strong>的比较可以创建Comparator实现类对象，<strong>调用compare</strong>方法<strong>进行两两比较</strong>(如数值型比较一般)</li>
<li><strong>编写排序算法</strong>
<ul>
<li>此时可以选择自己写一个方法通过<strong>传入Comparator实现类对象</strong>，与待排序对象集合，调用compare()实现对一组对象(数组/集合)进行排序，如同数值型数据写排序算法一般。</li>
<li>也可以选择调用JDK提供的排序方法带Comparator形参的，sort实现(底层快排实现，默认<strong>从小到大</strong>)：
<ul>
<li><strong>数组型</strong>：<code>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)</code></li>
<li><strong>集合型</strong>：<code>Collections.sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code></li>
<li>new TreeSet()</li>
<li>new TreeMap()</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="示例代码-2">示例代码</h4>
<h5 id="定制化String排序">定制化String排序</h5>
<ul>
<li>使其String比较按从大到小排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String[] strs = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;FF&quot;</span>,<span class="string">&quot;DD&quot;</span>,<span class="string">&quot;EE&quot;</span>,<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>&#125;;</span><br><span class="line">    Arrays.sort(strs, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -o1.compareTo(o2);<span class="comment">//将比较结果取反，实现倒序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(Arrays.toString(strs));<span class="comment">//[FF, EE, DD, CC, AA]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="自定义类">自定义类</h5>
<ul>
<li>自然排序规则：按<strong>价格从低到高</strong>排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.compare;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-09 15:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Goods</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略get、set方法与toString方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//自编写Goods对象的比较规则：默认价格从低到高排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Goods o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.getPrice() &gt; o.getPrice())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//this &gt; another</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.getPrice() &lt; o.getPrice())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//another &gt; this</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//this == another</span></span><br><span class="line">            <span class="comment">//还可以进行二级排序：当价格一样时，比较两商品名</span></span><br><span class="line">            <span class="comment">//return this.name.compareTo(another.getName());</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//也可以直接不写上面代码，用内置，实现是一样</span></span><br><span class="line">        <span class="comment">//return Double.compare(this.getPrice(),another.getPrice());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定制化排序规则，先按<strong>商品名从小到大</strong>排序，再按<strong>价格从大到小</strong>排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.website.compare;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-09 16:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Goods[] goodses = <span class="keyword">new</span> Goods[<span class="number">5</span>];</span><br><span class="line">        goodses[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;bbc&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        goodses[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;ttt&quot;</span>, <span class="number">55</span>);</span><br><span class="line">        goodses[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;aaq&quot;</span>, <span class="number">900</span>);</span><br><span class="line">        goodses[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;aaq&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        goodses[<span class="number">4</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;ccd&quot;</span>, <span class="number">2300</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(goodses, <span class="keyword">new</span> Comparator&lt;Goods&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Goods o1, Goods o2)</span> </span>&#123;<span class="comment">//可以使用内置函数，也可自己写逻辑</span></span><br><span class="line">                <span class="keyword">int</span> result = o1.getName().compareTo(o2.getName());</span><br><span class="line">                <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;<span class="comment">//二级排序进入条件</span></span><br><span class="line">                    <span class="comment">//内部可利用已经写好的自然排序的功能规则，一般是这样使用</span></span><br><span class="line">                    <span class="keyword">return</span> -o1.compareTo(o2);<span class="comment">//取反,从大到小</span></span><br><span class="line">                    <span class="comment">//也可以选择废弃自然排序规则，重新编写全新排序逻辑</span></span><br><span class="line">                    <span class="comment">//return -Double.compare(o1.getPrice(),o2.getPrice());//取反,从大到小</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(goodses));</span><br><span class="line">        <span class="comment">//[Goods&#123;name=&#x27;aaq&#x27;, price=1000.0&#125;,</span></span><br><span class="line">        <span class="comment">// Goods&#123;name=&#x27;aaq&#x27;, price=900.0&#125;,</span></span><br><span class="line">        <span class="comment">// Goods&#123;name=&#x27;bbc&#x27;, price=1000.0&#125;,</span></span><br><span class="line">        <span class="comment">// Goods&#123;name=&#x27;ccd&#x27;, price=2300.0&#125;,</span></span><br><span class="line">        <span class="comment">// Goods&#123;name=&#x27;ttt&#x27;, price=55.0&#125;]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自然与定制排序">自然与定制排序</h2>
<h3 id="自然排序概念">自然排序概念</h3>
<ul>
<li><strong>自然排序</strong>可以理解为一种数据类型<strong>默认的、内置的、于其绑定的、天生的</strong>一个<strong>排序规则</strong>。</li>
<li>是有该数据类型该类本身去实现的一种比较规则，也可以说<strong>属于该数据类型的属性之一</strong></li>
<li>如数值型的自然排序就是：按数字大小本身排序</li>
<li><strong>其他类型的自然排序</strong>就是：该数据类型实现Comparable接口的compareTo()方法排序</li>
</ul>
<hr>
<h3 id="两者对比">两者对比</h3>
<p>定指排序<strong>不是</strong>该数据类型的一个<strong>默认的排序规则</strong>，而是<strong>经过定制化的比较器排序后</strong>得出的一种<strong>任意可能性的序列</strong>。</p>
<h4 id="从翻译角度">从翻译角度</h4>
<ul>
<li><strong>Comparable</strong>译为“<strong>可比较</strong>”，顾名思义，是一种内置化的比较，即自然排序</li>
<li><strong>Comparator</strong>译为“<strong>比较器</strong>”，顾名思义，是一种外置的比较器。</li>
</ul>
<h4 id="接口方法定义角度">接口方法定义角度</h4>
<ul>
<li>
<p>Comparable抽像方法：<code>public int compareTo(Object obj)</code>，this(本身) 与 obj之间的比较</p>
</li>
<li>
<p>Comparator抽像方法：<code>public int compare(Object obj1,Object obj2)</code>是独立的两个比较</p>
</li>
</ul>
<h2 id="使用逻辑">使用逻辑</h2>
<ul>
<li>
<p><strong>自然排序的接口设计</strong>是一种<strong>高可用，高解耦的程序设计方式</strong>，能最大程度地减低对象之间的耦合程度。</p>
<blockquote>
<p>《Head First面向对象分析与设计》有感</p>
</blockquote>
</li>
<li>
<p>因此<strong>尽可能地使所有排序业务都可以基于自然排序实现，是自然排序规则设计的最高境界</strong>。</p>
</li>
<li>
<p><strong>在此基础上，不能仅由自然排序完成的排序业务再由定制排序一一定制化实现</strong>。</p>
</li>
</ul>
<h1 id="System-2">System</h1>
<ul>
<li>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。 该类位于java.lang包。</li>
<li>由于该类的<strong>构造器是private</strong>的，所以无法创建该类的对象，即一般用于调用其静态方法</li>
<li>其内部的<strong>成员变量</strong>和<strong>成员方法</strong>都是<strong>static</strong>的，所以也可以很方便 的进行调用。</li>
</ul>
<h2 id="属性">属性</h2>
<p>System的成员属性只有三个，<strong>都是流对象</strong></p>
<table>
<thead>
<tr>
<th>静态属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>static PrintStream <strong>out</strong></td>
<td>&quot;标准&quot;输出流</td>
</tr>
<tr>
<td>static InputStream <strong>in</strong></td>
<td>&quot;标准&quot;输入流</td>
</tr>
<tr>
<td>static PrintStream <strong>err</strong></td>
<td>&quot;标准&quot;错误输出流</td>
</tr>
</tbody>
</table>
<h2 id="方法-3">方法</h2>
<p>基本都是静态方法，当工具类使用</p>
<table>
<thead>
<tr>
<th>静态方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>native long <strong>currentTimeMillis</strong>()</td>
<td>返回当前时间戳，单位ms</td>
</tr>
<tr>
<td>void <strong>exit</strong>(int status)</td>
<td>该方法的作用是<strong>退出程序</strong>。其中status的值意义：<br/>0：代表正常退出，<br/>非0：代表异常退出。<br/>使用该方法可以在图形界面编程中实现程序的退出功能等</td>
</tr>
<tr>
<td>void <strong>gc</strong>()</td>
<td>该方法的作用是<strong>请求系统进行垃圾回收</strong>。<br/>至于系统是否立刻回收，则取决于系统中<br/>垃圾回收算法的实现以及系统执行时的情况。</td>
</tr>
<tr>
<td>String <strong>getProperty</strong>(String key)</td>
<td>通过属性名key获取系统常见的基本信息<br/>&quot;<strong>java.version</strong>&quot; ： Java运行时环境版本<br/>&quot;<strong>java.home</strong>&quot; ：Java安装目录<br/>&quot;<strong><a class="link"   target="_blank" rel="noopener" href="http://os.name" >os.name<i class="fas fa-external-link-alt"></i></a></strong>&quot; ：操作系统的名称<br/>&quot;<strong>os.version</strong>&quot;：操作系统的版本<br/>&quot;<strong><a class="link"   target="_blank" rel="noopener" href="http://user.name" >user.name<i class="fas fa-external-link-alt"></i></a></strong>&quot;：用户的主目录<br/>&quot;<strong>user.dir</strong>&quot;：用户的当前工作目录<br/>…</td>
</tr>
</tbody>
</table>
<h3 id="示例代码-3">示例代码</h3>
<h4 id="getProperty">getProperty</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String property = System.getProperty(<span class="string">&quot;java.version&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;property = &quot;</span> + property);<span class="comment">//1.8.0_144</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Math">Math</h1>
<p>java.lang.Math提供了一系列<strong>静态方法</strong>用于数学科学计算。其方法的<strong>参数和返回值</strong>类型一般为<strong>double</strong>型</p>
<p>//待补充</p>
<h2 id="属性-2">属性</h2>
<ul>
<li>Math.PI：返回圆周率</li>
</ul>
<h2 id="方法-4">方法</h2>
<ul>
<li>abs 绝对值</li>
<li>acos,asin,atan,cos,sin,tan 三角函数</li>
<li>sqrt 平方根</li>
<li>pow(double a,doble b) a的b次幂</li>
<li>log 自然对数</li>
<li>exp e为底指数</li>
<li>max(double a,double b)</li>
<li>min(double a,double b)</li>
<li><strong>random</strong>() ：返回0.0到1.0的随机数，[0.0,1.0)</li>
<li>long <strong>round</strong>(double a) double型数据a转换为long型（四舍五入）</li>
<li>toDegrees(double angrad) 弧度—&gt;角度</li>
<li>toRadians(double angdeg) 角度—&gt;弧度</li>
<li>…</li>
</ul>
<h1 id="BigInteger">BigInteger</h1>
<ul>
<li>Integer类作为int的包装类，能存储的最大整型值为2^31-1</li>
<li>Long类也是有限的， 最大为2^63-1。，</li>
<li>如果要表示再大的整数，java.math包的BigInteger可以<strong>表示不可变的任意精度的整数</strong></li>
<li><strong>“不可变”含义</strong>：即BigInteger的运算不能使用普通的±*/等运算符直接修改，而是只能通过调用BigInteger提供的数据计算方法进行操作，操作完之后也是一个新的BigInteger对象</li>
<li><strong>“任意精度”含义</strong>：理论上BigInteger表示的<strong>数无上限，想多少位就多少位</strong></li>
</ul>
<h2 id="构造器-2">构造器</h2>
<ul>
<li><strong>BigInteger(String val)</strong>：根据字符串构建BigInteger对象</li>
</ul>
<h2 id="方法-5">方法</h2>
<p>BigInteger 提供 所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。 另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、 位操作以及一些其他操作。</p>
<ul>
<li>public BigInteger <strong>abs</strong>()：返回此 BigInteger 的绝对值的 BigInteger。</li>
<li>BigInteger <strong>add</strong>(BigInteger val) ：返回其值为 (this + val) 的 BigInteger</li>
<li>BigInteger <strong>subtract</strong>(BigInteger val) ：返回其值为 (this - val) 的 BigInteger</li>
<li>BigInteger <strong>multiply</strong>(BigInteger val) ：返回其值为 (this * val) 的 BigInteger</li>
<li>BigInteger <strong>divide</strong>(BigInteger val) ：返回其值为 (this / val) 的 BigInteger。整数 相除只保留整数部分</li>
<li>BigInteger <strong>remainder</strong>(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。</li>
<li>BigInteger[] <strong>divideAndRemainder</strong>(BigInteger val)：返回包含 (this / val) 后跟 (this % val) 的两个 BigInteger 的数组。</li>
<li>BigInteger <strong>pow</strong>(int exponent) ：返回其值为 (thisexponent) 的 BigInteger。</li>
<li>…</li>
</ul>
<h1 id="BigDecimal">BigDecimal</h1>
<ul>
<li>一般的Float类和Double类可以用来做科学计算或工程计算，</li>
<li>但在<strong>商业计算中</strong>， 要求数字精度比较高，故用到java.math.BigDecimal类。</li>
<li>BigDecimal类支持<strong>不可变的</strong>、<strong>任意精度</strong>的有符号十进制定点数。
<ul>
<li>概念类似BigInteger</li>
</ul>
</li>
</ul>
<h2 id="构造器-3">构造器</h2>
<ul>
<li>public <strong>BigDecimal</strong>(<strong>double</strong> val)</li>
<li>public <strong>BigDecimal</strong>(<strong>String</strong> val)</li>
</ul>
<h2 id="方法-6">方法</h2>
<ul>
<li>public BigDecimal <strong>add</strong>(BigDecimal augend)</li>
<li>public BigDecimal <strong>subtract</strong>(BigDecimal subtrahend)</li>
<li>public BigDecimal <strong>multiply</strong>(BigDecimal multiplicand)</li>
<li>public BigDecimal <strong>divide</strong>(BigDecimal divisor, int scale, int roundingMode)</li>
</ul>
<h2 id="示例代码-4">示例代码</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBigInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="string">&quot;12433241123&quot;</span>);</span><br><span class="line">    BigDecimal bd = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;12435.351&quot;</span>);</span><br><span class="line">    BigDecimal bd2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">    System.out.println(bi);</span><br><span class="line">    <span class="comment">// System.out.println(bd.divide(bd2));//报错因为结果除不尽，但又为指明余数操作</span></span><br><span class="line">    System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP));<span class="comment">//除法，且四舍五入</span></span><br><span class="line">    System.out.println(bd.divide(bd2, <span class="number">15</span>, BigDecimal.ROUND_HALF_UP));<span class="comment">//除法，且保留15位小数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Arrays">Arrays</h1>
<p>//待补充</p>
<ul>
<li>
<p>操作数组的工具类：有封装好的快排，二分排等操作(可查看源码学习)</p>
<table>
<thead>
<tr>
<th>method</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>static &lt;T&gt; List&lt;T&gt; <strong>asList</strong>(T…a)</td>
<td>返回可变参数列表的List集合对象</td>
</tr>
<tr>
<td>static&lt;T&gt; T[]<strong>copyOf</strong>(T[] original,  int newLength)</td>
<td>将original数组复制到指定长度的新数组中<br/>并返回新数组的引用</td>
</tr>
<tr>
<td>boolean <strong>equals</strong>(int[] a,int[] b)</td>
<td>判断两个数组是否相等。</td>
</tr>
<tr>
<td>String <strong>toString</strong>(int[] a)</td>
<td>打印数组信息</td>
</tr>
<tr>
<td>void <strong>fill</strong>(int[] a,int val)</td>
<td>将指定值均填充到数组之中</td>
</tr>
<tr>
<td>void <strong>sort</strong>(int[] a)</td>
<td>还有很对重载方法，对数组进行排序</td>
</tr>
<tr>
<td>int <strong>binarySearch</strong>(int[] a,int key)</td>
<td>对排序后的数组进行二分法检索指定的值</td>
</tr>
<tr>
<td>…详细查看API</td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h1 id="Scanner">Scanner</h1>
<p>//待补充</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br></pre></td></tr></table></figure>
<h1 id="JUnitTest">JUnitTest</h1>
<ul>
<li>
<p><strong>JUnitTest单元测试类</strong>：</p>
</li>
<li>
<p><strong>快捷步骤</strong>：</p>
<ol>
<li>直接在想要测试的方法上添加<code>@Test</code>注解，通过eclipse提示导入相关内容</li>
</ol>
</li>
<li>
<p><strong>详细步骤与细节</strong></p>
<ol>
<li>中当前工程 - 右键择：build path - add libraries - JUnit 4 - 下一步</li>
<li>单元测试类要求：public、供公共的无参的构造器</li>
<li>单元测试方法的要求：public、无返回值，无形参</li>
<li>单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test;</li>
<li>左键双击单元测试方法名，右键：run as - JUnit Test</li>
</ol>
<hr>
<ul>
<li>执行结果没任何异常：绿条</li>
<li>执行结果出现异常：红条</li>
</ul>
</li>
</ul>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：Java常用类</li>
        <li>Post author：yhd</li>
        <li>Create time：2021-06-09 20:20:23</li>
        <li>
            Post link：https://keep.xpoet.cn/2021/06/09/Java常用类/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/06/10/Java%E6%9E%9A%E4%B8%BE,%E6%B3%A8%E8%A7%A3%E5%8F%8A%E6%B3%9B%E5%9E%8B/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Java枚举,注解及泛型</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/06/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">多线程编程基础</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">yhd</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.1</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#String"><span class="nav-number">1.</span> <span class="nav-text">String</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text">不可变特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8Cfinal%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.1.</span> <span class="nav-text">双final特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="nav-number">1.1.2.</span> <span class="nav-text">特性的体现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%BD%93%E7%8E%B0"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">错误体现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E4%BD%93%E7%8E%B0"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">正确体现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86"><span class="nav-number">1.2.</span> <span class="nav-text">存储原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">1.2.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.2.</span> <span class="nav-text">存储机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">核心机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="nav-number">1.2.2.1.1.</span> <span class="nav-text">测试代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">字面量机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81-2"><span class="nav-number">1.2.2.2.1.</span> <span class="nav-text">测试代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new-%E6%9E%84%E9%80%A0%E5%99%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">new+构造器机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81-3"><span class="nav-number">1.2.2.3.1.</span> <span class="nav-text">测试代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E8%B5%8B%E5%80%BC%E5%8E%9F%E7%90%86"><span class="nav-number">1.2.2.3.2.</span> <span class="nav-text">源码赋值原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E9%9D%99%E6%80%81%E7%B1%BB%E5%B1%9E%E6%80%A7%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">非静态类属性机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81-4"><span class="nav-number">1.2.2.4.1.</span> <span class="nav-text">测试代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">字符串操作机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="nav-number">1.2.2.5.1.</span> <span class="nav-text">字符串拼接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#String%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="nav-number">1.2.2.5.2.</span> <span class="nav-text">String方法调用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AA%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">未解决问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93"><span class="nav-number">1.2.3.</span> <span class="nav-text">核心总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%89%E5%8F%8AJVM%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86"><span class="nav-number">1.3.</span> <span class="nav-text">涉及JVM结构部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%A2%91API"><span class="nav-number">1.4.</span> <span class="nav-text">高频API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#API%E7%AE%97%E6%B3%95%E5%88%A9%E7%94%A8"><span class="nav-number">1.4.1.</span> <span class="nav-text">API算法利用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%AD%90%E4%B8%B2%E5%9C%A8%E4%B8%BB%E4%B8%B2%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">返回子串在主串出现次数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.5.</span> <span class="nav-text">String类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B9%8B%E9%97%B4"><span class="nav-number">1.5.1.</span> <span class="nav-text">包装类之间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#char%E6%95%B0%E7%BB%84%E4%B9%8B%E9%97%B4"><span class="nav-number">1.5.2.</span> <span class="nav-text">char数组之间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#byte%E6%95%B0%E7%BB%84%E4%B9%8B%E9%97%B4"><span class="nav-number">1.5.3.</span> <span class="nav-text">byte数组之间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%AD%97%E7%AC%A6%E5%BA%8F%E5%88%97%E4%B9%8B%E9%97%B4"><span class="nav-number">1.5.4.</span> <span class="nav-text">可变字符序列之间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%AD%97%E7%AC%A6%E5%BA%8F%E5%88%97"><span class="nav-number">2.</span> <span class="nav-text">可变字符序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="nav-number">2.1.</span> <span class="nav-text">基本特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E6%80%A7%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.</span> <span class="nav-text">可变性原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8"><span class="nav-number">2.2.1.</span> <span class="nav-text">底层存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E6%89%A9%E5%AE%B9"><span class="nav-number">2.2.2.</span> <span class="nav-text">自动扩容</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">初始容量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">扩容机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0"><span class="nav-number">2.2.2.2.1.</span> <span class="nav-text">简述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">2.2.2.2.2.</span> <span class="nav-text">源码分析</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%88%B6%E7%B1%BB%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.3.</span> <span class="nav-text">父类实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E5%AF%BC%E6%84%8F%E4%B9%89"><span class="nav-number">2.4.</span> <span class="nav-text">指导意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8API"><span class="nav-number">2.5.</span> <span class="nav-text">常用API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E6%96%B9%E6%B3%95%E9%93%BE%E6%96%B9%E6%B3%95"><span class="nav-number">2.5.1.</span> <span class="nav-text">支持方法链方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="nav-number">3.</span> <span class="nav-text">日期时间</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK8%E5%89%8DAPI"><span class="nav-number">3.1.</span> <span class="nav-text">JDK8前API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#System"><span class="nav-number">3.1.1.</span> <span class="nav-text">System</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Date"><span class="nav-number">3.1.2.</span> <span class="nav-text">Date</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java-util-Date"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">java.util.Date</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">3.1.2.1.1.</span> <span class="nav-text">构造器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.2.1.2.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java-sql-Date"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">java.sql.Date</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">3.1.2.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SimpleDateFormat"><span class="nav-number">3.1.3.</span> <span class="nav-text">SimpleDateFormat</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">格式化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#pattern"><span class="nav-number">3.1.3.1.1.</span> <span class="nav-text">pattern</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Calendar"><span class="nav-number">3.1.4.</span> <span class="nav-text">Calendar</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8API-2"><span class="nav-number">3.1.4.2.</span> <span class="nav-text">常用API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#get-set"><span class="nav-number">3.1.4.2.1.</span> <span class="nav-text">get&amp;set</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#add"><span class="nav-number">3.1.4.2.2.</span> <span class="nav-text">add</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getTime"><span class="nav-number">3.1.4.3.</span> <span class="nav-text">getTime</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setTime"><span class="nav-number">3.1.4.4.</span> <span class="nav-text">setTime</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8"><span class="nav-number">3.1.5.</span> <span class="nav-text">综合应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%A5%E6%9C%9F%E8%BD%ACsql-Date"><span class="nav-number">3.1.5.1.</span> <span class="nav-text">字符串日期转sql.Date</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E5%A4%A9%E6%95%B0%E8%AE%A1%E7%AE%97"><span class="nav-number">3.1.5.2.</span> <span class="nav-text">总天数计算</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK8%E5%90%8EAPI"><span class="nav-number">3.2.</span> <span class="nav-text">JDK8后API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E6%99%AF-2"><span class="nav-number">3.2.1.</span> <span class="nav-text">背景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A7API%E7%BC%BA%E9%99%B7"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">旧API缺陷</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0API"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">新API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="nav-number">3.2.2.</span> <span class="nav-text">本地日期时间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-2"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-2"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#getXxx"><span class="nav-number">3.2.2.2.1.</span> <span class="nav-text">getXxx()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#withXxx"><span class="nav-number">3.2.2.2.2.</span> <span class="nav-text">withXxx()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#plusXxx"><span class="nav-number">3.2.2.2.3.</span> <span class="nav-text">plusXxx()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#minusXxx"><span class="nav-number">3.2.2.2.4.</span> <span class="nav-text">minusXxx()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Instant"><span class="nav-number">3.2.3.</span> <span class="nav-text">Instant</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-3"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DateTimeFormat"><span class="nav-number">3.2.4.</span> <span class="nav-text">DateTimeFormat</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-%E6%A0%BC%E5%BC%8F%E8%AE%BE%E7%BD%AE"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">实例化&#x2F;格式设置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F"><span class="nav-number">3.2.4.1.1.</span> <span class="nav-text">预定义标准格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%8C%96%E7%9B%B8%E5%85%B3%E6%A0%BC%E5%BC%8F"><span class="nav-number">3.2.4.1.2.</span> <span class="nav-text">本地化相关格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F"><span class="nav-number">3.2.4.1.3.</span> <span class="nav-text">自定义格式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96-2"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">格式化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-2"><span class="nav-number">3.2.4.3.</span> <span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Date%E9%97%B4%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.2.5.</span> <span class="nav-text">Date间转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96API"><span class="nav-number">3.2.6.</span> <span class="nav-text">其他API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="nav-number">3.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E6%AF%94%E8%BE%83%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">Java比较器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">4.1.</span> <span class="nav-text">基础概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Comparable"><span class="nav-number">4.2.</span> <span class="nav-text">Comparable</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">4.2.1.</span> <span class="nav-text">实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E7%A4%BA%E4%BE%8B"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">String示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%B2%E5%AE%9E%E7%8E%B0%E6%AF%94%E8%BE%83%E7%B1%BB"><span class="nav-number">4.2.2.</span> <span class="nav-text">已实现比较类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E6%8E%92%E5%BA%8F"><span class="nav-number">4.2.3.</span> <span class="nav-text">自定义类排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="nav-number">4.2.3.1.</span> <span class="nav-text">实现步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">4.2.3.2.</span> <span class="nav-text">示例代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Comparator"><span class="nav-number">4.3.</span> <span class="nav-text">Comparator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.3.1.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">4.3.2.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%99%A8"><span class="nav-number">4.3.3.</span> <span class="nav-text">自定义比较器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-2"><span class="nav-number">4.3.3.1.</span> <span class="nav-text">示例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6%E5%8C%96String%E6%8E%92%E5%BA%8F"><span class="nav-number">4.3.3.1.1.</span> <span class="nav-text">定制化String排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="nav-number">4.3.3.1.2.</span> <span class="nav-text">自定义类</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E7%84%B6%E4%B8%8E%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">4.4.</span> <span class="nav-text">自然与定制排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F%E6%A6%82%E5%BF%B5"><span class="nav-number">4.4.1.</span> <span class="nav-text">自然排序概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E8%80%85%E5%AF%B9%E6%AF%94"><span class="nav-number">4.4.2.</span> <span class="nav-text">两者对比</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E7%BF%BB%E8%AF%91%E8%A7%92%E5%BA%A6"><span class="nav-number">4.4.2.1.</span> <span class="nav-text">从翻译角度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E8%A7%92%E5%BA%A6"><span class="nav-number">4.4.2.2.</span> <span class="nav-text">接口方法定义角度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%80%BB%E8%BE%91"><span class="nav-number">4.5.</span> <span class="nav-text">使用逻辑</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#System-2"><span class="nav-number">5.</span> <span class="nav-text">System</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7"><span class="nav-number">5.1.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-3"><span class="nav-number">5.2.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-3"><span class="nav-number">5.2.1.</span> <span class="nav-text">示例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#getProperty"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">getProperty</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Math"><span class="nav-number">6.</span> <span class="nav-text">Math</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7-2"><span class="nav-number">6.1.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-4"><span class="nav-number">6.2.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BigInteger"><span class="nav-number">7.</span> <span class="nav-text">BigInteger</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-2"><span class="nav-number">7.1.</span> <span class="nav-text">构造器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-5"><span class="nav-number">7.2.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BigDecimal"><span class="nav-number">8.</span> <span class="nav-text">BigDecimal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-3"><span class="nav-number">8.1.</span> <span class="nav-text">构造器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-6"><span class="nav-number">8.2.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-4"><span class="nav-number">8.3.</span> <span class="nav-text">示例代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Arrays"><span class="nav-number">9.</span> <span class="nav-text">Arrays</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Scanner"><span class="nav-number">10.</span> <span class="nav-text">Scanner</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JUnitTest"><span class="nav-number">11.</span> <span class="nav-text">JUnitTest</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>



<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
