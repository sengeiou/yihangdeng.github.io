<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="yhd">
    
    <title>
        
            JavaSE基础 |
        
        DyhBlog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/MyLogo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"yoursite.com","root":"/","language":"en","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.jpg","favicon":"/images/MyLogo.svg","article_img_align":"left","left_side_width":"230px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.jpeg"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.1"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.1.1"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                DyhBlog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">JavaSE基础</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">yhd</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-03-04 11:40:32
    </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/JavaSE/">JavaSE</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>27.9k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>108 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="语言概述"><a href="#语言概述" class="headerlink" title="语言概述"></a>语言概述</h1><h2 id="语言历史"><a href="#语言历史" class="headerlink" title="语言历史"></a>语言历史</h2><p>​    创始人：java之父<strong>James Gosling</strong></p>
<ul>
<li><p><strong>SUN</strong>(Stanford University Network，斯坦福大学网络公司 )<strong>1995</strong>推出</p>
</li>
<li><p><strong>1991</strong>年 Green项目，开发语言<strong>最初版本</strong>命名为<strong>Oak (橡树)</strong></p>
<p>…</p>
</li>
<li><p><strong>2004年，发布里程碑式版本：JDK 1.5，</strong>为突出此版本的重要性，**<em>更名为JDK 5.0**</em></p>
</li>
<li><p>2005年，改名J2SE -&gt; <strong>JavaSE(桌面级)**，J2EE -&gt; **JavaEE(企业WEB)**，J2ME -&gt; **JavaME</strong></p>
</li>
<li><p>2009年，<strong>Oracle公司收购</strong>SUN，交易价格74亿美元</p>
<p>…                              </p>
</li>
<li><p><strong>2014</strong>年，**<em>发布JDK 8.0**</em>，<strong>是继JDK 5.0以来</strong>变化最大的版本**</p>
<p>…</p>
</li>
<li><p>2018年3月，发布JDK <strong>10.0</strong>，版本号也称为<strong>18.3</strong>(<strong>改为时间命名</strong>)号称<strong>每月一更</strong></p>
</li>
<li><p>2018年9月，发布JDK 11.0，版本号也称为18.9</p>
</li>
</ul>
<h2 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h2><ol>
<li>java是一种<strong>半编译半解释型</strong>语言</li>
<li><strong>面向对象</strong>：类、对象、<strong>封装、继承、多态</strong></li>
<li><strong>健壮性</strong>：<strong>垃圾回收机制</strong>(<strong>GC</strong>机制)，<em>但仍存在内存泄漏与溢出</em>。c通过malloc与free手动管理)</li>
<li><strong>跨平台性</strong>：<strong>java虚拟</strong>(<strong>JVM</strong>)，write once,run anywhere 一次编译，到处运行</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7.png"
                     
                ></p>
<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><h2 id="JDK-amp-JRM-amp-JVM"><a href="#JDK-amp-JRM-amp-JVM" class="headerlink" title="JDK&amp;JRM&amp;JVM"></a>JDK&amp;JRM&amp;JVM</h2><ul>
<li><p><strong>JDK</strong> ：<strong>Java开发工具包</strong> (Java Development Kit), 用与<strong>开发及运行</strong></p>
<ul>
<li><strong>JDK = JRE+开发工具集</strong></li>
</ul>
</li>
<li><p><strong>Java开发工具</strong>：<strong>javac.exe</strong> (编译工具) ，<strong>jar</strong>.<strong>exe</strong>(打包工具)等</p>
</li>
<li><p><strong>JRE</strong>：<strong>Java运行环境</strong>(Java Runtime Environment)，仅用于<strong>运行</strong>java项目</p>
<ul>
<li><strong>JRE = JVM+Java SE标准类库</strong></li>
</ul>
</li>
<li><p><strong>JVM：Java虚拟机</strong>(JVM Java Virtual Machine)和Java程序所需的<strong>核心类库</strong>等</p>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE回炉-JDK-JRE-JVM.png"
                      style="zoom: 80%;" /
                >

<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="下载安装JDK"><a href="#下载安装JDK" class="headerlink" title="下载安装JDK"></a>下载安装JDK</h3><p>官网，一键式傻瓜安装。可自定义安装路径，但注意安装软件的路径中不能包含中文、空格。(建议安装文件夹保留JDK版本号)</p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p><strong>配置path环境变量</strong>：</p>
<ol>
<li><p>进入<strong>系统变量设置</strong>：(win10)计算机，右键属性，高级系统变量，环境变量</p>
</li>
<li><p>把安装<strong>JDK</strong>的<strong>bin目录路径</strong>添加到环境变量<strong>path</strong>中(若不存在path则新建)</p>
<ul>
<li><p><strong>方式1</strong>：直接把JDK下的<strong>bin目录</strong>路径添加到<strong>path变量</strong>中即可</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210325104845.png"
                     
                ></p>
</li>
<li><p><strong>方式2</strong>(<strong>推荐</strong>)：</p>
<ol>
<li><p>在<strong>系统变量</strong>中<strong>新建</strong>名为<strong>JAVA_HOME</strong>，值为<strong>JDK目录</strong>路径的环境变量</p>
</li>
<li><p>在path中<strong>通过引用</strong>的方式添加，即在path中添加 <strong>%JAVA_HOME%\bin;</strong>  (注意win10末尾无需分号)</p>
<ul>
<li>新建JAVA_HOME变量如下图</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210325105539.png"
                     
                ></p>
<ul>
<li>在Path环境变量中引用JAVA_HOME在bin目录下配置如下图</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210325103947.png"
                     
                ></p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>Tips：推荐使用方式2，后续tomcat运行环境需识别JAVA_HOME</p>
</blockquote>
<h3 id="验证配置"><a href="#验证配置" class="headerlink" title="验证配置"></a>验证配置</h3><p><strong>注意，要重新打开一个新的cmd窗口</strong>输入<code>javac</code>命令显示如下内容信息则安装成功，java -version只能检查是否安装了jdk，不能检查有关环境变量的配置。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-JDK%E5%AE%89%E8%A3%852.png"
                     
                ></p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul>
<li><p>重写打开一个新的cmd窗口测试javac</p>
</li>
<li><p>尝试把java的环境变量的位置以至最前面(防止部分功能失效)</p>
</li>
<li><p><strong>win10环境</strong>下配置环境变量，<strong>无需添加</strong>末尾的分号’;’</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210325104539.png"
                     
                ></p>
</li>
</ul>
<h2 id="JDK内容概要"><a href="#JDK内容概要" class="headerlink" title="JDK内容概要"></a>JDK内容概要</h2><p>默认安装路径：C:\Program Files\Java\jdk1.8.0_144</p>
<ul>
<li><strong>bin</strong>  – 开发工具（常用，javac.c 编译，java.exe 解析运行，javadoc.exe，生成文档）</li>
<li><strong>db</strong>  – java 实现的数据库</li>
<li><strong>include</strong> – 含c语言编写的头文件</li>
<li><strong>jre</strong> – java运行时环境</li>
<li><strong>lib</strong> – 存放jar包</li>
<li><strong>src.zip</strong> – 存放java开源代码，一些常用的类库(IDE中查看源码可引用它)</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-java8-JDK%E5%9B%BE.png"
                     
                ></p>
<ul>
<li><strong>JDK主要的包</strong>(packed)介绍<ul>
<li><strong>java.lang</strong>(language)：包含一些Java语言的<strong>核心类</strong>，如String、Math、Integer、 System和 Thread，提供常用功能</li>
<li><strong>java.net</strong>：包含执行与<strong>网络相关</strong>的操作的类和接口</li>
<li><strong>java.io</strong>：包含能提供多种<strong>输入/输出</strong>功能的类</li>
<li>j<strong>ava.util</strong>：包含一些实用<strong>工具类</strong>，如定义<strong>系统特性</strong>、接口的<strong>集合</strong>框架类、使用与<strong>日期日历</strong>相关的函数</li>
<li><strong>java.text</strong>：包含了一些java<strong>格式化</strong>相关的类</li>
<li><strong>java.sql</strong>：包含了java进行<strong>JDBC数据库编程</strong>的相关类/接口</li>
<li>j<strong>ava.awt</strong>：包含了构成<strong>抽象窗口</strong>工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 B/S C/S</li>
</ul>
</li>
</ul>
<h2 id="环境变量详解"><a href="#环境变量详解" class="headerlink" title="环境变量详解"></a>环境变量详解</h2><ol>
<li><p><strong>path环境变量</strong>：<strong>windows</strong>系统在cmd内执行命令时要<strong>搜寻的路径</strong>。配置path环境变量可实现在<strong>任何目录下</strong>都可以执行配置在path内容里的程序的效果。</p>
<ul>
<li><strong>环境变量类型</strong>：<strong>用户变量</strong>针对当前用户有效。<strong>系统变量</strong>，针对所有用户有效</li>
<li><strong>cmd命令的搜索逻辑</strong>：从当前目录—&gt;path路径(<strong>从前往后</strong>)</li>
<li><strong>环境变量值格式</strong>：由<strong>绝对路径</strong>组成。多个值用<strong>分号“;”</strong> (win7)隔开或(win10) 通过” 新建”的方式直接添加。</li>
<li><strong>%**JAVA_HOME</strong>%<strong>\bin;中</strong>“%%”<strong>表示</strong>获取<strong>这个</strong>环境变量的值**</li>
</ul>
</li>
<li><p>一台电脑允许同时安装多个版本JDK，实际使用哪个，却决与环境变量的指定</p>
</li>
<li><p>官方JDK安装过程会弹出两个安装框，一个是JDK安装，一个是独立的JRE安装，其实理论上安装JDK已经包含JRE，这个多出来的独立安装的JRE为了方便eclipse识别而安装，建议安装。</p>
</li>
</ol>
<h1 id="Java程序运行逻辑"><a href="#Java程序运行逻辑" class="headerlink" title="Java程序运行逻辑"></a>Java程序运行逻辑</h1><h2 id="执行逻辑"><a href="#执行逻辑" class="headerlink" title="执行逻辑"></a>执行逻辑</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-java%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.png"
                     
                ></p>
<h2 id="编译及运行命令"><a href="#编译及运行命令" class="headerlink" title="编译及运行命令"></a>编译及运行命令</h2><ul>
<li><p><strong>编译.java文件</strong>：<code>javac XXX.java</code>    (需含.java后缀)</p>
<blockquote>
<p>同目录下会编译出.class字节码文件，该<strong>字节码文件名</strong>由代码中<strong>class类名</strong>决定的</p>
</blockquote>
</li>
<li><p><strong>运行.class文件</strong>：<code>java .class文件名</code> (无需.class后缀)</p>
</li>
</ul>
<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><ol>
<li><p>新建一个<strong>HelloWorld.java</strong>结尾的文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloChina</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello,world!&quot;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译及运行</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-%E7%BC%96%E8%AF%91%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95.png"
                     
                ></p>
<ol start="3">
<li><strong>补充说明</strong><ol>
<li>javac命令<strong>因在</strong>Windows<strong>平台下执行，因此</strong>不区分<strong>大小写</strong></li>
<li>java命令<strong>是涉及java中的的执行，java是</strong>严格区分<strong>大小写的</strong></li>
<li>任何书写语法都没错，但还是报出“<strong>错误：找不到或无法加载主类</strong>”，有可能电脑配置了classpath的环境变量，classpath的配置表示使所有**.class文件**的执行都往该路径去寻找，导致在classpath路径下找不到对于执行的.class文件，因此提示错误。只需要删除classpath环境变量即可</li>
</ol>
</li>
</ol>
<h2 id="public-class"><a href="#public-class" class="headerlink" title="public class"></a>public class</h2><ol>
<li>在一个java源文件中可以声明多个类，但一个源文件中<strong>只能有一个</strong>类能<strong>声明public</strong>，</li>
<li>而且声明public的类的<strong>类名</strong>必须与源文件<strong>文件名相同</strong>，才不会出现编译错误</li>
<li>存在多个class的源文件编译会生成对应的多个字节码文件，<strong>java.exe只需执行</strong>含<strong>main方法</strong>的类即可</li>
</ol>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>​    java包含三种注释：单行注释、多行注释、<strong>文档注释</strong>(java特有)</p>
<h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p><strong>文档注释</strong>：通过指定的注释格式，使注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。可以进入生成的文件夹，打开index.html即可。</p>
<ol>
<li><p><strong>注释格式</strong>：javadoc 工具默认只处理以 <strong>public 或 protected</strong> 修饰的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> 指定java程序的作者</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 指定源文件的版本</span></span><br><span class="line"><span class="comment">文本内容，在类头部形成对class的文档注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXX</span></span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	在方法头部形成对方法的一个文档注释</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>javadoc命令使用</strong>：<code>javadoc –d filename –author –version javaFile.java</code></p>
<p>bug：</p>
<p>错误提示：javadoc 编码GBK的不可映射字符</p>
<p>原因：由于jdk是国际版的, 在编译时, 如果没有使用-encoding参数指定java源程序的编码格式, javac.exe则会获取操作系统默认的编码格式.</p>
<p>解决方案：</p>
<p>方案1：追加指定编码命令：<code>javadoc -d filename -author -version -encoding utf-8 HelloWorld.java</code></p>
</li>
</ol>
<h2 id="关键字、保留字、标识符"><a href="#关键字、保留字、标识符" class="headerlink" title="关键字、保留字、标识符"></a>关键字、保留字、标识符</h2><ul>
<li><p><strong>关键字</strong>：被Java语言赋予了特殊含义，用做<strong>专门用途</strong>的字符串。如**int、for、class…**（小写单词）</p>
</li>
<li><p><strong>保留字</strong>：现Java版本<strong>尚未使用</strong>，但以后版本<strong>可能会作为关键字</strong>使用。如：<strong>goto 、const</strong></p>
</li>
<li><p><strong>标识符(Unicode编码)**：凡是自己可以起名字的地方都叫标识符 (为了提高阅读性，要尽量意义，“</strong>见名知意**”)</p>
<p><strong>规则</strong>：</p>
<ul>
<li>由26个<strong>英文</strong>字母大小写，<strong>0-9</strong>，**_或$**组成</li>
<li><strong>数字不可以开头</strong>，不可以使用关键字和保留字，但能包含关键字和保留字</li>
<li>Java中<strong>严格区分大小写</strong>，长度无限制。</li>
<li>标识符<strong>不能包含空格</strong>。</li>
</ul>
</li>
</ul>
<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><ul>
<li><strong>包名</strong>：多单词组成，所有字母<strong>小写</strong>，xxxyyyzzz</li>
<li><strong>类名、接口名</strong>：多单词组成时，所有单词的<strong>首字母大写</strong>，XxxYyyZzz(大驼峰)</li>
<li><strong>变量名、方法名</strong>：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写，xxxYyyZzz(小驼峰)</li>
<li><strong>常量名</strong>：所有<strong>字母都大写</strong>。多单词时每个单词用<strong>下划线连接</strong>，XXX_YYY_zzz</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="类型分类"><a href="#类型分类" class="headerlink" title="类型分类"></a>类型分类</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE回炉-数据类型.png"
                      style="zoom:80%;" /
                >

<table>
<thead>
<tr>
<th>数据类型</th>
<th>内存空间</th>
<th>默认值</th>
<th>表示范围</th>
</tr>
</thead>
<tbody><tr>
<td><strong>byte</strong></td>
<td>1 byte (2<sup>0</sup>)</td>
<td>0</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td><strong>short /char</strong></td>
<td>2 byte (2<sup>1</sup>)</td>
<td>0</td>
<td>-2<sup>15</sup>~2<sup>15</sup>-1 / 0 ~ 2<sup>16</sup>-1 (无符号整型)</td>
</tr>
<tr>
<td><strong>int</strong></td>
<td>4 byte (2<sup>2</sup>)</td>
<td>0</td>
<td>-2<sup>31</sup>~2<sup>31</sup>-1(约21亿)</td>
</tr>
<tr>
<td><strong>long</strong></td>
<td>8 byte (2<sup>3</sup>)</td>
<td>0L 或 0l</td>
<td>-2<sup>63</sup>~2<sup>63</sup>-1</td>
</tr>
<tr>
<td><strong>float</strong></td>
<td>4 byte</td>
<td>0.0F 或 0.0f</td>
<td></td>
</tr>
<tr>
<td><strong>double</strong></td>
<td>8 byte</td>
<td>0.0</td>
<td></td>
</tr>
</tbody></table>
<h3 id="整型与浮点型初始化"><a href="#整型与浮点型初始化" class="headerlink" title="整型与浮点型初始化"></a>整型与浮点型初始化</h3><ul>
<li>Java的<strong>整型常量</strong>默认为 <strong>int 型</strong>，因此<strong>声明long</strong>型常量须后加 <strong>‘l’或‘L’</strong></li>
<li>Java 的<strong>浮点型常量</strong>默认为<strong>double型</strong>，因此<strong>声明float</strong>型常量，须后加<strong>‘f’或‘F’</strong></li>
</ul>
<blockquote>
<p>无论是赋值语句的数字还是字面常量的数字，只要是整型数字 java就认为是int，只要浮点数字就认为double</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译成功，但bigValue并非long型，而是int型</span></span><br><span class="line"><span class="keyword">long</span> bigValue = <span class="number">100</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译失败 ，系统不会把 9999999999999 当成long类型处理</span></span><br><span class="line"><span class="comment">所以超出 int 的表数范围，从而引起错误</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">long</span> bigValue1 = <span class="number">9999999999999</span>;</span><br><span class="line"><span class="comment">//下面代码是正确的，在巨大的整数值后使用 L 后缀 ，强制使用long 类型</span></span><br><span class="line"><span class="keyword">long</span> bigVa1ue2 = <span class="number">9223372036854775807L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译失败，12.3默认是double型，大类型转小类型必须加强制转换符，或改为12.3f</span></span><br><span class="line"><span class="keyword">float</span> f1 = <span class="number">12.3</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="整数型"><a href="#整数型" class="headerlink" title="整数型"></a>整数型</h3><ul>
<li><strong>整数值</strong>的<strong>4种</strong>表示方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义两个 8 位的二进制整数</span></span><br><span class="line"><span class="comment">// 注意，计算机底层都是以补码的方式存储数据的</span></span><br><span class="line"><span class="keyword">int</span> binVal1 = <span class="number">0b11010100</span>; </span><br><span class="line"><span class="keyword">byte</span> bnVal2= <span class="number">0B01101001</span>;</span><br><span class="line"><span class="comment">//以 0 开头的整数值是八进制的整数</span></span><br><span class="line"><span class="keyword">int</span> octa1Va1ue = <span class="number">013</span> ; </span><br><span class="line"><span class="comment">//0~9组成的十进制整数</span></span><br><span class="line"><span class="keyword">int</span> decValue = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//以 0x 或0X 开头的整数值是十六进制的整数</span></span><br><span class="line"><span class="keyword">int</span> hexVa1uel = <span class="number">0x13</span> ; </span><br><span class="line"><span class="keyword">int</span> hexVa1ue2 = <span class="number">0XaF</span>;</span><br></pre></td></tr></table></figure>

<h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><ul>
<li>字符型的3种表示方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接指定单个字符作为字符值</span></span><br><span class="line"><span class="keyword">char</span> aChar = <span class="string">&#x27;a&#x27;</span>; </span><br><span class="line"><span class="comment">//使用转义字符来作为字符值</span></span><br><span class="line"><span class="keyword">char</span> enterChar = <span class="string">&#x27;\r&#x27;</span>; </span><br><span class="line"><span class="comment">//使用 Unicode 编码值来指定字符值</span></span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;\u9999&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>常用acsii编码字符</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>ASCII码</th>
</tr>
</thead>
<tbody><tr>
<td>a ~ z</td>
<td>97 ~ 122</td>
</tr>
<tr>
<td>A ~ Z</td>
<td>65 ~ 90</td>
</tr>
<tr>
<td>0 ~ 9</td>
<td>48 ~ 57</td>
</tr>
</tbody></table>
<ul>
<li>常见编码积累<ol>
<li>Windows CMD 默认编码是：ANSI编码，即GBK编码</li>
<li>UTF-8 是 Unicode 编码的一种形式，是国际最通用的编码</li>
</ol>
</li>
</ul>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><ul>
<li><strong>浮点型</strong>的<strong>2种</strong>表示方式<ul>
<li>十进制数形式：如5.12 、512.0 、.512 。浮点数必须包含一个小数点</li>
<li>科学计数法形式：例如 5.12e2 (即 5.12x10<sup>2</sup>)，5.12E2 也是5.12x10<sup>2</sup><ul>
<li>float：单精度，尾数可以精确到<strong>7位有效数字</strong>。很多情况下，精度很难满足需求<ul>
<li>虽说float只占4个字节，但因为尾数表示方式，表示数值的范围比long还大</li>
</ul>
</li>
<li>double：双精度，精度是float的两倍。通常采用此类型。</li>
</ul>
</li>
</ul>
</li>
<li>小结：整型通常使用int类型，浮点型通常使用double</li>
</ul>
<h3 id="类型间转换"><a href="#类型间转换" class="headerlink" title="类型间转换"></a>类型间转换</h3><p>类型间运算及其转换(不含boolean)</p>
<h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><ul>
<li><p>自动类型转换发生在<strong>不同数据类型之间进行运算</strong>时，结果自动<strong>提升为容量大的数据类型</strong>。</p>
</li>
<li><p>当<strong>byte、char、short</strong>三种类型之间<strong>任何两种</strong>，<strong>包括自身两种</strong>变量做运算时，结果都转换为<strong>int型</strong></p>
<ul>
<li>如：byte + byte = int….、byte + short = int 、char + byte = int 、char + short = int </li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png"
                     
                ></p>
<ul>
<li><strong>示例代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相关练习与测试</span></span><br><span class="line">System.out.println(<span class="string">&quot;*	*&quot;</span>); 			<span class="comment">//*	   *</span></span><br><span class="line">System.out.print1n(<span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&#x27;*&#x27;</span>);	 <span class="comment">//93</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&quot;\t&quot;</span> + <span class="string">&#x27;*&#x27;</span>); 	 <span class="comment">//*	*</span></span><br><span class="line">System.out.printin(<span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&quot;*&quot;</span>); 	 <span class="comment">//51*</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + (<span class="string">&#x27;\t&#x27;</span> + <span class="string">&quot;*&quot;</span>));  <span class="comment">//*	*</span></span><br></pre></td></tr></table></figure>

<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ol>
<li><p>自动类型转换的逆运算，加强制转换符 ()，注意精度损失，或溢出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">100.0</span>;</span><br><span class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>)d;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>String与其他类型的运算</strong>：String可以和8种基本数据类型变量做+运算，且运算只能是<strong>连接运算</strong>，运算的结果<strong>仍然是String类</strong>型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number = <span class="number">100</span>;</span><br><span class="line">String numberStr = <span class="string">&quot;学号&quot;</span>;</span><br><span class="line">System.out.println(numberStr + number);<span class="comment">//输出 &quot;学号100&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>无论是自动转换还是<strong>强制转换</strong>，只能<strong>适用数值间</strong>的转换<strong>，即强制类型转换符()也</strong>只适用数值的数据类型</p>
</blockquote>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><ol>
<li><p><strong>前至++与后至++</strong></p>
<ul>
<li><p>前置++：++i，先自增，后使用</p>
</li>
<li><p>后置++：i++，先使用，后自增</p>
</li>
<li><p>++与–的特点：<strong>不改变原数据类型</strong>的情况下进行++与–，<strong>效率高</strong></p>
</li>
<li><p>无论前置还是后置++还是–，<strong>均改变变量</strong>，i++ == i = i +1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">10</span>;</span><br><span class="line">s1 = s1 + <span class="number">1</span>;<span class="comment">//编译失败，int不能直接转换为short</span></span><br><span class="line">s1 = (<span class="keyword">short</span>)s1 + <span class="number">1</span> <span class="comment">//正确写法，效率低，截断方式</span></span><br><span class="line">s1++; <span class="comment">//编译运行均通过，正确写法，效率高</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>/除运算</strong>：</p>
<ul>
<li><p>无论在什么地方，<strong>两个int型相除</strong>，结果一定为<strong>整型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> result = <span class="number">12</span> / <span class="number">5</span>; <span class="comment">// result = 2.0;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>%模运算</strong>/取余：</p>
<ul>
<li><strong>模运算 = 前除后，求余数</strong></li>
<li>java规定，结果的符号与<strong>被模数</strong>(前面的数)的符号相同</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>模运算式</th>
<th>结果</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>0 % 1</td>
<td>0</td>
<td><strong>0除以任何数=0</strong>，<strong>不会存在余数</strong></td>
</tr>
<tr>
<td>1 % 0</td>
<td>error</td>
<td>0<strong>不能作除数</strong>，作分母，溢出</td>
</tr>
<tr>
<td>2 % 1</td>
<td>0</td>
<td>整除余0</td>
</tr>
<tr>
<td>7 % 5</td>
<td>2</td>
<td>够除 1余2</td>
</tr>
<tr>
<td>2 % 3</td>
<td>3</td>
<td>不够除：0余2</td>
</tr>
<tr>
<td>12 % -5</td>
<td>2</td>
<td>符号由被<strong>模数决定</strong></td>
</tr>
<tr>
<td>-12 % -5</td>
<td>-2</td>
<td>同上</td>
</tr>
</tbody></table>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><ul>
<li><p>复合/扩展运算符：</p>
<ul>
<li><p>基本原理：<code>num1 +=2; 等价 num1 = num1 + 2;</code></p>
</li>
<li><p>特点，同++一样，复合赋值运算符同样可以在<strong>不改变原数据类型</strong>情况下运算，更加高效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>; s1 += <span class="number">2</span>;<span class="comment">//编译运行均通过</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>; i *= <span class="number">0.1</span>; <span class="comment">//编译运行均通过 输出0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>综合练习</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">n += (n++) + (++n); <span class="comment">//n = n + (n++) + (++n); n = 10 + 10 + 12</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table>
<thead>
<tr>
<th></th>
<th>布尔</th>
<th>数值(按位与)</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>if( true &amp; num++ )，全部执行</td>
<td>二进制按位与</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>短路与：if ( true &amp;&amp; num++ )，可得出结果就停止执行，即num++不执行</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>注意：**&amp;，|，^<strong>这三个运算符</strong>同为逻辑运算符与位运算符<strong>，具体表示哪种，</strong>取决于参与运算对象**是数值还是布尔值</li>
</ul>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><h4 id="位运算类型"><a href="#位运算类型" class="headerlink" title="位运算类型"></a>位运算类型</h4><table>
<thead>
<tr>
<th>位运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
</tr>
<tr>
<td>~</td>
<td>按位取反</td>
</tr>
<tr>
<td>&lt;&lt;n</td>
<td>左移n位右<strong>补零</strong></td>
</tr>
<tr>
<td>&gt;&gt;n</td>
<td>按位右移n位，<strong>补最高位</strong>(正数0，负数1)</td>
</tr>
<tr>
<td>&gt;&gt;&gt;</td>
<td>无符号右移，空缺位<strong>均补零</strong></td>
</tr>
</tbody></table>
<p>tips：注意，真正对计算机<strong>数值数据移位</strong>也是移动该数值的<strong>补码</strong>，如 -5 &lt;&lt; 2结果如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-%E8%B4%9F%E6%95%B0%E7%A7%BB%E4%BD%8D.png"
                     
                ></p>
<h4 id="位运算技巧"><a href="#位运算技巧" class="headerlink" title="位运算技巧"></a>位运算技巧</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-j%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8.png"
                     
                ></p>
<ul>
<li><strong>示例代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、你能否写出最高效的2 * 8的实现方式？ </span></span><br><span class="line"><span class="number">2</span> &lt;&lt; <span class="number">3</span>  或  <span class="number">8</span> &lt;&lt; <span class="number">1</span></span><br><span class="line"><span class="comment">//2、交换两个数值变量的几种方式</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1 + <span class="string">&quot;,num2 = &quot;</span> + num2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式一：定义临时变量的方式</span></span><br><span class="line"><span class="comment">//推荐的方式</span></span><br><span class="line"><span class="comment">//int temp = num1;</span></span><br><span class="line"><span class="comment">//num1 = num2;</span></span><br><span class="line"><span class="comment">//num2 = temp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：好处：不用定义临时变量  </span></span><br><span class="line"><span class="comment">//弊端：① 相加操作可能超出存储范围 ② 有局限性：只能适用于数值类型</span></span><br><span class="line"><span class="comment">//num1 = num1 + num2;</span></span><br><span class="line"><span class="comment">//num2 = num1 - num2;</span></span><br><span class="line"><span class="comment">//num1 = num1 - num2;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*方式三：使用位运算符</span></span><br><span class="line"><span class="comment">	num1=(numl ^ num2)^num2;</span></span><br><span class="line"><span class="comment">	num2=(num2 ^ num1)^num1;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//有局限性：只能适用于数值类型</span></span><br><span class="line">num1 = num1 ^ num2;</span><br><span class="line">num2 = num1 ^ num2;</span><br><span class="line">num1 = num1 ^ num2;<span class="comment">//此时num2 == num1</span></span><br><span class="line">System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1 + <span class="string">&quot;,num2 = &quot;</span> + num2);</span><br></pre></td></tr></table></figure>





<h3 id="三元-目表达式"><a href="#三元-目表达式" class="headerlink" title="三元/目表达式"></a>三元/目表达式</h3><ul>
<li>格式：表达式1 ? 表达式2 : 表达式3</li>
</ul>
<p>​       含义：若表达式1为真，整个条件表达式返回表达式2的结果反之表达式3的结果</p>
<ul>
<li><p>三元运算符可以嵌套使用</p>
</li>
<li><p>若程序使用三元运算符，又可以使用if-else结构，优先选择三元运算符。原因：简洁、执行效率高。</p>
</li>
<li><p>表达式1和表达式2不要求完全一致，但必须可兼容为其中一种类型</p>
</li>
<li><p>对于数值基本数据类型，使用三元运算符还会想使用比较运算符那样进行自动类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">true</span> ? <span class="number">3</span> : <span class="number">4.0</span>);<span class="comment">//输出3.0，自动转换为double型</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul>
<li>‘==，&gt;，&lt;，&gt;=，&lt;= ‘：粗略来说，比较运算符只能用于<strong>数值类型</strong>(类型不一定完全相同，底层是数值即可)</li>
<li>特别说明，’==’ 也可以在<strong>引用类型中使用</strong>，但也聚焦在<strong>数值上</strong>(地址值)</li>
</ul>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><h4 id="if-else结构"><a href="#if-else结构" class="headerlink" title="if-else结构"></a>if-else结构</h4><ul>
<li><p>if：符合则执行</p>
</li>
<li><p>if - else：2选1</p>
</li>
<li><p>if - else if - else ：n选1</p>
<hr>
<ul>
<li><p>若if-else结构中只有<strong>一条执行语句</strong>，则可以省略{}</p>
</li>
<li><p>同时，省略{}的if语句的else总是与<strong>最近</strong>的未匹配的if匹配</p>
</li>
</ul>
</li>
</ul>
<h4 id="switch结构"><a href="#switch结构" class="headerlink" title="switch结构"></a>switch结构</h4><h5 id="语法逻辑"><a href="#语法逻辑" class="headerlink" title="语法逻辑"></a>语法逻辑</h5><ul>
<li><strong>执行逻辑</strong>：根据switch表达式的值，依次匹配各个case中的常量。一旦匹配成功，则执行case结构中语句。若此时没有遇到break语句，则<strong>不判断地</strong>直接继续向下执行其他case结构中的执行语句，直到遇到break关键字或末尾结束为止。(为更好理解，表达式与case 后语句划上等号进行的判断)</li>
<li>表达式支持<strong>6种</strong>数据类型：<strong>byte 、short、char、int、枚举类型</strong>(JDK5.0新增)、<strong>String</strong>类型(JDK7.0新增)</li>
<li>把<strong>default</strong>语句理解成为一个<strong>无条件case</strong>语句则一切明了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例1：常见方式</span></span><br><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 常量表达式<span class="number">1</span> : 语句<span class="number">1</span>;<span class="comment">//break;</span></span><br><span class="line">	…</span><br><span class="line">	<span class="keyword">case</span> 常量表达式n : 语句n;<span class="comment">//break;</span></span><br><span class="line">	<span class="keyword">default</span> : 语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出1，2，3，4</span></span><br><span class="line"><span class="keyword">int</span> i =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(i)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:System.out.println(<span class="string">&quot;2&quot;</span>);		</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:System.out.println(<span class="string">&quot;3&quot;</span>);		</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例2：多个case共用一条语句</span></span><br><span class="line"><span class="comment">//应理解为，每个case的执行语句都为空，且没有break，因此连续执行</span></span><br><span class="line"><span class="comment">//不应该理解为内嵌case语句</span></span><br><span class="line"><span class="comment">//值为‘A\B\C’都执行语句1</span></span><br><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> ‘A’ :</span><br><span class="line">	<span class="keyword">case</span> ‘B’ :</span><br><span class="line">	<span class="keyword">case</span> ‘C’ : 语句<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">	…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="编写经验"><a href="#编写经验" class="headerlink" title="编写经验"></a>编写经验</h5><p>若多个条件表达式之间的关系是：</p>
<ul>
<li>“<strong>互斥</strong>“关系(或没有交集的关系),哪个判断和执行语句声明在上面还是下面，无所谓</li>
<li>交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面</li>
<li><strong>有包含</strong>的关系，通常情况下，需要将<strong>范围小</strong>的声明<strong>在范围大的上面</strong>。<strong>否则，范围小的就没机会执行了</strong></li>
<li>示例代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例1：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graduate</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		InstanceTest test = <span class="keyword">new</span> InstanceTest();</span><br><span class="line">		test.method(<span class="keyword">new</span> Student());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Person e)</span></span>&#123;</span><br><span class="line">		<span class="comment">//错误写法,每次执行第一个if</span></span><br><span class="line">        <span class="comment">//if(e instanceof Person)&#123;</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;a graduated student&quot;);</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;a student&quot;);</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;a person&quot;);</span></span><br><span class="line"><span class="comment">//		&#125;else if(e instanceof Student)&#123;</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;a student&quot;);</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;a person&quot;);</span></span><br><span class="line"><span class="comment">//		&#125;else if(e instanceof Graduate)&#123;</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;a person&quot;);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">       </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//方式一，包含关系应将范围小的在范围大前判断</span></span><br><span class="line">		<span class="keyword">if</span>(e <span class="keyword">instanceof</span> Graduate)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;a graduated student&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a student&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a person&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a student&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;a person&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a person&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//方式二</span></span><br><span class="line">		<span class="keyword">if</span>(e <span class="keyword">instanceof</span> Graduate)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a graduated student&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(e <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a student&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(e <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a person&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="相关关键字"><a href="#相关关键字" class="headerlink" title="相关关键字"></a>相关关键字</h4><ul>
<li><p><strong>break</strong>：结束<strong>当前</strong>循环体的循环</p>
</li>
<li><p><strong>continue</strong>：结束<strong>当次</strong>循环体当的循环</p>
<hr>
</li>
<li><p>break与continue<strong>语句后</strong>均<strong>不能声明执行语句</strong></p>
</li>
<li><p>break与continue只作用在离关键字<strong>最近的循环体</strong></p>
<hr>
</li>
<li><p><strong>带标签break与continue</strong>语句使用：可指定作用在哪一层循环结构</p>
<ol>
<li>在拟作用循环体前<strong>声明标签</strong>：<strong>label :  for</strong>()</li>
<li>在break或continue语句后追加标签民：<strong>break label;</strong></li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">label:<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">10</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">//break;//默认跳出包裹此关键字最近的一层循环。</span></span><br><span class="line">			<span class="comment">//continue;</span></span><br><span class="line">			<span class="keyword">break</span> label;<span class="comment">//结束指定标识的一层循环结构</span></span><br><span class="line">             <span class="comment">//continue labe1；//结束指定标识的一层循环结构当次循环  </span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(j);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><ul>
<li>for内的变量只在for中有效</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首次执行：1-&gt;2-&gt;3-&gt;4</span></span><br><span class="line"><span class="comment">//循环执行：2-&gt;3-&gt;4，2-&gt;3-&gt;4...</span></span><br><span class="line"><span class="comment">//可输入多个语句用逗号“，”</span></span><br><span class="line"><span class="keyword">for</span>( <span class="number">1</span>,?,? ; <span class="number">2</span> ; <span class="number">4</span>)&#123;</span><br><span class="line">	<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首次执行：1-&gt;2-&gt;3</span></span><br><span class="line"><span class="comment">//循环执行：2-&gt;3,2-&gt;3...</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">2</span>)&#123;</span><br><span class="line">	<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h4><ul>
<li>do-while循环至少会执行一次循环体！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首次执行：1 - 3 - 4 </span></span><br><span class="line"><span class="comment">//循环执行：2 - 3 - 4 </span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	<span class="number">3</span>;</span><br><span class="line">	<span class="number">4</span>;</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>数组的类型可以是<strong>基本数据类型</strong>，也可<strong>引用数据类型</strong></p>
</li>
<li><p>数组是<strong>引用数据类型</strong>，必须含<strong>new</strong>，含方法，含属性(常用length)</p>
</li>
<li><p>数组长度一旦确定，就不可修改</p>
</li>
</ul>
<h3 id="声明与初始化"><a href="#声明与初始化" class="headerlink" title="声明与初始化"></a>声明与初始化</h3><p>含静态初始化，动态初始化</p>
<ul>
<li><strong>静态初始化</strong>：<strong>指定</strong>数组元素的<strong>初始值</strong>，由<strong>系统决定</strong>数组<strong>长度</strong> </li>
<li><strong>动态初始化</strong>：<strong>指定数组长度</strong>(可以是<strong>变量</strong>)，由<strong>系统</strong>为数组元素<strong>分配初始值</strong></li>
</ul>
<hr>
<ul>
<li>数组初始化默认值<ul>
<li>整型：0</li>
<li>浮点型：0.0</li>
<li>char型：0或’\u0000’，而非’0’</li>
<li>boolean型：false</li>
<li>用数据类型：null</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [] ids;<span class="comment">//声明</span></span><br><span class="line">ids = <span class="keyword">new</span> ids[]&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>&#125;;<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;<span class="comment">//简化语法格式</span></span><br><span class="line"></span><br><span class="line">String[] names = <span class="keyword">new</span> String[<span class="number">4</span>];<span class="comment">//动态初始化，数组长度可以是变量</span></span><br></pre></td></tr></table></figure>

<h3 id="数组的内存解析"><a href="#数组的内存解析" class="headerlink" title="数组的内存解析"></a>数组的内存解析</h3><ul>
<li>待补充，暂时不需要</li>
</ul>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul>
<li><p>从数组底层的运行机制上来看(线性内存，多维映射)，没有多维数组</p>
</li>
<li><p>把多维数组看成多个一维数组的内嵌，如二维数组是一个一维数组，每个数组元素也是一个数组</p>
</li>
</ul>
<h3 id="二维数组使用"><a href="#二维数组使用" class="headerlink" title="二维数组使用"></a>二维数组使用</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li><p>Java二维数组动态初始化有别于C语言</p>
</li>
<li><p>Java：半自动初始化：<code>new int[3][];</code></p>
<ul>
<li>C语言：全自动初始化：<code>int[][3];</code></li>
</ul>
</li>
<li><p><strong>示例代码</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;<span class="comment">//静态初始化</span></span><br><span class="line">String[][] arr2 = <span class="keyword">new</span> String[<span class="number">2</span>][<span class="number">3</span>];<span class="comment">//动态初始化</span></span><br><span class="line"></span><br><span class="line">String[][] arr3 = <span class="keyword">new</span> String[<span class="number">3</span>][];<span class="comment">//动态初始化，但不能直接使用，还需实例化列才可使用</span></span><br><span class="line">								  <span class="comment">//注意，指定哪个(实例化哪个)用哪个可用</span></span><br><span class="line">arr3[<span class="number">0</span>] = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>获取长度</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">arr1.length;<span class="comment">//3</span></span><br><span class="line">arr1[<span class="number">0</span>].length;<span class="comment">//3</span></span><br><span class="line">arr1[<span class="number">1</span>].length;<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h3 id="内存解析"><a href="#内存解析" class="headerlink" title="内存解析"></a>内存解析</h3><ul>
<li><strong>示例代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//规定：二维数组分为外层数组的元素，内层数组的元素</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">//外层元素：arr[0],arr[1]等</span></span><br><span class="line"><span class="comment">//内层元素：arr[0][0],arr[1][2]等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组元素的默认初始化值 </span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">//外层元素的初始化值为：地址值</span></span><br><span class="line"><span class="comment">//内层元素的初始化值为：与一维数组初始化情况相同</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][];</span><br><span class="line"><span class="comment">//外层元素的初始化值为：null</span></span><br><span class="line"><span class="comment">//内层元素的初始化值为：不能调用，否则报错。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>图示分析</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-java8-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90.jpg"
                     
                ></p>
<h2 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h2><ul>
<li><strong>ArrayIndexOutOfBoundsException</strong>：角标越界异常</li>
<li><strong>NullPointerException</strong>：空指针异常</li>
</ul>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="基础概念-1"><a href="#基础概念-1" class="headerlink" title="基础概念"></a>基础概念</h2><ul>
<li><strong>类</strong>：对一类事物的描述，是抽象的，概念上的定义</li>
<li><strong>对象</strong>：某个类的具体实体，也成为<strong>实例</strong>(instance)，创建一个对象 == <strong>实例化</strong></li>
<li><strong>属性</strong>：类中的<strong>成员的变量</strong>(field)，调用 <code>对象.属性;</code></li>
<li><strong>行为</strong>：类的<strong>成员的方法</strong>(method)，调用 <code>对象.方法()</code></li>
<li><strong>类成员</strong>：属性、方法、构造器、代码块、内部类</li>
</ul>
<h2 id="属性与局部变量"><a href="#属性与局部变量" class="headerlink" title="属性与局部变量"></a>属性与局部变量</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><strong>直接定义</strong>在<strong>类</strong>的一对{}内</li>
<li>声明属性可<strong>指明其权限</strong>：<strong>private</strong>、<strong>public</strong>、<strong>缺省</strong>(默认不写权限)、<strong>protected</strong></li>
</ul>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><ul>
<li>声明在<strong>方法</strong>内、<strong>方法形参</strong>、<strong>代码块内</strong>、<strong>构造器形参、构造器内部</strong>的变量</li>
<li><strong>不可使用</strong>权限修饰符</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法的创建"><a href="#方法的创建" class="headerlink" title="方法的创建"></a>方法的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">method(<span class="string">&quot;Tom&quot;</span>);<span class="comment">//传入的为实参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String name)</span></span>&#123;&#125;<span class="comment">//方法参数。形式参数</span></span><br></pre></td></tr></table></figure>

<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>“两同一不同”。与<strong>权限修饰符、返回值类型、形参变量名、方法体均无关</strong>(按<strong>可区分调用角度</strong>理解即可)</p>
<ul>
<li>同一个<strong>类</strong>、相同<strong>方法名</strong></li>
<li>参数列表不同：参数<strong>个数不同</strong>，参数<strong>类型不同</strong></li>
</ul>
<h3 id="可变个数形参"><a href="#可变个数形参" class="headerlink" title="可变个数形参"></a>可变个数形参</h3><p>可变个数形参(jdk 5.0)格式：<code>数据类型 ... 变量名,如 String...strs </code></p>
<p>tips：当方法<strong>不止一个形参</strong>且<strong>含可变形参</strong>时，可变形参<strong>只能置于末尾</strong>，否则编译不通过(不可区分变量类型)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public void show(String...strs,int i); //错误情况，</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i,String...strs)</span></span>;<span class="comment">// 正确情况</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>内在逻辑：除与数组作为新参的<strong>实参传入格式不一样</strong>外(可变形参用逗号)，可变个数形参<strong>等价于数组</strong></p>
</li>
<li><p>因此可与数组类型构成<strong>重写</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">show(<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Wang&quot;</span>,<span class="string">&quot;Deng&quot;</span>)<span class="comment">//可连续传入多个数据，用逗号隔开。</span></span><br><span class="line">show(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Wang&quot;</span>,<span class="string">&quot;Deng&quot;</span>&#125;);<span class="comment">//同样可以通过数组的方式传入实参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String...strs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; stes.length;i++)&#123;<span class="comment">//等价与数组</span></span><br><span class="line">        System.out.println(strs[i]);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String name)</span></span>&#123;&#125;<span class="comment">//可以构成重载</span></span><br></pre></td></tr></table></figure>

<h3 id="return关键字"><a href="#return关键字" class="headerlink" title="return关键字"></a>return关键字</h3><ul>
<li><strong>无返回值</strong>：结束当前方法</li>
<li><strong>有返回值</strong>：结束当前方法且返回指定变量</li>
</ul>
<h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><ul>
<li><strong>匿名对象</strong>：<code>new Person().run();</code><ul>
<li>匿名对象<strong>只能调用一次</strong></li>
</ul>
</li>
</ul>
<h3 id="值传递机制"><a href="#值传递机制" class="headerlink" title="值传递机制"></a>值传递机制</h3><p>Java方法参数传递方式<strong>只有一种</strong>，<strong>值传递！</strong></p>
<ul>
<li>基本数据类型：变量<strong>值</strong></li>
<li>引用数据类型：地址<strong>值</strong></li>
</ul>
<hr>
<h4 id="String与值传递机制"><a href="#String与值传递机制" class="headerlink" title="String与值传递机制"></a>String与值传递机制</h4><ul>
<li><p>字符串是存储在字符串常量池，是<strong>不可变</strong>(特性)的字符序列</p>
</li>
<li><p>当字符串常量池中已经有相同的字符串，则直接复用执行该字符串的地址</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">method(s1);</span><br><span class="line">System.out.println(s1);<span class="comment">//仍输出hello </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    str = <span class="string">&quot;hi~&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>String确实是<strong>引用数据类型</strong>，值传递也确实在传递s1的<strong>地址值</strong>，但由于字<strong>符串常量池的特性</strong>(不可变序列)导致没有改变</p>
</li>
<li><p>由于字符串在java中大量使用，因此JVM特意开辟一个空间专门用于存储字符串，若同时又两个相同的字符串，常量池只记录一个</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-String%E5%86%85%E5%AD%98%E4%B8%8E%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6.png"
                     
                ></p>
</li>
</ul>
<ol>
<li>在字符串常量池创建字符串”hello”，因为字符串底层是通过char[]存储的，确定后是不可变的字符序列</li>
<li>把“hello”字符串与s1关联起来</li>
<li>调用方法时，实参传入s1的地址值，并赋值给str</li>
<li>由于字符串常量池不可变的特性，拟赋值的“hi~~”字符串只能新建一份</li>
<li>并将“hi~~”字符串与赋值语句中的str关联</li>
</ol>
</blockquote>
<h4 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//需实现调用method方法后，打印除a=100,b=200,请写出method方法代码</span></span><br><span class="line">        method(a,b);</span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;b=&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>由于Java基本数据类型<strong>无指针操作</strong>，若想通过<strong>方法调用</strong>实现交换两个<strong>基本数据类型</strong>的值。严格来说是<strong>不行的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现方式1：方法内打印，立即终止程序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        a = a*<span class="number">10</span>;</span><br><span class="line">        b = b*<span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;b=&quot;</span> + b);</span><br><span class="line">    	System.exit(<span class="number">0</span>);<span class="comment">//终止程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现方式2：方法重写/覆盖</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    PrintStream ps = <span class="keyword">new</span> PrintStream(System.out)&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span></span>&#123;</span><br><span class="line">              <span class="keyword">if</span>(<span class="string">&quot;a=10&quot;</span>.equals(x))&#123;</span><br><span class="line">                  x = <span class="string">&quot;a=100&quot;</span>;</span><br><span class="line">              &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;b=10&quot;</span>.equals(x))&#123;</span><br><span class="line">                  x = <span class="string">&quot;b=200&quot;</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">super</span>.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    System.setOut(ps);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>若想通过调用一个方法实现数组两个元素值交换，则必须通过<strong>引用类型</strong>作为<strong>引导媒介</strong>进行交换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：若想通过调用一个方法的形式交换数组中某两个值，只能如下写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = arr[i];   </span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="基础概念-2"><a href="#基础概念-2" class="headerlink" title="基础概念"></a>基础概念</h3><ul>
<li><p><strong>高内聚</strong> ：类的内部数据操作细节自己完成，不允许外部干涉；</p>
</li>
<li><p><strong>低耦合</strong> ：仅对外暴露少量的方法用于使用</p>
</li>
<li><p><strong>封装性的一些体现</strong>：具体体现在面向对象程序设计上</p>
<ul>
<li>属性私有化(private)、公共(public)方法来调用</li>
<li>不对外暴露的私有方法</li>
<li>单例模式…</li>
</ul>
</li>
</ul>
<h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><h4 id="修饰符类型"><a href="#修饰符类型" class="headerlink" title="修饰符类型"></a>修饰符类型</h4><p><strong>权限修饰符</strong>：</p>
<ul>
<li><strong>private</strong>、<strong>缺省</strong>(默认不写权限)、</li>
<li><strong>protected</strong>、</li>
<li><strong>public</strong>(从小到大)，可添加到<strong>类的成员</strong>与<strong>类</strong>(class)前</li>
</ul>
<h4 id="可修饰对象"><a href="#可修饰对象" class="headerlink" title="可修饰对象"></a>可修饰对象</h4><h5 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h5><p><strong>可修饰类型</strong>：：属性、方法、构造器、内部类、<del>代码块</del></p>
<ul>
<li>注意：以下权限范围的调用对象类成员，是<strong>类的成员可以不可被调用，不是类可不可以创建</strong></li>
<li>常用private与public，需注意是(缺省)与protected的对比</li>
</ul>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类内部</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>同一工程</th>
</tr>
</thead>
<tbody><tr>
<td><strong>private</strong></td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>(缺省)</td>
<td>Yes</td>
<td><strong>Yes</strong>(需注意)</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>protected</strong></td>
<td>Yes</td>
<td>Yes</td>
<td><strong>Yes</strong>(需注意)</td>
<td></td>
</tr>
<tr>
<td><strong>public</strong></td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
<h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><ul>
<li><strong>类</strong>：仅允许<strong>public</strong>与缺省(<strong>default</strong>)</li>
<li>package结构在jdk9之前都没有统一的管理结果，可通过<strong>import</strong>导入指定的包/类</li>
</ul>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建类的对象：new + 构造器</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person(); <span class="comment">//new Person()就是调用构造器</span></span><br></pre></td></tr></table></figure>

<h4 id="隐式语法"><a href="#隐式语法" class="headerlink" title="隐式语法"></a>隐式语法</h4><ul>
<li><p>子类实例化加载前是先对其父类及所有间接父类先加载，通过从子类构造器一直往上调用父类的构造器</p>
</li>
<li><p>因此<strong>没显式</strong>的定义类的构造器的话，则系统默认提供一个<strong>空参的构造器</strong></p>
</li>
<li><p>当构造器的<strong>首行</strong>没有显式地使用<code>this()</code>或<code>super()</code>关键字调用指定的构造器结构时，默认构造器首行存在一个<code>super()</code>语句。</p>
</li>
<li><p>构造器<strong>不可定义返回值</strong>，其实构造器的作用就是<strong>返回引用的地址值</strong>，因此不能自定义</p>
</li>
</ul>
<h4 id="其他语法"><a href="#其他语法" class="headerlink" title="其他语法"></a>其他语法</h4><ul>
<li>一个类中定义的<strong>多个构造器</strong>，彼此<strong>构成重载</strong></li>
<li><strong>一旦显式的定义</strong>了类的构造器之后，系统就<strong>不再提供默认的空参构造器</strong></li>
<li>一个类中，<strong>至少会有一个构造器</strong></li>
</ul>
<h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><p><strong>JavaBean</strong>：由java语言编写的<strong>可重用组件</strong></p>
<ul>
<li>类是公共的</li>
<li>有一个public的无参构造器</li>
<li>有属性，且含属性对应的getter和setter方法</li>
</ul>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><h3 id="基本含义"><a href="#基本含义" class="headerlink" title="基本含义"></a>基本含义</h3><ul>
<li><p>this理解为“当前创建的对象”，即<strong>谁调用this，谁就是this</strong></p>
</li>
<li><p>可调用的结构：<strong>属性、方法；构造器</strong></p>
</li>
</ul>
<h3 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h3><p>解决形参与属性<strong>同名</strong>时，通过<strong>this特指类成员</strong>的属性/方法</p>
<ul>
<li>格式：<code>this.field; 或 this.method();</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;<span class="comment">//同名解决</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h3><p>用于<strong>构造器中调用其他重载构造器</strong>，常用于解决重载构造器代码冗余问题</p>
<ul>
<li>调用空参构造器：<code>this();</code></li>
<li>构造器内部，<strong>只能使用一次</strong>this调用其他构造器</li>
<li>构造器中”this(形参列表)”必须声明在当前<strong>构造器的首行</strong></li>
<li>由于<strong>子类构造器</strong>默认<strong>必须存在调用父类构造器的操作</strong>，因此<strong>子类构造器</strong>间的调用<strong>不能构成死循环</strong><ul>
<li>在自身构造器中不能再调用自身构造器</li>
<li>同理如类中有n个构造器，则最多有 n - 1构造器中使用了”this(形参列表)”</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需求：Person初始化时，均需要调用的一相同的部分初始化代码</span></span><br><span class="line"><span class="comment">//则可以使用this()方式调用指定的重载构造器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//通用的初始化逻辑</span></span><br><span class="line">		System.out.println(info);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>();<span class="comment">//其他构造器调用空参构造器逻辑即可</span></span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>();<span class="comment">//其他构造器调用空参构造器逻辑即可</span></span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(age);<span class="comment">//还可以通过形参指定构造器调用</span></span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UML简述"><a href="#UML简述" class="headerlink" title="UML简述"></a>UML简述</h2><ul>
<li><p><strong>UML简述</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE回炉-UML简述.png"
                      style="zoom:80%;" /
                >

</li>
</ul>
<h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><ul>
<li>为了<strong>方便管理</strong>项目中的<strong>类</strong>，提供包的概念，一个包含多个类</li>
<li>使用package关键字声明类或接口所属的包时，应声明在<strong>头部</strong></li>
</ul>
<h3 id="MVC规范定义"><a href="#MVC规范定义" class="headerlink" title="MVC规范定义"></a>MVC规范定义</h3><ul>
<li><strong>Model</strong> 模型层：处理数据<ul>
<li>数据对象封装：model.bean/domain</li>
<li>数据库操作类：model.dao</li>
<li>数据库：model.db</li>
</ul>
</li>
<li><strong>Controller</strong> 控制层：处理业务逻辑<ul>
<li>应用界面相关：controller.activity</li>
<li>存放fragment：controller.fragment</li>
<li>显示列表的适配器：controller.adapter</li>
<li>服务相关的：controller.service</li>
<li>抽取的基类：controller.base</li>
</ul>
</li>
<li><strong>View</strong> 视图层： 显示数据<ul>
<li>相关工具类：view.utils</li>
<li>自定义view：view.ui</li>
</ul>
</li>
</ul>
<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><h3 id="功能与语法"><a href="#功能与语法" class="headerlink" title="功能与语法"></a>功能与语法</h3><ul>
<li><p>在源文件中显式的使用import关键字结构<strong>导入指定包</strong>下的<strong>类、接口</strong></p>
</li>
<li><p>可以使用<code>xxx.*(通配符)方式</code>，表示可以导入xxx包下的**所有结构 **<code>import java.util.*;</code></p>
</li>
<li><p>如果使用的类或接口是<strong>java.lang包</strong>下定义的，则<strong>可以省略import</strong>结构</p>
</li>
<li><p>如果在源文件中，使用了<strong>不同包</strong>下的<strong>同名的类</strong>，则必须<strong>至少一个</strong>类需要以<strong>全类名</strong>的方式显示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若存在com.test.java1.Account与com.test.java2.Account</span></span><br><span class="line"><span class="comment">//想同时使用不同包下的Account类则至少一个使用全类名的方式使用</span></span><br><span class="line"><span class="keyword">import</span> com.test.java1;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Account acct = <span class="keyword">new</span> Account();<span class="comment">//使用了com.test.java1</span></span><br><span class="line">        <span class="comment">//通过全类名的方式指定使用</span></span><br><span class="line">        com.test.java2.Account acct2 = <span class="keyword">new</span> com.test.java2.Account();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="通配符下的子包"><a href="#通配符下的子包" class="headerlink" title="通配符下的子包"></a>通配符下的子包</h3><ul>
<li>当时用通配符方式导入包结构时，如需使用的<strong>该包下的子包的结构</strong>，则仍需要<strong>显式导入子包</strong></li>
<li>例如：</li>
<li>如存在：<code> com.test.java1 与 com.test.java1.son</code>，则son属于<code>com.test.java1</code>的子包<ul>
<li>即就算<code>import com.test.java1.*;</code>若使用<code>com.test.java1.son</code>仍需显式导入</li>
</ul>
</li>
</ul>
<h3 id="导入静态结构"><a href="#导入静态结构" class="headerlink" title="导入静态结构"></a>导入静态结构</h3><ul>
<li><p>import static:<strong>导入</strong>指定类或接口中的<strong>静态结构</strong>(非类结构)，而是静态的<strong>属性和方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如JDK中System类</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;<span class="comment">//此时所有System静态的书写和方法都被导入</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//此时使用打印语句可以省略System</span></span><br><span class="line">out.println(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承的效果"><a href="#继承的效果" class="headerlink" title="继承的效果"></a>继承的效果</h3><p><strong>继承的效果</strong>(extends：<strong>延展、扩展</strong>)：</p>
<ul>
<li>当子类继承父类后，子类就<strong>加载了</strong>(获得了)父类的<strong>所有结构</strong>(属性、方法等)(包括<strong>间接父类</strong>、包括<strong>私有结构</strong>)</li>
<li>确实是把父类的结构加载到子类了，因为每一个子类对象都是独立拥有父类的结构的</li>
<li>但<strong>当子类调用父类</strong>的结构时<strong>是受父类结构的权限修饰符影响的</strong>，即子类是<strong>无法直接调用父类私有结构</strong>(private)</li>
</ul>
<h3 id="继承的作用"><a href="#继承的作用" class="headerlink" title="继承的作用"></a>继承的作用</h3><ul>
<li><strong>减少</strong>了代码的<strong>冗余</strong>，<strong>提高</strong>了代码的<strong>复用性</strong><ul>
<li>便于<strong>功能的扩展</strong></li>
<li>为之后<strong>多态性</strong>的使用，提供了<strong>前提</strong></li>
</ul>
</li>
</ul>
<h3 id="继承的使用"><a href="#继承的使用" class="headerlink" title="继承的使用"></a>继承的使用</h3><h4 id="基础语法-1"><a href="#基础语法-1" class="headerlink" title="基础语法"></a>基础语法</h4><p><strong>继承的格式</strong>：<code>class A extends B&#123;&#125;</code>，若B is A == true ，在逻辑上符合继承</p>
<ul>
<li>A：子类、派生类、<strong>sub</strong>class</li>
<li>B：父类、超类、基类、<strong>super</strong>class</li>
</ul>
<h4 id="单继承特性"><a href="#单继承特性" class="headerlink" title="单继承特性"></a>单继承特性</h4><p><strong>Java的单继承性</strong>：一个类<strong>只能有一个父类</strong>，但可<strong>多层单继承</strong>。</p>
<ul>
<li>子类<strong>直接继承</strong>的父类称为，<strong>直接父类</strong></li>
<li>子类<strong>间接继承</strong>的父类称为，<strong>间接父类</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-java%E7%B1%BB%E5%8D%95%E7%BB%A7%E6%89%BF%E6%80%A7.jpg"
                     
                ></p>
<h3 id="根父类"><a href="#根父类" class="headerlink" title="根父类"></a>根父类</h3><ul>
<li>若一个类的没有显式继承某个父类的，则<strong>此类默认直接继承于java.lang.Object类</strong></li>
<li>因此可以说除java.lang.Object类外，<strong>所有java类</strong>都<strong>直接或间接</strong>的继承于java.lang.<strong>Object</strong>类</li>
<li>意味着，所有java类都加载了java.lang.Object类的结构，Object类也常称为<strong>根父类</strong></li>
</ul>
<h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><h4 id="重写效果"><a href="#重写效果" class="headerlink" title="重写效果"></a>重写效果</h4><p>重写(override/overwrite)</p>
<ul>
<li>当子类继承父类以后，可以<strong>对父类</strong>中<strong>同名同参</strong>的<strong>方法</strong>，进行<strong>覆盖操作</strong>(重写操作)</li>
<li>当子类重写了父类方法时，子类的方法将覆盖父类的方法，即会被优先调用子类重写过的方法</li>
</ul>
<h4 id="重写规则"><a href="#重写规则" class="headerlink" title="重写规则"></a>重写规则</h4><h5 id="重写的对象"><a href="#重写的对象" class="headerlink" title="重写的对象"></a>重写的对象</h5><ul>
<li><p><strong>只能重写方法，属性无重写一说</strong></p>
</li>
<li><p>子类定义父类的同名属性叫左把父类的同名属性“<strong>隐藏</strong>”</p>
<blockquote>
<p>若<strong>子类</strong>与<strong>父类</strong>声明<strong>同名属性</strong>，按就近原则调用同名属性</p>
<ul>
<li>即编译时的类型，左边的类型</li>
<li>多态：父类</li>
<li>子类：子类</li>
</ul>
</blockquote>
</li>
<li><p>无法重写父类<strong>private</strong>权限的方法：由于private权限的方法<strong>子类无法调用，无法感知，不存在重写</strong>。</p>
</li>
<li><p>无法重写父类<strong>static</strong>修饰的方法：static修饰的结果<strong>属于类的结构，不是类的成员</strong>。 </p>
<blockquote>
<p>且当字符类存在同名方法，而父类中声明为static时，子类必须也声明成static，但还是不属于方法重写</p>
</blockquote>
</li>
</ul>
<h5 id="重写的权限修饰符"><a href="#重写的权限修饰符" class="headerlink" title="重写的权限修饰符"></a>重写的权限修饰符</h5><ul>
<li><strong>子类重写</strong>的方法的<strong>权限修饰符范围</strong>  <strong>≥ 父类</strong>被重写方法的权限修饰符</li>
<li>即子类重写方法时<strong>不能降低原有父类方法的权限</strong>。</li>
</ul>
<h5 id="重写的返回值"><a href="#重写的返回值" class="headerlink" title="重写的返回值"></a>重写的返回值</h5><ul>
<li><strong>void</strong>类型：<strong>只能对应void</strong></li>
<li><strong>引用数据类型</strong>：被重写的返回类型为<strong>A类型</strong>，则重写的返回类型可以是<strong>A类或A类的子类</strong></li>
<li><strong>基本数据类型</strong>：重写的返回值类型<strong>必须与被重写返回类型相同</strong></li>
</ul>
<h5 id="重写的异常"><a href="#重写的异常" class="headerlink" title="重写的异常"></a>重写的异常</h5><ul>
<li><strong>子类重写</strong>的方法<strong>抛出的异常类型</strong> <strong>≤ 父类</strong>被重写的方法<strong>抛出的异常类型</strong></li>
<li>即子类重写方法抛出的异常<strong>不能越界</strong>与父类抛出的异常。</li>
</ul>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><h3 id="基本含义-1"><a href="#基本含义-1" class="headerlink" title="基本含义"></a>基本含义</h3><p>super关键字：特指父类的结构</p>
<ul>
<li><strong>可调用的结构</strong>：类this关键字，同样适用于<strong>属性、方法、构造器</strong></li>
<li>super关键字定位父类结构，默认按<strong>直接父类到间接父类一层层往上找，一旦匹配则结束</strong></li>
</ul>
<h3 id="属性与方法-1"><a href="#属性与方法-1" class="headerlink" title="属性与方法"></a>属性与方法</h3><ul>
<li><p>常用于在子类中调用<strong>父类同名的属性</strong>(属性无重写之说)</p>
</li>
<li><p>常用在子类中调用<strong>父类被重写的方法</strong></p>
<blockquote>
<ul>
<li><p>常见IDE快捷创建重写方法操作时，会默认补上一句super.method()，即对被覆盖方法的重新调用</p>
</li>
<li><p>防止某些进行了重写行为，但没有写重写方法体时，也可调用回父类被重写的方法。一种保护作用</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="构造器-2"><a href="#构造器-2" class="headerlink" title="构造器"></a>构造器</h3><ul>
<li>可以在子类的构造器中显式的使用”<code>super(形参列表)</code>“的方式，<strong>调用父类</strong>中声明的<strong>指定的重载构造器</strong></li>
<li>super对构造器的使用与this一致，必须声明在<strong>子类构造器</strong>的<strong>首行</strong></li>
<li>this与super调用构造器<strong>只能二选一</strong>，<strong>不能同时出现</strong></li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态概念"><a href="#多态概念" class="headerlink" title="多态概念"></a>多态概念</h3><ul>
<li><p><strong>从表意上看</strong>：多态是指<strong>一个事物</strong>在<strong>不同场合下</strong>具有<strong>多个不同的表现形式或形态的能力</strong></p>
</li>
<li><p><strong>代码语法层面看</strong>：</p>
<ul>
<li>多态指，<strong>父类的引用</strong>指向<strong>子类的对象</strong>，同时对<strong>父类</strong>进行<strong>虚拟方法调用</strong></li>
</ul>
<blockquote>
<p>菜鸟教程：多态就是<strong>同一个接口</strong>，使用<strong>不同的实例</strong>而<strong>执行不同操作</strong></p>
</blockquote>
<ul>
<li>多态也是<strong>引用数据类型向上转型的一个过程</strong></li>
</ul>
</li>
</ul>
<h3 id="多态使用"><a href="#多态使用" class="headerlink" title="多态使用"></a>多态使用</h3><ul>
<li><p>多态使用语法表现：<strong>父类的引用</strong>指向<strong>子类的对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编译期/编码期</strong>：<strong>只能操作父类的结构</strong>(如属性、方法等)</p>
</li>
<li><p><strong>运行期</strong>：</p>
<ul>
<li><p>属性：调用<strong>父类的属性</strong>(属性无重写即无多态 ; 可通过向下转型调用子类的内容)</p>
</li>
<li><p>方法：默认调用<strong>父类</strong>声明的方法，若方法<strong>被子类重写</strong>则<strong>调用子类重写的方法</strong>(虚拟方法调用)</p>
<blockquote>
<ul>
<li><p>一般多态的使用，主要集中在虚拟方法的调用。一般子类继承父类都常重写父类的特定方法。</p>
</li>
<li><p>因此粗略归纳多态的使用条件可以有两点</p>
<ul>
<li>类的继承关系</li>
<li>方法的重写</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>注</strong>：多态基于继承或实现方式形成。对于继承来说子类肯定是已经先加载了父类的所有结构，只是由于变量声明为父类类型，导致编译时只能调用父类声明的属性和方法</p>
<h3 id="多态的作用"><a href="#多态的作用" class="headerlink" title="多态的作用"></a>多态的作用</h3><ul>
<li><p>消除类型之间的耦合关系</p>
</li>
<li><p>可替换性</p>
</li>
<li><p>可扩充性，(自带，归类分配控制器，减少编写重载方法)</p>
</li>
<li><p>接口性</p>
</li>
<li><p>灵活性</p>
</li>
<li><p>简化性</p>
<blockquote>
<p>多态的作用与优点不仅几段文字描述，需从面向对象程序设计思想中学习多态的作用</p>
</blockquote>
</li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><ul>
<li><strong>Java类</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;动物，在进食&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;动物，在跑&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Dog，在进食&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Dog，在跑&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Cat，在进食&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Cat，在跑&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>测试类调用</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Animal a = <span class="keyword">new</span> Dog();</span><br><span class="line">		active(a);<span class="comment">//输出：Dog，在进食，Dog，在跑</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//多态的使用，只需编写一个方法，减少重载方法的编写</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">active</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">		animal.eat();</span><br><span class="line">		animal.run();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//若不使用多态</span></span><br><span class="line"><span class="comment">//	public static void active(Dog dog)&#123;</span></span><br><span class="line"><span class="comment">//		dog.eat();</span></span><br><span class="line"><span class="comment">//		dog.run();</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	public static void active(Cat cat)&#123;</span></span><br><span class="line"><span class="comment">//		cat.eat();</span></span><br><span class="line"><span class="comment">//		cat.run();</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h3><h4 id="重载-1"><a href="#重载-1" class="headerlink" title="重载"></a>重载</h4><ul>
<li><strong>重载</strong>：不表现为多态性</li>
<li>对于编译器而言，这些同名方法就成了不同的方法。在方法调用之前，<strong>编译器</strong>就已经确定了所要调用的方法，这称为“<strong>早绑定</strong>”或“<strong>静态绑定</strong>”；属于一个<strong>编译型行为</strong>。</li>
<li>Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法</li>
</ul>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><ul>
<li><strong>重写</strong>：表现为多态性</li>
<li>对于多态，只有等到方法调用的那一刻，<strong>解释运行器</strong>才会确定所要调用的具体方法</li>
<li>这样的方法调用在编译时其无法确定，称为“<strong>晚绑定</strong>”或“<strong>动态绑定</strong>”。属于一个<strong>运行时行为</strong></li>
</ul>
<blockquote>
<p>引用一句Bruce Eckel的话：“不要犯傻，如果它不是<strong>晚绑定</strong>，它就不是<strong>多态</strong>！”</p>
</blockquote>
<h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><h4 id="多态与类型转换"><a href="#多态与类型转换" class="headerlink" title="多态与类型转换"></a>多态与类型转换</h4><ul>
<li><strong>多态的从语法层面上</strong>，是一种引用数据类型<strong>向上转型的过程</strong></li>
<li><strong>相反</strong>，通过多态定义的对象，也可以通过<strong>向下转型</strong>恢复回本身的子类类型</li>
<li>多态的Java类可通过 <code>()</code>进行强制向下转型</li>
<li>向下转型后的对象是<strong>子类的引用与实例</strong>，此时则<strong>可调用子类特用的属性和方法</strong></li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE回炉-java8-多态向下上转型.jpg"
                      style="zoom: 80%;" /
                >

<h4 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h4><h5 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h5><ul>
<li><strong>只要是向下转型</strong>(强制类型转换)，无论是引用数据类型还是基本数据类型，<strong>都是存在风险的</strong><ul>
<li>基本数据类型：溢出风险</li>
<li>引用数据类型：转换类型不兼容风险</li>
</ul>
</li>
<li>通常向下转型前先用<code>instanceof</code> 关键字判别实际类型是否符合想要转换的类型</li>
<li>提前避免不兼容的类型强转，报出 ClassCastException 异常</li>
</ul>
<h5 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h5><ul>
<li><strong>功能</strong>：<code>a instanceof A</code>：判断<strong>对象a</strong>是否是<strong>类A的类型</strong>。如果是，<strong>返回true</strong>；否则返回false。</li>
<li><strong>推论</strong>：若<code>a instanceof A == true</code>，则A类及其A类<strong>所有直接间接父类</strong>(顶级父类Object)<strong>都返回true</strong><ul>
<li>因为若a是A类型，则A类型多态与它的父类或间接父类是一个很正常的合法行为</li>
</ul>
</li>
</ul>
<h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h5><ul>
<li>instanceof使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用上述例子的Animal、Dog、Cat类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Animal a = <span class="keyword">new</span> Dog();</span><br><span class="line">        <span class="comment">//强制向下转型</span></span><br><span class="line">        Dog dog = (Dog)a;<span class="comment">//通过</span></span><br><span class="line">        Cat cat = (Cat)a;<span class="comment">//报错</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;向下转型成功，此对象为Dog&quot;</span>);<span class="comment">//正常输出</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>概念练习测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//问题一：编译时通过，运行时不通过</span></span><br><span class="line">		<span class="comment">//举例一：</span></span><br><span class="line"><span class="comment">//	Person p3 = new Woman();</span></span><br><span class="line"><span class="comment">//	Man m3 = (Man)p3;</span></span><br><span class="line">	<span class="comment">//举例二：</span></span><br><span class="line"><span class="comment">//	Person p4 = new Person();</span></span><br><span class="line"><span class="comment">//	Man m4 = (Man)p4;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//问题二：编译通过，运行时也通过</span></span><br><span class="line"><span class="comment">//	Object obj = new Woman();</span></span><br><span class="line"><span class="comment">//	Person p = (Person)obj;</span></span><br><span class="line">		</span><br><span class="line">	<span class="comment">//问题三：编译不通过</span></span><br><span class="line"><span class="comment">//	Man m5 = new Woman();</span></span><br><span class="line"><span class="comment">//	String str = new Date();</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldMethodTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Sub s = <span class="keyword">new</span> Sub();</span><br><span class="line">		System.out.println(s.count);<span class="comment">//20</span></span><br><span class="line">		s.display();<span class="comment">//20</span></span><br><span class="line">		</span><br><span class="line">		Base b = s;<span class="comment">//多态性</span></span><br><span class="line">		<span class="comment">//==：对于引用数据类型来讲，比较的是两个引用数据类型变量的地址值是否相同</span></span><br><span class="line">		System.out.println(b == s);<span class="comment">//true</span></span><br><span class="line">		System.out.println(b.count);<span class="comment">//10</span></span><br><span class="line">		b.display();<span class="comment">//20</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>java.lang.Object类是所Java类的<strong>根父类</strong>，<strong>所有类</strong>的直接或间接地继承它<ul>
<li>因此Object类中的结构(属性、方法)就具<strong>通用性</strong></li>
<li>以下主要介绍Object API结构，Object<strong>没有定义属性，只有构造器和方法</strong></li>
</ul>
</li>
</ul>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h4><ul>
<li>Object类只声明了一个空参的构造器(所有对象实例化都调用)</li>
</ul>
<h4 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h4><table>
<thead>
<tr>
<th>Method</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>Object <strong>clone</strong>()</td>
<td>创建该对象的副本，即对象克隆</td>
</tr>
<tr>
<td>boolean <strong>equals</strong>(Object obj)</td>
<td>判断this对象与obj对象是否相同</td>
</tr>
<tr>
<td>void <strong>finalize</strong>()</td>
<td>对象垃圾回收之前被系统自动调用，一般不主动调用</td>
</tr>
<tr>
<td>Class&lt;?&gt; <strong>getClass</strong>()</td>
<td>返回此对象的运行时类，即对应的Class实例</td>
</tr>
<tr>
<td>int <strong>hashCode</strong>()</td>
<td>生成对象的哈希值</td>
</tr>
<tr>
<td>wait重载、notify、notifyAll</td>
<td>多线程操作相关</td>
</tr>
</tbody></table>
<p><strong>注</strong>：目前详细讲解equals和toString方法</p>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><h4 id="“-”的使用"><a href="#“-”的使用" class="headerlink" title="“==”的使用"></a>“==”的使用</h4><p>“ == ” 是一个<strong>运算符</strong>，对比<strong>数值概念上的相等</strong>，可用于<strong>基本数据类型和引用数据类型</strong></p>
<ul>
<li>基本数据类型：数学数值上是否相等</li>
<li>引用数据类型：对象的地址值是否相等，前提是比较双方<strong>类型可兼容</strong>，否则会出现<strong>编译型错误</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、基本数据类型：数值</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">10.0</span>;</span><br><span class="line">    System.out.println(i == d);<span class="comment">//输出true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、引用数据类型：地址值(数值)，此时没有重写Person的equals方法</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>,<span class="number">21</span>);</span><br><span class="line">    Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>,<span class="number">21</span>);</span><br><span class="line">    System.out.println(p1 == p2);<span class="comment">//输出false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="原生定义"><a href="#原生定义" class="headerlink" title="原生定义"></a>原生定义</h4><ul>
<li><p>Object对equals的源码实现是<strong>返回的对象等号</strong>“ <strong>==</strong> ”<strong>比较的结果</strong></p>
</li>
<li><p>即Object的equals的方法是比较<strong>两个对象</strong>的<strong>地址值是否相同</strong></p>
</li>
<li><p><strong>Object equals源码</strong>：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重写定义"><a href="#重写定义" class="headerlink" title="重写定义"></a>重写定义</h4><ul>
<li>实际开发中常对equals方法进行重写，用来比较两个引用类型<strong>实体内容</strong>是否相等，<strong>并非地址值</strong></li>
</ul>
<ul>
<li>String、Date、File、包装类等都重写了Object类中的equals()方法：被重写成<strong>实体内容</strong>是否相等</li>
<li><strong>示例代码</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、未重写Object equals()方法：等同==，比较两个引用地址值</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>,<span class="number">21</span>);</span><br><span class="line">    Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>,<span class="number">21</span>);</span><br><span class="line">    System.out.println(p1.equals(p2));<span class="comment">//输出false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、某java提供类重写了equals()实现了比较实体内容是否相等的功能</span></span><br><span class="line">    String s1 = <span class="keyword">new</span> String(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">    String s2 = <span class="keyword">new</span> String(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">    System.out.println(s1.equals(s2));<span class="comment">//输出true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里主要通过String new的方式说明源码重写了String的equals方法</span></span><br><span class="line">    <span class="comment">//但通过 == 的方式直接创建字符串会因字符串常量池原理而出现== 为true情况</span></span><br><span class="line">    <span class="comment">//String s3 = &quot;ABC&quot;;</span></span><br><span class="line">    <span class="comment">//String s4 = &quot;ABC&quot;;</span></span><br><span class="line">    <span class="comment">//System.out.println(s3 == s4);//输出true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重写范例"><a href="#重写范例" class="headerlink" title="重写范例"></a>重写范例</h4><ul>
<li>自实现，重逻辑引入，非绝对范例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3、自定义重写equals方法实现自定义类实体内容上的比较</span></span><br><span class="line"><span class="comment">//简陋版</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span> == obj) <span class="comment">//若地址一致，内容则肯定一致</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person)&#123; <span class="comment">//判断前提是类型一致，</span></span><br><span class="line">			Person anObj = (Person)obj;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name.equals(anObj.name) &amp;&amp; <span class="keyword">this</span>.age == anObj.age;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(p1.equals(p2));<span class="comment">//输出true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>IDE自动生成的标准equals</li>
<li>被生成Person类只有String name和int age属性</li>
<li>自动生成的方式equals和自编写的逻辑一直，只是其中大量使用了“<strong>判断内容先判断地址，在判断实体</strong>”的优化操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eclipse自动生成equals方法(标准高效参考)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Person other = (Person) obj;</span><br><span class="line">    <span class="keyword">if</span> (age != other.age)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.name != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>String的equals源码重写范例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line"> 		<span class="comment">//1、若引用地址都一样，则内容肯定一样(重写equals通用代码)</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    	<span class="comment">//2、若与String比较的传入类型不是String，则不允许，返回false</span></span><br><span class="line">   <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">           String anotherString = (String)anObject;</span><br><span class="line">       <span class="keyword">int</span> n = value.length;<span class="comment">//String底层通过char [] value;数组存储</span></span><br><span class="line">           <span class="comment">//3、若字符序列的长度都不一样，则内容肯定不一样</span></span><br><span class="line">           <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">               <span class="keyword">char</span> v1[] = value;</span><br><span class="line">               <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">               <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">               <span class="comment">//4、挨个字符比较</span></span><br><span class="line">             <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                   i++;</span><br><span class="line">             &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重写要求"><a href="#重写要求" class="headerlink" title="重写要求"></a>重写要求</h4><ul>
<li><strong>Null-false</strong>：任何情况下，x.equals(null)，永远返回是“false” </li>
<li><strong>类型一致</strong>：x.equals(和x不同类型的对象)永远返回是“false”</li>
<li><strong>对称性</strong>：如果x.equals(y)返回是“true” ，那么y.equals(x)也应该返回是 “true”<ul>
<li><strong>自反性</strong>：x.equals(x)必须返回是“true”</li>
<li><strong>传递性</strong>：如果x.equals(y)返回是“true” ，而且y.equals(z)返回是“true” ， 那么z.equals(x)也应该返回是“true”</li>
<li><strong>一致性</strong>：如果x.equals(y)返回是“true” ，只要x和y内容一直不变，不管你 重复x.equals(y)多少次，返回都是“true”</li>
</ul>
</li>
</ul>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><h4 id="原生定义-1"><a href="#原生定义-1" class="headerlink" title="原生定义"></a>原生定义</h4><ul>
<li>Object对equals的源码实现是返回返回<strong>对象</strong>的<strong>字符串表示形式</strong></li>
<li>即返回对象的<strong>类名 + 所在堆空间存储地址</strong>(虚拟地址)</li>
<li><strong>Object toString源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//类名 + 堆空间存储地址(通过hashCode计算出来数值并转换为十六进制的)</span></span><br><span class="line">   <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重写定义-1"><a href="#重写定义-1" class="headerlink" title="重写定义"></a>重写定义</h4><ul>
<li>实际开发中常对toString方法进行重写，用于<strong>打印引用类型实体的内容</strong>(一般为全部属性)</li>
<li>像String、Date、File、等都重写了toString()方法，<strong>Date重写后就输出时间内容</strong></li>
<li>IDE对自定义类重写toString方式示例代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="print与toString"><a href="#print与toString" class="headerlink" title="print与toString"></a>print与toString</h4><ul>
<li><p>其中，System.out.<strong>println</strong>(引用数据类型)，输出语句<strong>底层也是调用对象的toString方法</strong></p>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;ABV&quot;</span>, <span class="number">10</span>);</span><br><span class="line">System.out.println(p1); <span class="comment">//输出：com.yhd.test.Person@15db9742</span></span><br><span class="line">System.out.println(p1.toString()); <span class="comment">//输出：com.yhd.test.Person@15db9742</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p><strong>源码分析</strong>：</p>
<ol>
<li><p>先将所有类型即Object类型通过String.valueOf()都转换为字符串类型</p>
</li>
<li><p>在String.valueOf()方法中调用了对象的toString()方法</p>
</li>
</ol>
<hr>
<ul>
<li>PrintStream.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">      String s = String.valueOf(x); <span class="comment">//主要通过调用了String.valueOf();</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            print(s);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>String.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (obj == <span class="keyword">null</span>) ? <span class="string">&quot;null&quot;</span> : obj.toString();<span class="comment">//调用了toString()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li>由于Java推出时倡导就是万物皆对象，基本数据类型显得格格不入</li>
<li>为了使基本数据类型的变量<strong>具有类的特征</strong>。java提供8种基本数据类型的包装类</li>
<li>这些包装类可以完成对应基本数据类型的所有功能操作(都含对应基本数据类型的value属性)。</li>
<li>同时因为封装成类，<strong>还可提供各种丰富的方法调用</strong></li>
<li>包装类的作用小结如下两点：<ol>
<li>使基本数据类型具有类的特征</li>
<li>由于封装成类，可提供各种丰富方法调用</li>
</ol>
</li>
</ul>
<p><strong>注</strong>：包装类的出现<strong>不能也不是为了改变基本数据类型在java方法中只能通过return来修改内容的特性</strong></p>
<blockquote>
<ul>
<li>这种特性的源泉也不能完全是java语法特性所造成，这是大部分语言的共性(由于形参是局部变量)</li>
<li>c语言可以通过方法修改基本数据类型只是因为，c语言与&amp;指针操作符，通过传递其种子达到修改能指针指向的内容，本质还是因为形参是局部变量而不能改变指针的引用。</li>
</ul>
</blockquote>
<h3 id="包装类类型"><a href="#包装类类型" class="headerlink" title="包装类类型"></a>包装类类型</h3><ul>
<li>除int对应Integer和char对应Charactet，其他基本数据类型的包装类均为其首字母大写 </li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-%E5%8C%85%E8%A3%85%E7%B1%BB.png"
                     
                ></p>
<h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><ul>
<li>装箱：从基本数据类型转换为包装类类型</li>
<li>拆箱：从包装类类型转换为基本数据类型</li>
<li>jdk5的时候退出了自动拆箱与装箱的功能</li>
</ul>
<h4 id="装箱与自动装箱"><a href="#装箱与自动装箱" class="headerlink" title="装箱与自动装箱"></a>装箱与自动装箱</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、基本数据类型 ——&gt; 包装类</span></span><br><span class="line"><span class="comment">//1、手动装箱：构造器封装/创建</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">Integer itg1 = <span class="keyword">new</span> Integer(i);</span><br><span class="line">Integer itg2 = <span class="keyword">new</span> Integer(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="comment">//Integer itg3 = new Integer(&quot;2B&quot;);//异常：数字格式/匹配异常</span></span><br><span class="line">System.out.println(<span class="string">&quot;itg1: &quot;</span> + itg1 + <span class="string">&quot; , itg2：&quot;</span> + itg2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、自动装箱</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">Integer j_itg = j;</span><br><span class="line">System.out.println(<span class="string">&quot;j_itg: &quot;</span> + j_itg);</span><br></pre></td></tr></table></figure>

<h4 id="拆箱与自动拆箱"><a href="#拆箱与自动拆箱" class="headerlink" title="拆箱与自动拆箱"></a>拆箱与自动拆箱</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2、包装类 ——&gt; 基本数据类型(多种类型)</span></span><br><span class="line"><span class="comment">//1、手动拆箱：调用包装类的 xxxValue();方法</span></span><br><span class="line">Float flt = <span class="keyword">new</span> Float(<span class="number">1F</span>);</span><br><span class="line"><span class="keyword">float</span> f = flt.floatValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、自动拆箱</span></span><br><span class="line"><span class="keyword">float</span> f2 = flt;</span><br></pre></td></tr></table></figure>

<h4 id="String之间的转换"><a href="#String之间的转换" class="headerlink" title="String之间的转换"></a>String之间的转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、[数值型] —— &gt; String</span></span><br><span class="line">    <span class="comment">//方式1：与空串 &quot;&quot; 进行连接运算</span></span><br><span class="line">    String s1 = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式2：调用String重载的valueOf(XXX xxx) 重载方法</span></span><br><span class="line">    String s2 = String.valueOf(i);<span class="comment">//基本数据类型</span></span><br><span class="line">    s2 = String.valueOf(itg1);<span class="comment">//包装类/obj多态传入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式3：调用包装类的toStrin方法</span></span><br><span class="line">    s2 = itg1.toString();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、String ——&gt; [数值型]</span></span><br><span class="line">    <span class="comment">//方式1：调用包装类parseXxx()方法</span></span><br><span class="line">    String s3 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> num1 = Integer.parseInt(s3);</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：除了boolean，其他有关字符串的装拆箱，与转换若存在字符匹配问题都会报错，需注意</p>
<h3 id="Integer缓存"><a href="#Integer缓存" class="headerlink" title="Integer缓存"></a>Integer缓存</h3><ul>
<li>Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[]，保存了从-128~127范围的整数</li>
<li>如果我们使用自动装箱的方式，给Integer赋值的范围在-128~127范围内时，</li>
<li>可以直接使用Integer[]数组中的元素，不用再去new了，从而达到节省内存消耗</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    Integer m = <span class="number">1</span>;</span><br><span class="line">    Integer n = <span class="number">1</span>;</span><br><span class="line">    System.out.println(m == n);<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意，如果数值不一样是肯定不一样的</span></span><br><span class="line">    Integer a = <span class="number">210</span>;</span><br><span class="line">    Integer b = <span class="number">211</span>;</span><br><span class="line">    System.out.println(a == b);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    Integer x = <span class="number">128</span>;</span><br><span class="line">    Integer y = <span class="number">128</span>;</span><br><span class="line">    System.out.println(x == y);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[],</span></span><br><span class="line"><span class="comment">//  保存了从-128~127范围的整数。如果我们使用自动装箱的方式，给Integer赋值的范围在</span></span><br><span class="line"><span class="comment">//  -128~127范围内时，可以直接使用数组中的元素，不用再去new了。目的：提高效率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Integer m = 1; //-128~127范围内相当于同一个数组地址</span></span><br><span class="line"><span class="comment">//  Integer n = 1;</span></span><br><span class="line"><span class="comment">//  Integer x = 128;//相当于new了一个Integer对象</span></span><br><span class="line"><span class="comment">//  Integer y = 128;//相当于new了一个Integer对象</span></span><br></pre></td></tr></table></figure>

<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><strong>可修饰结构</strong>：属性、方法、代码块、内部类</li>
<li>被static修饰的结构称为<strong>类结构</strong>，随着<strong>类的加载而加载</strong>(加载要<strong>早于对象的创建</strong>)</li>
<li>由于随类的加载而加载，因此无需实例化对象也可以<strong>直接通过类名</strong>进行调用”<code>类.静态结构</code>“</li>
<li>由于<strong>类只会加载一次</strong>，因此对应的<strong>静态结构也只会加载一份</strong>，存放在<strong>方法区的静态域</strong>中。因此所有类及其对象都共用一份</li>
</ul>
<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><ul>
<li>被static修饰的变量称为<strong>静态变量</strong>或<strong>类变量</strong>，</li>
<li>由于<strong>类只会加载一次</strong>，则静态变量在内存中也<strong>只会存在一份</strong></li>
<li>由于只存在一份，因此静态变量将会被<strong>同一个类多个对象共用</strong><ul>
<li>静态属性举例：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    PrintStream out = System.out;</span><br><span class="line">    <span class="keyword">double</span> pi = Math.PI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态资源的内存结构</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE回炉-静态变量内存解析.jpg"
                      style="zoom:80%;" /
                >

<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul>
<li>同样随着类的加载而加载，可以通过”<code>类.静态方法</code>“的方式进行调用</li>
<li>在<strong>静态方法</strong>中，<strong>只能</strong>调用<strong>静态的方法或属性</strong>，而(因为静态方法和属性比对象<strong>加载的早</strong>)<ul>
<li>同理：在静态的方法内，<strong>不能使用this关键字、super</strong>关键字(因为这些都是创建对象使用的关键字)</li>
</ul>
</li>
<li><strong>非静态方法</strong>中，<strong>既可</strong>以调用非静态的方法或属性，<strong>也可</strong>以调用静态的方法或属性</li>
</ul>
<h3 id="static应用场景"><a href="#static应用场景" class="headerlink" title="static应用场景"></a>static应用场景</h3><h4 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h4><ul>
<li>当属性是可以被多个<strong>对象共享</strong>的，<strong>不会随着对象的不同而不同</strong>的</li>
<li>类中的<strong>常量</strong>也常常声明为static</li>
</ul>
<h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><ul>
<li><strong>操作静态属性</strong>的方法，通常设置为static的</li>
<li><strong>工具类</strong>中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections</li>
</ul>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><h5 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h5><ul>
<li><strong>单例模式</strong>：采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例</li>
<li>常见的单例模式含，懒汉式、饿汉式</li>
</ul>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><ol>
<li><p>若让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为<strong>private</strong></p>
</li>
<li><p>这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象</p>
</li>
<li><p>因为在类的外部开始还无法得到类的对象，只能调用该类的<strong>某个静态方法</strong>以返回类内部创建的对象</p>
</li>
<li><p><strong>静态方法只能访问类中的静态成员变量</strong>，所以，指向类内部产生的该类对象的变量也必须定义成静态的</p>
<hr>
</li>
</ol>
<ul>
<li><strong>两种单例模式编写</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、(简单/不安全)懒汉式：什么时候用，什么时候创建</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//1、构造器私有化</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Bank instance;<span class="comment">//2、静态化</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="comment">//2、静态化</span></span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">			instance = <span class="keyword">new</span> Bank();</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、饿汉式：不管什么，先创建再说</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//1、构造器私有化</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">new</span> Order();<span class="comment">//2、直接实例化(静态只有一份)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="单例模式间对比"><a href="#单例模式间对比" class="headerlink" title="单例模式间对比"></a>单例模式间对比</h5><ul>
<li><strong>饿汉式</strong>：<ul>
<li>缺点：对象加载时间过长</li>
<li>优点：线程安全</li>
</ul>
</li>
<li><strong>懒汉式</strong>：<ul>
<li>缺点：目前写法线程不安全(两个线程挤入if == null)，<strong>可以改写为线程安全</strong></li>
<li>优点：延迟对象的创建</li>
</ul>
</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>网站的计数器，一般也是单例模式实现，否则难以同步</li>
<li>应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志 文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加</li>
<li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源</li>
<li>项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置 文件数据，都生成一个对象去读取</li>
<li>Application 也是单例的典型应用</li>
<li>Windows的Task Manager (任务管理器)就是很典型的单例模式</li>
<li>Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程 中，回收站一直维护着仅有的一个实例。</li>
</ul>
<h2 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>main()方法作为<strong>程序的入口</strong></li>
<li>main()方法也是一个普通的静态方法</li>
<li>main()方法可以作为我们与控制台<strong>交互的方式，即将控制台获取的数据传入main函数形参</strong>String[] args</li>
</ul>
<h3 id="eclipse参数输入"><a href="#eclipse参数输入" class="headerlink" title="eclipse参数输入"></a>eclipse参数输入</h3><ol>
<li>在允许程序的Run As一项，选中<strong>Run Configurations</strong></li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-eclipse%E6%96%B9%E5%BC%8F%E4%B8%8Emain%E5%BD%A2%E5%8F%82%E4%BA%A4%E4%BA%921.jpg"
                     
                ></p>
<ol start="2">
<li>如下图所示操作，并在Program arguments里输入参数</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-eclipse%E6%96%B9%E5%BC%8F%E4%B8%8Emain%E5%BD%A2%E5%8F%82%E4%BA%A4%E4%BA%922.jpg"
                     
                ></p>
<h3 id="控制台参数输入"><a href="#控制台参数输入" class="headerlink" title="控制台参数输入"></a>控制台参数输入</h3><ul>
<li><p>直接在控制台java指令最后最加内容，默认就是字符串，不用写双引号也行。</p>
</li>
<li><p>多个参数同样用逗号隔开</p>
</li>
<li><p>注意：记事本方式javac编译需把 packeage 代码去掉</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE回炉-控制台方式与main形参交互.jpg"
                      style="zoom:150%;" /
                >

</li>
</ul>
<h3 id="输入参数获取"><a href="#输入参数获取" class="headerlink" title="输入参数获取"></a>输入参数获取</h3><h4 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h4><ul>
<li>main函数中的<code>String[]args</code>字符数组就是以此存放用户输入的参数的</li>
<li>按一般数组处理，可以通过<code>args[0]</code>获取到第一个输入参数</li>
<li>注意，为防止角标越界，获取指定位置参数时，先判断用户是否输入了这么多参数，即判断数组length</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul>
<li>控制台用户指向命令有：<code> java -jar TestJava.jar Tom Jerry 123 true</code></li>
<li>程序后台获取的结果为</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sysout(args[<span class="number">0</span>]);<span class="comment">//&quot;Tom&quot;</span></span><br><span class="line">sysout(args[<span class="number">3</span>]);<span class="comment">//&quot;true&quot;  --&gt;Boolean.parseBoolean(args[3]);</span></span><br><span class="line">sysout(args[<span class="number">4</span>]);<span class="comment">//报异常,角标越界</span></span><br></pre></td></tr></table></figure>

<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h3 id="功能与作用"><a href="#功能与作用" class="headerlink" title="功能与作用"></a>功能与作用</h3><ul>
<li><p>代码块的作用，用来<strong>初始化类、对象的信息</strong></p>
<blockquote>
<p>初始化类、对象信息不是构造器负责的吗？为什么还要代码块？</p>
</blockquote>
</li>
<li><p>与构造器相比，<strong>代码块应用场景</strong>在于<strong>类的内部私有化构造器后</strong>，用于<strong>顶替构造器的地位用于初始化</strong>，或在外部调用的情况下进行初始化</p>
</li>
</ul>
<h3 id="创建代码块"><a href="#创建代码块" class="headerlink" title="创建代码块"></a>创建代码块</h3><ul>
<li><strong>代码块使用</strong>：如同方法一般的声明位置，格式为<code>&#123;&#125;</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非静态代码块"><a href="#非静态代码块" class="headerlink" title="非静态代码块"></a>非静态代码块</h3><ul>
<li>随着<strong>对象的创建而执行</strong>，每创建一次执行一次，且在构造器执行前执行</li>
<li><strong>多个非静态代码块</strong>，则<strong>按声明的先后顺序执行</strong>(一般只写一个)</li>
</ul>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><h4 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><p>代码块只能被static关键字修饰</p>
</li>
<li><p>静态代码块，<strong>随着类的加载</strong>而执行，<strong>即只执行一次</strong></p>
</li>
<li><p>类中定义了多个静态代码块，则按照声明的先后顺序执行(一般只写一个)</p>
</li>
<li><p>static修饰类同性质</p>
<ul>
<li>静态代码块随类的加载而加载一次，非静态随对象创建而加载</li>
<li>静态代码块的执行要优先于非静态代码块的执行</li>
<li>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</li>
<li>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</li>
</ul>
</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>静态代码块，常用于给<strong>静态方法</strong>提供的看似为”<strong>静态构造器</strong>“的作用，完成一种静态的初始化(一次性初始化)</li>
<li>示例场景：JdbcUtils中静态代码块的使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如JDBC连接池</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//一次性初始化/实例化，DataSource 数据库连接池</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		InputStream is = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			is = DBCPTest.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;);</span><br><span class="line">			Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">			pros.load(is);</span><br><span class="line">			<span class="comment">//调用BasicDataSourceFactory的静态方法，获取数据源。</span></span><br><span class="line">			dataSource = BasicDataSourceFactory.createDataSource(pros);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(is != <span class="keyword">null</span>)&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					is.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//使用DBCP数据库连接池获取数据库的连接</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">		Connection conn = dataSource.getConnection();</span><br><span class="line">		System.out.println(conn);</span><br><span class="line">		<span class="keyword">return</span> conn;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="再谈对象实例化顺序"><a href="#再谈对象实例化顺序" class="headerlink" title="再谈对象实例化顺序"></a>再谈对象实例化顺序</h3><ul>
<li>无论使静态还是非静态，<strong>代码块</strong>都在<strong>构造器前</strong>执行</li>
<li>由父及子，静态先行</li>
<li><strong>代码块属性赋值执行顺序</strong>：系统初始化 —&gt; 显示初始化 / <strong>代码块初始化</strong> —&gt; 构造器初始化 —&gt;外部调用初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java3;</span><br><span class="line"><span class="comment">//总结：由父及子，静态先行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Root</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的无参数的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mid</span> <span class="keyword">extends</span> <span class="title">Root</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的无参数的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		<span class="comment">//通过this调用同一类中重载的构造器</span></span><br><span class="line">		<span class="keyword">this</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的带参数构造器，其参数值：&quot;</span></span><br><span class="line">			+ msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Mid</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//通过super调用父类中有一个字符串参数的构造器</span></span><br><span class="line">		<span class="keyword">super</span>(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeafTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Leaf(); </span><br><span class="line">		System.out.println();</span><br><span class="line">		<span class="keyword">new</span> Leaf();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果如下：</span></span><br><span class="line"><span class="comment">Root的静态初始化块</span></span><br><span class="line"><span class="comment">Mid的静态初始化块</span></span><br><span class="line"><span class="comment">Leaf的静态初始化块</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Root的普通初始化块</span></span><br><span class="line"><span class="comment">Root的无参数的构造器</span></span><br><span class="line"><span class="comment">Mid的普通初始化块</span></span><br><span class="line"><span class="comment">Mid的无参数的构造器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Mid的带参数构造器，其参数值：尚硅谷</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Leaf的普通初始化块</span></span><br><span class="line"><span class="comment">Leaf的构造器</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul>
<li>final关键字译为“最终”，可修饰结构含<strong>类、方法、变量</strong></li>
<li>final与不同修饰结构结合后具有类同的概念和功能</li>
</ul>
<h3 id="final-Class"><a href="#final-Class" class="headerlink" title="final Class"></a>final Class</h3><ul>
<li>被final修饰的类，即为“<strong>最终的类</strong>”，不能再被延续传承下去</li>
<li>即final修饰的类<strong>不能被其他类所继承</strong>(无子类)</li>
<li>常用于表示该类已经功能完全，没有继承和重写的意义，常见有内置的API定义成final</li>
<li>如，String类、System类、StringBuffer类都定义成了final</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final-Method"><a href="#final-Method" class="headerlink" title="final Method"></a>final Method</h3><ul>
<li>被final修饰的方法，即为“<strong>最终的方法</strong>”，不能再被延续扩充了</li>
<li>被final修饰的的方法<strong>不可以被重写</strong></li>
<li>如：Object类中getClass()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final-Field"><a href="#final-Field" class="headerlink" title="final Field"></a>final Field</h3><h4 id="基本概念-5"><a href="#基本概念-5" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>被final修饰的变量，即为“<strong>最终的变量</strong>”，不能再被修改</li>
<li>被final修饰的变量称为<strong>常量</strong>，必须提供初始化且不能被修改，只能被使用</li>
<li>而变量又有类成员变量、和局部变量</li>
</ul>
<h4 id="静态属性-1"><a href="#静态属性-1" class="headerlink" title="静态属性"></a>静态属性</h4><h5 id="类中的初始化结构"><a href="#类中的初始化结构" class="headerlink" title="类中的初始化结构"></a>类中的初始化结构</h5><ul>
<li>在类的结构中，有3种初始化结构：显式初始化、代码块中初始化、构造器中初始化</li>
<li>因此静态属性必须在3种结构之一得到初始化</li>
</ul>
<h4 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h4><h5 id="局部变量-1"><a href="#局部变量-1" class="headerlink" title="局部变量"></a>局部变量</h5><ul>
<li><strong>必须显式初始化</strong>，只能使用，不能重新赋值</li>
</ul>
<h5 id="形参局部变量"><a href="#形参局部变量" class="headerlink" title="形参局部变量"></a>形参局部变量</h5><ul>
<li>新参采用final修饰，表示<strong>方法体内</strong>对该变量<strong>只能使用，不能重新赋值</strong></li>
<li>可以修饰基本数据类型，引用类型的形参</li>
</ul>
<ul>
<li><strong>示例代码</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本数据类型形参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="comment">//i++; //报错，只能使用不能赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用数据类型形参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">(<span class="keyword">final</span> Person p)</span></span>&#123;</span><br><span class="line">    p.age++;<span class="comment">//通过</span></span><br><span class="line">    p = <span class="keyword">new</span> Person();<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static-final"><a href="#static-final" class="headerlink" title="static final"></a>static final</h3><p>static final 同时修饰结为两个关键字效果之和</p>
<ul>
<li><strong>属性</strong>：全局(静态)常量，比较常见</li>
<li><strong>方法</strong>：静态方法且不可重写</li>
</ul>
<h2 id="抽像类"><a href="#抽像类" class="headerlink" title="抽像类"></a>抽像类</h2><h3 id="基本概念-6"><a href="#基本概念-6" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>abstract译为“抽象”，可修饰，<strong>类、方法</strong>结构</p>
<hr>
</li>
<li><p>abstract自身是“抽象化”的代表，是不能够直接使用，不提供具体的内容</p>
</li>
<li><p>它的存在就是被用来给子类将其从抽象化概念至变为实际的存在的概念</p>
</li>
<li><p>因此<strong>abstract只能修饰</strong>在<strong>能被其他类</strong>(子类)<strong>感知的领域</strong>，反之即<strong>abstract不能修饰如下</strong>：</p>
<ul>
<li><p><strong>final的类</strong>：任何类都无法继承，不能对其提供实现。那样的抽象只有抽象本身，没有意义了</p>
</li>
<li><p><strong>private方法</strong>：子类无法感知，更加无法重写(实现)</p>
</li>
<li><p><strong>final的方法</strong>：不允许方法的重写(实现)</p>
</li>
<li><p><strong>static方法</strong>：不属于继承范畴，是类本身的结构</p>
</li>
</ul>
</li>
</ul>
<h3 id="abstract-class"><a href="#abstract-class" class="headerlink" title="abstract class"></a>abstract class</h3><h4 id="基本概念-7"><a href="#基本概念-7" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><p>被修饰成abstract的类称为<strong>抽象类</strong></p>
</li>
<li><p>抽象类<strong>不能实例化，但也有构造器</strong>，用于维持子类继承抽象类时实例化调用</p>
</li>
<li><p>由于抽象类本身不能被实例化，因此开发中，都会<strong>提供抽象类的子类</strong>，让子类继承抽象类进行操作</p>
</li>
<li><p><strong>除此之外，抽象类和普通类一样</strong>，可以定义一般类的成员，如，属性、方法、代码块…</p>
</li>
<li><p>也和普通类一样具备面向对象的一般操作，如继承，多态，子类自身实例化等等</p>
</li>
<li><p>假设Person是抽象类</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person p = new Person();//不允许</span></span><br><span class="line">Person p = <span class="keyword">new</span> Man();<span class="comment">//允许，假设class Man extends Person </span></span><br><span class="line">Man m = <span class="keyword">new</span> Man();<span class="comment">//允许</span></span><br></pre></td></tr></table></figure>

<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li><p>抽象类的使用<strong>具备继承特性</strong>，<strong>可多态特性</strong>，以及<strong>抽象方法特性</strong></p>
</li>
<li><p>由于抽象类被子类所继承才由存在意义，因此抽象类自身具有绝对的继承关系</p>
</li>
<li><p>由于抽象类还可具备抽象方法，这使得抽象类比普通的父类从基于继承特性来设计类的角度上，具备比普通父类更高层次的概念抽象设计。即可定义一些抽象类本身从概念上完全无法实现，只能由子类实现的抽象方法</p>
</li>
<li><p>其次绝对的继承关系，为后续在使用多态特性提供了绝对的支持</p>
</li>
</ul>
<h3 id="abstract-method"><a href="#abstract-method" class="headerlink" title="abstract method"></a>abstract method</h3><h4 id="基本概念-8"><a href="#基本概念-8" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><p>被abstract修饰的方法称为<strong>抽象方法</strong></p>
</li>
<li><p>抽象方法<strong>只有声明，没有方法体</strong>：<code>public abstract void eat();</code></p>
</li>
<li><p><strong>抽象方法只能声明在抽像类中</strong>。反之，抽象类中可以没有抽象方法的</p>
</li>
<li><p>继承抽象类的子类<strong>必须强制实现</strong>(重写)抽象父类中的<strong>所有的抽象方法</strong>，若<strong>子类也是抽象</strong>类则不用</p>
</li>
</ul>
<h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul>
<li>抽象方法只能在抽象类中定义，因此都是结合抽象类使用的</li>
<li>抽象方法使其抽象类可定义一些抽象类本身从概念上完全无法实现，只能由子类实现的抽象方法</li>
<li>能够提供更加抽象的抽象设计</li>
</ul>
<h3 id="匿名继承子类"><a href="#匿名继承子类" class="headerlink" title="匿名继承子类"></a>匿名继承子类</h3><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽线类Person</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//书写步骤：Person p = new Person()&#123;&lt;回车&gt;&#125;;</span></span><br><span class="line"><span class="comment">//创建一个匿名子类对象(其实是通过多态的一种方式实现了匿名实例化)</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个匿名子类的匿名对象</span></span><br><span class="line"><span class="comment">//书写：method(new Person()&#123;&lt;回车&gt;&#125;);</span></span><br><span class="line">method(<span class="keyword">new</span> Person()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="类的设计领域"><a href="#类的设计领域" class="headerlink" title="类的设计领域"></a>类的设计领域</h4><ul>
<li>在类设计领域，抽象类的核心在于结合抽象方法提供<strong>比普通父类更高抽象化的设计</strong></li>
<li>如上所述的抽象类与抽象方法的作用的基础上，对类进行设计</li>
<li>IO流中涉及到的抽象类：InputStream/OutputStream / Reader /Writer。在其内部<br>定义了抽象的read()、write()方法。</li>
<li>Servlet API 中GenericServlet的过渡与整合设计</li>
</ul>
<h4 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h4><h5 id="基本概念-9"><a href="#基本概念-9" class="headerlink" title="基本概念"></a>基本概念</h5><ul>
<li>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模 板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式</li>
<li>当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以 把不确定的部分暴露出去，让子类去实现。</li>
<li>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用， 这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽 象出来，供不同子类实现。这就是一种模板模式</li>
</ul>
<h5 id="程序允许时间模板示例"><a href="#程序允许时间模板示例" class="headerlink" title="程序允许时间模板示例"></a>程序允许时间模板示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		TemplateSub ts = <span class="keyword">new</span> TemplateSub();</span><br><span class="line">		ts.spendTime();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模板方法设计模式体现</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">spendTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		code();<span class="comment">//易变部分，不确认部分</span></span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;运行时间：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemplateSub</span> <span class="keyword">extends</span> <span class="title">Template</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j=<span class="number">0</span>;i &lt; <span class="number">100000</span>;i++)</span><br><span class="line">			j+=j;</span><br><span class="line">		System.out.println(<span class="string">&quot;代码执行中...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="业务流程模板示例"><a href="#业务流程模板示例" class="headerlink" title="业务流程模板示例"></a>业务流程模板示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类的应用：模板方法的设计模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethodTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		BankTemplateMethod btm = <span class="keyword">new</span> DrawMoney();</span><br><span class="line">		btm.process();</span><br><span class="line"></span><br><span class="line">		BankTemplateMethod btm2 = <span class="keyword">new</span> ManageMoney();</span><br><span class="line">		btm2.process();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTemplateMethod</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 具体方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;取号排队&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">transact</span><span class="params">()</span></span>; <span class="comment">// 办理具体的业务 //钩子方法</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evaluate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;反馈评分&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模板方法，把基本操作组合到一起，子类一般不能重写</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.takeNumber();</span><br><span class="line">		<span class="keyword">this</span>.transact();<span class="comment">// 像个钩子，具体执行时，挂哪个子类，就执行哪个子类的实现代码</span></span><br><span class="line">		<span class="keyword">this</span>.evaluate();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DrawMoney</span> <span class="keyword">extends</span> <span class="title">BankTemplateMethod</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我要取款！！！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManageMoney</span> <span class="keyword">extends</span> <span class="title">BankTemplateMethod</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我要理财！我这里有2000万美元!!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h5><p>模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的 影子，比如常见的有：</p>
<ul>
<li>数据库访问的封装</li>
<li>Junit单元测试</li>
<li>JavaWeb的Servlet中关于doGet/doPost方法调用</li>
<li>Hibernate中模板程序</li>
<li>Spring中JDBCTemlate、HibernateTemplate等</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="概念与作用"><a href="#概念与作用" class="headerlink" title="概念与作用"></a>概念与作用</h3><h4 id="类的设计角度"><a href="#类的设计角度" class="headerlink" title="类的设计角度"></a>类的设计角度</h4><p>有时须从几个类中抽取出一些共同的<strong>行为特征</strong>，而它们之间又<strong>没有is-a的关系</strong>，仅仅是具有<strong>通用的行为特征</strong>而已，此时就把这种行为特征定义成接口，比在内部声明这些行为</p>
<ul>
<li><p>由若干个类构成的类型概念范畴中的共同<strong>行为特征</strong></p>
</li>
<li><p>接口与这些类之间<strong>没有</strong>“<strong>is-a</strong>”的关系，即<strong>接口和类没有直接关系</strong></p>
</li>
<li><p>若由关系则应该定义成类或者其父类的内部结构，如属性、方法等，不应该定义成接口</p>
</li>
<li><p>反过来说，即<strong>定义成接口</strong>概念的事物必须<strong>在一定的类型概念范畴中</strong>，<strong>具备绝对的概念上的通用性</strong></p>
</li>
<li><p>继承是一个”<strong>是不是</strong>“的关系，而接口实现则是 “<strong>能不能</strong>“ 的关系</p>
</li>
<li><p>接口的本质是<strong>契约，标准，规范</strong>，是您<strong>支持这种功能</strong>所必须具备的一种<strong>规范的集合体</strong></p>
<ul>
<li>如你像实现打羽毛球的接口，那你必须实现打羽毛球这个行为能力所具备的其他行为的集合</li>
<li>如实现打羽毛球接口，必须实现里面所有的规范/方法，比如含<code>羽毛球发球抽象方法()</code>、<code>羽毛球回球的抽象方法</code>等等，此时当实现完这些规范的集合时，你就真正地具备类这种功能，这种行为</li>
</ul>
<hr>
</li>
<li><p>注意，接口<strong>不能理解为抽象类的更高抽象化层次表现</strong>，<strong>它们之间不是同一类概念</strong>。</p>
</li>
<li><p>同类一概念，或者说基于同一概念上衍生的出来的概念，应该是普通父类与抽象类之间的关系，而不是接口与抽象类之间的关系。接口和抽象类两者从概念上，定义上无任何关系。</p>
<blockquote>
<ul>
<li>其实太过注重语法从而导致无法真正掌握接口和普通类得概念是一个意料之外有情理之中的表现</li>
<li>由于初学课程介绍知识讲授时，秉持以先掌握“实”再掌握“形”的正确理念。</li>
<li>为了更容易建立语法体系与区分语法概念，常会以普通父类到抽线类，再到接口。从有构造器可实例化，到有构造器没实例化，到无构造器无实例化。这样的一个递进关系去解释</li>
<li>这就让初学者很容易陷入，它们之间就是一种递进关系。</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>小结</strong>：接口是“<strong>能不能</strong>”的概念，是一种在一定范畴内<strong>通用的行为特征</strong>所应具备的<strong>规范的集合体</strong></p>
<h4 id="语法层面"><a href="#语法层面" class="headerlink" title="语法层面"></a>语法层面</h4><ul>
<li><strong>错误逻辑</strong>是，单从语法层面上理解，Java具备允许多实现，但只能单继承的特性</li>
<li>但我们不能就语法层面特性与区别，反过来去推到和理解接口和继承的含义</li>
<li><strong>正确的逻辑</strong>应该是，<strong>因接口和继承类本身从概念上的不同，从而决定了接口能够多实现，而类只能单继承</strong></li>
</ul>
<h4 id="接口设计示例"><a href="#接口设计示例" class="headerlink" title="接口设计示例"></a>接口设计示例</h4><h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-%E6%8E%A5%E5%8F%A3%E4%B8%BE%E4%BE%8B01.jpg"
                     
                ></p>
<h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/javaSE%E5%9B%9E%E7%82%89-%E6%8E%A5%E5%8F%A3%E4%B8%BE%E4%BE%8B02.jpg"
                     
                ></p>
<h3 id="接口的语法定义"><a href="#接口的语法定义" class="headerlink" title="接口的语法定义"></a>接口的语法定义</h3><ul>
<li>接口使用<strong>interface</strong>关键字来定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口定义上的语法体现"><a href="#接口定义上的语法体现" class="headerlink" title="接口定义上的语法体现"></a>接口定义上的语法体现</h3><h4 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h4><ul>
<li><p>因秉持正确的逻辑推断，即由接口的本质去推断接口的结构与语法，即</p>
</li>
<li><p>接口是“<strong>能不能</strong>”的概念，是一种在一定范畴内<strong>通用的行为特征</strong>所应具备的<strong>规范的集合体</strong></p>
</li>
</ul>
<h4 id="接口不是类的概念，更加没有继承关系"><a href="#接口不是类的概念，更加没有继承关系" class="headerlink" title="接口不是类的概念，更加没有继承关系"></a>接口不是类的概念，更加没有继承关系</h4><ul>
<li><strong>接口不存在实例化</strong>，因为接口是一种规范的集合体，本身是一种规范，是给别人实现的规范。本身就不是类和对象的概念。</li>
<li>同时接口从概念上就脱离了继承的概念，因此<strong>接口不存在构造器</strong></li>
</ul>
<h4 id="如何定义接口的规范"><a href="#如何定义接口的规范" class="headerlink" title="如何定义接口的规范"></a>如何定义接口的规范</h4><ul>
<li><p>接口通过<strong>抽象方法的定义</strong>来使实现类从语法层面必须基于规范的实现</p>
</li>
<li><p>由于接口就是规范的集合体，本身就以为被别人实现而存在</p>
</li>
<li><p>因此接口中的规范(抽象方法)，一定是能够被别人所感知的</p>
</li>
<li><p>因此接口中的抽象方法必有，<code>public abstract</code>的修饰</p>
<hr>
</li>
<li><p>由于接口中的抽象方法具有统一的修饰，因此定义抽象方法时省略<code>public abstract</code></p>
</li>
<li><p>即<code>public abstract void  method();</code>等价于<code> void method()</code></p>
</li>
</ul>
<h4 id="接口是行为特征"><a href="#接口是行为特征" class="headerlink" title="接口是行为特征"></a>接口是行为特征</h4><ul>
<li>接口不像类，不是会与实现类/子类构成继承层面上的关系</li>
<li>接口知识行为特征的规范集合体，而一个类可以拥有多个行为特征，这是合理的</li>
<li>因此Java中的<strong>接口可以多实现，即一个类可实现多个接口</strong></li>
</ul>
<h3 id="非概念性语法"><a href="#非概念性语法" class="headerlink" title="非概念性语法"></a>非概念性语法</h3><h4 id="描述接口自身的结构"><a href="#描述接口自身的结构" class="headerlink" title="描述接口自身的结构"></a>描述接口自身的结构</h4><ul>
<li>java从语法角度上支持了除抽象方法外其他结构在接口中的定义，使其接口自身描述更丰富</li>
</ul>
<table>
<thead>
<tr>
<th>JDK Version</th>
<th>Support Structure</th>
</tr>
</thead>
<tbody><tr>
<td>JDK 1</td>
<td>public static final field;</td>
</tr>
<tr>
<td>JDK 8</td>
<td><strong>public static</strong> xxx <strong>mehtod</strong>(){}<br><strong>default</strong> xxx method(){}</td>
</tr>
<tr>
<td>JDK 9</td>
<td><strong>private</strong> xxx method(){}</td>
</tr>
</tbody></table>
<h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><p>java允许在接口中定义属性，但<strong>只能是全局静态常量属性</strong>，即<code>public static final</code></p>
<ul>
<li><p><strong>public staic</strong>：接口不具备继承特性，定义的属性不能被实现类所继承，因此只供描述接口自身使用</p>
</li>
<li><p><strong>final</strong>：接口本身是规范的集合，可变的属性违背了接口的定义，同时也不具备使用的价值</p>
<hr>
</li>
<li><p>由于接口属性只能是全局静态常量属性，因此<code>public static final</code>可省略</p>
</li>
<li><p>即<code>public static final int MAX;</code>等价于<code>int MAX;</code></p>
</li>
<li><p>全局静态常量可通过接口名直接调用，<code>Interface.field;</code></p>
</li>
</ul>
<h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><ol>
<li><strong>public static xxxx method</strong><ul>
<li>java为了便于<strong>接口对应的工具类合并</strong>，以后不用再另外新建(如Collection与Collections)</li>
<li>想通过接口本身充当接口的工具类，因此提供了静态方法</li>
<li>例如JDK8可以将Collection与Collections工具类提供的静态方法合并一起</li>
</ul>
</li>
<li>(public) <strong>default xxxx method</strong><ul>
<li>default不是静态方法，它需<strong>通过实现类的对象才可调用</strong>，属于一个<strong>白给的方法</strong>，不能理解为继</li>
<li>default方法<strong>可以被实现类重写</strong></li>
<li>若实现类又继承了一个父类，而且存在与接口default的同名方法，优先调用父类的</li>
<li>default还要研究，只为了某些便利性？</li>
</ul>
</li>
<li><strong>private  xxx method</strong><ul>
<li>private方法只能有接口内部调用</li>
<li>其实从可以default方法开始，private方法就应该可定义</li>
<li>因为当接口中有明确的方法体的方法可创建时，如default方法。就应该与之对应开放出代码封装的功能，即去实现代码复用的效果</li>
<li>static方法显然不能作为封装代码的表现，default又有特殊含义，因此只能开放private方法供接口内部方法体编写时用于实现代码封装与复用</li>
<li>因此猜测是属于一种新特性支持没考虑周全的表现</li>
</ul>
</li>
</ol>
<h4 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h4><ul>
<li>接口通过让实现类以<strong>implements</strong>关键字方式实现接口</li>
<li>当实现类实习某个接口时，<strong>必须实现该接口定义的所有规范</strong>(抽象方法)</li>
</ul>
<h4 id="接口多态性"><a href="#接口多态性" class="headerlink" title="接口多态性"></a>接口多态性</h4><ul>
<li><strong>接口和类</strong>是从语法角度上是<strong>并列</strong>的</li>
<li>此时可以通过让<strong>接口引用指向实现类的对象</strong>，来形成多态性</li>
<li>类同普通类的多态效果<ul>
<li>编译时：调用接口中定义的方法</li>
<li>运行时：执行实现类实现的方法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="接口间的继承"><a href="#接口间的继承" class="headerlink" title="接口间的继承"></a>接口间的继承</h4><ul>
<li>接口可以通过extends关键字继承父接口</li>
<li>当子接口继承父接口后，子接口拥有父接口的所有结构，且不要求子接口实现的抽象方法</li>
<li>java中<strong>接口</strong>实际<strong>支持多继承</strong></li>
</ul>
<h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><ul>
<li><strong>接口和类</strong>是从语法角度上是<strong>并列</strong>的，均只能<strong>public 和 缺省</strong>两种修饰符修饰</li>
</ul>
<h3 id="匿名实现类"><a href="#匿名实现类" class="headerlink" title="匿名实现类"></a>匿名实现类</h3><ul>
<li><strong>接口匿名实现类</strong>：同抽象类的匿名实现类创建方式</li>
</ul>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="类的设计领域-1"><a href="#类的设计领域-1" class="headerlink" title="类的设计领域"></a>类的设计领域</h4><ul>
<li>接口对于类的设计，反应客观世界的新的关系具有非常重要的作用</li>
<li>是面向对象程序设计不可或缺的概念</li>
</ul>
<h4 id="相关设计模式"><a href="#相关设计模式" class="headerlink" title="相关设计模式"></a>相关设计模式</h4><h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h5><ul>
<li>安全代理：屏蔽对真实角色的直接访问</li>
<li>远程代理：通过代理类处理远程方法调用（RMI） </li>
<li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象 比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有 100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理 模式，当需要查看图片时，用proxy来进行大图片的打开。 </li>
<li>分类 <ul>
<li>静态代理（静态定义代理类） </li>
<li>动态代理（动态生成代理类）<ul>
<li>JDK自带的动态代理，需要反射等知识</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><ul>
<li>工厂模式指让创建对象的工作交付给一个类</li>
<li>而且可以通过设置工厂类的某些参数定制化地自动地产生对应的定制化的类</li>
<li>就如同工厂一般，能按照用户的需求进行生产</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="基本概念-10"><a href="#基本概念-10" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>当一个事物的内部，还有一个部分需要一个完整的结构进行描述，</li>
<li>且这个内部的结构又只为该事物提供服务，那么整个内部的完整结构最好使用内部类封装</li>
</ul>
<h3 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h3><p>内部类是类的成员变量的一份子，可以变量在类中的不同定义来区分不同类型的内部类</p>
<ul>
<li><strong>成员变量</strong>：属性(成员内部类)<ul>
<li>非静态成员变量：属性(非静态内部类)</li>
<li>静态变量：类变量(静态内部类)<ul>
<li><strong>局部变量</strong>：方法、构造器、代码块内</li>
<li>局部内部类</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>示例代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestInClass</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//非静态成员内部类</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员内部类</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BB</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">EE</span></span>&#123;<span class="comment">//局部内部类</span></span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TestInClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//局部内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">CC</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#123;	<span class="comment">//局部内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">DD</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="成员内部"><a href="#成员内部" class="headerlink" title="成员内部"></a>成员内部</h3><h4 id="基本概念-11"><a href="#基本概念-11" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>作为外部类的成员(属性理解)：<ul>
<li>可以<strong>调用外部类</strong>的结构</li>
<li>可以<strong>被static修饰</strong>(外部类-普通类不可以)</li>
<li>可以被<strong>4种权限修饰符修饰</strong>(普通类只有缺省和public)</li>
<li>作为类：拥有普通类的常见情况<ul>
<li>类内可以定义属性、方法、构造器等</li>
<li>可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</li>
<li>可以被abstract修饰</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><ul>
<li><strong>实例化成员内部类</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建静态的Dog内部类的实例(静态的成员内部类):</span></span><br><span class="line">Person.Dog dog = <span class="keyword">new</span> Person.Dog();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建非静态的Bird内部类的实例(非静态的成员内部类):</span></span><br><span class="line"><span class="comment">//Person.Bird bird = new Person.Bird();//错误的</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person.Bird bird = p.<span class="function">new <span class="title">Bird</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="内部类与外部类同名属性调用"><a href="#内部类与外部类同名属性调用" class="headerlink" title="内部类与外部类同名属性调用"></a>内部类与外部类同名属性调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	String name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//非静态成员内部类</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">		String name = <span class="string">&quot;杜鹃&quot;</span>;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		System.out.println(name);<span class="comment">//方法的形参</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);<span class="comment">//内部类的属性</span></span><br><span class="line">        System.out.println(Person.<span class="keyword">this</span>.name);<span class="comment">//外部类的属性</span></span><br><span class="line">        <span class="comment">//Person.this.eat();</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>在局部内部类的方法中的调用方法的局部变量话,要求此局部变量声明为final的。</p>
<ul>
<li>jdk 7及之前版本：要求此局部变量显式的声明为final的</li>
<li>jdk 8及之后的版本：可以省略final的声明</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="comment">//num = 20;//错误，num默认为final</span></span><br><span class="line">				System.out.println(num);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回内部类实例方法定义"><a href="#返回内部类实例方法定义" class="headerlink" title="返回内部类实例方法定义"></a>返回内部类实例方法定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个实现了Comparable接口的类的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Comparable <span class="title">getComparable</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//创建一个实现了Comparable接口的类:局部内部类</span></span><br><span class="line">	<span class="comment">//方式一：</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MyComparable</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> MyComparable();</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//方式二：</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Comparable()&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部类字节码文件"><a href="#内部类字节码文件" class="headerlink" title="内部类字节码文件"></a>内部类字节码文件</h3><p>成员内部类和局部内部类，在编译以后，都会生成字节码文件</p>
<ul>
<li>成员内部类：<code>外部类$内部类名.class</code></li>
<li>局部内部类：<code>外部类$数字 内部类名.class</code></li>
</ul>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="异常概述"><a href="#异常概述" class="headerlink" title="异常概述"></a>异常概述</h2><ul>
<li>在Java语言中，将程序执行中发生的<strong>不正常情况</strong>称为“异常” (开发过程中的语法错误和逻辑错误不是异常)。</li>
<li>运行中所发生的异常事件可分为：<strong>Error</strong>、<strong>Exception</strong> 两种异常</li>
</ul>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>Java虚拟机<strong>无法解决的严重问题</strong>。如：JVM系统内部错误、资源 耗尽等严重情况。比如：StackOverflowError和OOM。<strong>一般不编写</strong>针对性的代码进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1、栈溢出：java.lang.StackOverflowError</span></span><br><span class="line">		<span class="comment">//通过死循环调用方法使其申请无限个形参(局部变量)，</span></span><br><span class="line">        <span class="comment">//由于局部变量是存放在栈空间，所以会引发栈溢出错误</span></span><br><span class="line">		<span class="comment">//main(args);</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2、堆溢出：java.lang.OutOfMemoryError，new出来的内容均存放在堆空间</span></span><br><span class="line">		Integer[] arr = <span class="keyword">new</span> Integer[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p><strong>因编程错误</strong>或偶然的<strong>外在因素</strong>导致的一般性问题，<strong>可以</strong>使用针对性的代码<strong>进行处理</strong>。(无特别说明，以下异常均指Exception)</p>
<ul>
<li>空指针访问</li>
<li>试图读取不存在的文件</li>
<li>网络连接中断</li>
<li>数组角标越界等</li>
</ul>
<h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><p>异常可分为<strong>编译时异常</strong>和<strong>运行时异常</strong></p>
<ul>
<li>捕获错误最理想的是在<strong>编译期间</strong>(可预知的异常)，</li>
<li>但有些错误<strong>只有在运行时才发生</strong>。 比如：除数为0，数组下标越界等，叫做运行时错误</li>
</ul>
<h2 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h2><p>异常体系结构均为类，且均为继承关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* java.lang.Throwable</span><br><span class="line">* 		|-----java.lang.Error:一般不编写针对性的代码进行处理。</span><br><span class="line">* 		|-----java.lang.Exception:可以进行异常的处理</span><br><span class="line">* 			|------编译时异常(checked)</span><br><span class="line">* 					|-----IOException</span><br><span class="line">* 						|-----FileNotFoundException</span><br><span class="line">* 					|-----ClassNotFoundException</span><br><span class="line">* 			|------运行时异常(unchecked,RuntimeException)</span><br><span class="line">* 					|-----NullPointerException</span><br><span class="line">* 					|-----ArrayIndexOutOfBoundsException</span><br><span class="line">* 					|-----ClassCastException</span><br><span class="line">* 					|-----NumberFormatException</span><br><span class="line">* 					|-----InputMismatchException</span><br><span class="line">* 					|-----ArithmeticException</span><br></pre></td></tr></table></figure>

<ul>
<li>图示1</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png"
                     
                ></p>
<ul>
<li>API图示1：Exception</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210401113307.png"
                     
                ></p>
<ul>
<li>API图示2：RuntimeException</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210401113534.png"
                     
                ></p>
<h2 id="常见异常-1"><a href="#常见异常-1" class="headerlink" title="常见异常"></a>常见异常</h2><h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><table>
<thead>
<tr>
<th>运行时异常</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>NullPointerException</td>
<td>空指针异常</td>
</tr>
<tr>
<td>ArrayIndexOutOfBoundsException</td>
<td>数组角标越界</td>
</tr>
<tr>
<td>StringIndexOutOfBoundsException</td>
<td>字符串角标越界</td>
</tr>
<tr>
<td>ClassCastException</td>
<td>类型转换异常</td>
</tr>
<tr>
<td>NumberFormatException</td>
<td>数字格式异常</td>
</tr>
<tr>
<td>InputMismatchException</td>
<td>输入不匹配异常</td>
</tr>
<tr>
<td>ArithmeticException</td>
<td>算术异常</td>
</tr>
</tbody></table>
<ul>
<li><strong>示例代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//******************以下是运行时异常***************************</span></span><br><span class="line"><span class="comment">//NullPointerException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//int[] arr = null;</span></span><br><span class="line">    <span class="comment">//System.out.println(arr[3]);</span></span><br><span class="line">    String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    str = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(str.charAt(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">//StringIndexOutOfBoundsException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//ArrayIndexOutOfBoundsException</span></span><br><span class="line">    <span class="comment">//int[] arr = new int[10];</span></span><br><span class="line">    <span class="comment">//System.out.println(arr[10]);</span></span><br><span class="line">    <span class="comment">//StringIndexOutOfBoundsException</span></span><br><span class="line">    String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    System.out.println(str.charAt(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ClassCastException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Date();</span><br><span class="line">    String str = (String)obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NumberFormatException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> num = Integer.parseInt(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InputMismatchException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> score = scanner.nextInt();</span><br><span class="line">    System.out.println(score);<span class="comment">//当输入非int类型时</span></span><br><span class="line">    scanner.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ArithmeticException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    System.out.println(a / b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//******************以下是编译时异常***************************</span></span><br><span class="line"><span class="comment">//如下代码逻辑合语法均没错误</span></span><br><span class="line"><span class="comment">//但IDE会提示存在IOException、FileNotFoundException等编译时异常</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">	File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">	FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> data = fis.read();</span><br><span class="line">	<span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">		System.out.print((<span class="keyword">char</span>)data);</span><br><span class="line">		data = fis.read();</span><br><span class="line">	&#125;</span><br><span class="line">	fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常的产生与处理"><a href="#异常的产生与处理" class="headerlink" title="异常的产生与处理"></a>异常的产生与处理</h2><h3 id="异常的产生"><a href="#异常的产生" class="headerlink" title="异常的产生"></a>异常的产生</h3><p>异常的产生，又叫异常的抛出，有两种情况都就抛出异常，注意下面两种异常都能被用户捕获。</p>
<ol>
<li>运行时异常，由系统隐式自动抛出</li>
<li>编译时异常，由用户手动throw抛出，也可以理解为用户自定义的异常</li>
</ol>
<hr>
<ul>
<li>捕获运行时异常，由系统隐式抛出。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-01 10:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TestException-method方法执行开始&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">12</span> / <span class="number">0</span>;<span class="comment">//运行时异常，出现异常后，系统默认抛出异常，是可被捕获的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;TestException-method方法执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            method();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;捕获到异常：&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><p>java中异常的处理有两种：</p>
<ol>
<li>catch捕获异常处理</li>
<li>throws把异常抛出处理，让上一级调用者处理。(不作为也是一种作为)</li>
</ol>
<h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><p><strong>引言</strong>：在编写程序时，经常要在可能出现错误的地方加上检测的代码， 如进行x/y运算时，要检测分母为0，数据为空，输入的不是数据 而是字符等。<strong>过多的if-else分支</strong>会导致程序的代码<strong>加长、臃肿， 可读性</strong>差。因此采用异常处理机制。</p>
<p>Java采用的异常处理机制是将异常处理的程序代码<strong>集中在一起</strong>， 与正常的程序代码分开，使得程序简洁、优雅，并易于维护。</p>
<h3 id="抓抛模型"><a href="#抓抛模型" class="headerlink" title="抓抛模型"></a>抓抛模型</h3><h4 id="“抛”"><a href="#“抛”" class="headerlink" title="“抛”"></a>“抛”</h4><ul>
<li>程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应的<strong>异常类的对象</strong>，并将此对象抛出。<strong>一旦抛出异常对象</strong>以后，<strong>其后的代码就不再执行</strong>。</li>
<li>关于异常对象的产生<ol>
<li>系统自动生成的异常对象</li>
<li>手动的生成一个异常对象，并抛出（throw）</li>
</ol>
</li>
</ul>
<h4 id="“抓”"><a href="#“抓”" class="headerlink" title="“抓”"></a>“抓”</h4><ul>
<li>“<strong>抓</strong>“：可以理解为<strong>异常的处理方式</strong>：① try-<strong>catch</strong>-finally  ② throws</li>
</ul>
<h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">//可能出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="comment">//处理异常的方式1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line">	<span class="comment">//处理异常的方式2</span></span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">finally</span>&#123;<span class="comment">//可选项</span></span><br><span class="line">	<span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h4><ol>
<li>try-catch-finally中：<strong>至少</strong>try-catch或<strong>try-finally</strong>(此时异常属于<strong>未处理状态</strong>)，<strong>至多</strong>try-catch-finally。</li>
<li>使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，<strong>去catch中进行匹配</strong>。一旦<strong>匹配到某一个</strong>catch时则<strong>不再匹配</strong>，随之进入匹配的catch中进行异常的处理，<strong>处理完</strong>毕后<strong>继续执行其后的代码</strong>。（没有写finally的情况）</li>
<li>catch中的异常类型如果<strong>没有子父类关系</strong>，则声明次序无关。</li>
<li>catch中的异常类型如果<strong>满足子父类关系</strong>，则要求<strong>子类</strong>一定声明<strong>在父类的上面</strong>。<strong>否则，报错</strong></li>
<li>常用的<strong>异常对象</strong>的调用的方法<ol>
<li>String  getMessage()：打印异常基本描述信息</li>
<li>printStackTrace()：打印异常所涉及的整个堆栈调用信息</li>
</ol>
</li>
<li>在try结构中声明的变量，再出了try结构以后，就不能再被调用</li>
<li>try-catch-finally结构<strong>可嵌套</strong></li>
</ol>
<hr>
<p>finally结构说明：</p>
<ol>
<li>finally是可选的。</li>
<li>finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中return语句，catch中return语句等情况，finally都会被执行。</li>
<li>注意：从第2点可以看出，若try-catch中出现return语句，<strong>finally是在return之前执行</strong>的。因此<strong>若finally中出现return语句，肯定是整个方法的return结果</strong></li>
<li>如像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。</li>
</ol>
<hr>
<p>小结：</p>
<ul>
<li><p>使用try-catch-finally处理编译时异常，是得程序在<strong>编译时就不再报错</strong>，但是运<strong>行时仍可能报错</strong>。</p>
<ul>
<li>相当于我们使用try-catch-finally将一个编译时可能出现的异常，<strong>延迟到运行时出现</strong>。</li>
<li>开发中，<strong>运行时异常</strong>一般只能重新构造代码逻辑，不针异常编写try-catch-finally了(没用)</li>
<li>对于<strong>编译时异常</strong>，则一定要考虑异常的处理。</li>
</ul>
</li>
</ul>
<h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h3><h4 id="语法说明-1"><a href="#语法说明-1" class="headerlink" title="语法说明"></a>语法说明</h4><p>语法格式：<code>throws 异常类型1,异常类型2...</code></p>
<ol>
<li>“throws + 异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。<br>一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象<strong>满足throws</strong>后异常类型时，就会<strong>被抛出</strong>。<strong>异常代码后续的代码，就不再执行！</strong></li>
<li>throws的方式只是将异常抛给了方法的调用者。并没有真正将异常处理掉</li>
</ol>
<hr>
<ol>
<li>子类重写的方法抛出的异常类型<strong>小于或等于</strong>父类被重写的方法抛出的异常类型</li>
<li>子类重写的方法的<strong>异常处理方式</strong>必须与父类处理异常的方式<strong>一致</strong>。</li>
</ol>
<ul>
<li><p>try-catch-finally真正的将异常给处理掉了。</p>
</li>
<li><p>throws方式只是将异常抛给了方法的调用者。并没真正将异常处理掉。 </p>
</li>
<li><p>开发中异常处理的选择：</p>
<ol>
<li><p>在执行某个方法A时，这个方法内又递归地调用的几个方法，而且这几个被调用的方法都可能存在异常。则建议内部几个被递归调用的方法都采用throws，总的方法A采用try-catch的方式处理。</p>
<ul>
<li>如下，方法float method 中递归地调用了三个方法，递归地调用指如method1返回值拿去调用method2返回的值又再给method3调用。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210404212904.png"
                     
                ></p>
<ul>
<li>由于这种递归调用的方式，若在method1、2、3中使用try-catch方式处理，则会出现某个被带哦用的方法出现了异常，确实被处理了，代码也继续执行，但返回的值已经不能供下一个方法正常执行。所以在这种递归地调用方法结构上过早地通过try-catch处理调异常并非是件好事。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="手动抛出异常对象-throw"><a href="#手动抛出异常对象-throw" class="headerlink" title="手动抛出异常对象-throw"></a>手动抛出异常对象-throw</h2><p><strong>tips：throws</strong>是<strong>异常处理</strong>的一种方式，而<strong>throw</strong>是<strong>创建异常</strong>的关键字。其实当系统发现异常时，默认自动执行的操作就是throw操作。</p>
<h3 id="语法要求"><a href="#语法要求" class="headerlink" title="语法要求"></a>语法要求</h3><p>语法：在方法内<code>throw 异常类</code></p>
<p>一般选择抛出<strong>Exception</strong>(含编译与运行时异常)或运行时异常<strong>RuntimeException</strong>，或<strong>自定义异常类</strong>。抛出时通过使用这些异常类的重载构造器(如带参描述)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;i &lt; 0&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="需求场景模拟"><a href="#需求场景模拟" class="headerlink" title="需求场景模拟"></a>需求场景模拟</h3><ul>
<li>没有通过抛出异常处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	如下限制Person的age必须&gt;0，若采用传统的if-else无法达到效果</span></span><br><span class="line"><span class="comment">	因为即使断绝了age的赋值，age都会以默认初始化值为0(非法)继续</span></span><br><span class="line"><span class="comment">	执行，无法有效断绝非法数据的执行。如下代码效果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Person p = <span class="keyword">new</span> Person();</span><br><span class="line">		p.setAge(-<span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;age：&quot;</span> + p.getAge());</span><br><span class="line">		System.out.println(<span class="string">&quot;代码继续执行.....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(age &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">this</span>.age = age;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;输入非法数据&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>打印结果如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入非法数据</span><br><span class="line">age：0</span><br><span class="line">代码继续执行.....</span><br></pre></td></tr></table></figure>

<ul>
<li>异常处理方式1：抛出<strong>运行时异常</strong>，编译的时候setAge()方法无需对异常处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Person p = <span class="keyword">new</span> Person();</span><br><span class="line">		p.setAge(-<span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;age：&quot;</span> + p.getAge());</span><br><span class="line">		System.out.println(<span class="string">&quot;代码继续执行.....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(age &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;运行时异常：非法年龄输入&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>打印结果如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: 运行时异常：非法年龄输入</span><br><span class="line">at com.test.java.Person.setAge(ThrowTest.java:19)</span><br><span class="line">at com.test.java.ThrowTest.main(ThrowTest.java:7)</span><br></pre></td></tr></table></figure>

<ul>
<li>异常处理方式2：抛出<strong>异常</strong>，编译的时候setAge()会检查到异常，需即刻对异常进行处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Person p = <span class="keyword">new</span> Person();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			p.setAge(-<span class="number">1</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;age：&quot;</span> + p.getAge());</span><br><span class="line">			System.out.println(<span class="string">&quot;代码继续执行.....&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(age &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;运行时异常：非法年龄输入&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>打印结果如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Exception: 运行时异常：非法年龄输入</span><br><span class="line">at com.test.java.Person.setAge(ThrowTest.java:24)</span><br><span class="line">at com.test.java.ThrowTest.main(ThrowTest.java:8)</span><br></pre></td></tr></table></figure>

<h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><ul>
<li>如何自定义异常类？<ol>
<li>继承于<strong>现有的异常结构</strong>：常用<strong>RuntimeException</strong> 、<strong>Exception</strong></li>
<li>提供全局常量：<strong>serialVersionUID</strong>，用于序列化传输时唯一标识当前类</li>
<li>提供<strong>重载的构造器</strong></li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7034897193246939L</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="资源加载与JVM"><a href="#资源加载与JVM" class="headerlink" title="资源加载与JVM"></a>资源加载与JVM</h1><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><h3 id="作用角度上"><a href="#作用角度上" class="headerlink" title="作用角度上"></a>作用角度上</h3><ol>
<li><strong>局部变量</strong>：方法体构造体内、形参、代码块内</li>
<li><strong>成员变量</strong><ul>
<li>非静态成员变量：属性</li>
<li>静态成员变量：类变量</li>
</ul>
</li>
</ol>
<h4 id="局部变量-2"><a href="#局部变量-2" class="headerlink" title="局部变量"></a>局部变量</h4><ul>
<li>局部变量指：方法体、构造器体内定义的变量，方法构造器的形参、代码块内定义的变量</li>
<li>局部变量随着所在结构被调用时申请空间，并在该结构调用结束后释放</li>
</ul>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><h5 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h5><ul>
<li>属性使定义在类中的，方法体外的非静态变量</li>
<li>随着对象的创建而创建，随着对象的销毁而销毁</li>
</ul>
<h5 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h5><ul>
<li>类变量是指static静态修饰的类属性</li>
<li>随着类的加载而被加载</li>
</ul>
<h3 id="数据类型上"><a href="#数据类型上" class="headerlink" title="数据类型上"></a>数据类型上</h3><ol>
<li>基本数据类型：byte、short/char、int、long、float、double…</li>
<li>引用数据类型：数组、String、各种自定义类<ul>
<li>引用数据类型比基本数据类型多一个实体引用，即地址值</li>
</ul>
</li>
</ol>
<h2 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h2><h3 id="声明与初始化-1"><a href="#声明与初始化-1" class="headerlink" title="声明与初始化"></a>声明与初始化</h3><h4 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h4><ul>
<li>变量的声明是指，仅定义了变量名，但未为其赋值的操作</li>
<li>如基本数据类型变量的声明</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num;</span><br></pre></td></tr></table></figure>

<ul>
<li>引用数据类型的声明</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream ips;</span><br></pre></td></tr></table></figure>

<h4 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h4><ul>
<li>变量的初始化即为变量声明后赋值上一个初始值</li>
<li>基本数据类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1，先声明后初始化/赋值</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2，声明同时初始化/赋值</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>引用数据类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="局部变量-3"><a href="#局部变量-3" class="headerlink" title="局部变量"></a>局部变量</h3><ul>
<li><p>在java中的<strong>局部变量没有默认初始值</strong>，必须<strong>先声明再使用</strong></p>
</li>
<li><p>即局部变量必须<strong>显式初始化后</strong>(赋值)才能使用(运算/调用)够使用</p>
</li>
<li><p><strong>否则是无法通过编译的，报编译错误</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    System.out.println(num);<span class="comment">//编译阶段就不通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h3><p>当用户<strong>没有显式初始化时</strong>，<strong>成员变量是具有默认的初始值</strong></p>
<table>
<thead>
<tr>
<th>成员变量类型</th>
<th>具体类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>整数型</td>
<td>byte、short、int、long</td>
<td>0</td>
</tr>
<tr>
<td>浮点型</td>
<td>float、double</td>
<td>0.0</td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
<td>0 或 ‘\u0000’</td>
</tr>
<tr>
<td>布尔型</td>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>引用数据类型</td>
<td>类、数组</td>
<td>null</td>
</tr>
</tbody></table>
<h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><p>Java程序加载流程：<strong>编译</strong> 、一个或多个<strong>字节码文件</strong>(class) 、JVM<strong>类加载器</strong>和<strong>解析器</strong>进行<strong>解析运行</strong></p>
<ul>
<li><strong>虚拟机堆</strong>(heap)：存放<strong>非静态引用数据类型的实体</strong>，如<strong>数组的内容</strong>、<strong>对象实例</strong>的结构(含<strong>非static属性</strong>)</li>
<li><strong>虚拟机栈</strong>(stack)：存放<strong>局部变量</strong>、<strong>对象的引用</strong></li>
<li><strong>方法区</strong>(method area)：存储虚拟机已加载的、<strong>类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>编译后的代码</strong></li>
<li>本地方法栈(native method stack)：</li>
<li>程序计数器(PC)：</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/jdk8_JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.jpg"
                     
                ></p>
<h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><h3 id="实例化对象加载过程"><a href="#实例化对象加载过程" class="headerlink" title="实例化对象加载过程"></a>实例化对象加载过程</h3><h4 id="为什么要向上加载"><a href="#为什么要向上加载" class="headerlink" title="为什么要向上加载"></a>为什么要向上加载</h4><p>在学习面向对象过程中提及子类实例化的构造器必须调用父类构造器，为什么要调用父类构造器？</p>
<ul>
<li><p>由于java是支持面向对象程序设计，具备支持类的继承特性</p>
</li>
<li><p>当<strong>子类继承与父类</strong>时，<strong>子类就需拥有了直接父类与所有间接父类的所有结构</strong></p>
</li>
<li><p>此时，子类实例化时就要求必须<strong>加载父类的资源</strong>，每一个子类对象都是独自占有父类资源的</p>
</li>
<li><p>而<strong>实例化一个类的资源</strong>，使用的<strong>就是构造器</strong></p>
</li>
<li><p>而且除了加载直接父类外，还有间接父类，即对于父类来说的直接父类…一直延续到Object根父类</p>
</li>
<li><p>Object类是所有类的根父类，仅提供了一个空参构造器，作为上层加载的终点</p>
</li>
<li><p>其次，<strong>任何类都需要向上加载</strong>，因为即使没有显式地继承其他类，但也默认继承了Object类</p>
<ul>
<li>如Object中定义的方法，任何类都要加载</li>
</ul>
<hr>
</li>
<li><p>虽然创建子类对象时，调用了许多父类的构造器，但<strong>自始至终只创建过一个对象</strong>，即为new的子类对象。调用父类构造器只是加载父类结构的过程，而并非实例化父类</p>
</li>
<li><p>例如如下</p>
<ul>
<li>Dog继承了Animal，Animal继承了Creature，Creature继承了Object的内存加载</li>
<li>则<code>Dog dog = new Dog(&quot;小花&quot;,&quot;小红&quot;);</code>在堆空间加载的资源状况如下</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yihangdeng/blogImage/raw/master/img/20210701204516.png"
                     
                ></p>
</li>
</ul>
<p><strong>结论</strong>：<strong>由于继承特性</strong>，<strong>任何类都需加载直接父类</strong>继承的资源。而<strong>加载资源的渠道</strong>就是调用<strong>上层构造器</strong>。</p>
<h4 id="如何进行向上加载"><a href="#如何进行向上加载" class="headerlink" title="如何进行向上加载"></a>如何进行向上加载</h4><p>通过上述可知，<strong>任何类都需加载上层资源</strong>，具体就是<strong>调用直接父类的构造器</strong></p>
<ul>
<li><p>因此，Java编译时期就要求任何类的构造器都需要<strong>隐式或显式地，加载直接父类的资源</strong>、即调用构造器</p>
</li>
<li><p>当用户没有<strong>显式声明类的构造器时，系统默认提供一个空参构造器</strong></p>
<blockquote>
<ul>
<li>向上加载直接父类的资源，不要求一定是调用空参构造器，只要能绝对地成功调用父类构造器进行资源加载即可。</li>
<li>可以隐式地加载，也可以显式地super()加载，反正就至少有一个构造器能够调用直接父类的构造器</li>
</ul>
</blockquote>
</li>
<li><p>再而任何构造器的首行若没有使用<code>this(空参或形参)或super(形参)</code>显式调用其他构造器时，系统默认都在构造器的首行隐含了一句<code>super()</code>，<strong>即默认都调用父类的空参构造器</strong></p>
</li>
<li><p>由以上种种机制辅助下加编译时的检查，确保任何类都能够直接调用直接父类的构造器</p>
</li>
</ul>
<h2 id="资源的加载顺序"><a href="#资源的加载顺序" class="headerlink" title="资源的加载顺序"></a>资源的加载顺序</h2><ul>
<li>虽然实例化加载资源的<strong>代表是构造器</strong>的调用，但实际加载资源中<strong>构造器是最后被调用的</strong><ol>
<li>系统申请变量空间，<strong>提供属性的默认初始化值</strong>，多个属性按声明顺序初始化</li>
<li>加载<strong>显式初始化的赋值</strong>，多个属性按声明顺序初始化</li>
<li>调用<strong>代码块</strong>进行初始化，<strong>多个代码块按声明顺序调用</strong></li>
<li>调用构造器进行初始化，若<strong>静态资源加载没有构造器调用这一步</strong></li>
</ol>
</li>
</ul>
<h2 id="静态资源的优先加载"><a href="#静态资源的优先加载" class="headerlink" title="静态资源的优先加载"></a>静态资源的优先加载</h2><ul>
<li><p>静态资源并非在实例化对象时加载，而是<strong>随着类的加载而加载</strong>，即<strong>在实例化之前加载</strong></p>
</li>
<li><p>因此<strong>静态资源又称为类的结构</strong>，如静态属性、静态方法又称为类属性、类方法</p>
</li>
<li><p>由于<strong>类只会加载一遍</strong>，因此<strong>静态的资源也只会加载一份</strong>，同一个类的<strong>多个对象是共享这些静态资源</strong>的</p>
<hr>
</li>
<li><p><strong>类的加载时机是当用户首次操作该类时，系统将其自动加载</strong>，含多种情况</p>
<ul>
<li><strong>情况1</strong>：首次操作只调用了类的静态资源，则<strong>只加载了类而没有进行实例化</strong></li>
<li><strong>情况2</strong>：首次操作是类的对象实例化，则<strong>先进行了类的加载，再进行对象的初始化</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.java;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-30 22:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;value = &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//情况1：只加载了类，没有实例化过对象</span></span><br><span class="line">        <span class="comment">//此时就已经加载了类结构与，静态属性value和静态方法showValue</span></span><br><span class="line">        String str = Person.value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//情况2：先进行类的加载，在进行实例化(注意此时是情况1代码不存在时)</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="完整的加载流程"><a href="#完整的加载流程" class="headerlink" title="完整的加载流程"></a>完整的加载流程</h2><ul>
<li><strong>由父及子，静态先行</strong></li>
<li><strong>静态资源</strong>加载顺序：<strong>静态默认初始化、显式初始化、静态代码块初始化</strong>。按声明顺序初始化</li>
<li><strong>非静态资源</strong>加载顺序为：<strong>默认初始化、显式初始化、代码块初始化、构造器初始化</strong>。按声明顺序初始化</li>
</ul>
<hr>
<ol>
<li>先进行<strong>父类</strong>的<strong>静态资源</strong>加载顺序：静态属性、静态代码块。按声明顺序初始化</li>
<li>后进行<strong>子类</strong>的<strong>静态资源</strong>加载顺序：静态属性、静态代码块。按声明顺序初始化</li>
<li>再进行<strong>父类</strong>的<strong>非静态资源</strong>加载顺序：属性、代码块、构造器。按声明顺序初始化</li>
<li>再进行<strong>子类</strong>的<strong>非静态资源</strong>加载顺序：属性、代码块、构造器。按声明顺序初始化</li>
</ol>
<h2 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h2><h1 id="值传递机制-1"><a href="#值传递机制-1" class="headerlink" title="值传递机制"></a>值传递机制</h1><h2 id="值传递机制-2"><a href="#值传递机制-2" class="headerlink" title="值传递机制"></a>值传递机制</h2><ul>
<li>不仅是java，大部分的编译性语言方法的参数转递机制都是值传递机制</li>
<li>值传递机制指，方法调用实参传入形参的总是“<strong>数值</strong>”<ul>
<li>基本数据类型：值内容本身</li>
<li>引用数据类型：地址值</li>
</ul>
</li>
</ul>
<h3 id="局部变量的形参"><a href="#局部变量的形参" class="headerlink" title="局部变量的形参"></a>局部变量的形参</h3><ul>
<li>当外部传入参数调用方法时，系统首先会创建一份传入实参的副本，赋值给新参</li>
<li>形参是一个<strong>局部变量</strong>，在方法调用时创建，方法执行完毕后释放</li>
<li>方法体内部操作的实际是实参的副本——形参的值</li>
</ul>
<h3 id="带返回值覆盖调用"><a href="#带返回值覆盖调用" class="headerlink" title="带返回值覆盖调用"></a>带返回值覆盖调用</h3><ul>
<li><p>由于方法可以声明带返回值，外部调用后若将其返回的结果对某个变量进行<strong>重新赋值</strong>，是<strong>可以改变外部的参数的值</strong>。<strong>毫无疑问，是绝对可以改变值得</strong>。即等同于在外部重新为其参数赋值的操作而已</p>
</li>
<li><p>因此主要讨论的是无返回值函数调用的情况</p>
</li>
</ul>
<h3 id="无返回值调用"><a href="#无返回值调用" class="headerlink" title="无返回值调用"></a>无返回值调用</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul>
<li><strong>任何语言</strong>，在无返回值方法调用中，传入基本数据类型实参，是<strong>无法修改外部值的</strong></li>
<li>示例代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    change1(i);<span class="comment">//不能修改</span></span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    i = change2(i);<span class="comment">//只能重新赋值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i);<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change2</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>原理</strong>：由于基本数据类型传入数据的本体，仅操作形参这个局部变量没有用，方法执行完就回收掉了，无法对外部调用者产生任何修改，属于空操作。</li>
</ul>
<h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>对于无返回值函数调用，当引用的类型创建副本后</p>
<ul>
<li><p><strong>结论</strong>：<strong>只能修改引用指向的内容</strong>，<strong>无法修改引用本身</strong></p>
<blockquote>
<ul>
<li><p>java不同于C，C能对任意数据类型(含指针类型)，再创建指向它的一个指针/引用(取地址&amp;)</p>
</li>
<li><p>而java不能，对一个引用类型不存在再创建引用它的引用，若想调用方法修改最外层的引用，则只能通过返回值方法重新赋值引用。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<ul>
<li><strong>示例代码</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>);<span class="comment">//一级引用</span></span><br><span class="line">    changePerson1(person);<span class="comment">//引用类型的第一级引用无法通过方法内部直接改变引用值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Name: &quot;</span> + person.getName());<span class="comment">//Tom</span></span><br><span class="line"></span><br><span class="line">    person = changePerson2(person);<span class="comment">//引用类型的第一级引用只能通过返回值赋值来改变引用值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Name: &quot;</span> + person.getName());<span class="comment">//Jack</span></span><br><span class="line"></span><br><span class="line">    changeName(person);<span class="comment">//可以改变引用指向的本体内容</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Name: &quot;</span> + person.getName());<span class="comment">//Tom-</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changePerson1</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">    person = <span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>);<span class="comment">//尝试改变其引用，不行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">changePerson2</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">    person = <span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>);<span class="comment">//尝试改变其引用，不行</span></span><br><span class="line">    <span class="keyword">return</span> person;<span class="comment">//仅能返回引用进行修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeName</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">    person.setName(<span class="string">&quot;Tom-&quot;</span>);<span class="comment">//修改一级引用的本体，可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原理：<ul>
<li>同基本数据类型，修改引用的本身存储在形参，形参局部变量在方法执行完后就会自动回收，因此修改形参值本身是无效的，是个空操作，</li>
<li>而修改其引用指向的内容，就可以在局部变量有限的生命周期中造成对外界永久的修改。</li>
</ul>
</li>
</ul>
<h4 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h4><ul>
<li><p>基本数据类型：</p>
<ul>
<li><p><strong>任何语言都，只能通过返回值覆盖的方式</strong>修改其内容</p>
<blockquote>
<p>C语言可以修改是因为传入的是&amp;取指后的指针类型</p>
</blockquote>
</li>
<li><p><strong>无返回值方法</strong>调用，是<strong>无法修改外部的值</strong></p>
</li>
</ul>
</li>
<li><p>引用数据类型：</p>
<ul>
<li><strong>无返回值方法</strong>调用，<strong>只能修改引用指向的内容，无法修改引用本身</strong>，即对引用的赋值(=)操作均无效。</li>
<li><strong>若想修改引用本身(地址)，只能通过返回值覆盖的方式修改</strong></li>
</ul>
</li>
</ul>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：JavaSE基础</li>
        <li>Post author：yhd</li>
        <li>Create time：2021-03-04 11:40:32</li>
        <li>
            Post link：https://keep.xpoet.cn/2021/03/04/JavaSE基础/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/03/14/%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E5%BA%93/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">网络资源库</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2020/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">数据库原理 第二章 关系数据库</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">yhd</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.1</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">语言概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E5%8E%86%E5%8F%B2"><span class="nav-number">1.1.</span> <span class="nav-text">语言历史</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9"><span class="nav-number">1.2.</span> <span class="nav-text">语言特点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="nav-number">2.</span> <span class="nav-text">开发环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK-amp-JRM-amp-JVM"><span class="nav-number">2.1.</span> <span class="nav-text">JDK&amp;JRM&amp;JVM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-number">2.2.</span> <span class="nav-text">环境搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85JDK"><span class="nav-number">2.2.1.</span> <span class="nav-text">下载安装JDK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">2.2.2.</span> <span class="nav-text">配置环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E9%85%8D%E7%BD%AE"><span class="nav-number">2.2.3.</span> <span class="nav-text">验证配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.4.</span> <span class="nav-text">常见问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK%E5%86%85%E5%AE%B9%E6%A6%82%E8%A6%81"><span class="nav-number">2.3.</span> <span class="nav-text">JDK内容概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.4.</span> <span class="nav-text">环境变量详解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91"><span class="nav-number">3.</span> <span class="nav-text">Java程序运行逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91"><span class="nav-number">3.1.</span> <span class="nav-text">执行逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%8F%8A%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="nav-number">3.2.</span> <span class="nav-text">编译及运行命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%94%E7%A4%BA"><span class="nav-number">3.3.</span> <span class="nav-text">演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#public-class"><span class="nav-number">3.4.</span> <span class="nav-text">public class</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">4.1.</span> <span class="nav-text">注释</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="nav-number">4.1.1.</span> <span class="nav-text">文档注释</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E4%BF%9D%E7%95%99%E5%AD%97%E3%80%81%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-number">4.2.</span> <span class="nav-text">关键字、保留字、标识符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="nav-number">4.3.</span> <span class="nav-text">命名规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.4.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="nav-number">4.4.1.</span> <span class="nav-text">类型分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B%E4%B8%8E%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.4.2.</span> <span class="nav-text">整型与浮点型初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E5%9E%8B"><span class="nav-number">4.4.3.</span> <span class="nav-text">整数型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="nav-number">4.4.4.</span> <span class="nav-text">字符型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="nav-number">4.4.5.</span> <span class="nav-text">浮点型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E9%97%B4%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.4.6.</span> <span class="nav-text">类型间转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.4.6.1.</span> <span class="nav-text">自动类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.4.6.2.</span> <span class="nav-text">强制类型转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">4.5.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">4.5.1.</span> <span class="nav-text">算术运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">4.5.2.</span> <span class="nav-text">赋值运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">4.5.3.</span> <span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">4.5.4.</span> <span class="nav-text">位运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.5.4.1.</span> <span class="nav-text">位运算类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7"><span class="nav-number">4.5.4.2.</span> <span class="nav-text">位运算技巧</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E5%85%83-%E7%9B%AE%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.5.5.</span> <span class="nav-text">三元&#x2F;目表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">4.5.6.</span> <span class="nav-text">比较运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">4.6.</span> <span class="nav-text">流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="nav-number">4.6.1.</span> <span class="nav-text">顺序结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="nav-number">4.6.2.</span> <span class="nav-text">分支结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#if-else%E7%BB%93%E6%9E%84"><span class="nav-number">4.6.2.1.</span> <span class="nav-text">if-else结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#switch%E7%BB%93%E6%9E%84"><span class="nav-number">4.6.2.2.</span> <span class="nav-text">switch结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E9%80%BB%E8%BE%91"><span class="nav-number">4.6.2.2.1.</span> <span class="nav-text">语法逻辑</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E7%BB%8F%E9%AA%8C"><span class="nav-number">4.6.2.2.2.</span> <span class="nav-text">编写经验</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="nav-number">4.6.3.</span> <span class="nav-text">循环结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">4.6.3.1.</span> <span class="nav-text">相关关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="nav-number">4.6.3.2.</span> <span class="nav-text">for循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="nav-number">4.6.3.3.</span> <span class="nav-text">while循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#do-while%E5%BE%AA%E7%8E%AF"><span class="nav-number">4.6.3.4.</span> <span class="nav-text">do-while循环</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">5.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">5.1.</span> <span class="nav-text">一维数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">5.1.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.1.2.</span> <span class="nav-text">声明与初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90"><span class="nav-number">5.1.3.</span> <span class="nav-text">数组的内存解析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">5.2.</span> <span class="nav-text">多维数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">5.2.1.</span> <span class="nav-text">基础概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BD%BF%E7%94%A8"><span class="nav-number">5.2.2.</span> <span class="nav-text">二维数组使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90"><span class="nav-number">5.2.3.</span> <span class="nav-text">内存解析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="nav-number">5.3.</span> <span class="nav-text">常见异常</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">6.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-1"><span class="nav-number">6.1.</span> <span class="nav-text">基础概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">6.2.</span> <span class="nav-text">属性与局部变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7"><span class="nav-number">6.2.1.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">6.2.2.</span> <span class="nav-text">局部变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">6.3.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">6.3.1.</span> <span class="nav-text">方法的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82"><span class="nav-number">6.3.2.</span> <span class="nav-text">形参与实参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD"><span class="nav-number">6.3.3.</span> <span class="nav-text">重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E4%B8%AA%E6%95%B0%E5%BD%A2%E5%8F%82"><span class="nav-number">6.3.4.</span> <span class="nav-text">可变个数形参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#return%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">6.3.5.</span> <span class="nav-text">return关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="nav-number">6.3.6.</span> <span class="nav-text">匿名对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6"><span class="nav-number">6.3.7.</span> <span class="nav-text">值传递机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E4%B8%8E%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6"><span class="nav-number">6.3.7.1.</span> <span class="nav-text">String与值传递机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90"><span class="nav-number">6.3.7.2.</span> <span class="nav-text">例题分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">6.4.</span> <span class="nav-text">封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-2"><span class="nav-number">6.4.1.</span> <span class="nav-text">基础概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">6.4.2.</span> <span class="nav-text">权限修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.4.2.1.</span> <span class="nav-text">修饰符类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E4%BF%AE%E9%A5%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number">6.4.2.2.</span> <span class="nav-text">可修饰对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E6%88%90%E5%91%98"><span class="nav-number">6.4.2.2.1.</span> <span class="nav-text">类成员</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">6.4.2.2.2.</span> <span class="nav-text">类</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">6.5.</span> <span class="nav-text">构造器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-number">6.5.1.</span> <span class="nav-text">基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="nav-number">6.5.1.1.</span> <span class="nav-text">隐式语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95"><span class="nav-number">6.5.1.2.</span> <span class="nav-text">其他语法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaBean"><span class="nav-number">6.5.2.</span> <span class="nav-text">JavaBean</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">6.6.</span> <span class="nav-text">this关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%90%AB%E4%B9%89"><span class="nav-number">6.6.1.</span> <span class="nav-text">基本含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="nav-number">6.6.2.</span> <span class="nav-text">属性与方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-1"><span class="nav-number">6.6.3.</span> <span class="nav-text">构造器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UML%E7%AE%80%E8%BF%B0"><span class="nav-number">6.7.</span> <span class="nav-text">UML简述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#package"><span class="nav-number">6.8.</span> <span class="nav-text">package</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="nav-number">6.8.1.</span> <span class="nav-text">基本功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVC%E8%A7%84%E8%8C%83%E5%AE%9A%E4%B9%89"><span class="nav-number">6.8.2.</span> <span class="nav-text">MVC规范定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#import"><span class="nav-number">6.9.</span> <span class="nav-text">import</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E4%B8%8E%E8%AF%AD%E6%B3%95"><span class="nav-number">6.9.1.</span> <span class="nav-text">功能与语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8B%E7%9A%84%E5%AD%90%E5%8C%85"><span class="nav-number">6.9.2.</span> <span class="nav-text">通配符下的子包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E9%9D%99%E6%80%81%E7%BB%93%E6%9E%84"><span class="nav-number">6.9.3.</span> <span class="nav-text">导入静态结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">6.10.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%95%88%E6%9E%9C"><span class="nav-number">6.10.1.</span> <span class="nav-text">继承的效果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">6.10.2.</span> <span class="nav-text">继承的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">6.10.3.</span> <span class="nav-text">继承的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-1"><span class="nav-number">6.10.3.1.</span> <span class="nav-text">基础语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E7%BB%A7%E6%89%BF%E7%89%B9%E6%80%A7"><span class="nav-number">6.10.3.2.</span> <span class="nav-text">单继承特性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E7%88%B6%E7%B1%BB"><span class="nav-number">6.10.4.</span> <span class="nav-text">根父类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="nav-number">6.10.5.</span> <span class="nav-text">方法的重写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E6%95%88%E6%9E%9C"><span class="nav-number">6.10.5.1.</span> <span class="nav-text">重写效果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E8%A7%84%E5%88%99"><span class="nav-number">6.10.5.2.</span> <span class="nav-text">重写规则</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">6.10.5.2.1.</span> <span class="nav-text">重写的对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E7%9A%84%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">6.10.5.2.2.</span> <span class="nav-text">重写的权限修饰符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">6.10.5.2.3.</span> <span class="nav-text">重写的返回值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="nav-number">6.10.5.2.4.</span> <span class="nav-text">重写的异常</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#super"><span class="nav-number">6.11.</span> <span class="nav-text">super</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%90%AB%E4%B9%89-1"><span class="nav-number">6.11.1.</span> <span class="nav-text">基本含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95-1"><span class="nav-number">6.11.2.</span> <span class="nav-text">属性与方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-2"><span class="nav-number">6.11.3.</span> <span class="nav-text">构造器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">6.12.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E6%A6%82%E5%BF%B5"><span class="nav-number">6.12.1.</span> <span class="nav-text">多态概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E4%BD%BF%E7%94%A8"><span class="nav-number">6.12.2.</span> <span class="nav-text">多态使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">6.12.3.</span> <span class="nav-text">多态的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">6.12.4.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99"><span class="nav-number">6.12.5.</span> <span class="nav-text">重载与重写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD-1"><span class="nav-number">6.12.5.1.</span> <span class="nav-text">重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99"><span class="nav-number">6.12.5.2.</span> <span class="nav-text">重写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="nav-number">6.12.6.</span> <span class="nav-text">向下转型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">6.12.6.1.</span> <span class="nav-text">多态与类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#instanceof%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">6.12.6.2.</span> <span class="nav-text">instanceof关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="nav-number">6.12.6.2.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D"><span class="nav-number">6.12.6.2.2.</span> <span class="nav-text">使用介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="nav-number">6.12.6.2.3.</span> <span class="nav-text">示例代码</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object"><span class="nav-number">6.13.</span> <span class="nav-text">Object</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">6.13.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#API"><span class="nav-number">6.13.2.</span> <span class="nav-text">API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Constructor"><span class="nav-number">6.13.2.1.</span> <span class="nav-text">Constructor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Methods"><span class="nav-number">6.13.2.2.</span> <span class="nav-text">Methods</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#equals"><span class="nav-number">6.13.3.</span> <span class="nav-text">equals</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%9C-%E2%80%9D%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">6.13.3.1.</span> <span class="nav-text">“&#x3D;&#x3D;”的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F%E5%AE%9A%E4%B9%89"><span class="nav-number">6.13.3.2.</span> <span class="nav-text">原生定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E5%AE%9A%E4%B9%89"><span class="nav-number">6.13.3.3.</span> <span class="nav-text">重写定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E8%8C%83%E4%BE%8B"><span class="nav-number">6.13.3.4.</span> <span class="nav-text">重写范例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E8%A6%81%E6%B1%82"><span class="nav-number">6.13.3.5.</span> <span class="nav-text">重写要求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#toString-NaN"><span class="nav-number">6.13.4.</span> <span class="nav-text">toString</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F%E5%AE%9A%E4%B9%89-1"><span class="nav-number">6.13.4.1.</span> <span class="nav-text">原生定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E5%AE%9A%E4%B9%89-1"><span class="nav-number">6.13.4.2.</span> <span class="nav-text">重写定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#print%E4%B8%8EtoString"><span class="nav-number">6.13.4.3.</span> <span class="nav-text">print与toString</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">6.14.</span> <span class="nav-text">包装类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">6.14.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.14.2.</span> <span class="nav-text">包装类类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="nav-number">6.14.3.</span> <span class="nav-text">自动装箱与拆箱</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A3%85%E7%AE%B1%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1"><span class="nav-number">6.14.3.1.</span> <span class="nav-text">装箱与自动装箱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%86%E7%AE%B1%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1"><span class="nav-number">6.14.3.2.</span> <span class="nav-text">拆箱与自动拆箱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">6.14.3.3.</span> <span class="nav-text">String之间的转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Integer%E7%BC%93%E5%AD%98"><span class="nav-number">6.14.4.</span> <span class="nav-text">Integer缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static"><span class="nav-number">6.15.</span> <span class="nav-text">static</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="nav-number">6.15.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7"><span class="nav-number">6.15.2.</span> <span class="nav-text">静态属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">6.15.3.</span> <span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">6.15.4.</span> <span class="nav-text">static应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="nav-number">6.15.4.1.</span> <span class="nav-text">共享数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">6.15.4.2.</span> <span class="nav-text">工具类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.15.4.3.</span> <span class="nav-text">单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-3"><span class="nav-number">6.15.4.3.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.15.4.3.2.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E9%97%B4%E5%AF%B9%E6%AF%94"><span class="nav-number">6.15.4.3.3.</span> <span class="nav-text">单例模式间对比</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">6.15.4.4.</span> <span class="nav-text">其他</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#main%E6%96%B9%E6%B3%95"><span class="nav-number">6.16.</span> <span class="nav-text">main方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="nav-number">6.16.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eclipse%E5%8F%82%E6%95%B0%E8%BE%93%E5%85%A5"><span class="nav-number">6.16.2.</span> <span class="nav-text">eclipse参数输入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%8F%82%E6%95%B0%E8%BE%93%E5%85%A5"><span class="nav-number">6.16.3.</span> <span class="nav-text">控制台参数输入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96"><span class="nav-number">6.16.4.</span> <span class="nav-text">输入参数获取</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="nav-number">6.16.4.1.</span> <span class="nav-text">获取方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">6.16.4.2.</span> <span class="nav-text">示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">6.17.</span> <span class="nav-text">代码块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E4%B8%8E%E4%BD%9C%E7%94%A8"><span class="nav-number">6.17.1.</span> <span class="nav-text">功能与作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">6.17.2.</span> <span class="nav-text">创建代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">6.17.3.</span> <span class="nav-text">非静态代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">6.17.4.</span> <span class="nav-text">静态代码块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-4"><span class="nav-number">6.17.4.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">6.17.4.2.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%8D%E8%B0%88%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="nav-number">6.17.5.</span> <span class="nav-text">再谈对象实例化顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final"><span class="nav-number">6.18.</span> <span class="nav-text">final</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="nav-number">6.18.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final-Class"><span class="nav-number">6.18.2.</span> <span class="nav-text">final Class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final-Method"><span class="nav-number">6.18.3.</span> <span class="nav-text">final Method</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final-Field"><span class="nav-number">6.18.4.</span> <span class="nav-text">final Field</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-5"><span class="nav-number">6.18.4.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7-1"><span class="nav-number">6.18.4.2.</span> <span class="nav-text">静态属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84"><span class="nav-number">6.18.4.2.1.</span> <span class="nav-text">类中的初始化结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">6.18.4.3.</span> <span class="nav-text">静态局部变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-1"><span class="nav-number">6.18.4.3.1.</span> <span class="nav-text">局部变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BD%A2%E5%8F%82%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">6.18.4.3.2.</span> <span class="nav-text">形参局部变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static-final"><span class="nav-number">6.18.5.</span> <span class="nav-text">static final</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E5%83%8F%E7%B1%BB"><span class="nav-number">6.19.</span> <span class="nav-text">抽像类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-6"><span class="nav-number">6.19.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#abstract-class"><span class="nav-number">6.19.2.</span> <span class="nav-text">abstract class</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-7"><span class="nav-number">6.19.2.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-number">6.19.2.2.</span> <span class="nav-text">作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#abstract-method"><span class="nav-number">6.19.3.</span> <span class="nav-text">abstract method</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-8"><span class="nav-number">6.19.3.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8-1"><span class="nav-number">6.19.3.2.</span> <span class="nav-text">作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E7%BB%A7%E6%89%BF%E5%AD%90%E7%B1%BB"><span class="nav-number">6.19.4.</span> <span class="nav-text">匿名继承子类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-2"><span class="nav-number">6.19.4.1.</span> <span class="nav-text">示例代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">6.19.5.</span> <span class="nav-text">应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%86%E5%9F%9F"><span class="nav-number">6.19.5.1.</span> <span class="nav-text">类的设计领域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.19.5.2.</span> <span class="nav-text">模板方法设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-9"><span class="nav-number">6.19.5.2.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%85%81%E8%AE%B8%E6%97%B6%E9%97%B4%E6%A8%A1%E6%9D%BF%E7%A4%BA%E4%BE%8B"><span class="nav-number">6.19.5.2.2.</span> <span class="nav-text">程序允许时间模板示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E6%A8%A1%E6%9D%BF%E7%A4%BA%E4%BE%8B"><span class="nav-number">6.19.5.2.3.</span> <span class="nav-text">业务流程模板示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">6.19.5.2.4.</span> <span class="nav-text">实际应用场景</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.20.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%9C%E7%94%A8"><span class="nav-number">6.20.1.</span> <span class="nav-text">概念与作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%92%E5%BA%A6"><span class="nav-number">6.20.1.1.</span> <span class="nav-text">类的设计角度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%B1%82%E9%9D%A2"><span class="nav-number">6.20.1.2.</span> <span class="nav-text">语法层面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E7%A4%BA%E4%BE%8B"><span class="nav-number">6.20.1.3.</span> <span class="nav-text">接口设计示例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B1"><span class="nav-number">6.20.1.3.1.</span> <span class="nav-text">示例1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B2"><span class="nav-number">6.20.1.3.2.</span> <span class="nav-text">示例2</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%AF%AD%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="nav-number">6.20.2.</span> <span class="nav-text">接口的语法定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E4%B8%8A%E7%9A%84%E8%AF%AD%E6%B3%95%E4%BD%93%E7%8E%B0"><span class="nav-number">6.20.3.</span> <span class="nav-text">接口定义上的语法体现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">6.20.3.1.</span> <span class="nav-text">接口的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8D%E6%98%AF%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E6%9B%B4%E5%8A%A0%E6%B2%A1%E6%9C%89%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="nav-number">6.20.3.2.</span> <span class="nav-text">接口不是类的概念，更加没有继承关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%A7%84%E8%8C%83"><span class="nav-number">6.20.3.3.</span> <span class="nav-text">如何定义接口的规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E6%98%AF%E8%A1%8C%E4%B8%BA%E7%89%B9%E5%BE%81"><span class="nav-number">6.20.3.4.</span> <span class="nav-text">接口是行为特征</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E6%A6%82%E5%BF%B5%E6%80%A7%E8%AF%AD%E6%B3%95"><span class="nav-number">6.20.4.</span> <span class="nav-text">非概念性语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E6%8E%A5%E5%8F%A3%E8%87%AA%E8%BA%AB%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">6.20.4.1.</span> <span class="nav-text">描述接口自身的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7-1"><span class="nav-number">6.20.4.1.1.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-1"><span class="nav-number">6.20.4.1.2.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.20.4.2.</span> <span class="nav-text">接口的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%A4%9A%E6%80%81%E6%80%A7"><span class="nav-number">6.20.4.3.</span> <span class="nav-text">接口多态性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E9%97%B4%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">6.20.4.4.</span> <span class="nav-text">接口间的继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96-1"><span class="nav-number">6.20.4.5.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">6.20.5.</span> <span class="nav-text">匿名实现类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="nav-number">6.20.6.</span> <span class="nav-text">应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%86%E5%9F%9F-1"><span class="nav-number">6.20.6.1.</span> <span class="nav-text">类的设计领域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.20.6.2.</span> <span class="nav-text">相关设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.20.6.2.1.</span> <span class="nav-text">代理模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.20.6.2.2.</span> <span class="nav-text">工厂模式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">6.21.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-10"><span class="nav-number">6.21.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">6.21.2.</span> <span class="nav-text">内部类的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8"><span class="nav-number">6.21.3.</span> <span class="nav-text">成员内部</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-11"><span class="nav-number">6.21.3.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">6.21.3.2.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8E%E5%A4%96%E9%83%A8%E7%B1%BB%E5%90%8C%E5%90%8D%E5%B1%9E%E6%80%A7%E8%B0%83%E7%94%A8"><span class="nav-number">6.21.3.3.</span> <span class="nav-text">内部类与外部类同名属性调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">6.21.4.</span> <span class="nav-text">局部内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%86%85%E9%83%A8%E7%B1%BB%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="nav-number">6.21.5.</span> <span class="nav-text">返回内部类实例方法定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6"><span class="nav-number">6.21.6.</span> <span class="nav-text">内部类字节码文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">7.</span> <span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%A6%82%E8%BF%B0"><span class="nav-number">7.1.</span> <span class="nav-text">异常概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Error"><span class="nav-number">7.2.</span> <span class="nav-text">Error</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exception"><span class="nav-number">7.3.</span> <span class="nav-text">Exception</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB"><span class="nav-number">7.3.1.</span> <span class="nav-text">异常分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">7.4.</span> <span class="nav-text">异常体系结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8-1"><span class="nav-number">7.5.</span> <span class="nav-text">常见异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="nav-number">7.5.1.</span> <span class="nav-text">运行时异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="nav-number">7.5.2.</span> <span class="nav-text">编译时异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BA%A7%E7%94%9F%E4%B8%8E%E5%A4%84%E7%90%86"><span class="nav-number">7.6.</span> <span class="nav-text">异常的产生与处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="nav-number">7.6.1.</span> <span class="nav-text">异常的产生</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">7.6.2.</span> <span class="nav-text">异常的处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">7.7.</span> <span class="nav-text">异常处理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%93%E6%8A%9B%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.7.1.</span> <span class="nav-text">抓抛模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%9C%E6%8A%9B%E2%80%9D"><span class="nav-number">7.7.1.1.</span> <span class="nav-text">“抛”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%9C%E6%8A%93%E2%80%9D"><span class="nav-number">7.7.1.2.</span> <span class="nav-text">“抓”</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#try-catch-finally"><span class="nav-number">7.7.2.</span> <span class="nav-text">try-catch-finally</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="nav-number">7.7.2.1.</span> <span class="nav-text">语法格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E"><span class="nav-number">7.7.2.2.</span> <span class="nav-text">语法说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#throws"><span class="nav-number">7.7.3.</span> <span class="nav-text">throws</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E-1"><span class="nav-number">7.7.3.1.</span> <span class="nav-text">语法说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1-throw"><span class="nav-number">7.8.</span> <span class="nav-text">手动抛出异常对象-throw</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E8%A6%81%E6%B1%82"><span class="nav-number">7.8.1.</span> <span class="nav-text">语法要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E5%9C%BA%E6%99%AF%E6%A8%A1%E6%8B%9F"><span class="nav-number">7.8.2.</span> <span class="nav-text">需求场景模拟</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="nav-number">7.9.</span> <span class="nav-text">自定义异常类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E4%B8%8EJVM"><span class="nav-number">8.</span> <span class="nav-text">资源加载与JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.1.</span> <span class="nav-text">变量类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E8%A7%92%E5%BA%A6%E4%B8%8A"><span class="nav-number">8.1.1.</span> <span class="nav-text">作用角度上</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-2"><span class="nav-number">8.1.1.1.</span> <span class="nav-text">局部变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">8.1.1.2.</span> <span class="nav-text">成员变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7-2"><span class="nav-number">8.1.1.2.1.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="nav-number">8.1.1.2.2.</span> <span class="nav-text">类变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8A"><span class="nav-number">8.1.2.</span> <span class="nav-text">数据类型上</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">8.2.</span> <span class="nav-text">变量初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="nav-number">8.2.1.</span> <span class="nav-text">声明与初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-number">8.2.1.1.</span> <span class="nav-text">变量的声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">8.2.1.2.</span> <span class="nav-text">变量的初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-3"><span class="nav-number">8.2.2.</span> <span class="nav-text">局部变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-1"><span class="nav-number">8.2.3.</span> <span class="nav-text">成员变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">8.3.</span> <span class="nav-text">JVM内存结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">8.4.</span> <span class="nav-text">类的加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">8.4.1.</span> <span class="nav-text">实例化对象加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%90%91%E4%B8%8A%E5%8A%A0%E8%BD%BD"><span class="nav-number">8.4.1.1.</span> <span class="nav-text">为什么要向上加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%90%91%E4%B8%8A%E5%8A%A0%E8%BD%BD"><span class="nav-number">8.4.1.2.</span> <span class="nav-text">如何进行向上加载</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="nav-number">8.5.</span> <span class="nav-text">资源的加载顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E4%BC%98%E5%85%88%E5%8A%A0%E8%BD%BD"><span class="nav-number">8.6.</span> <span class="nav-text">静态资源的优先加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="nav-number">8.7.</span> <span class="nav-text">完整的加载流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E9%A2%98"><span class="nav-number">8.8.</span> <span class="nav-text">测试题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6-1"><span class="nav-number">9.</span> <span class="nav-text">值传递机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6-2"><span class="nav-number">9.1.</span> <span class="nav-text">值传递机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%BD%A2%E5%8F%82"><span class="nav-number">9.1.1.</span> <span class="nav-text">局部变量的形参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E8%A6%86%E7%9B%96%E8%B0%83%E7%94%A8"><span class="nav-number">9.1.2.</span> <span class="nav-text">带返回值覆盖调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%E8%B0%83%E7%94%A8"><span class="nav-number">9.1.3.</span> <span class="nav-text">无返回值调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">9.1.3.1.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">9.1.3.2.</span> <span class="nav-text">引用数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93"><span class="nav-number">9.1.3.3.</span> <span class="nav-text">核心总结</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>



<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
